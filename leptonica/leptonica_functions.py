
# -*- coding: utf-8 -*-

from __future__ import absolute_import
from builtins import object
import sys
import ctypes
from .leptonica_structures import *
from . import leptonica_structures as structs

try:
    leptonica = ctypes.cdll.LoadLibrary("liblept.so")
    libc = ctypes.cdll.LoadLibrary("libc.so.6")
except OSError: 
    # Known issue: liblept.so fails to load in ctypes with
    # Ubuntu 10.10 package - probably due to a missing dependence
    #Windows: untested ! 
    import ctypes.util
    leptonica = ctypes.cdll.LoadLibrary("liblept.dll")
    libc = ctypes.cdll.LoadLibrary(ctypes.util.find_msvcrt())

free = libc.free

def _convert_params(*args):
    new_args = []
    for arg in args:
        if isinstance(arg, structs.LeptonObject):
            arg = arg._address_
        elif isinstance(arg, str):
            arg = arg.encode('utf-8')
        new_args.append(arg)
    return tuple(new_args)



class adaptmap(object):
    """<pre>

-------------------------------------------------------------------

Image binarization algorithms are found in:
grayquant.c:   standard, simple, general grayscale quantization
adaptmap.c:    local adaptive; mostly gray-to-gray in preparation
for binarization
binarize.c:    special binarization methods, locally adaptive.

-------------------------------------------------------------------

Clean background to white using background normalization
PIX       *pixCleanBackgroundToWhite()

Adaptive background normalization (top-level functions)
PIX       *pixBackgroundNormSimple()     8 and 32 bpp
PIX       *pixBackgroundNorm()           8 and 32 bpp
PIX       *pixBackgroundNormMorph()      8 and 32 bpp

Arrays of inverted background values for normalization (16 bpp)
l_int32    pixBackgroundNormGrayArray()   8 bpp input
l_int32    pixBackgroundNormRGBArrays()   32 bpp input
l_int32    pixBackgroundNormGrayArrayMorph()   8 bpp input
l_int32    pixBackgroundNormRGBArraysMorph()   32 bpp input

Measurement of local background
l_int32    pixGetBackgroundGrayMap()        8 bpp
l_int32    pixGetBackgroundRGBMap()         32 bpp
l_int32    pixGetBackgroundGrayMapMorph()   8 bpp
l_int32    pixGetBackgroundRGBMapMorph()    32 bpp
l_int32    pixFillMapHoles()
PIX       *pixExtendByReplication()         8 bpp
l_int32    pixSmoothConnectedRegions()      8 bpp

Measurement of local foreground
l_int32    pixGetForegroundGrayMap()        8 bpp

Generate inverted background map for each component
PIX       *pixGetInvBackgroundMap()   16 bpp

Apply inverse background map to image
PIX       *pixApplyInvBackgroundGrayMap()   8 bpp
PIX       *pixApplyInvBackgroundRGBMap()    32 bpp

Apply variable map
PIX       *pixApplyVariableGrayMap()        8 bpp

Non-adaptive (global) mapping
PIX       *pixGlobalNormRGB()               32 bpp or cmapped
PIX       *pixGlobalNormNoSatRGB()          32 bpp

Adaptive threshold spread normalization
l_int32    pixThresholdSpreadNorm()         8 bpp

Adaptive background normalization (flexible adaptaption)
PIX       *pixBackgroundNormFlex()          8 bpp

Adaptive contrast normalization
PIX             *pixContrastNorm()          8 bpp
l_int32          pixMinMaxTiles()
l_int32          pixSetLowContrast()
PIX             *pixLinearTRCTiled()
static l_int32  *iaaGetLinearTRC()

Background normalization is done by generating a reduced map (or set
of maps) representing the estimated background value of the
input image, and using this to shift the pixel values so that
this background value is set to some constant value.

Specifically, normalization has 3 steps:
(1) Generate a background map at a reduced scale.
(2) Make the array of inverted background values by inverting
the map.  The result is an array of local multiplicative factors.
(3) Apply this inverse background map to the image

The inverse background arrays can be generated in two different ways here:
(1) Remove the 'foreground' pixels and average over the remaining
pixels in each tile.  Propagate values into tiles where
values have not been assigned, either because there was not
enough background in the tile or because the tile is covered
by a foreground region described by an image mask.
After the background map is made, the inverse map is generated by
smoothing over some number of adjacent tiles
(block convolution) and then inverting.
(2) Remove the foreground pixels using a morphological closing
on a subsampled version of the image.  Propagate values
into pixels covered by an optional image mask.  Invert the
background map without preconditioning by convolutional smoothing.

Other methods for adaptively normalizing the image are also given here.

(1) pixThresholdSpreadNorm() computes a local threshold over the image
and normalizes the input pixel values so that this computed threshold
is a constant across the entire image.

(2) pixContrastNorm() computes and applies a local TRC so that the
local dynamic range is expanded to the full 8 bits, where the
darkest pixels are mapped to 0 and the lightest to 255.  This is
useful for improving the appearance of pages with very light
foreground or very dark background, and where the local TRC
function doesn't change rapidly with position.
</pre>




"""
    
    try:
        leptonica.pixCleanBackgroundToWhite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCleanBackgroundToWhite.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCleanBackgroundToWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCleanBackgroundToWhite(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_float32', 'gamma')       
('l_int32', 'blackval')       
('l_int32', 'whiteval')       

:param[in]    pixs:       8 bpp grayscale or 32 bpp rgb
:param[in]    pixim:      [optional] 1 bpp 'image' mask; can be null
:param[in]    pixg:       [optional] 8 bpp grayscale version; can be null
:param[in]    gamma:      gamma correction; must be > 0.0; typically ~1.0
:param[in]    blackval:   dark value to set to black (0)
:param[in]    whiteval:   light value to set to white (255)
:returns:  pixd 8 bpp or 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This is a simplified interface for cleaning an image.
For comparison, see pixAdaptThresholdToBinaryGen().
(2) The suggested default values for the input parameters are:
gamma:    1.0  (reduce this to increase the contrast; e.g.,
for light text)
blackval   70  (a bit more than 60)
whiteval  190  (a bit less than 200)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCleanBackgroundToWhite(*args)
    
    

    try:
        leptonica.pixBackgroundNormSimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBackgroundNormSimple.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormSimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormSimple(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       

:param[in]    pixs:     8 bpp grayscale or 32 bpp rgb
:param[in]    pixim:    [optional] 1 bpp 'image' mask; can be null
:param[in]    pixg:     [optional] 8 bpp grayscale version; can be null
:returns:  pixd 8 bpp or 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This is a simplified interface to pixBackgroundNorm(),
where seven parameters are defaulted.
(2) The input image is either grayscale or rgb.
(3) See pixBackgroundNorm() for usage and function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormSimple(*args)
    
    

    try:
        leptonica.pixBackgroundNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBackgroundNorm.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNorm(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       

:param[in]    pixs:        8 bpp grayscale or 32 bpp rgb
:param[in]    pixim:       [optional] 1 bpp 'image' mask; can be null
:param[in]    pixg:        [optional] 8 bpp grayscale version; can be null
:param[in]    sx,: sy      tile size in pixels
:param[in]    thresh:      threshold for determining foreground
:param[in]    mincount:    min threshold on counts in a tile
:param[in]    bgval:       target bg val; typ. > 128
:param[in]    smoothx:     half-width of block convolution kernel width
:param[in]    smoothy:     half-width of block convolution kernel height
:returns:  pixd 8 bpp or 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This is a top-level interface for normalizing the image intensity
by mapping the image so that the background is near the input
value 'bgval'.
(2) The input image is either grayscale or rgb.
(3) For each component in the input image, the background value
in each tile is estimated using the values in the tile that
are not part of the foreground, where the foreground is
determined by the input 'thresh' argument.
(4) An optional binary mask can be specified, with the foreground
pixels typically over image regions.  The resulting background
map values will be determined by surrounding pixels that are
not under the mask foreground.  The origin (0,0) of this mask
is assumed to be aligned with the origin of the input image.
This binary mask must not fully cover pixs, because then there
will be no pixels in the input image available to compute
the background.
(5) An optional grayscale version of the input pixs can be supplied.
The only reason to do this is if the input is RGB and this
grayscale version can be used elsewhere.  If the input is RGB
and this is not supplied, it is made internally using only
the green component, and destroyed after use.
(6) The dimensions of the pixel tile (sx, sy) give the amount by
by which the map is reduced in size from the input image.
(7) The threshold is used to binarize the input image, in order to
locate the foreground components.  If this is set too low,
some actual foreground may be used to determine the maps;
if set too high, there may not be enough background
to determine the map values accurately.  Typically, it's
better to err by setting the threshold too high.
(8) A 'mincount' threshold is a minimum count of pixels in a
tile for which a background reading is made, in order for that
pixel in the map to be valid.  This number should perhaps be
at least 1/3 the size of the tile.
(9) A 'bgval' target background value for the normalized image.  This
should be at least 128.  If set too close to 255, some
clipping will occur in the result.
(10) Two factors, 'smoothx' and 'smoothy', are input for smoothing
the map.  Each low-pass filter kernel dimension is
is 2 * (smoothing factor) + 1, so a
value of 0 means no smoothing. A value of 1 or 2 is recommended.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNorm(*args)
    
    

    try:
        leptonica.pixBackgroundNormMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBackgroundNormMorph.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('l_int32', 'bgval')       

:param[in]    pixs:        8 bpp grayscale or 32 bpp rgb
:param[in]    pixim:       [optional] 1 bpp 'image' mask; can be null
:param[in]    reduction:   at which morph closings are done; between 2 and 16
:param[in]    size:        of square Sel for the closing; use an odd number
:param[in]    bgval:       target bg val; typ. > 128
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) This is a top-level interface for normalizing the image intensity
by mapping the image so that the background is near the input
value 'bgval'.
(2) The input image is either grayscale or rgb.
(3) For each component in the input image, the background value
is estimated using a grayscale closing; hence the 'Morph'
in the function name.
(4) An optional binary mask can be specified, with the foreground
pixels typically over image regions.  The resulting background
map values will be determined by surrounding pixels that are
not under the mask foreground.  The origin (0,0) of this mask
is assumed to be aligned with the origin of the input image.
This binary mask must not fully cover pixs, because then there
will be no pixels in the input image available to compute
the background.
(5) The map is computed at reduced size (given by 'reduction')
from the input pixs and optional pixim.  At this scale,
pixs is closed to remove the background, using a square Sel
of odd dimension.  The product of reduction * size should be
large enough to remove most of the text foreground.
(6) No convolutional smoothing needs to be done on the map before
inverting it.
(7) A 'bgval' target background value for the normalized image.  This
should be at least 128.  If set too close to 255, some
clipping will occur in the result.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormMorph(*args)
    
    

    try:
        leptonica.pixBackgroundNormGrayArray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixBackgroundNormGrayArray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormGrayArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormGrayArray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('PIX', '**ppixd')       

:param[in]    pixs:       8 bpp grayscale
:param[in]    pixim:      [optional] 1 bpp 'image' mask; can be null
:param[in]    sx,: sy     tile size in pixels
:param[in]    thresh:     threshold for determining foreground
:param[in]    mincount:   min threshold on counts in a tile
:param[in]    bgval:      target bg val; typ. > 128
:param[in]    smoothx:    half-width of block convolution kernel width
:param[in]    smoothy:    half-width of block convolution kernel height
:param[out]   ppixd:      16 bpp array of inverted background value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See notes in pixBackgroundNorm().
(2) This returns a 16 bpp pix that can be used by
pixApplyInvBackgroundGrayMap() to generate a normalized version
of the input pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormGrayArray(*args)
    
    

    try:
        leptonica.pixBackgroundNormRGBArrays.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBackgroundNormRGBArrays.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormRGBArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormRGBArrays(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       

:param[in]    pixs:       32 bpp rgb
:param[in]    pixim:      [optional] 1 bpp 'image' mask; can be null
:param[in]    pixg:       [optional] 8 bpp grayscale version; can be null
:param[in]    sx,: sy     tile size in pixels
:param[in]    thresh:     threshold for determining foreground
:param[in]    mincount:   min threshold on counts in a tile
:param[in]    bgval:      target bg val; typ. > 128
:param[in]    smoothx:    half-width of block convolution kernel width
:param[in]    smoothy:    half-width of block convolution kernel height
:param[out]   ppixr:      16 bpp array of inverted R background value
:param[out]   ppixg:      16 bpp array of inverted G background value
:param[out]   ppixb:      16 bpp array of inverted B background value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See notes in pixBackgroundNorm().
(2) This returns a set of three 16 bpp pix that can be used by
pixApplyInvBackgroundGrayMap() to generate a normalized version
of each component of the input pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormRGBArrays(*args)
    
    

    try:
        leptonica.pixBackgroundNormGrayArrayMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixBackgroundNormGrayArrayMorph.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormGrayArrayMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormGrayArrayMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('l_int32', 'bgval')       
('PIX', '**ppixd')       

:param[in]    pixs:        8 bpp grayscale
:param[in]    pixim:       [optional] 1 bpp 'image' mask; can be null
:param[in]    reduction:   at which morph closings are done; between 2 and 16
:param[in]    size:        of square Sel for the closing; use an odd number
:param[in]    bgval:       target bg val; typ. > 128
:param[out]   ppixd:       16 bpp array of inverted background value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See notes in pixBackgroundNormMorph().
(2) This returns a 16 bpp pix that can be used by
pixApplyInvBackgroundGrayMap() to generate a normalized version
of the input pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormGrayArrayMorph(*args)
    
    

    try:
        leptonica.pixBackgroundNormRGBArraysMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBackgroundNormRGBArraysMorph.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormRGBArraysMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormRGBArraysMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('l_int32', 'bgval')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       

:param[in]    pixs:        32 bpp rgb
:param[in]    pixim:       [optional] 1 bpp 'image' mask; can be null
:param[in]    reduction:   at which morph closings are done; between 2 and 16
:param[in]    size:        of square Sel for the closing; use an odd number
:param[in]    bgval:       target bg val; typ. > 128
:param[out]   ppixr:       16 bpp array of inverted R background value
:param[out]   ppixg:       16 bpp array of inverted G background value
:param[out]   ppixb:       16 bpp array of inverted B background value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See notes in pixBackgroundNormMorph().
(2) This returns a set of three 16 bpp pix that can be used by
pixApplyInvBackgroundGrayMap() to generate a normalized version
of each component of the input pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormRGBArraysMorph(*args)
    
    

    try:
        leptonica.pixGetBackgroundGrayMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetBackgroundGrayMap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBackgroundGrayMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundGrayMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('PIX', '**ppixd')       

:param[in]    pixs:       8 bpp grayscale; not cmapped
:param[in]    pixim:      [optional] 1 bpp 'image' mask; can be null;
it should not have only foreground pixels
:param[in]    sx,: sy     tile size in pixels
:param[in]    thresh:     threshold for determining foreground
:param[in]    mincount:   min threshold on counts in a tile
:param[out]   ppixd:      8 bpp grayscale map
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The background is measured in regions that don't have
images.  It is then propagated into the image regions,
and finally smoothed in each image region.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundGrayMap(*args)
    
    

    try:
        leptonica.pixGetBackgroundRGBMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetBackgroundRGBMap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBackgroundRGBMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundRGBMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('PIX', '*pixg')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('PIX', '**ppixmr')       
('PIX', '**ppixmg')       
('PIX', '**ppixmb')       

:param[in]    pixs:       32 bpp rgb
:param[in]    pixim:      [optional] 1 bpp 'image' mask; can be null; it
should not have all foreground pixels
:param[in]    pixg:       [optional] 8 bpp grayscale version; can be null
:param[in]    sx,: sy     tile size in pixels
:param[in]    thresh:     threshold for determining foreground
:param[in]    mincount:   min threshold on counts in a tile
:param[out]   ppixmr:     red component map
:param[out]   ppixmg:     green component map
:param[out]   ppixmb:     blue component map
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If pixg, which is a grayscale version of pixs, is provided,
use this internally to generate the foreground mask.
Otherwise, a grayscale version of pixs will be generated
from the green component only, used, and destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundRGBMap(*args)
    
    

    try:
        leptonica.pixGetBackgroundGrayMapMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetBackgroundGrayMapMorph.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBackgroundGrayMapMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundGrayMapMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('PIX', '**ppixm')       

:param[in]    pixs:        8 bpp grayscale; not cmapped
:param[in]    pixim:       [optional] 1 bpp 'image' mask; can be null; it
should not have all foreground pixels
:param[in]    reduction:   factor at which closing is performed
:param[in]    size:        of square Sel for the closing; use an odd number
:param[out]   ppixm:       grayscale map
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundGrayMapMorph(*args)
    
    

    try:
        leptonica.pixGetBackgroundRGBMapMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetBackgroundRGBMapMorph.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBackgroundRGBMapMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBackgroundRGBMapMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'reduction')       
('l_int32', 'size')       
('PIX', '**ppixmr')       
('PIX', '**ppixmg')       
('PIX', '**ppixmb')       

:param[in]    pixs:        32 bpp rgb
:param[in]    pixim:       [optional] 1 bpp 'image' mask; can be null; it
should not have all foreground pixels
:param[in]    reduction:   factor at which closing is performed
:param[in]    size:        of square Sel for the closing; use an odd number
:param[out]   ppixmr:      red component map
:param[out]   ppixmg:      green component map
:param[out]   ppixmb:      blue component map
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBackgroundRGBMapMorph(*args)
    
    

    try:
        leptonica.pixFillMapHoles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFillMapHoles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFillMapHoles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillMapHoles(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'filltype')       

:param[in]    pix:        8 bpp; a map, with one pixel for each tile in
a larger image
:param[in]    nx:         number of horizontal pixel tiles that are entirely
covered with pixels in the original source image
:param[in]    ny:         ditto for the number of vertical pixel tiles
:param[in]    filltype:   L_FILL_WHITE or L_FILL_BLACK
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation on pix (the map).  pix is
typically a low-resolution version of some other image
from which it was derived, where each pixel in pix
corresponds to a rectangular tile (say, m x n) of pixels
in the larger image.  All we need to know about the larger
image is whether or not the rightmost column and bottommost
row of pixels in pix correspond to tiles that are
only partially covered by pixels in the larger image.
(2) Typically, some number of pixels in the input map are
not known, and their values must be determined by near
pixels that are known.  These unknown pixels are the 'holes'.
They can take on only two values, 0 and 255, and the
instruction about which to fill is given by the filltype flag.
(3) The "holes" can come from two sources.  The first is when there
are not enough foreground or background pixels in a tile;
the second is when a tile is at least partially covered
by an image mask.  If we're filling holes in a fg mask,
the holes are initialized to black (0) and use L_FILL_BLACK.
For filling holes in a bg mask, initialize the holes to
white (255) and use L_FILL_WHITE.
(4) If w is the map width, nx = w or nx = w - 1; ditto for h and ny.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillMapHoles(*args)
    
    

    try:
        leptonica.pixExtendByReplication.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixExtendByReplication.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtendByReplication not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtendByReplication(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'addw')       
('l_int32', 'addh')       

:param[in]    pixs:    8 bpp
:param[in]    addw:    number of extra pixels horizontally to add
:param[in]    addh:    number of extra pixels vertically to add
:returns:  pixd extended with replicated pixel values, or NULL on error

<pre>
Notes:
(1) The pixel values are extended to the left and down, as required.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtendByReplication(*args)
    
    

    try:
        leptonica.pixSmoothConnectedRegions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSmoothConnectedRegions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSmoothConnectedRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSmoothConnectedRegions(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'factor')       

:param[in]    pixs:    8 bpp grayscale; no colormap
:param[in]    pixm:    [optional] 1 bpp; if null, this is a no-op
:param[in]    factor:  subsampling factor for getting average; >= 1
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pixels in pixs corresponding to those in each
8-connected region in the mask are set to the average value.
(2) This is required for adaptive mapping to avoid the
generation of stripes in the background map, due to
variations in the pixel values near the edges of mask regions.
(3) This function is optimized for background smoothing, where
there are a relatively small number of components.  It will
be inefficient if used where there are many small components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSmoothConnectedRegions(*args)
    
    

    try:
        leptonica.pixGetInvBackgroundMap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetInvBackgroundMap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetInvBackgroundMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetInvBackgroundMap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       

:param[in]    pixs:       8 bpp grayscale; no colormap
:param[in]    bgval:      target bg val; typ. > 128
:param[in]    smoothx:    half-width of block convolution kernel width
:param[in]    smoothy:    half-width of block convolution kernel height
:returns:  pixd 16 bpp, or NULL on error

<pre>
Notes:
(1) bgval should typically be > 120 and < 240
(2) pixd is a normalization image; the original image is
multiplied by pixd and the result is divided by 256.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetInvBackgroundMap(*args)
    
    

    try:
        leptonica.pixApplyInvBackgroundGrayMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixApplyInvBackgroundGrayMap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixApplyInvBackgroundGrayMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyInvBackgroundGrayMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'sx')       
('l_int32', 'sy')       

:param[in]    pixs:    8 bpp grayscale; no colormap
:param[in]    pixm:    16 bpp, inverse background map
:param[in]    sx:      tile width in pixels
:param[in]    sy:      tile height in pixels
:returns:  pixd 8 bpp, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyInvBackgroundGrayMap(*args)
    
    

    try:
        leptonica.pixApplyInvBackgroundRGBMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixApplyInvBackgroundRGBMap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixApplyInvBackgroundRGBMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyInvBackgroundRGBMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixmr')       
('PIX', '*pixmg')       
('PIX', '*pixmb')       
('l_int32', 'sx')       
('l_int32', 'sy')       

:param[in]    pixs:    32 bpp rbg
:param[in]    pixmr:   16 bpp, red inverse background map
:param[in]    pixmg:   16 bpp, green inverse background map
:param[in]    pixmb:   16 bpp, blue inverse background map
:param[in]    sx:      tile width in pixels
:param[in]    sy:      tile height in pixels
:returns:  pixd 32 bpp rbg, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyInvBackgroundRGBMap(*args)
    
    

    try:
        leptonica.pixApplyVariableGrayMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixApplyVariableGrayMap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixApplyVariableGrayMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixApplyVariableGrayMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       
('l_int32', 'target')       

:param[in]    pixs:     8 bpp
:param[in]    pixg:     8 bpp, variable map
:param[in]    target:   typ. 128 for threshold
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) Suppose you have an image that you want to transform based
on some photometric measurement at each point, such as the
threshold value for binarization.  Representing the photometric
measurement as an image pixg, you can threshold in input image
using pixVarThresholdToBinary().  Alternatively, you can map
the input image pointwise so that the threshold over the
entire image becomes a constant, such as 128.  For example,
if a pixel in pixg is 150 and the target is 128, the
corresponding pixel in pixs is mapped linearly to a value
(128/150) of the input value.  If the resulting mapped image
pixd were then thresholded at 128, you would obtain the
same result as a direct binarization using pixg with
pixVarThresholdToBinary().
(2) The sizes of pixs and pixg must be equal.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixApplyVariableGrayMap(*args)
    
    

    try:
        leptonica.pixGlobalNormRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGlobalNormRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGlobalNormRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGlobalNormRGB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'mapval')       

:param[in]    pixd:     [optional] null, existing or equal to pixs
:param[in]    pixs:     32 bpp rgb, or colormapped
:param[in]    rval,: gval, bval   pixel values in pixs that are
linearly mapped to mapval
:param[in]    mapval:   use 255 for mapping to white
:returns:  pixd 32 bpp rgb or colormapped, or NULL on error

<pre>
Notes:
(1) The value of pixd determines if the results are written to a
new pix (use NULL), in-place to pixs (use pixs), or to some
other existing pix.
(2) This does a global normalization of an image where the
r,g,b color components are not balanced.  Thus, white in pixs is
represented by a set of r,g,b values that are not all 255.
(3) The input values (rval, gval, bval) should be chosen to
represent the gray color (mapval, mapval, mapval) in src.
Thus, this function will map (rval, gval, bval) to that gray color.
(4) Typically, mapval = 255, so that (rval, gval, bval)
corresponds to the white point of src.  In that case, these
parameters should be chosen so that few pixels have higher values.
(5) In all cases, we do a linear TRC separately on each of the
components, saturating at 255.
(6) If the input pix is 8 bpp without a colormap, you can get
this functionality with mapval = 255 by calling:
pixGammaTRC(pixd, pixs, 1.0, 0, bgval);
where bgval is the value you want to be mapped to 255.
Or more generally, if you want bgval to be mapped to mapval:
pixGammaTRC(pixd, pixs, 1.0, 0, 255 * bgval / mapval);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGlobalNormRGB(*args)
    
    

    try:
        leptonica.pixGlobalNormNoSatRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixGlobalNormNoSatRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGlobalNormNoSatRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGlobalNormNoSatRGB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'factor')       
('l_float32', 'rank')       

:param[in]    pixd:       [optional] null, existing or equal to pixs
:param[in]    pixs:       32 bpp rgb
:param[in]    rval,: gval, bval   pixel values in pixs that are
linearly mapped to mapval; but see below
:param[in]    factor:     subsampling factor; integer >= 1
:param[in]    rank:       between 0.0 and 1.0; typ. use a value near 1.0
:returns:  pixd 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This is a version of pixGlobalNormRGB(), where the output
intensity is scaled back so that a controlled fraction of
pixel components is allowed to saturate.  See comments in
pixGlobalNormRGB().
(2) The value of pixd determines if the results are written to a
new pix (use NULL), in-place to pixs (use pixs), or to some
other existing pix.
(3) This does a global normalization of an image where the
r,g,b color components are not balanced.  Thus, white in pixs is
represented by a set of r,g,b values that are not all 255.
(4) The input values (rval, gval, bval) can be chosen to be the
color that, after normalization, becomes white background.
For images that are mostly background, the closer these values
are to the median component values, the closer the resulting
background will be to gray, becoming white at the brightest places.
(5) The mapval used in pixGlobalNormRGB() is computed here to
avoid saturation of any component in the image (save for a
fraction of the pixels given by the input rank value).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGlobalNormNoSatRGB(*args)
    
    

    try:
        leptonica.pixThresholdSpreadNorm.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdSpreadNorm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdSpreadNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdSpreadNorm(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'filtertype')       
('l_int32', 'edgethresh')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
('l_int32', 'targetthresh')       
('PIX', '**ppixth')       
('PIX', '**ppixb')       
('PIX', '**ppixd')       

:param[in]    pixs:              8 bpp grayscale; not colormapped
:param[in]    filtertype:        L_SOBEL_EDGE or L_TWO_SIDED_EDGE;
:param[in]    edgethresh:        threshold on magnitude of edge filter;
typ 10-20
:param[in]    smoothx,: smoothy  half-width of convolution kernel applied to
spread threshold: use 0 for no smoothing
:param[in]    gamma:             gamma correction; typ. about 0.7
:param[in]    minval:            input value that gives 0 for output; typ. -25
:param[in]    maxval:            input value that gives 255 for output;
typ. 255
:param[in]    targetthresh:      target threshold for normalization
:param[out]   ppixth:            [optional] computed local threshold value
:param[out]   ppixb:             [optional] thresholded normalized image
:param[out]   ppixd:             [optional] normalized image
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The basis of this approach is the use of seed spreading
on a (possibly) sparse set of estimates for the local threshold.
The resulting dense estimates are smoothed by convolution
and used to either threshold the input image or normalize it
with a local transformation that linearly maps the pixels so
that the local threshold estimate becomes constant over the
resulting image.  This approach is one of several that
have been suggested (and implemented) by Ray Smith.
(2) You can use either the Sobel or TwoSided edge filters.
The results appear to be similar, using typical values
of edgethresh in the rang 10-20.
(3) To skip the trc enhancement, use gamma = 1.0, minval = 0
and maxval = 255.
(4) For the normalized image pixd, each pixel is linearly mapped
in such a way that the local threshold is equal to targetthresh.
(5) The full width and height of the convolution kernel
are (2 * smoothx + 1) and (2 * smoothy + 1).
(6) This function can be used with the pixtiling utility if the
images are too large.  See pixOtsuAdaptiveThreshold() for
an example of this.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdSpreadNorm(*args)
    
    

    try:
        leptonica.pixBackgroundNormFlex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBackgroundNormFlex.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBackgroundNormFlex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBackgroundNormFlex(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_int32', 'delta')       

:param[in]    pixs:               8 bpp grayscale; not colormapped
:param[in]    sx,: sy             desired tile dimensions; size may vary;
use values between 3 and 10
:param[in]    smoothx,: smoothy   half-width of convolution kernel applied to
threshold array: use values between 1 and 3
:param[in]    delta:              difference parameter in basin filling;
use 0 to skip
:returns:  pixd 8 bpp, background-normalized), or NULL on error

<pre>
Notes:
(1) This does adaptation flexibly to a quickly varying background.
For that reason, all input parameters should be small.
(2) sx and sy give the tile size; they should be in [5 - 7].
(3) The full width and height of the convolution kernel
are (2 * smoothx + 1) and (2 * smoothy + 1).  They
should be in [1 - 2].
(4) Basin filling is used to fill the large fg regions.  The
parameter %delta measures the height that the black
background is raised from the local minima.  By raising
the background, it is possible to threshold the large
fg regions to foreground.  If %delta is too large,
bg regions will be lifted, causing thickening of
the fg regions.  Use 0 to skip.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBackgroundNormFlex(*args)
    
    

    try:
        leptonica.pixContrastNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixContrastNorm.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixContrastNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixContrastNorm(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'mindiff')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       

:param[in]    pixd:               [optional] 8 bpp; null or equal to pixs
:param[in]    pixs:               8 bpp grayscale; not colormapped
:param[in]    sx,: sy             tile dimensions
:param[in]    mindiff:            minimum difference to accept as valid
:param[in]    smoothx,: smoothy   half-width of convolution kernel applied to
min and max arrays: use 0 for no smoothing
:returns:  pixd always

<pre>
Notes:
(1) This function adaptively attempts to expand the contrast
to the full dynamic range in each tile.  If the contrast in
a tile is smaller than %mindiff, it uses the min and max
pixel values from neighboring tiles.  It also can use
convolution to smooth the min and max values from
neighboring tiles.  After all that processing, it is
possible that the actual pixel values in the tile are outside
the computed [min ... max] range for local contrast
normalization.  Such pixels are taken to be at either 0
(if below the min) or 255 (if above the max).
(2) pixd can be equal to pixs (in-place operation) or
null (makes a new pixd).
(3) sx and sy give the tile size; they are typically at least 20.
(4) mindiff is used to eliminate results for tiles where it is
likely that either fg or bg is missing.  A value around 50
or more is reasonable.
(5) The full width and height of the convolution kernel
are (2 * smoothx + 1) and (2 * smoothy + 1).  Some smoothing
is typically useful, and we limit the smoothing half-widths
to the range from 0 to 8.
(6) A linear TRC (gamma = 1.0) is applied to increase the contrast
in each tile.  The result can subsequently be globally corrected,
by applying pixGammaTRC() with arbitrary values of gamma
and the 0 and 255 points of the mapping.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixContrastNorm(*args)
    
    

    try:
        leptonica.pixMinMaxTiles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMinMaxTiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMinMaxTiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMinMaxTiles(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'mindiff')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('PIX', '**ppixmin')       
('PIX', '**ppixmax')       

:param[in]    pixs:               8 bpp grayscale; not colormapped
:param[in]    sx,: sy             tile dimensions
:param[in]    mindiff:            minimum difference to accept as valid
:param[in]    smoothx,: smoothy   half-width of convolution kernel applied to
min and max arrays: use 0 for no smoothing
:param[out]   ppixmin:            tiled minima
:param[out]   ppixmax:            tiled maxima
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes filtered and smoothed values for the min and
max pixel values in each tile of the image.
(2) See pixContrastNorm() for usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMinMaxTiles(*args)
    
    

    try:
        leptonica.pixSetLowContrast.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetLowContrast.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetLowContrast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetLowContrast(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'mindiff')       

:param[in]    pixs1:      8 bpp
:param[in]    pixs2:      8 bpp
:param[in]    mindiff:    minimum difference to accept as valid
:returns:  0 if OK; 1 if no pixel diffs are large enough, or on error

<pre>
Notes:
(1) This compares corresponding pixels in pixs1 and pixs2.
When they differ by less than %mindiff, set the pixel
values to 0 in each.  Each pixel typically represents a tile
in a larger image, and a very small difference between
the min and max in the tile indicates that the min and max
values are not to be trusted.
(2) If contrast (pixel difference) detection is expected to fail,
caller should check return value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetLowContrast(*args)
    
    

    try:
        leptonica.pixLinearTRCTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixLinearTRCTiled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixLinearTRCTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLinearTRCTiled(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('PIX', '*pixmin')       
('PIX', '*pixmax')       

:param[in]    pixd:     [optional] 8 bpp
:param[in]    pixs:     8 bpp, not colormapped
:param[in]    sx,: sy   tile dimensions
:param[in]    pixmin:   pix of min values in tiles
:param[in]    pixmax:   pix of max values in tiles
:returns:  pixd always

<pre>
Notes:
(1) pixd can be equal to pixs (in-place operation) or
null (makes a new pixd).
(2) sx and sy give the tile size; they are typically at least 20.
(3) pixmin and pixmax are generated by pixMinMaxTiles()
(4) For each tile, this does a linear expansion of the dynamic
range so that the min value in the tile becomes 0 and the
max value in the tile becomes 255.
(5) The LUTs that do the mapping are generated as needed
and stored for reuse in an integer array within the ptr array iaa[].
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixLinearTRCTiled(*args)
    




class colorcontent(object):
    """<pre>

Build an image of the color content, on a per-pixel basis,
as a measure of the amount of divergence of each color
component (R,G,B) from gray.
l_int32    pixColorContent()

Find the 'amount' of color in an image, on a per-pixel basis,
as a measure of the difference of the pixel color from gray.
PIX       *pixColorMagnitude()

Find the fraction of pixels with "color" that are not close to black
l_int32    pixColorFraction()

Do a linear TRC to map colors so that the three input reference
values go to white.  These three numbers are typically the median
or average background values.
PIX       *pixColorShiftWhitePoint()

Generate a mask over pixels that have sufficient color and
are not too close to gray pixels.
PIX       *pixMaskOverColorPixels()

Generate a mask over dark pixels with little color
PIX       *pixMaskOverGrayPixels()

Generate mask over pixels within a prescribed cube in RGB space
PIX       *pixMaskOverColorRange()

Determine if there are significant color regions that are
not background in a page image
l_int32    pixFindColorRegions()

Find the number of perceptually significant gray intensities
in a grayscale image.
l_int32    pixNumSignificantGrayColors()

Identify images where color quantization will cause posterization
due to the existence of many colors in low-gradient regions.
l_int32    pixColorsForQuantization()

Find the number of unique colors in an image
l_int32    pixNumColors()

Lossless conversion of RGB image to colormapped
PIX       *pixConvertRGBToCmapLossless()

Find the most "populated" colors in the image (and quantize)
l_int32    pixGetMostPopulatedColors()
PIX       *pixSimpleColorQuantize()

Construct a color histogram based on rgb indices
NUMA      *pixGetRGBHistogram()
l_int32    makeRGBIndexTables()
l_int32    getRGBFromIndex()

Identify images that have highlight (red) color
l_int32    pixHasHighlightRed()

Color is tricky.  If we consider gray (r = g = b) to have no color
content, how should we define the color content in each component
of an arbitrary pixel, as well as the overall color magnitude?

I can think of three ways to define the color content in each component:

(1) Linear.  For each component, take the difference from the average
of all three.
(2) Linear.  For each component, take the difference from the average
of the other two.
(3) Nonlinear.  For each component, take the minimum of the differences
from the other two.

How might one choose from among these?  Consider two different situations:
(a) r = g = 0, b = 255            {255}   /255/   <255>
(b) r = 0, g = 127, b = 255       {191}   /128/   <255>
How much g is in each of these?  The three methods above give:
(a)  1: 85   2: 127   3: 0        [85]
(b)  1: 0    2: 0     3: 127      [0]
How much b is in each of these?
(a)  1: 170  2: 255   3: 255      [255]
(b)  1: 127  2: 191   3: 127      [191]
The number I'd "like" to give is in [].  (Please don't ask why, it's
just a feeling.

So my preferences seem to be somewhere between (1) and (2).
(3) is just too "decisive!"  Let's pick (2).

We also allow compensation for white imbalance.  For each
component, we do a linear TRC (gamma = 1.0), where the black
point remains at 0 and the white point is given by the input
parameter.  This is equivalent to doing a global remapping,
as with pixGlobalNormRGB(), followed by color content (or magnitude)
computation, but without the overhead of first creating the
white point normalized image.

Another useful property is the overall color magnitude in the pixel.
For this there are again several choices, such as:
(a) rms deviation from the mean
(b) the average L1 deviation from the mean
(c) the maximum (over components) of one of the color
content measures given above.

For now, we will consider three of the methods in (c):
L_INTERMED_DIFF
Define the color magnitude as the intermediate value of the
three differences between the three components.
For (a) and (b) above, this value is in /../.
L_AVE_MAX_DIFF_2
Define the color magnitude as the maximum over components
of the difference between the component value and the
average of the other two.  It is easy to show that
this is equivalent to selecting the two component values
that are closest to each other, averaging them, and
using the distance from that average to the third component.
For (a) and (b) above, this value is in {..}.
L_MAX_DIFF
Define the color magnitude as the maximum value of the
three differences between the three components.
For (a) and (b) above, this value is in <..>.
</pre>




"""
    
    try:
        leptonica.pixColorContent.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixColorContent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorContent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorContent(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rref')       
('l_int32', 'gref')       
('l_int32', 'bref')       
('l_int32', 'mingray')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       

:param[in]    pixs:      32 bpp rgb or 8 bpp colormapped
:param[in]    rref:      reference value for red component
:param[in]    gref:      reference value for green component
:param[in]    bref:      reference value for blue component
:param[in]    mingray:   min gray value for which color is measured
:param[out]   ppixr:     [optional] 8 bpp red 'content'
:param[out]   ppixg:     [optional] 8 bpp green 'content'
:param[out]   ppixb:     [optional] 8 bpp blue 'content'
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns the color content in each component, which is
a measure of the deviation from gray, and is defined
as the difference between the component and the average of
the other two components.  See the discussion at the
top of this file.
(2) The three numbers (rref, gref and bref) can be thought
of in two ways:
(a) as the values in the image corresponding to white,
to compensate for an unbalanced color white point.
(b) the median or mean values of the background color of
a scan.
The gamma TRC transformation is used to modify all colors so that
these reference values become white.
These three numbers must either be all 0 or all non-zero.
To skip the TRC transform, set them all to 0.
(3) If the maximum component after white point correction,
max(r,g,b), is less than mingray, all color components
for that pixel are set to zero.
Use mingray = 0 to turn off this filtering of dark pixels.
(4) Therefore, use 0 for all four input parameters if the color
magnitude is to be calculated without either white balance
correction or dark filtering.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorContent(*args)
    
    

    try:
        leptonica.pixColorMagnitude.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorMagnitude.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorMagnitude not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorMagnitude(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rref')       
('l_int32', 'gref')       
('l_int32', 'bref')       
('l_int32', 'type')       

:param[in]    pixs:    32 bpp rgb or 8 bpp colormapped
:param[in]    rref:    reference value for red component
:param[in]    gref:    reference value for green component
:param[in]    bref:    reference value for blue component
:param[in]    type:    chooses the method for calculating the color magnitude:
L_INTERMED_DIFF, L_AVE_MAX_DIFF_2, L_MAX_DIFF
:returns:  pixd 8 bpp, amount of color in each source pixel,
or NULL on error

<pre>
Notes:
(1) For an RGB image, a gray pixel is one where all three components
are equal.  We define the amount of color in an RGB pixel as
a function depending on the absolute value of the differences
between the three color components.  Consider the two largest
of these differences.  The pixel component in common to these
two differences is the color farthest from the other two.
The color magnitude in an RGB pixel can be taken as one
of these three definitions:
(a) The minimum value of these two differences.  This is
the intermediate value of the three distances between
component values.
(b) The average of these two differences.  This is the
average distance from the two components that are
nearest to each other to the third component.
(c) The maximum difference between component values.
(2) As an example, suppose that R and G are the closest in
magnitude.  Then the color is determined as either:
(a) The minimum distance of B from these two:
min(|B - R|, |B - G|).
(b) The average distance of B from these two:
(|B - R| + |B - G|) / 2
(c) The maximum distance of B from these two:
max(|B - R|, |B - G|)
(3) This example can be visualized graphically.  Put the R,G and B
component values on a line; e.g.,
G...R...........B
(a) B - R
(b) B - (R + G) / 2
(c) B - G
(4) The three methods for choosing the color magnitude from
the components are selected with these flags:
(a) L_INTERMED_DIFF
(b) L_AVE_MAX_DIFF_2
(c) L_MAX_DIFF
(5) The three numbers (rref, gref and bref) can be thought
of in two ways:
(a) as the values in the image corresponding to white,
to compensate for an unbalanced color white point.
(b) the median or mean values of the background color of
a scan.
The gamma TRC transformation is used to modify all colors so that
these reference values become white.
These three numbers must either be all 0 or all non-zero.
To skip the TRC transform, set them all to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorMagnitude(*args)
    
    

    try:
        leptonica.pixColorFraction.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixColorFraction.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorFraction(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       
('l_int32', 'factor')       
('l_float32', '*ppixfract')       
('l_float32', '*pcolorfract')       

:param[in]    pixs:  32 bpp rgb
:param[in]    darkthresh:    threshold near black; if the largest (lightest)
component is below this, the pixel is not
considered in the statistics; typ. 20
:param[in]    lightthresh:   threshold near white; if the smallest (darkest)
component is above this, the pixel is not
considered in the statistics; typ. 244
:param[in]    diffthresh:    thresh for the maximum difference between
component values; below this the pixel is not
considered to have sufficient color
:param[in]    factor:        subsampling factor
:param[out]   ppixfract:     fraction of pixels in intermediate
brightness range that were considered
for color content
:param[out]   pcolorfract:   fraction of pixels that meet the
criterion for sufficient color; 0.0 on error
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function is asking the question: to what extent does the
image appear to have color?   The amount of color a pixel
appears to have depends on both the deviation of the
individual components from their average and on the average
intensity itself.  For example, the color will be much more
obvious with a small deviation from white than the same
deviation from black.
(2) Any pixel that meets these three tests is considered a
colorful pixel:
(a) the lightest component must equal or exceed %darkthresh
(b) the darkest component must not exceed %lightthresh
(c) the max difference between components must equal or
exceed %diffthresh.
(3) The dark pixels are removed from consideration because
they don't appear to have color.
(4) The very lightest pixels are removed because if an image
has a lot of "white", the color fraction will be artificially
low, even if all the other pixels are colorful.
(5) If pixfract is very small, there are few pixels that are neither
black nor white.  If colorfract is very small, the pixels
that are neither black nor white have very little color
content.  The product 'pixfract * colorfract' gives the
fraction of pixels with significant color content.
(6) One use of this function is as a preprocessing step for median
cut quantization (colorquant2.c), which does a very poor job
splitting the color space into rectangular volume elements when
all the pixels are near the diagonal of the color cube.  For
octree quantization of an image with only gray values, the
2^(level) octcubes on the diagonal are the only ones
that can be occupied.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorFraction(*args)
    
    

    try:
        leptonica.pixColorShiftWhitePoint.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorShiftWhitePoint.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorShiftWhitePoint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorShiftWhitePoint(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rref')       
('l_int32', 'gref')       
('l_int32', 'bref')       

:param[in]    pixs:      32 bpp rgb or 8 bpp colormapped
:param[in]    rref:      reference value for red component
:param[in]    gref:      reference value for green component
:param[in]    bref:      reference value for blue component
:returns:  pix2  32 bpp if OK, NULL on error

<pre>
Notes:
(1) This returns a pix where the colors are linearly mapped to
so that the components go to 255 at the input reference values.
(2) These three numbers (rref, gref and bref) can be thought
of in two ways:
(a) as the values in the image corresponding to white,
to compensate for an unbalanced color white point.
(b) the median or mean values of the background color of
an image.
A linear (gamma = 1) TRC transformation is used.
(3) Any existing colormap is removed and a 32 bpp rgb pix is returned.
(4) No transformation is applied if any of the three numbers are <= 0.
If any are < 0, or if some but not all are 0, a warning is given.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorShiftWhitePoint(*args)
    
    

    try:
        leptonica.pixMaskOverColorPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMaskOverColorPixels.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaskOverColorPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskOverColorPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'threshdiff')       
('l_int32', 'mindist')       

:param[in]    pixs:         32 bpp rgb or 8 bpp colormapped
:param[in]    threshdiff:   threshold for minimum of the max difference
between components
:param[in]    mindist:      min allowed distance from nearest non-color pixel
:returns:  pixd 1 bpp, mask over color pixels, or NULL on error

<pre>
Notes:
(1) The generated mask identifies each pixel as either color or
non-color.  For a pixel to be color, it must satisfy two
constraints:
(a) The max difference between the r,g and b components must
equal or exceed a threshold %threshdiff.
(b) It must be at least %mindist (in an 8-connected way)
from the nearest non-color pixel.
(2) The distance constraint (b) is only applied if %mindist > 1.
For example, if %mindist == 2, the color pixels identified
by (a) are eroded by a 3x3 Sel.  In general, the Sel size
for erosion is 2 * (%mindist - 1) + 1.
Why have this constraint?  In scanned images that are
essentially gray, color artifacts are typically introduced
in transition regions near sharp edges that go from dark
to light, so this allows these transition regions to be removed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskOverColorPixels(*args)
    
    

    try:
        leptonica.pixMaskOverGrayPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMaskOverGrayPixels.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaskOverGrayPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskOverGrayPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxlimit')       
('l_int32', 'satlimit')       

:param[in]    pixs:      32 bpp rgb
:param[in]    maxlimit:  only consider pixels with max component <= %maxlimit
:param[in]    satlimit:  only consider pixels with saturation <= %satlimit
:returns:  pixd (1 bpp), or NULL on error

<pre>
Notes:
(1) This generates a mask over rgb pixels that are gray (i.e.,
have low saturation) and are not too bright.  For example, if
we know that the gray pixels in %pixs have saturation
(max - min) less than 10, and brightness (max) less than 200,
pixMaskOverGrayPixels(pixs, 220, 10)
will generate a mask over the gray pixels.  Other pixels that
are not too dark and have a relatively large saturation will
be little affected.
(2) The algorithm is related to pixDarkenGray().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskOverGrayPixels(*args)
    
    

    try:
        leptonica.pixMaskOverColorRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMaskOverColorRange.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaskOverColorRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskOverColorRange(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rmin')       
('l_int32', 'rmax')       
('l_int32', 'gmin')       
('l_int32', 'gmax')       
('l_int32', 'bmin')       
('l_int32', 'bmax')       

:param[in]    pixs:          32 bpp rgb or 8 bpp colormapped
:param[in]    rmin,: rmax    min and max allowed values for red component
:param[in]    gmin,: gmax    ditto for green
:param[in]    bmin,: bmax    ditto for blue
:returns:  pixd 1 bpp, mask over color pixels, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskOverColorRange(*args)
    
    

    try:
        leptonica.pixFindColorRegions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindColorRegions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindColorRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindColorRegions(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'factor')       
('l_int32', 'lightthresh')       
('l_int32', 'darkthresh')       
('l_int32', 'mindiff')       
('l_int32', 'colordiff')       
('l_float32', 'edgefract')       
('l_float32', '*pcolorfract')       
('PIX', '**pcolormask1')       
('PIX', '**pcolormask2')       
('PIXA', '*pixadb')       

:param[in]    pixs:         32 bpp rgb
:param[in]    pixm:         [optional] 1 bpp mask image
:param[in]    factor:       subsample factor; integer >= 1
:param[in]    lightthresh:  threshold for component average in lightest
of 10 buckets; typ. 210; -1 for default
:param[in]    darkthresh:   threshold to eliminate dark pixels (e.g., text)
from consideration; typ. 70; -1 for default.
:param[in]    mindiff:      minimum difference (b - r) and (g - r), used to
find blue or green pixels; typ. 10; -1 for default
:param[in]    colordiff:    minimum difference in (max - min) component to
qualify as a color pixel; typ. 90; -1 for default
:param[in]    edgefract:    fraction of image half-width and half-height
for which color pixels are ignored; typ. 0.05.
:param[out]   pcolorfract:  fraction of 'color' pixels found
:param[out]   pcolormask1:  [optional] mask over background color, if any
:param[out]   pcolormask2:  [optional] filtered mask over background color
:param[out]   pixadb:       [optional] debug intermediate results
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function tries to determine if there is a significant
color or darker region on a scanned page image, where part
of the image is background that is either white or reddish.
This also allows extraction of regions of colored pixels that
have a smaller red component than blue or green components.
(2) If %pixm exists, pixels under its fg are combined with
dark pixels to make a mask of pixels not to be considered
as color candidates.
(3) There are four thresholds.
%lightthresh: compute the average value of each rgb pixel,
and make 10 buckets by value.  If the lightest bucket gray
value is below %lightthresh, the image is not considered
to have a light bg, and this returns 0.0 for %colorfract.
%darkthresh: ignore pixels darker than this (typ. fg text).
We make a 1 bpp mask of these pixels, and then dilate it to
remove all vestiges of fg from their vicinity.
%mindiff: consider pixels with either (b - r) or (g - r)
being at least this value, as having color.
%colordiff: consider pixels where the (max - min) difference
of the pixel components exceeds this value, as having color.
(4) All components of color pixels that are touching the image
border are removed.  Additionally, all pixels within some
normalized distance %edgefract from the image border can
be removed.  This insures that dark pixels near the edge
of the image are not included.
(5) This returns in %pcolorfract the fraction of pixels that have
color and are not in the set consisting of an OR between
%pixm and the dilated dark pixel mask.
(6) No masks are returned unless light color pixels are found.
If colorfract > 0.0 and %pcolormask1 is defined, this returns
a 1 bpp mask with fg pixels over the color background.
This mask may have some holes in it.
(7) If colorfract > 0.0 and %pcolormask2 is defined, this returns
a version of colormask1 where small holes have been filled.
(8) To generate a boxa of rectangular regions from the overlap
of components in the filtered mask:
boxa1 = pixConnCompBB(colormask2, 8);
boxa2 = boxaCombineOverlaps(boxa1, NULL);
This is done here in debug mode.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindColorRegions(*args)
    
    

    try:
        leptonica.pixNumSignificantGrayColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixNumSignificantGrayColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixNumSignificantGrayColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixNumSignificantGrayColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_float32', 'minfract')       
('l_int32', 'factor')       
('l_int32', '*pncolors')       

:param[in]    pixs:          8 bpp gray
:param[in]    darkthresh:    dark threshold for minimum intensity to be
considered; typ. 20
:param[in]    lightthresh:   threshold near white, for maximum intensity
to be considered; typ. 236
:param[in]    minfract:      minimum fraction of all pixels to include a level
as significant; typ. 0.0001; should be < 0.001
:param[in]    factor:        subsample factor; integer >= 1
:param[out]   pncolors:      number of significant colors; 0 on error
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function is asking the question: how many perceptually
significant gray color levels is in this pix?
A color level must meet 3 criteria to be significant:
~ it can't be too close to black
~ it can't be too close to white
~ it must have at least some minimum fractional population
(2) Use -1 for default values for darkthresh, lightthresh and minfract.
(3) Choose default of darkthresh = 20, because variations in very
dark pixels are not visually significant.
(4) Choose default of lightthresh = 236, because document images
that have been jpeg'd typically have near-white pixels in the
8x8 jpeg blocks, and these should not be counted.  It is desirable
to obtain a clean image by quantizing this noise away.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixNumSignificantGrayColors(*args)
    
    

    try:
        leptonica.pixColorsForQuantization.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixColorsForQuantization.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorsForQuantization not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorsForQuantization(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('l_int32', '*pncolors')       
('l_int32', '*piscolor')       
('l_int32', 'debug')       
:param[in]    pixs: 8     bpp gray or 32 bpp rgb; with or without colormap
:param[in]    thresh:     binary threshold on edge gradient; 0 for default
:param[out]   pncolors:   the number of colors found
:param[out]   piscolor:   [optional] 1 if significant color is found;
0 otherwise.  If pixs is 8 bpp, and does not have
a colormap with color entries, this is 0
:param[in]    debug:      1 to output masked image that is tested for colors;
0 otherwise
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This function finds a measure of the number of colors that are
found in low-gradient regions of an image.  By its
magnitude relative to some threshold (not specified in
this function), it gives a good indication of whether
quantization will generate posterization.   This number
is larger for images with regions of slowly varying
intensity (if 8 bpp) or color (if rgb). Such images, if
quantized, may require dithering to avoid posterization,
and lossless compression is then expected to be poor.
(2) If pixs has a colormap, the number of colors returned is
the number in the colormap.
(3) It is recommended that document images be reduced to a width
of 800 pixels before applying this function.  Then it can
be expected that color detection will be fairly accurate
and the number of colors will reflect both the content and
the type of compression to be used.  For less than 15 colors,
there is unlikely to be a halftone image, and lossless
quantization should give both a good visual result and
better compression.
(4) When using the default threshold on the gradient (15),
images (both gray and rgb) where ncolors is greater than
about 15 will compress poorly with either lossless
compression or dithered quantization, and they may be
posterized with non-dithered quantization.
(5) For grayscale images, or images without significant color,
this returns the number of significant gray levels in
the low-gradient regions.  The actual number of gray levels
can be large due to jpeg compression noise in the background.
(6) Similarly, for color images, the actual number of different
(r,g,b) colors in the low-gradient regions (rather than the
number of occupied level 4 octcubes) can be quite large, e.g.,
due to jpeg compression noise, even for regions that appear
to be of a single color.  By quantizing to level 4 octcubes,
most of these superfluous colors are removed from the counting.
(7) The image is tested for color.  If there is very little color,
it is thresholded to gray and the number of gray levels in
the low gradient regions is found.  If the image has color,
the number of occupied level 4 octcubes is found.
(8) The number of colors in the low-gradient regions increases
monotonically with the threshold %thresh on the edge gradient.
(9) Background: grayscale and color quantization is often useful
to achieve highly compressed images with little visible
distortion.  However, gray or color washes (regions of
low gradient) can defeat this approach to high compression.
How can one determine if an image is expected to compress
well using gray or color quantization?  We use the fact that
gray washes, when quantized with less than 50 intensities,
have posterization (visible boundaries between regions
of uniform 'color') and poor lossless compression
color washes, when quantized with level 4 octcubes,
typically result in both posterization and the occupancy
of many level 4 octcubes.
Images can have colors either intrinsically or as jpeg
compression artifacts.  This function reduces but does not
completely eliminate measurement of jpeg quantization noise
in the white background of grayscale or color images.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorsForQuantization(*args)
    
    

    try:
        leptonica.pixNumColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixNumColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixNumColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixNumColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', '*pncolors')       
:param[in]    pixs:       2, 4, 8, 32 bpp
:param[in]    factor:     subsampling factor; integer
:param[out]   pncolors:   the number of colors found in the pix
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This returns the number of colors found in the image,
even if there is a colormap.  If %factor == 1 and the
number of colors differs from the number of entries
in the colormap, a warning is issued.
(2) Use %factor == 1 to find the actual number of colors.
Use %factor > 1 to more efficiently find an approximate
number of colors.
(3) For d = 2, 4 or 8 bpp grayscale, this returns the number
of colors found in the image in 'ncolors'.
(4) For d = 32 bpp (rgb), if the number of colors is greater
than 256, this uses a hash set with %factor == 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixNumColors(*args)
    
    

    try:
        leptonica.pixConvertRGBToCmapLossless.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToCmapLossless.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToCmapLossless not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToCmapLossless(*args):
        """
        ('PIX', '*pixs')       
:param[in]    pixs:     32 bpp RGB
:returns:  pixd   if num colors <= 256; null otherwise or on error

<pre>
Notes:
(1) If there are not more than 256 colors, this losslessly
converts and RGB image to a colormapped one, with the
smallest pixel depth required to hold all the colors.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToCmapLossless(*args)
    
    

    try:
        leptonica.pixGetMostPopulatedColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetMostPopulatedColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetMostPopulatedColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetMostPopulatedColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'factor')       
('l_int32', 'ncolors')       
('l_uint32', '**parray')       
('PIXCMAP', '**pcmap')       
:param[in]    pixs: 32   bpp rgb
:param[in]    sigbits:   2-6, significant bits retained in the quantizer
for each component of the input image
:param[in]    factor:    subsampling factor; use 1 for no subsampling
:param[in]    ncolors:   the number of most populated colors to select
:param[out]   parray:    [optional] array of colors, each as 0xrrggbb00
:param[out]   pcmap:     [optional] colormap of the colors
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This finds the %ncolors most populated cubes in rgb colorspace,
where the cube size depends on %sigbits as
cube side = (256 >> sigbits)
(2) The rgb color components are found at the center of the cube.
(3) The output array of colors can be displayed using
pixDisplayColorArray(array, ncolors, ...);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetMostPopulatedColors(*args)
    
    

    try:
        leptonica.pixSimpleColorQuantize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSimpleColorQuantize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSimpleColorQuantize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSimpleColorQuantize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'factor')       
('l_int32', 'ncolors')       
:param[in]    pixs:      32 bpp rgb
:param[in]    sigbits:   2-4, significant bits retained in the quantizer
for each component of the input image
:param[in]    factor:    subsampling factor; use 1 for no subsampling
:param[in]    ncolors:   the number of most populated colors to select
:returns:  pixd 8 bpp cmapped or NULL on error

<pre>
Notes:
(1) If you want to do color quantization for real, use octcube
or modified median cut.  This function shows that it is
easy to make a simple quantizer based solely on the population
in cells of a given size in rgb color space.
(2) The %ncolors most populated cells at the %sigbits level form
the colormap for quantizing, and this uses octcube indexing
under the covers to assign each pixel to the nearest color.
(3) %sigbits is restricted to 2, 3 and 4.  At the low end, the
color discrimination is very crude; at the upper end, a set of
similar colors can dominate the result.  Interesting results
are generally found for %sigbits = 3 and ncolors ~ 20.
(4) See also pixColorSegment() for a method of quantizing the
colors to generate regions of similar color.
(5) See also pixConvertRGBToCmapLossless() to losslessly convert
an RGB image with not more than 256 colors.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSimpleColorQuantize(*args)
    
    

    try:
        leptonica.pixGetRGBHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetRGBHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRGBHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'factor')       
:param[in]    pixs:      32 bpp rgb
:param[in]    sigbits:   2-6, significant bits retained in the quantizer
for each component of the input image
:param[in]    factor:    subsampling factor; use 1 for no subsampling
:returns:  numa histogram of colors, indexed by RGB
components, or NULL on error

<pre>
Notes:
(1) This uses a simple, fast method of indexing into an rgb image.
(2) The output is a 1D histogram of count vs. rgb-index, which
uses red sigbits as the most significant and blue as the least.
(3) This function produces the same result as pixMedianCutHisto().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBHistogram(*args)
    
    

    try:
        leptonica.makeRGBIndexTables.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.makeRGBIndexTables.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function makeRGBIndexTables not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeRGBIndexTables(*args):
        """
        ('l_uint32', '**prtab')       
('l_uint32', '**pgtab')       
('l_uint32', '**pbtab')       
('l_int32', 'sigbits')       

:param[out]   prtab,: pgtab, pbtab    256-entry rgb index tables
:param[in]    sigbits:   2-6, significant bits retained in the quantizer
for each component of the input image
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) These tables are used to map from rgb sample values to
an rgb index, using
rgbindex = rtab[rval] | gtab[gval] | btab[bval]
where, e.g., if sigbits = 3, the index is a 9 bit integer:
r7 r6 r5 g7 g6 g5 b7 b6 b5
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeRGBIndexTables(*args)
    
    

    try:
        leptonica.getRGBFromIndex.argtypes = [ctypes.c_uint32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getRGBFromIndex.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getRGBFromIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getRGBFromIndex(*args):
        """
        ('l_uint32', 'index')       
('l_int32', 'sigbits')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    index:      rgbindex
:param[in]    sigbits:    2-6, significant bits retained in the quantizer
for each component of the input image
:param[out]   prval,: pgval, pbval   rgb values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The %index is expressed in bits, based on the the
%sigbits of the r, g and b components, as
r7 r6 ... g7 g6 ... b7 b6 ...
(2) The computed rgb values are in the center of the quantized cube.
The extra bit that is OR'd accomplishes this.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getRGBFromIndex(*args)
    
    

    try:
        leptonica.pixHasHighlightRed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixHasHighlightRed.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixHasHighlightRed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHasHighlightRed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', 'minfract')       
('l_float32', 'fthresh')       
('l_int32', '*phasred')       
('l_float32', '*pratio')       
('PIX', '**ppixdb')       

:param[in]    pixs:      32 bpp rgb
:param[in]    factor:    subsampling; an integer >= 1; use 1 for all pixels
:param[in]    minfract:  threshold fraction of all image pixels; must be > 0.0
:param[in]    fthresh:   threshold on a function of the components; typ. ~2.5
:param[out]   phasred:   1 if red pixels are above threshold
:param[out]   pratio:    [optional] normalized fraction of threshold
red pixels that is actually observed
:param[out]   ppixdb:    [optional] seed pixel mask
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Pixels are identified as red if they satisfy two conditions:
(a) The components satisfy (R-B)/B > %fthresh   (red or dark fg)
(b) The red component satisfied R > 128  (red or light bg)
Masks are generated for (a) and (b), and the intersection
gives the pixels that are red but not either light bg or
dark fg.
(2) A typical value for minfract = 0.0001, which gives sensitivity
to an image where a small fraction of the pixels are printed
in red.
(3) A typical value for fthresh = 2.5.  Higher values give less
sensitivity to red, and fewer false positives.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHasHighlightRed(*args)
    




class numafunc1(object):
    """<pre>

--------------------------------------
This file has these Numa utilities:
- arithmetic operations
- simple data analysis
- generation of special sequences
- permutations
- interpolation
- sorting
- data analysis requiring sorting
- joins and rearrangements
--------------------------------------

Arithmetic and logic
NUMA        *numaArithOp()
NUMA        *numaLogicalOp()
NUMA        *numaInvert()
l_int32      numaSimilar()
l_int32      numaAddToNumber()

Simple extractions
l_int32      numaGetMin()
l_int32      numaGetMax()
l_int32      numaGetSum()
NUMA        *numaGetPartialSums()
l_int32      numaGetSumOnInterval()
l_int32      numaHasOnlyIntegers()
NUMA        *numaSubsample()
NUMA        *numaMakeDelta()
NUMA        *numaMakeSequence()
NUMA        *numaMakeConstant()
NUMA        *numaMakeAbsValue()
NUMA        *numaAddBorder()
NUMA        *numaAddSpecifiedBorder()
NUMA        *numaRemoveBorder()
l_int32      numaCountNonzeroRuns()
l_int32      numaGetNonzeroRange()
l_int32      numaGetCountRelativeToZero()
NUMA        *numaClipToInterval()
NUMA        *numaMakeThresholdIndicator()
NUMA        *numaUniformSampling()
NUMA        *numaReverse()

Signal feature extraction
NUMA        *numaLowPassIntervals()
NUMA        *numaThresholdEdges()
NUMA        *numaGetSpanValues()
NUMA        *numaGetEdgeValues()

Interpolation
l_int32      numaInterpolateEqxVal()
l_int32      numaInterpolateEqxInterval()
l_int32      numaInterpolateArbxVal()
l_int32      numaInterpolateArbxInterval()

Functions requiring interpolation
l_int32      numaFitMax()
l_int32      numaDifferentiateInterval()
l_int32      numaIntegrateInterval()

Sorting
NUMA        *numaSortGeneral()
NUMA        *numaSortAutoSelect()
NUMA        *numaSortIndexAutoSelect()
l_int32      numaChooseSortType()
NUMA        *numaSort()
NUMA        *numaBinSort()
NUMA        *numaGetSortIndex()
NUMA        *numaGetBinSortIndex()
NUMA        *numaSortByIndex()
l_int32      numaIsSorted()
l_int32      numaSortPair()
NUMA        *numaInvertMap()

Random permutation
NUMA        *numaPseudorandomSequence()
NUMA        *numaRandomPermutation()

Functions requiring sorting
l_int32      numaGetRankValue()
l_int32      numaGetMedian()
l_int32      numaGetBinnedMedian()
l_int32      numaGetMeanDevFromMedian()
l_int32      numaGetMedianDevFromMedian()
l_int32      numaGetMode()

Rearrangements
l_int32      numaJoin()
l_int32      numaaJoin()
NUMA        *numaaFlattenToNuma()

Things to remember when using the Numa:

(1) The numa is a struct, not an array.  Always use accessors
(see numabasic.c), never the fields directly.

(2) The number array holds l_float32 values.  It can also
be used to store l_int32 values.  See numabasic.c for
details on using the accessors.

(3) If you use numaCreate(), no numbers are stored and the size is 0.
You have to add numbers to increase the size.
If you want to start with a numa of a fixed size, with each
entry initialized to the same value, use numaMakeConstant().

(4) Occasionally, in the comments we denote the i-th element of a
numa by na[i].  This is conceptual only -- the numa is not an array!
</pre>




"""
    
    try:
        leptonica.numaArithOp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaArithOp.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaArithOp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaArithOp(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'op')       

:param[in]    nad:     [optional] can be null or equal to na1 (in-place
:param[in]    na1:
:param[in]    na2:
:param[in]    op:      L_ARITH_ADD, L_ARITH_SUBTRACT,
L_ARITH_MULTIPLY, L_ARITH_DIVIDE
:returns:  nad always: operation applied to na1 and na2

<pre>
Notes:
(1) The sizes of na1 and na2 must be equal.
(2) nad can only null or equal to na1.
(3) To add a constant to a numa, or to multipy a numa by
a constant, use numaTransform().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaArithOp(*args)
    
    

    try:
        leptonica.numaLogicalOp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaLogicalOp.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaLogicalOp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaLogicalOp(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'op')       

:param[in]    nad:     [optional] can be null or equal to na1 (in-place
:param[in]    na1:
:param[in]    na2:
:param[in]    op:      L_UNION, L_INTERSECTION, L_SUBTRACTION, L_EXCLUSIVE_OR
:returns:  nad always: operation applied to na1 and na2

<pre>
Notes:
(1) The sizes of na1 and na2 must be equal.
(2) nad can only be null or equal to na1.
(3) This is intended for use with indicator arrays (0s and 1s).
Input data is extracted as integers (0 == false, anything
else == true); output results are 0 and 1.
(4) L_SUBTRACTION is subtraction of val2 from val1.  For bit logical
arithmetic this is (val1 & ~val2), but because these values
are integers, we use (val1 && !val2).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaLogicalOp(*args)
    
    

    try:
        leptonica.numaInvert.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaInvert.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaInvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInvert(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       

:param[in]    nad:    [optional] can be null or equal to nas (in-place
:param[in]    nas:
:returns:  nad always: 'inverts' nas

<pre>
Notes:
(1) This is intended for use with indicator arrays (0s and 1s).
It gives a boolean-type output, taking the input as
an integer and inverting it:
0              -->  1
anything else  -->   0
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInvert(*args)
    
    

    try:
        leptonica.numaSimilar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaSimilar.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaSimilar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSimilar(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_float32', 'maxdiff')       
('l_int32', '*psimilar')       

:param[in]    na1:
:param[in]    na2:
:param[in]    maxdiff:    use 0.0 for exact equality
:param[out]   psimilar:   1 if similar; 0 if different
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Float values can differ slightly due to roundoff and
accumulated errors.  Using %maxdiff > 0.0 allows similar
arrays to be identified.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSimilar(*args)
    
    

    try:
        leptonica.numaAddToNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaAddToNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaAddToNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddToNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       

:param[in]    na:       source numa
:param[in]    index:    element to be changed
:param[in]    val:      new value to be added
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is useful for accumulating sums, regardless of the index
order in which the values are made available.
(2) Before use, the numa has to be filled up to %index.  This would
typically be used by creating the numa with the full sized
array, initialized to 0.0, using numaMakeConstant().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddToNumber(*args)
    
    

    try:
        leptonica.numaGetMin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetMin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMin(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pminval')       
('l_int32', '*piminloc')       

:param[in]    na:        source numa
:param[out]   pminval:   [optional] min value
:param[out]   piminloc:  [optional] index of min location
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMin(*args)
    
    

    try:
        leptonica.numaGetMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMax.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMax(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pmaxval')       
('l_int32', '*pimaxloc')       

:param[in]    na:        source numa
:param[out]   pmaxval:   [optional] max value
:param[out]   pimaxloc:  [optional] index of max location
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMax(*args)
    
    

    try:
        leptonica.numaGetSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetSum.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSum(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*psum')       

:param[in]    na:     source numa
:param[out]   psum:   sum of values
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSum(*args)
    
    

    try:
        leptonica.numaGetPartialSums.argtypes = [ctypes.c_void_p]
        leptonica.numaGetPartialSums.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaGetPartialSums not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetPartialSums(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:    source numa
:returns:  nasum, or NULL on error

<pre>
Notes:
(1) nasum[i] is the sum for all j <= i of na[j].
So nasum[0] = na[0].
(2) If you want to generate a rank function, where rank[0] - 0.0,
insert a 0.0 at the beginning of the nasum array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetPartialSums(*args)
    
    

    try:
        leptonica.numaGetSumOnInterval.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetSumOnInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetSumOnInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSumOnInterval(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_float32', '*psum')       

:param[in]    na:      source numa
:param[in]    first:   beginning index
:param[in]    last:    final index
:param[out]   psum:    sum of values in the index interval range
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSumOnInterval(*args)
    
    

    try:
        leptonica.numaHasOnlyIntegers.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaHasOnlyIntegers.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaHasOnlyIntegers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHasOnlyIntegers(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxsamples')       
('l_int32', '*pallints')       

:param[in]    na:           source numa
:param[in]    maxsamples:   maximum number of samples to check
:param[out]   pallints:     1 if all sampled values are ints; else 0
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Set %maxsamples == 0 to check every integer in na.  Otherwise,
this samples no more than %maxsamples.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaHasOnlyIntegers(*args)
    
    

    try:
        leptonica.numaSubsample.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSubsample.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaSubsample not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSubsample(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'subfactor')       

:param[in]    nas:
:param[in]    subfactor:    subsample factor, >= 1
:returns:  nad evenly sampled values from nas, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSubsample(*args)
    
    

    try:
        leptonica.numaMakeDelta.argtypes = [ctypes.c_void_p]
        leptonica.numaMakeDelta.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeDelta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeDelta(*args):
        """
        ('NUMA', '*nas')       

:param[in]    nas:    input numa
:returns:  numa of difference values val[i+1] - val[i],
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeDelta(*args)
    
    

    try:
        leptonica.numaMakeSequence.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.numaMakeSequence.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeSequence(*args):
        """
        ('l_float32', 'startval')       
('l_float32', 'increment')       
('l_int32', 'size')       

:param[in]    startval:
:param[in]    increment:
:param[in]    size:       of sequence
:returns:  numa of sequence of evenly spaced values, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeSequence(*args)
    
    

    try:
        leptonica.numaMakeConstant.argtypes = [ctypes.c_float, ctypes.c_int32]
        leptonica.numaMakeConstant.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeConstant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeConstant(*args):
        """
        ('l_float32', 'val')       
('l_int32', 'size')       

:param[in]    val:
:param[in]    size:     of numa
:returns:  numa of given size with all entries equal to 'val',
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeConstant(*args)
    
    

    try:
        leptonica.numaMakeAbsValue.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaMakeAbsValue.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeAbsValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeAbsValue(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       

:param[in]    nad:   can be null for new array, or the same as nas for inplace
:param[in]    nas:   input numa
:returns:  nad with all numbers being the absval of the input,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeAbsValue(*args)
    
    

    try:
        leptonica.numaAddBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.numaAddBorder.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaAddBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddBorder(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_float32', 'val')       

:param[in]    nas:
:param[in]    left:    number of elements to add before the start
:param[in]    right:   number of elements to add after the end
:param[in]    val: initialize border elements
:returns:  nad with added elements at left and right, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddBorder(*args)
    
    

    try:
        leptonica.numaAddSpecifiedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaAddSpecifiedBorder.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaAddSpecifiedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddSpecifiedBorder(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'type')       

:param[in]    nas:
:param[in]    left:    number of elements to add before the start
:param[in]    right:   number of elements to add after the end
:param[in]    type:    L_CONTINUED_BORDER, L_MIRRORED_BORDER
:returns:  nad with added elements at left and right, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddSpecifiedBorder(*args)
    
    

    try:
        leptonica.numaRemoveBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaRemoveBorder.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaRemoveBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRemoveBorder(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'left')       
('l_int32', 'right')       

:param[in]    nas:
:param[in]    left:    number of elements to remove from the start
:param[in]    right:   number of elements to remove up to the end
:returns:  nad with removed elements at left and right, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRemoveBorder(*args)
    
    

    try:
        leptonica.numaCountNonzeroRuns.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaCountNonzeroRuns.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaCountNonzeroRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCountNonzeroRuns(*args):
        """
        ('NUMA', '*na')       
('l_int32', '*pcount')       

:param[in]    na:      e.g., of pixel counts in rows or columns
:param[out]   pcount:  number of nonzero runs
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCountNonzeroRuns(*args)
    
    

    try:
        leptonica.numaGetNonzeroRange.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetNonzeroRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetNonzeroRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetNonzeroRange(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'eps')       
('l_int32', '*pfirst')       
('l_int32', '*plast')       

:param[in]    na:              source numa
:param[in]    eps:             largest value considered to be zero
:param[out]   pfirst,: plast   interval of array indices
where values are nonzero
:returns:  0 if OK, 1 on error or if no nonzero range is found.


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetNonzeroRange(*args)
    
    

    try:
        leptonica.numaGetCountRelativeToZero.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetCountRelativeToZero.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetCountRelativeToZero not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetCountRelativeToZero(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'type')       
('l_int32', '*pcount')       

:param[in]    na:      source numa
:param[in]    type:    L_LESS_THAN_ZERO, L_EQUAL_TO_ZERO, L_GREATER_THAN_ZERO
:param[out]   pcount:  count of values of given type
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetCountRelativeToZero(*args)
    
    

    try:
        leptonica.numaClipToInterval.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaClipToInterval.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaClipToInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaClipToInterval(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'first')       
('l_int32', 'last')       

:param[in]    nas:
:param[in]    first,: last     clipping interval
:returns:  numa with the same values as the input, but clipped
to the specified interval

<pre>
Notes:
If you want the indices of the array values to be unchanged,
use first = 0.
Usage:
This is useful to clip a histogram that has a few nonzero
values to its nonzero range.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaClipToInterval(*args)
    
    

    try:
        leptonica.numaMakeThresholdIndicator.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.numaMakeThresholdIndicator.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeThresholdIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeThresholdIndicator(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'thresh')       
('l_int32', 'type')       

:param[in]    nas:      input numa
:param[in]    thresh:   threshold value
:param[in]    type:     L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:   nad : indicator array: values are 0 and 1

<pre>
Notes:
(1) For each element in nas, if the constraint given by 'type'
correctly specifies its relation to thresh, a value of 1
is recorded in nad.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeThresholdIndicator(*args)
    
    

    try:
        leptonica.numaUniformSampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaUniformSampling.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaUniformSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaUniformSampling(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'nsamp')       

:param[in]    nas:     input numa
:param[in]    nsamp:   number of samples
:returns:  nad : resampled array, or NULL on error

<pre>
Notes:
(1) This resamples the values in the array, using %nsamp
equal divisions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaUniformSampling(*args)
    
    

    try:
        leptonica.numaReverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaReverse.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReverse(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       

:param[in]    nad:    [optional] can be null or equal to nas
:param[in]    nas:    input numa
:returns:  nad : reversed, or NULL on error

<pre>
Notes:
(1) Usage:
numaReverse(nas, nas);   // in-place
nad = numaReverse(NULL, nas);  // makes a new one
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaReverse(*args)
    
    

    try:
        leptonica.numaLowPassIntervals.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaLowPassIntervals.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaLowPassIntervals not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaLowPassIntervals(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'thresh')       
('l_float32', 'maxn')       

:param[in]    nas:      input numa
:param[in]    thresh:   threshold fraction of max; in [0.0 ... 1.0]
:param[in]    maxn:     for normalizing; set maxn = 0.0 to use the max in nas
:returns:  nad : interval abscissa pairs, or NULL on error

<pre>
Notes:
(1) For each interval where the value is less than a specified
fraction of the maximum, this records the left and right "x"
value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaLowPassIntervals(*args)
    
    

    try:
        leptonica.numaThresholdEdges.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.numaThresholdEdges.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaThresholdEdges not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaThresholdEdges(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'thresh1')       
('l_float32', 'thresh2')       
('l_float32', 'maxn')       

:param[in]    nas:      input numa
:param[in]    thresh1:  low threshold as fraction of max; in [0.0 ... 1.0]
:param[in]    thresh2:  high threshold as fraction of max; in [0.0 ... 1.0]
:param[in]    maxn:     for normalizing; set maxn = 0.0 to use the max in nas
:returns:  nad   edge interval triplets, or NULL on error

<pre>
Notes:
(1) For each edge interval, where where the value is less
than %thresh1 on one side, greater than %thresh2 on
the other, and between these thresholds throughout the
interval, this records a triplet of values: the
'left' and 'right' edges, and either +1 or -1, depending
on whether the edge is rising or falling.
(2) No assumption is made about the value outside the array,
so if the value at the array edge is between the threshold
values, it is not considered part of an edge.  We start
looking for edge intervals only after leaving the thresholded
band.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaThresholdEdges(*args)
    
    

    try:
        leptonica.numaGetSpanValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetSpanValues.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaGetSpanValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSpanValues(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'span')       
('l_int32', '*pstart')       
('l_int32', '*pend')       

:param[in]    na:       numa that is output of numaLowPassIntervals()
:param[in]    span:     span number, zero-based
:param[out]   pstart:   [optional] location of start of transition
:param[out]   pend:     [optional] location of end of transition
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSpanValues(*args)
    
    

    try:
        leptonica.numaGetEdgeValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetEdgeValues.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaGetEdgeValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetEdgeValues(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'edge')       
('l_int32', '*pstart')       
('l_int32', '*pend')       
('l_int32', '*psign')       

:param[in]    na:       numa that is output of numaThresholdEdges()
:param[in]    edge:     edge number, zero-based
:param[out]   pstart:   [optional] location of start of transition
:param[out]   pend:     [optional] location of end of transition
:param[out]   psign:    [optional] transition sign: +1 is rising,
-1 is falling
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetEdgeValues(*args)
    
    

    try:
        leptonica.numaInterpolateEqxVal.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaInterpolateEqxVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaInterpolateEqxVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateEqxVal(*args):
        """
        ('l_float32', 'startx')       
('l_float32', 'deltax')       
('NUMA', '*nay')       
('l_int32', 'type')       
('l_float32', 'xval')       
('l_float32', '*pyval')       

:param[in]    startx:   xval corresponding to first element in array
:param[in]    deltax:   x increment between array elements
:param[in]    nay:      numa of ordinate values, assumed equally spaced
:param[in]    type:     L_LINEAR_INTERP, L_QUADRATIC_INTERP
:param[in]    xval:
:param[out]   pyval:    interpolated value
:returns:  0 if OK, 1 on error e.g., if xval is outside range

<pre>
Notes:
(1) Considering nay as a function of x, the x values
are equally spaced
(2) Caller should check for valid return.

For linear Lagrangian interpolation (through 2 data pts):
y(x) = y1(x-x2)/(x1-x2) + y2(x-x1)/(x2-x1)

For quadratic Lagrangian interpolation (through 3 data pts):
y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
y3(x-x1)(x-x2)/((x3-x1)(x3-x2))

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateEqxVal(*args)
    
    

    try:
        leptonica.numaInterpolateArbxVal.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaInterpolateArbxVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaInterpolateArbxVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateArbxVal(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'type')       
('l_float32', 'xval')       
('l_float32', '*pyval')       

:param[in]    nax:    numa of abscissa values
:param[in]    nay:    numa of ordinate values, corresponding to nax
:param[in]    type:   L_LINEAR_INTERP, L_QUADRATIC_INTERP
:param[in]    xval:
:param[out]   pyval:  interpolated value
:returns:  0 if OK, 1 on error e.g., if xval is outside range

<pre>
Notes:
(1) The values in nax must be sorted in increasing order.
If, additionally, they are equally spaced, you can use
numaInterpolateEqxVal().
(2) Caller should check for valid return.
(3) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
for formulas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateArbxVal(*args)
    
    

    try:
        leptonica.numaInterpolateEqxInterval.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaInterpolateEqxInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaInterpolateEqxInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateEqxInterval(*args):
        """
        ('l_float32', 'startx')       
('l_float32', 'deltax')       
('NUMA', '*nasy')       
('l_int32', 'type')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       

:param[in]    startx:    xval corresponding to first element in nas
:param[in]    deltax:    x increment between array elements in nas
:param[in]    nasy:      numa of ordinate values, assumed equally spaced
:param[in]    type:      L_LINEAR_INTERP, L_QUADRATIC_INTERP
:param[in]    x0:        start value of interval
:param[in]    x1:        end value of interval
:param[in]    npts:      number of points to evaluate function in interval
:param[out]   pnax:      [optional] array of x values in interval
:param[out]   pnay:      array of y values in interval
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Considering nasy as a function of x, the x values
are equally spaced.
(2) This creates nay (and optionally nax) of interpolated
values over the specified interval (x0, x1).
(3) If the interval (x0, x1) lies partially outside the array
nasy (as interpreted by startx and deltax), it is an
error and returns 1.
(4) Note that deltax is the intrinsic x-increment for the input
array nasy, whereas delx is the intrinsic x-increment for the
output interpolated array nay.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateEqxInterval(*args)
    
    

    try:
        leptonica.numaInterpolateArbxInterval.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaInterpolateArbxInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaInterpolateArbxInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInterpolateArbxInterval(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'type')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('NUMA', '**pnadx')       
('NUMA', '**pnady')       

:param[in]    nax:     numa of abscissa values
:param[in]    nay:     numa of ordinate values, corresponding to nax
:param[in]    type:    L_LINEAR_INTERP, L_QUADRATIC_INTERP
:param[in]    x0:      start value of interval
:param[in]    x1:      end value of interval
:param[in]    npts:    number of points to evaluate function in interval
:param[out]   pnadx:   [optional] array of x values in interval
:param[out]   pnady:   array of y values in interval
:returns:  0 if OK, 1 on error e.g., if x0 or x1 is outside range

<pre>
Notes:
(1) The values in nax must be sorted in increasing order.
If they are not sorted, we do it here, and complain.
(2) If the values in nax are equally spaced, you can use
numaInterpolateEqxInterval().
(3) Caller should check for valid return.
(4) We don't call numaInterpolateArbxVal() for each output
point, because that requires an O(n) search for
each point.  Instead, we do a single O(n) pass through
nax, saving the indices to be used for each output yval.
(5) Uses lagrangian interpolation.  See numaInterpolateEqxVal()
for formulas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInterpolateArbxInterval(*args)
    
    

    try:
        leptonica.numaFitMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaFitMax.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaFitMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFitMax(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pmaxval')       
('NUMA', '*naloc')       
('l_float32', '*pmaxloc')       

:param[in]    na:       numa of ordinate values, to fit a max to
:param[out]   pmaxval:  max value
:param[in]    naloc:    [optional] associated numa of abscissa values
:param[out]   pmaxloc:  abscissa value that gives max value in na;
if naloc == null, this is given as an interpolated
index value
:returns:  0 if OK; 1 on error

<pre>
Notes:
If %naloc is given, there is no requirement that the
data points are evenly spaced.  Lagrangian interpolation
handles that.  The only requirement is that the
data points are ordered so that the values in naloc
are either increasing or decreasing.  We test to make
sure that the sizes of na and naloc are equal, and it
is assumed that the correspondences %na[i] as a function
of %naloc[i] are properly arranged for all i.

The formula for Lagrangian interpolation through 3 data pts is:
y(x) = y1(x-x2)(x-x3)/((x1-x2)(x1-x3)) +
y2(x-x1)(x-x3)/((x2-x1)(x2-x3)) +
y3(x-x1)(x-x2)/((x3-x1)(x3-x2))

Then the derivative, using the constants (c1,c2,c3) defined below,
is set to 0:
y'(x) = 2x(c1+c2+c3) - c1(x2+x3) - c2(x1+x3) - c3(x1+x2) = 0
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaFitMax(*args)
    
    

    try:
        leptonica.numaDifferentiateInterval.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaDifferentiateInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaDifferentiateInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDifferentiateInterval(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('NUMA', '**pnadx')       
('NUMA', '**pnady')       

:param[in]    nax:     numa of abscissa values
:param[in]    nay:     numa of ordinate values, corresponding to nax
:param[in]    x0:      start value of interval
:param[in]    x1:      end value of interval
:param[in]    npts:    number of points to evaluate function in interval
:param[out]   pnadx:   [optional] array of x values in interval
:param[out]   pnady:   array of derivatives in interval
:returns:  0 if OK, 1 on error e.g., if x0 or x1 is outside range

<pre>
Notes:
(1) The values in nax must be sorted in increasing order.
If they are not sorted, it is done in the interpolation
step, and a warning is issued.
(2) Caller should check for valid return.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaDifferentiateInterval(*args)
    
    

    try:
        leptonica.numaIntegrateInterval.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaIntegrateInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaIntegrateInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaIntegrateInterval(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'x0')       
('l_float32', 'x1')       
('l_int32', 'npts')       
('l_float32', '*psum')       

:param[in]    nax:     numa of abscissa values
:param[in]    nay:     numa of ordinate values, corresponding to nax
:param[in]    x0:      start value of interval
:param[in]    x1:      end value of interval
:param[in]    npts:    number of points to evaluate function in interval
:param[out]   psum:    integral of function over interval
:returns:  0 if OK, 1 on error e.g., if x0 or x1 is outside range

<pre>
Notes:
(1) The values in nax must be sorted in increasing order.
If they are not sorted, it is done in the interpolation
step, and a warning is issued.
(2) Caller should check for valid return.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaIntegrateInterval(*args)
    
    

    try:
        leptonica.numaSortGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaSortGeneral.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSortGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortGeneral(*args):
        """
        ('NUMA', '*na')       
('NUMA', '**pnasort')       
('NUMA', '**pnaindex')       
('NUMA', '**pnainvert')       
('l_int32', 'sortorder')       
('l_int32', 'sorttype')       

:param[in]    na:          source numa
:param[out]   pnasort:     [optional] sorted numa
:param[out]   pnaindex:    [optional] index of elements in na associated
with each element of nasort
:param[out]   pnainvert:   [optional] index of elements in nasort associated
with each element of na
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:param[in]    sorttype:    L_SHELL_SORT or L_BIN_SORT
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Sorting can be confusing.  Here's an array of five values with
the results shown for the 3 output arrays.

na      nasort   naindex   nainvert
-----------------------------------
3         9         2         3
4         6         3         2
9         4         1         0
6         3         0         1
1         1         4         4

Note that naindex is a LUT into na for the sorted array values,
and nainvert directly gives the sorted index values for the
input array.  It is useful to view naindex is as a map:
0  -->  2
1  -->  3
2  -->  1
3  -->  0
4  -->  4
and nainvert, the inverse of this map:
0  -->  3
1  -->  2
2  -->  0
3  -->  1
4  -->  4

We can write these relations symbolically as:
nasort[i] = na[naindex[i]]
na[i] = nasort[nainvert[i]]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortGeneral(*args)
    
    

    try:
        leptonica.numaSortAutoSelect.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSortAutoSelect.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaSortAutoSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortAutoSelect(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       

:param[in]    nas:
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:returns:  naout output sorted numa, or NULL on error

<pre>
Notes:
(1) This does either a shell sort or a bin sort, depending on
the number of elements in nas and the dynamic range.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortAutoSelect(*args)
    
    

    try:
        leptonica.numaSortIndexAutoSelect.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSortIndexAutoSelect.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaSortIndexAutoSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortIndexAutoSelect(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       

:param[in]    nas:
:param[in]    sortorder:     L_SORT_INCREASING or L_SORT_DECREASING
:returns:  nad indices of nas, sorted by value in nas, or NULL on error

<pre>
Notes:
(1) This does either a shell sort or a bin sort, depending on
the number of elements in nas and the dynamic range.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortIndexAutoSelect(*args)
    
    

    try:
        leptonica.numaChooseSortType.argtypes = [ctypes.c_void_p]
        leptonica.numaChooseSortType.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaChooseSortType not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaChooseSortType(*args):
        """
        ('NUMA', '*nas')       

:param[in]    nas:     to be sorted
:returns:  sorttype  L_SHELL_SORT or L_BIN_SORT, or UNDEF on error.

<pre>
Notes:
(1) This selects either a shell sort or a bin sort, depending on
the number of elements in nas and the dynamic range.
(2) If there are negative values in nas, it selects shell sort.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaChooseSortType(*args)
    
    

    try:
        leptonica.numaSort.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSort.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSort(*args):
        """
        ('NUMA', '*naout')       
('NUMA', '*nain')       
('l_int32', 'sortorder')       

:param[in]    naout:       output numa; can be NULL or equal to nain
:param[in]    nain:        input numa
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:returns:  naout   output sorted numa, or NULL on error

<pre>
Notes:
(1) Set naout = nain for in-place; otherwise, set naout = NULL.
(2) Source: Shell sort, modified from K&R, 2nd edition, p.62.
Slow but simple O(n logn) sort.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSort(*args)
    
    

    try:
        leptonica.numaBinSort.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaBinSort.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaBinSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaBinSort(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       

:param[in]    nas:         of non-negative integers with a max that can
not exceed (MaxInitPtraSize - 1)
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:returns:  na   sorted, or NULL on error

<pre>
Notes:
(1) Because this uses a bin sort with buckets of size 1, it
is not appropriate for sorting either small arrays or
arrays containing very large integer values.  For such
arrays, use a standard general sort function like
numaSort().
(2) You can use numaSortAutoSelect() to decide which sorting
method to use.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaBinSort(*args)
    
    

    try:
        leptonica.numaGetSortIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaGetSortIndex.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaGetSortIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetSortIndex(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'sortorder')       

:param[in]    na:          source numa
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:returns:  na  giving an array of indices that would sort
the input array, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetSortIndex(*args)
    
    

    try:
        leptonica.numaGetBinSortIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaGetBinSortIndex.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaGetBinSortIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetBinSortIndex(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       

:param[in]    nas:         of non-negative integers with a max that can
not exceed (MaxInitPtraSize - 1)
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:returns:  na  sorted, or NULL on error

<pre>
Notes:
(1) This creates an array (or lookup table) that contains
the sorted position of the elements in the input Numa.
(2) Because it uses a bin sort with buckets of size 1, it
is not appropriate for sorting either small arrays or
arrays containing very large integer values.  For such
arrays, use a standard general sort function like
numaGetSortIndex().
(3) You can use numaSortIndexAutoSelect() to decide which
sorting method to use.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetBinSortIndex(*args)
    
    

    try:
        leptonica.numaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSortByIndex.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortByIndex(*args):
        """
        ('NUMA', '*nas')       
('NUMA', '*naindex')       

:param[in]    nas:
:param[in]    naindex:     na that maps from the new numa to the input numa
:returns:  nad  sorted, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortByIndex(*args)
    
    

    try:
        leptonica.numaIsSorted.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaIsSorted.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaIsSorted not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaIsSorted(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'sortorder')       
('l_int32', '*psorted')       

:param[in]    nas:
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:param[out]   psorted:     1 if sorted; 0 if not
:returns:  1 if OK; 0 on error

<pre>
Notes:
(1) This is a quick O(n) test if nas is sorted.  It is useful
in situations where the array is likely to be already
sorted, and a sort operation can be avoided.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaIsSorted(*args)
    
    

    try:
        leptonica.numaSortPair.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSortPair.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSortPair not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSortPair(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'sortorder')       
('NUMA', '**pnasx')       
('NUMA', '**pnasy')       

:param[in]    nax,: nay     input arrays
:param[in]    sortorder:    L_SORT_INCREASING or L_SORT_DECREASING
:param[out]   pnasx:        sorted
:param[out]   pnasy:        sorted exactly in order of nasx
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function sorts the two input arrays, nax and nay,
together, using nax as the key for sorting.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSortPair(*args)
    
    

    try:
        leptonica.numaInvertMap.argtypes = [ctypes.c_void_p]
        leptonica.numaInvertMap.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaInvertMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInvertMap(*args):
        """
        ('NUMA', '*nas')       

:param[in]    nas:
:returns:  nad  the inverted map, or NULL on error or if not invertible

<pre>
Notes:
(1) This requires that nas contain each integer from 0 to n-1.
The array is typically an index array into a sort or permutation
of another array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInvertMap(*args)
    
    

    try:
        leptonica.numaPseudorandomSequence.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.numaPseudorandomSequence.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaPseudorandomSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaPseudorandomSequence(*args):
        """
        ('l_int32', 'size')       
('l_int32', 'seed')       

:param[in]    size:     of sequence
:param[in]    seed:     for random number generation
:returns:  na  pseudorandom on {0,...,size - 1}, or NULL on error

<pre>
Notes:
(1) This uses the Durstenfeld shuffle.
See: http://en.wikipedia.org/wiki/Fisher–Yates_shuffle.
Result is a pseudorandom permutation of the sequence of integers
from 0 to size - 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaPseudorandomSequence(*args)
    
    

    try:
        leptonica.numaRandomPermutation.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaRandomPermutation.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaRandomPermutation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRandomPermutation(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'seed')       

:param[in]    nas:    input array
:param[in]    seed:   for random number generation
:returns:  nas  randomly shuffled array, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRandomPermutation(*args)
    
    

    try:
        leptonica.numaGetRankValue.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetRankValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetRankValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetRankValue(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'fract')       
('NUMA', '*nasort')       
('l_int32', 'usebins')       
('l_float32', '*pval')       

:param[in]    na:        source numa
:param[in]    fract:     use 0.0 for smallest, 1.0 for largest
:param[in]    nasort:    [optional] increasing sorted version of na
:param[in]    usebins:   0 for general sort; 1 for bin sort
:param[out]   pval:      rank val
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Computes the rank value of a number in the %na, which is
the number that is a fraction %fract from the small
end of the sorted version of %na.
(2) If you do this multiple times for different rank values,
sort the array in advance and use that for %nasort;
if you're only calling this once, input %nasort == NULL.
(3) If %usebins == 1, this uses a bin sorting method.
Use this only where:
the numbers are non-negative integers
there are over 100 numbers
the maximum value is less than about 50,000
(4) The advantage of using a bin sort is that it is O(n),
instead of O(nlogn) for general sort routines.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetRankValue(*args)
    
    

    try:
        leptonica.numaGetMedian.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMedian.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMedian(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pval')       

:param[in]    na:     source numa
:param[out]   pval:   median value
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Computes the median value of the numbers in the numa, by
sorting and finding the middle value in the sorted array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMedian(*args)
    
    

    try:
        leptonica.numaGetBinnedMedian.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetBinnedMedian.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetBinnedMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetBinnedMedian(*args):
        """
        ('NUMA', '*na')       
('l_int32', '*pval')       

:param[in]    na:      source numa
:param[out]   pval:    integer median value
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Computes the median value of the numbers in the numa,
using bin sort and finding the middle value in the sorted array.
(2) See numaGetRankValue() for conditions on na for which
this should be used.  Otherwise, use numaGetMedian().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetBinnedMedian(*args)
    
    

    try:
        leptonica.numaGetMeanDevFromMedian.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaGetMeanDevFromMedian.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetMeanDevFromMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMeanDevFromMedian(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'med')       
('l_float32', '*pdev')       

:param[in]      na:     source numa
:param[in]      med:    median value
:param[out]     pdev:   average absolute value deviation from median value
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMeanDevFromMedian(*args)
    
    

    try:
        leptonica.numaGetMedianDevFromMedian.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMedianDevFromMedian.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetMedianDevFromMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMedianDevFromMedian(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pmed')       
('l_float32', '*pdev')       

:param[in]    na:        source numa
:param[out]   pmed:      [optional] median value
:param[out]   pdev:      median deviation from median val
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Finds the median of the absolute value of the deviation from
the median value in the array.  Why take the absolute value?
Consider the case where you have values equally distributed
about both sides of a median value.  Without taking the absolute
value of the differences, you will get 0 for the deviation,
and this is not useful.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMedianDevFromMedian(*args)
    
    

    try:
        leptonica.numaGetMode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetMode.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetMode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetMode(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pval')       
('l_int32', '*pcount')       

:param[in]    na:      source numa
:param[out]   pval:    mode val
:param[out]   pcount:  [optional] mode count
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Computes the mode value of the numbers in the numa, by
sorting and finding the value of the number with the
largest count.
(2) Optionally, also returns that count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetMode(*args)
    
    

    try:
        leptonica.numaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaJoin(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    nad:      dest numa; add to this one
:param[in]    nas:      [optional] source numa; add from this one
:param[in]    istart:   starting index in nas
:param[in]    iend:     ending index in nas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) istart < 0 is taken to mean 'read from the start' (istart = 0)
(2) iend < 0 means 'read to the end'
(3) if nas == NULL, this is a no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaJoin(*args)
    
    

    try:
        leptonica.numaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaJoin(*args):
        """
        ('NUMAA', '*naad')       
('NUMAA', '*naas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    naad:     dest naa; add to this one
:param[in]    naas:     [optional] source naa; add from this one
:param[in]    istart:   starting index in nas
:param[in]    iend:     ending index in naas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) istart < 0 is taken to mean 'read from the start' (istart = 0)
(2) iend < 0 means 'read to the end'
(3) if naas == NULL, this is a no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaJoin(*args)
    
    

    try:
        leptonica.numaaFlattenToNuma.argtypes = [ctypes.c_void_p]
        leptonica.numaaFlattenToNuma.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaFlattenToNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaFlattenToNuma(*args):
        """
        ('NUMAA', '*naa')       

:param[in]    naa:
:returns:  numa, or NULL on error

<pre>
Notes:
(1) This 'flattens' the Numaa to a Numa, by joining successively
each Numa in the Numaa.
(2) It doesn't make any assumptions about the location of the
Numas in the Numaa array, unlike most Numaa functions.
(3) It leaves the input Numaa unchanged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaFlattenToNuma(*args)
    




class psio1stub(object):
    """<pre>

Stubs for psio1.c functions
</pre>




"""
    



class sel1(object):
    """<pre>

Basic ops on Sels and Selas

Create/destroy/copy:
SELA      *selaCreate()
void       selaDestroy()
SEL       *selCreate()
void       selDestroy()
SEL       *selCopy()
SEL       *selCreateBrick()
SEL       *selCreateComb()

Helper proc:
l_int32  **create2dIntArray()

Extension of sela:
SELA      *selaAddSel()
static l_int32  selaExtendArray()

Accessors:
l_int32    selaGetCount()
SEL       *selaGetSel()
char      *selGetName()
l_int32    selSetName()
l_int32    selaFindSelByName()
l_int32    selGetElement()
l_int32    selSetElement()
l_int32    selGetParameters()
l_int32    selSetOrigin()
l_int32    selGetTypeAtOrigin()
char      *selaGetBrickName()
char      *selaGetCombName()
static char      *selaComputeCompositeParameters()
l_int32    getCompositeParameters()
SARRAY    *selaGetSelnames()

Max translations for erosion and hmt
l_int32    selFindMaxTranslations()

Rotation by multiples of 90 degrees
SEL       *selRotateOrth()

Sela and Sel serialized I/O
SELA      *selaRead()
SELA      *selaReadStream()
SEL       *selRead()
SEL       *selReadStream()
l_int32    selaWrite()
l_int32    selaWriteStream()
l_int32    selWrite()
l_int32    selWriteStream()

Building custom hit-miss sels from compiled strings
SEL       *selCreateFromString()
char      *selPrintToString()     [for debugging]

Building custom hit-miss sels from a simple file format
SELA      *selaCreateFromFile()
static SEL *selCreateFromSArray()

Making hit-only sels from Pta and Pix
SEL       *selCreateFromPta()
SEL       *selCreateFromPix()

Making hit-miss sels from Pix and image files
SEL       *selReadFromColorImage()
SEL       *selCreateFromColorPix()
SELA      *selaCreateFromColorPixa()

Printable display of sel
PIX       *selDisplayInPix()
PIX       *selaDisplayInPix()

Usage notes:
In this file we have seven functions that make sels:
(1)  selCreate(), with input (h, w, [name])
The generic function.  Roll your own, using selSetElement().
(2)  selCreateBrick(), with input (h, w, cy, cx, val)
The most popular function.  Makes a rectangular sel of
all hits, misses or don't-cares.  We have many morphology
operations that create a sel of all hits, use it, and
destroy it.
(3)  selCreateFromString() with input (text, h, w, [name])
Adam Langley's clever function, allows you to make a hit-miss
sel from a string in code that is geometrically laid out
just like the actual sel.
(4)  selaCreateFromFile() with input (filename)
This parses a simple file format to create an array of
hit-miss sels.  The sel data uses the same encoding
as in (3), with geometrical layout enforced.
(5)  selCreateFromPta() with input (pta, cy, cx, [name])
Another way to make a sel with only hits.
(6)  selCreateFromPix() with input (pix, cy, cx, [name])
Yet another way to make a sel from hits.
(7)  selCreateFromColorPix() with input (pix, name).
Another way to make a general hit-miss sel, starting with
an image editor.
In addition, there are three functions in selgen.c that
automatically generate a hit-miss sel from a pix and
a number of parameters.  This is useful for problems like
"find all patterns that look like this one."

Consistency, being the hobgoblin of small minds,
is adhered to here in the dimensioning and accessing of sels.
Everything is done in standard matrix (row, column) order.
When we set specific elements in a sel, we likewise use
(row, col) ordering:
selSetElement(), with input (row, col, type)
</pre>




"""
    
    try:
        leptonica.selaCreate.argtypes = [ctypes.c_int32]
        leptonica.selaCreate.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial number of sel ptrs; use 0 for default
:returns:  sela, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaCreate(*args)
    
    

    try:
        leptonica.selaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.selaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function selaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaDestroy(*args):
        """
        ('SELA', '**psela')       

:param[in,out]   psela:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.selaDestroy(*args)
    
    

    try:
        leptonica.selCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.selCreate.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreate(*args):
        """
        ('l_int32', 'height')       
('l_int32', 'width')       
('const char', '*name')       

:param[in]    height:
:param[in]    width:
:param[in]    name:      [optional] sel name; can be null
:returns:  sel, or NULL on error

<pre>
Notes:
(1) selCreate() initializes all values to 0.
(2) After this call, (cy,cx) and nonzero data values must be
assigned.  If a text name is not assigned here, it will
be needed later when the sel is put into a sela.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selCreate(*args)
    
    

    try:
        leptonica.selDestroy.argtypes = [ctypes.c_void_p]
        leptonica.selDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function selDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selDestroy(*args):
        """
        ('SEL', '**psel')       

:param[in,out]   psel:   will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.selDestroy(*args)
    
    

    try:
        leptonica.selCopy.argtypes = [ctypes.c_void_p]
        leptonica.selCopy.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCopy(*args):
        """
        ('SEL', '*sel')       

:param[in]    sel:
:returns:  a copy of the sel, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selCopy(*args)
    
    

    try:
        leptonica.selCreateBrick.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selCreateBrick.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCreateBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateBrick(*args):
        """
        ('l_int32', 'h')       
('l_int32', 'w')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('l_int32', 'type')       

:param[in]    h,: w      height, width
:param[in]    cy,: cx    origin, relative to UL corner at 0,0
:param[in]    type:      SEL_HIT, SEL_MISS, or SEL_DONT_CARE
:returns:  sel, or NULL on error

<pre>
Notes:
(1) This is a rectangular sel of all hits, misses or don't cares.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateBrick(*args)
    
    

    try:
        leptonica.selCreateComb.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selCreateComb.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCreateComb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateComb(*args):
        """
        ('l_int32', 'factor1')       
('l_int32', 'factor2')       
('l_int32', 'direction')       

:param[in]    factor1:     contiguous space between comb tines
:param[in]    factor2:     number of comb tines
:param[in]    direction:   L_HORIZ, L_VERT
:returns:  sel, or NULL on error

<pre>
Notes:
(1) This generates a comb Sel of hits with the origin as
near the center as possible.
(2) In use, this is complemented by a brick sel of size %factor1,
Both brick and comb sels are made by selectComposableSels().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateComb(*args)
    
    

    try:
        leptonica.create2dIntArray.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.create2dIntArray.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_int32))
    except AttributeError:
        sys.stderr.write("Warning - function create2dIntArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def create2dIntArray(*args):
        """
        ('l_int32', 'sy')       
('l_int32', 'sx')       

:param[in]    sy:     rows == height
:param[in]    sx:     columns == width
:returns:  doubly indexed array i.e., an array of sy row pointers,
each of which points to an array of sx ints

<pre>
Notes:
(1) The array[sy][sx] is indexed in standard "matrix notation",
with the row index first.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.create2dIntArray(*args)
    
    

    try:
        leptonica.selaAddSel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.selaAddSel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selaAddSel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddSel(*args):
        """
        ('SELA', '*sela')       
('SEL', '*sel')       
('const char', '*selname')       
('l_int32', 'copyflag')       

:param[in]    sela:
:param[in]    sel:        to be added
:param[in]    selname:    ignored if already defined in sel;
req'd in sel when added to a sela
:param[in]    copyflag:   L_INSERT or L_COPY
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This adds a sel, either inserting or making a copy.
(2) Because every sel in a sela must have a name, it copies
the input name if necessary.  You can input NULL for
selname if the sel already has a name.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddSel(*args)
    
    

    try:
        leptonica.selaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.selaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function selaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetCount(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela:
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetCount(*args)
    
    

    try:
        leptonica.selaGetSel.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.selaGetSel.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaGetSel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetSel(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'i')       

:param[in]    sela:
:param[in]    i:        index of sel to be retrieved not copied
:returns:  sel, or NULL on error

<pre>
Notes:
(1) This returns a ptr to the sel, not a copy, so the caller
must not destroy it!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetSel(*args)
    
    

    try:
        leptonica.selGetName.argtypes = [ctypes.c_void_p]
        leptonica.selGetName.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function selGetName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetName(*args):
        """
        ('SEL', '*sel')       

:param[in]    sel:
:returns:  sel name not copied, or NULL if no name or on error


        """
        args = _convert_params(*args)
        
        return leptonica.selGetName(*args)
    
    

    try:
        leptonica.selSetName.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.selSetName.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selSetName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selSetName(*args):
        """
        ('SEL', '*sel')       
('const char', '*name')       

:param[in]    sel:
:param[in]    name:    [optional]; can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Always frees the existing sel name, if defined.
(2) If name is not defined, just clears any existing sel name.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selSetName(*args)
    
    

    try:
        leptonica.selaFindSelByName.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selaFindSelByName.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selaFindSelByName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaFindSelByName(*args):
        """
        ('SELA', '*sela')       
('const char', '*name')       
('l_int32', '*pindex')       
('SEL', '**psel')       

:param[in]    sela:
:param[in]    name:      sel name
:param[out]   pindex:    [optional]
:param[in]    psel:      [optional] sel (not a copy)
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaFindSelByName(*args)
    
    

    try:
        leptonica.selGetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.selGetElement.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selGetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetElement(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_int32', '*ptype')       

:param[in]    sel:
:param[in]    row:
:param[in]    col:
:param[out]   ptype:    SEL_HIT, SEL_MISS, SEL_DONT_CARE
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selGetElement(*args)
    
    

    try:
        leptonica.selSetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selSetElement.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selSetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selSetElement(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_int32', 'type')       

:param[in]    sel:
:param[in]    row:
:param[in]    col:
:param[in]    type:    SEL_HIT, SEL_MISS, SEL_DONT_CARE
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Because we use row and column to index into an array,
they are always non-negative.  The location of the origin
(and the type of operation) determine the actual
direction of the rasterop.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selSetElement(*args)
    
    

    try:
        leptonica.selGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selGetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetParameters(*args):
        """
        ('SEL', '*sel')       
('l_int32', '*psy')       
('l_int32', '*psx')       
('l_int32', '*pcy')       
('l_int32', '*pcx')       

:param[in]    sel:
:param[out]   psy,: psx, pcy, pcx    [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selGetParameters(*args)
    
    

    try:
        leptonica.selSetOrigin.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selSetOrigin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selSetOrigin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selSetOrigin(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'cy')       
('l_int32', 'cx')       

:param[in]    sel:
:param[in]    cy,: cx
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selSetOrigin(*args)
    
    

    try:
        leptonica.selGetTypeAtOrigin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selGetTypeAtOrigin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selGetTypeAtOrigin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selGetTypeAtOrigin(*args):
        """
        ('SEL', '*sel')       
('l_int32', '*ptype')       

:param[in]    sel:
:param[out]   ptype:    SEL_HIT, SEL_MISS, SEL_DONT_CARE
:returns:  0 if OK; 1 on error or if origin is not found


        """
        args = _convert_params(*args)
        
        return leptonica.selGetTypeAtOrigin(*args)
    
    

    try:
        leptonica.selaGetBrickName.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaGetBrickName.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function selaGetBrickName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetBrickName(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    sela:
:param[in]    hsize,: vsize    of brick sel
:returns:  sel name new string, or NULL if no name or on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetBrickName(*args)
    
    

    try:
        leptonica.selaGetCombName.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaGetCombName.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function selaGetCombName not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetCombName(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'size')       
('l_int32', 'direction')       

:param[in]    sela:
:param[in]    size:        the product of sizes of the brick and comb parts
:param[in]    direction:   L_HORIZ, L_VERT
:returns:  sel name new string, or NULL if name not found or on error

<pre>
Notes:
(1) Combs are by definition 1-dimensional, either horiz or vert.
(2) Use this with comb Sels; e.g., from selaAddDwaCombs().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetCombName(*args)
    
    

    try:
        leptonica.getCompositeParameters.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.getCompositeParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getCompositeParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getCompositeParameters(*args):
        """
        ('l_int32', 'size')       
('l_int32', '*psize1')       
('l_int32', '*psize2')       
('char', '**pnameh1')       
('char', '**pnameh2')       
('char', '**pnamev1')       
('char', '**pnamev2')       

:param[in]    size:
:param[out]   psize1:    [optional] brick factor size
:param[out]   psize2:    [optional] comb factor size
:param[out]   pnameh1:   [optional] name of horiz brick
:param[out]   pnameh2:   [optional] name of horiz comb
:param[out]   pnamev1:   [optional] name of vert brick
:param[out]   pnamev2:   [optional] name of vert comb
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This uses the big lookup table at the top of this file.
(2) All returned strings are copies that must be freed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getCompositeParameters(*args)
    
    

    try:
        leptonica.selaGetSelnames.argtypes = [ctypes.c_void_p]
        leptonica.selaGetSelnames.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaGetSelnames not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaGetSelnames(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela:
:returns:  sa of all sel names, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaGetSelnames(*args)
    
    

    try:
        leptonica.selFindMaxTranslations.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selFindMaxTranslations.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selFindMaxTranslations not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selFindMaxTranslations(*args):
        """
        ('SEL', '*sel')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       
('l_int32', '*pxn')       
('l_int32', '*pyn')       

:param[in]    sel:
:param[out]   pxp,: pyp, pxn, pyn     max shifts
:returns:  0 if OK; 1 on error

<pre>
Notes:
These are the maximum shifts for the erosion operation.
For example, when j < cx, the shift of the image
is +x to the cx.  This is a positive xp shift.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selFindMaxTranslations(*args)
    
    

    try:
        leptonica.selRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.selRotateOrth.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selRotateOrth(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'quads')       

:param[in]    sel:
:param[in]    quads:    0 - 4; number of 90 degree cw rotations
:returns:  seld, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selRotateOrth(*args)
    
    

    try:
        leptonica.selaRead.argtypes = [ctypes.c_char_p]
        leptonica.selaRead.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaRead(*args):
        """
        ('const char', '*fname')       

:param[in]    fname:    filename
:returns:  sela, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaRead(*args)
    
    

    try:
        leptonica.selaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.selaReadStream.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  sela, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaReadStream(*args)
    
    

    try:
        leptonica.selRead.argtypes = [ctypes.c_char_p]
        leptonica.selRead.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selRead(*args):
        """
        ('const char', '*fname')       

:param[in]    fname:    filename
:returns:  sel, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selRead(*args)
    
    

    try:
        leptonica.selReadStream.argtypes = [ctypes.c_void_p]
        leptonica.selReadStream.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  sel, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selReadStream(*args)
    
    

    try:
        leptonica.selaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.selaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaWrite(*args):
        """
        ('const char', '*fname')       
('SELA', '*sela')       

:param[in]    fname:    filename
:param[in]    sela:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaWrite(*args)
    
    

    try:
        leptonica.selaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaWriteStream(*args):
        """
        ('FILE', '*fp')       
('SELA', '*sela')       

:param[in]    fp:    file stream
:param[in]    sela:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaWriteStream(*args)
    
    

    try:
        leptonica.selWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.selWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selWrite(*args):
        """
        ('const char', '*fname')       
('SEL', '*sel')       

:param[in]    fname:    filename
:param[in]    sel:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selWrite(*args)
    
    

    try:
        leptonica.selWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selWriteStream(*args):
        """
        ('FILE', '*fp')       
('SEL', '*sel')       

:param[in]    fp:    file stream
:param[in]    sel:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.selWriteStream(*args)
    
    

    try:
        leptonica.selCreateFromString.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.selCreateFromString.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromString(*args):
        """
        ('const char', '*text')       
('l_int32', 'h')       
('l_int32', 'w')       
('const char', '*name')       

:param[in]    text:
:param[in]    h,: w    height, width
:param[in]    name:    [optional] sel name; can be null
:returns:  sel of the given size, or NULL on error

<pre>
Notes:
(1) The text is an array of chars (in row-major order) where
each char can be one of the following:
'x': hit
'o': miss
' ': don't-care
(2) When the origin falls on a hit or miss, use an upper case
char (e.g., 'X' or 'O') to indicate it.  When the origin
falls on a don't-care, indicate this with a 'C'.
The string must have exactly one origin specified.
(3) The advantage of this method is that the text can be input
in a format that shows the 2D layout of the Sel; e.g.,
\code
static const char *seltext = "x    "
"x Oo "
"x    "
"xxxxx";
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromString(*args)
    
    

    try:
        leptonica.selPrintToString.argtypes = [ctypes.c_void_p]
        leptonica.selPrintToString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function selPrintToString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selPrintToString(*args):
        """
        ('SEL', '*sel')       

:param[in]    sel:
:returns:  str string; caller must free

<pre>
Notes:
(1) This is an inverse function of selCreateFromString.
It prints a textual representation of the SEL to a malloc'd
string.  The format is the same as selCreateFromString
except that newlines are inserted into the output
between rows.
(2) This is useful for debugging.  However, if you want to
save some Sels in a file, put them in a Sela and write
them out with selaWrite().  They can then be read in
with selaRead().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selPrintToString(*args)
    
    

    try:
        leptonica.selaCreateFromFile.argtypes = [ctypes.c_char_p]
        leptonica.selaCreateFromFile.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaCreateFromFile(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  sela, or NULL on error

<pre>
Notes:
(1) The file contains a sequence of Sel descriptions.
(2) Each Sel is formatted as follows:
~ Any number of comment lines starting with '#' are ignored
~ The next line contains the selname
~ The next lines contain the Sel data.  They must be
formatted similarly to the string format in
selCreateFromString(), with each line beginning and
ending with a double-quote, and showing the 2D layout.
~ Each Sel ends when a blank line, a comment line, or
the end of file is reached.
(3) See selCreateFromString() for a description of the string
format for the Sel data.  As an example, here are the lines
of is a valid file for a single Sel.  In the file, all lines
are left-justified:
# diagonal sel
sel_5diag
"x    "
" x   "
"  X  "
"   x "
"    x"
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaCreateFromFile(*args)
    
    

    try:
        leptonica.selCreateFromPta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.selCreateFromPta.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCreateFromPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromPta(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('const char', '*name')       

:param[in]    pta:
:param[in]    cy,: cx    origin of sel
:param[in]    name:      [optional] sel name; can be null
:returns:  sel of minimum required size, or NULL on error

<pre>
Notes:
(1) The origin and all points in the pta must be positive.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromPta(*args)
    
    

    try:
        leptonica.selCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.selCreateFromPix.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('const char', '*name')       

:param[in]    pix:
:param[in]    cy,: cx    origin of sel
:param[in]    name:      [optional] sel name; can be null
:returns:  sel, or NULL on error

<pre>
Notes:
(1) The origin must be positive.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selCreateFromPix(*args)
    
    

    try:
        leptonica.selDisplayInPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.selDisplayInPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selDisplayInPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selDisplayInPix(*args):
        """
        ('SEL', '*sel')       
('l_int32', 'size')       
('l_int32', 'gthick')       

:param[in]    sel:
:param[in]    size:     of grid interiors; odd; minimum size of 13 is enforced
:param[in]    gthick:   grid thickness; minimum size of 2 is enforced
:returns:  pix display of sel, or NULL on error

<pre>
Notes:
(1) This gives a visual representation of a general (hit-miss) sel.
(2) The empty sel is represented by a grid of intersecting lines.
(3) Three different patterns are generated for the sel elements:
~ hit (solid black circle)
~ miss (black ring; inner radius is radius2)
~ origin (cross, XORed with whatever is there)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selDisplayInPix(*args)
    
    

    try:
        leptonica.selaDisplayInPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaDisplayInPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaDisplayInPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaDisplayInPix(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'size')       
('l_int32', 'gthick')       
('l_int32', 'spacing')       
('l_int32', 'ncols')       

:param[in]    sela:
:param[in]    size:     of grid interiors; odd; minimum size of 13 is enforced
:param[in]    gthick:   grid thickness; minimum size of 2 is enforced
:param[in]    spacing:  between sels, both horizontally and vertically
:param[in]    ncols:    number of sels per "line"
:returns:  pix display of all sels in sela, or NULL on error

<pre>
Notes:
(1) This gives a visual representation of all the sels in a sela.
(2) See notes in selDisplayInPix() for display params of each sel.
(3) This gives the nicest results when all sels in the sela
are the same size.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaDisplayInPix(*args)
    




class affine(object):
    """<pre>

Affine (3 pt) image transformation using a sampled
(to nearest integer) transform on each dest point
PIX        *pixAffineSampledPta()
PIX        *pixAffineSampled()

Affine (3 pt) image transformation using interpolation
(or area mapping) for anti-aliasing images that are
2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
PIX        *pixAffinePta()
PIX        *pixAffine()
PIX        *pixAffinePtaColor()
PIX        *pixAffineColor()
PIX        *pixAffinePtaGray()
PIX        *pixAffineGray()

Affine transform including alpha (blend) component
PIX        *pixAffinePtaWithAlpha()

Affine coordinate transformation
l_int32     getAffineXformCoeffs()
l_int32     affineInvertXform()
l_int32     affineXformSampledPt()
l_int32     affineXformPt()

Interpolation helper functions
l_int32     linearInterpolatePixelGray()
l_int32     linearInterpolatePixelColor()

Gauss-jordan linear equation solver
l_int32     gaussjordan()

Affine image transformation using a sequence of
shear/scale/translation operations
PIX        *pixAffineSequential()

One can define a coordinate space by the location of the origin,
the orientation of x and y axes, and the unit scaling along
each axis.  An affine transform is a general linear
transformation from one coordinate space to another.

For the general case, we can define the affine transform using
two sets of three (noncollinear) points in a plane.  One set
corresponds to the input (src) coordinate space; the other to the
transformed (dest) coordinate space.  Each point in the
src corresponds to one of the points in the dest.  With two
sets of three points, we get a set of 6 equations in 6 unknowns
that specifies the mapping between the coordinate spaces.
The interface here allows you to specify either the corresponding
sets of 3 points, or the transform itself (as a vector of 6
coefficients).

Given the transform as a vector of 6 coefficients, we can compute
both a a pointwise affine coordinate transformation and an
affine image transformation.

To compute the coordinate transform, we need the coordinate
value (x',y') in the transformed space for any point (x,y)
in the original space.  To derive this transform from the
three corresponding points, it is convenient to express the affine
coordinate transformation using an LU decomposition of
a set of six linear equations that express the six coordinates
of the three points in the transformed space as a function of
the six coordinates in the original space.  Once we have
this transform matrix , we can transform an image by
finding, for each destination pixel, the pixel (or pixels)
in the source that give rise to it.

This 'pointwise' transformation can be done either by sampling
and picking a single pixel in the src to replicate into the dest,
or by interpolating (or averaging) over four src pixels to
determine the value of the dest pixel.  The first method is
implemented by pixAffineSampled() and the second method by
pixAffine().  The interpolated method can only be used for
images with more than 1 bpp, but for these, the image quality
is significantly better than the sampled method, due to
the 'antialiasing' effect of weighting the src pixels.

Interpolation works well when there is relatively little scaling,
or if there is image expansion in general.  However, if there
is significant image reduction, one should apply a low-pass
filter before subsampling to avoid aliasing the high frequencies.

A typical application might be to align two images, which
may be scaled, rotated and translated versions of each other.
Through some pre-processing, three corresponding points are
located in each of the two images.  One of the images is
then to be (affine) transformed to align with the other.
As mentioned, the standard way to do this is to use three
sets of points, compute the 6 transformation coefficients
from these points that describe the linear transformation,

x' = ax + by + c
y' = dx + ey + f

and use this in a pointwise manner to transform the image.

N.B.  Be sure to see the comment in getAffineXformCoeffs(),
regarding using the inverse of the affine transform for points
to transform images.

There is another way to do this transformation; namely,
by doing a sequence of simple affine transforms, without
computing directly the affine coordinate transformation.
We have at our disposal (1) translations (using rasterop),
(2) horizontal and vertical shear about any horizontal and vertical
line, respectively, and (3) non-isotropic scaling by two
arbitrary x and y scaling factors.  We also have rotation
about an arbitrary point, but this is equivalent to a set
of three shears so we do not need to use it.

Why might we do this?  For binary images, it is usually
more efficient to do such transformations by a sequence
of word parallel operations.  Shear and translation can be
done in-place and word parallel; arbitrary scaling is
mostly pixel-wise.

Suppose that we are transforming image 1 to correspond to image 2.
We have a set of three points, describing the coordinate space
embedded in image 1, and we need to transform image 1 until
those three points exactly correspond to the new coordinate space
defined by the second set of three points.  In our image
matching application, the latter set of three points was
found to be the corresponding points in image 2.

The most elegant way I can think of to do such a sequential
implementation is to imagine that we're going to transform
BOTH images until they're aligned.  (We don't really want
to transform both, because in fact we may only have one image
that is undergoing a general affine transformation.)

Choose the 3 corresponding points as follows:
~ The 1st point is an origin
~ The 2nd point gives the orientation and scaling of the
"x" axis with respect to the origin
~ The 3rd point does likewise for the "y" axis.
These "axes" must not be collinear; otherwise they are
arbitrary (although some strange things will happen if
the handedness sweeping through the minimum angle between
the axes is opposite).

An important constraint is that we have shear operations
about an arbitrary horizontal or vertical line, but always
parallel to the x or y axis.  If we continue to pretend that
we have an unprimed coordinate space embedded in image 1 and
a primed coordinate space embedded in image 2, we imagine
(a) transforming image 1 by horizontal and vertical shears about
point 1 to align points 3 and 2 along the y and x axes,
respectively, and (b) transforming image 2 by horizontal and
vertical shears about point 1' to align points 3' and 2' along
the y and x axes.  Then we scale image 1 so that the distances
from 1 to 2 and from 1 to 3 are equal to the distances in
image 2 from 1' to 2' and from 1' to 3'.  This scaling operation
leaves the true image origin, at (0,0) invariant, and will in
general translate point 1.  The original points 1 and 1' will
typically not coincide in any event, so we must translate
the origin of image 1, at its current point 1, to the origin
of image 2 at 1'.  The images should now be aligned.  But
because we never really transformed image 2 (and image 2 may
not even exist), we now perform  on image 1 the reverse of
the shear transforms that we imagined doing on image 2;
namely, the negative vertical shear followed by the negative
horizontal shear.  Image 1 should now have its transformed
unprimed coordinates aligned with the original primed
coordinates.  In all this, it is only necessary to keep track
of the shear angles and translations of points during the shears.
What has been accomplished is a general affine transformation
on image 1.

Having described all this, if you are going to use an
affine transformation in an application, this is what you
need to know:

(1) You should NEVER use the sequential method, because
the image quality for 1 bpp text is much poorer
(even though it is about 2x faster than the pointwise sampled
method), and for images with depth greater than 1, it is
nearly 20x slower than the pointwise sampled method
and over 10x slower than the pointwise interpolated method!
The sequential method is given here for purely
pedagogical reasons.

(2) For 1 bpp images, use the pointwise sampled function
pixAffineSampled().  For all other images, the best
quality results result from using the pointwise
interpolated function pixAffinePta() or pixAffine();
the cost is less than a doubling of the computation time
with respect to the sampled function.  If you use
interpolation on colormapped images, the colormap will
be removed, resulting in either a grayscale or color
image, depending on the values in the colormap.
If you want to retain the colormap, use pixAffineSampled().

Typical relative timing of pointwise transforms (sampled = 1.0):
8 bpp:   sampled        1.0
interpolated   1.6
32 bpp:  sampled        1.0
interpolated   1.8
Additionally, the computation time/pixel is nearly the same
for 8 bpp and 32 bpp, for both sampled and interpolated.
</pre>




"""
    
    try:
        leptonica.pixAffineSampledPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffineSampledPta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffineSampledPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineSampledPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths
:param[in]    ptad:      3 pts of final coordinate space
:param[in]    ptas:      3 pts of initial coordinate space
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary.
(2) Retains colormap, which you can do for a sampled transform..
(3) The 3 points must not be collinear.
(4) The order of the 3 points is arbitrary; however, to compare
with the sequential transform they must be in these locations
and in this order: origin, x-axis, y-axis.
(5) For 1 bpp images, this has much better quality results
than pixAffineSequential(), particularly for text.
It is about 3x slower, but does not require additional
border pixels.  The poor quality of pixAffineSequential()
is due to repeated quantized transforms.  It is strongly
recommended that pixAffineSampled() be used for 1 bpp images.
(6) For 8 or 32 bpp, much better quality is obtained by the
somewhat slower pixAffinePta().  See that function
for relative timings between sampled and interpolated.
(7) To repeat, use of the sequential transform,
pixAffineSequential(), for any images, is discouraged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineSampledPta(*args)
    
    

    try:
        leptonica.pixAffineSampled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffineSampled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffineSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineSampled(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths
:param[in]    vc:        vector of 6 coefficients for affine transformation
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary.
(2) Retains colormap, which you can do for a sampled transform..
(3) For 8 or 32 bpp, much better quality is obtained by the
somewhat slower pixAffine().  See that function
for relative timings between sampled and interpolated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineSampled(*args)
    
    

    try:
        leptonica.pixAffinePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffinePta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffinePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths; colormap ok
:param[in]    ptad:      3 pts of final coordinate space
:param[in]    ptas:      3 pts of initial coordinate space
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary
(2) Removes any existing colormap, if necessary, before transforming
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePta(*args)
    
    

    try:
        leptonica.pixAffine.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAffine.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffine(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths; colormap ok
:param[in]    vc:        vector of 6 coefficients for affine transformation
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary
(2) Removes any existing colormap, if necessary, before transforming
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffine(*args)
    
    

    try:
        leptonica.pixAffinePtaColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixAffinePtaColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffinePtaColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePtaColor(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint32', 'colorval')       

:param[in]    pixs:       32 bpp
:param[in]    ptad:       3 pts of final coordinate space
:param[in]    ptas:       3 pts of initial coordinate space
:param[in]    colorval:   e.g.: 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePtaColor(*args)
    
    

    try:
        leptonica.pixAffineColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixAffineColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffineColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint32', 'colorval')       

:param[in]    pixs:       32 bpp
:param[in]    vc:         vector of 6 coefficients for affine transformation
:param[in]    colorval:   e.g.: 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineColor(*args)
    
    

    try:
        leptonica.pixAffinePtaGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixAffinePtaGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffinePtaGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePtaGray(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint8', 'grayval')       

:param[in]    pixs:      8 bpp
:param[in]    ptad:      3 pts of final coordinate space
:param[in]    ptas:      3 pts of initial coordinate space
:param[in]    grayval:   e.g.: 0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePtaGray(*args)
    
    

    try:
        leptonica.pixAffineGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixAffineGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffineGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint8', 'grayval')       

:param[in]    pixs:      8 bpp
:param[in]    vc:        vector of 6 coefficients for affine transformation
:param[in]    grayval:   e.g.: 0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineGray(*args)
    
    

    try:
        leptonica.pixAffinePtaWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixAffinePtaWithAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffinePtaWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffinePtaWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('PIX', '*pixg')       
('l_float32', 'fract')       
('l_int32', 'border')       

:param[in]    pixs:     32 bpp rgb
:param[in]    ptad:     3 pts of final coordinate space
:param[in]    ptas:     3 pts of initial coordinate space
:param[in]    pixg:     [optional] 8 bpp, can be null
:param[in]    fract:    between 0.0 and 1.0, with 0.0 fully transparent
and 1.0 fully opaque
:param[in]    border:   of pixels added to capture transformed source pixels
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The alpha channel is transformed separately from pixs,
and aligns with it, being fully transparent outside the
boundary of the transformed pixs.  For pixels that are fully
transparent, a blending function like pixBlendWithGrayMask()
will give zero weight to corresponding pixels in pixs.
(2) If pixg is NULL, it is generated as an alpha layer that is
partially opaque, using %fract.  Otherwise, it is cropped
to pixs if required and %fract is ignored.  The alpha channel
in pixs is never used.
(3) Colormaps are removed.
(4) When pixs is transformed, it doesn't matter what color is brought
in because the alpha channel will be transparent (0) there.
(5) To avoid losing source pixels in the destination, it may be
necessary to add a border to the source pix before doing
the affine transformation.  This can be any non-negative number.
(6) The input %ptad and %ptas are in a coordinate space before
the border is added.  Internally, we compensate for this
before doing the affine transform on the image after the border
is added.
(7) The default setting for the border values in the alpha channel
is 0 (transparent) for the outermost ring of pixels and
(0.5 * fract * 255) for the second ring.  When blended over
a second image, this
(a) shrinks the visible image to make a clean overlap edge
with an image below, and
(b) softens the edges by weakening the aliasing there.
Use l_setAlphaMaskBorder() to change these values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffinePtaWithAlpha(*args)
    
    

    try:
        leptonica.getAffineXformCoeffs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getAffineXformCoeffs.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getAffineXformCoeffs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getAffineXformCoeffs(*args):
        """
        ('PTA', '*ptas')       
('PTA', '*ptad')       
('l_float32', '**pvc')       

:param[in]    ptas:    source 3 points; unprimed
:param[in]    ptad:    transformed 3 points; primed
:param[out]   pvc:     vector of coefficients of transform
:returns:  0 if OK; 1 on error

<pre>
We have a set of six equations, describing the affine
transformation that takes 3 points ptas into 3 other
points ptad.  These equations are:

x1' = c[0]*x1 + c[1]*y1 + c[2]
y1' = c[3]*x1 + c[4]*y1 + c[5]
x2' = c[0]*x2 + c[1]*y2 + c[2]
y2' = c[3]*x2 + c[4]*y2 + c[5]
x3' = c[0]*x3 + c[1]*y3 + c[2]
y3' = c[3]*x3 + c[4]*y3 + c[5]

This can be represented as

AC = B

where B and C are column vectors

B = [ x1' y1' x2' y2' x3' y3' ]
C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]

and A is the 6x6 matrix

x1   y1   1   0    0    0
0    0   0   x1   y1   1
x2   y2   1   0    0    0
0    0   0   x2   y2   1
x3   y3   1   0    0    0
0    0   0   x3   y3   1

These six equations are solved here for the coefficients C.

These six coefficients can then be used to find the dest
point x',y') corresponding to any src point (x,y, according
to the equations

x' = c[0]x + c[1]y + c[2]
y' = c[3]x + c[4]y + c[5]

that are implemented in affineXformPt.

!!!!!!!!!!!!!!!!!!   Very important   !!!!!!!!!!!!!!!!!!!!!!

When the affine transform is composed from a set of simple
operations such as translation, scaling and rotation,
it is built in a form to convert from the un-transformed src
point to the transformed dest point.  However, when an
affine transform is used on images, it is used in an inverted
way: it converts from the transformed dest point to the
un-transformed src point.  So, for example, if you transform
a boxa using transform A, to transform an image in the same
way you must use the inverse of A.

For example, if you transform a boxa with a 3x3 affine matrix
'mat', the analogous image transformation must use 'matinv':
\code
boxad = boxaAffineTransform(boxas, mat);
affineInvertXform(mat, &matinv);
pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);
\endcode
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getAffineXformCoeffs(*args)
    
    

    try:
        leptonica.affineInvertXform.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.affineInvertXform.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function affineInvertXform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def affineInvertXform(*args):
        """
        ('l_float32', '*vc')       
('l_float32', '**pvci')       

:param[in]    vc:     vector of 6 coefficients
:param[out]   pvci:   inverted transform
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The 6 affine transform coefficients are the first
two rows of a 3x3 matrix where the last row has
only a 1 in the third column.  We invert this
using gaussjordan(), and select the first 2 rows
as the coefficients of the inverse affine transform.
(2) Alternatively, we can find the inverse transform
coefficients by inverting the 2x2 submatrix,
and treating the top 2 coefficients in the 3rd column as
a RHS vector for that 2x2 submatrix.  Then the
6 inverted transform coefficients are composed of
the inverted 2x2 submatrix and the negative of the
transformed RHS vector.  Why is this so?  We have
Y = AX + R  (2 equations in 6 unknowns)
Then
X = A'Y - A'R
Gauss-jordan solves
AF = R
and puts the solution for F, which is A'R,
into the input R vector.

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.affineInvertXform(*args)
    
    

    try:
        leptonica.affineXformSampledPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.affineXformSampledPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function affineXformSampledPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def affineXformSampledPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       

:param[in]    vc:         vector of 6 coefficients
:param[in]    x,: y       initial point
:param[out]   pxp,: pyp   transformed point
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds the nearest pixel coordinates of the transformed point.
(2) It does not check ptrs for returned data!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.affineXformSampledPt(*args)
    
    

    try:
        leptonica.affineXformPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.affineXformPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function affineXformPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def affineXformPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pxp')       
('l_float32', '*pyp')       

:param[in]    vc:         vector of 6 coefficients
:param[in]    x,: y       initial point
:param[out]   pxp,: pyp   transformed point
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This computes the floating point location of the transformed point.
(2) It does not check ptrs for returned data!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.affineXformPt(*args)
    
    

    try:
        leptonica.linearInterpolatePixelColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_uint32, ctypes.c_void_p]
        leptonica.linearInterpolatePixelColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function linearInterpolatePixelColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearInterpolatePixelColor(*args):
        """
        ('l_uint32', '*datas')       
('l_int32', 'wpls')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_uint32', 'colorval')       
('l_uint32', '*pval')       

:param[in]    datas:      ptr to beginning of image data
:param[in]    wpls:       32-bit word/line for this data array
:param[in]    w,: h       of image
:param[in]    x,: y       floating pt location for evaluation
:param[in]    colorval:   color brought in from the outside when the
input x,y location is outside the image;
in 0xrrggbb00 format)
:param[out]   pval:       interpolated color value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a standard linear interpolation function.  It is
equivalent to area weighting on each component, and
avoids "jaggies" when rendering sharp edges.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.linearInterpolatePixelColor(*args)
    
    

    try:
        leptonica.linearInterpolatePixelGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.linearInterpolatePixelGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function linearInterpolatePixelGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearInterpolatePixelGray(*args):
        """
        ('l_uint32', '*datas')       
('l_int32', 'wpls')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', 'grayval')       
('l_int32', '*pval')       

:param[in]    datas:     ptr to beginning of image data
:param[in]    wpls:      32-bit word/line for this data array
:param[in]    w,: h      of image
:param[in]    x,: y      floating pt location for evaluation
:param[in]    grayval:   color brought in from the outside when the
input x,y location is outside the image
:param[out]   pval:      interpolated gray value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a standard linear interpolation function.  It is
equivalent to area weighting on each component, and
avoids "jaggies" when rendering sharp edges.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.linearInterpolatePixelGray(*args)
    
    

    try:
        leptonica.gaussjordan.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.gaussjordan.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function gaussjordan not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gaussjordan(*args):
        """
        ('l_float32', '**a')       
('l_float32', '*b')       
('l_int32', 'n')       

:param[in]    a:     n x n matrix
:param[in]    b:     n x 1 right-hand side column vector
:param[in]    n:     dimension
:returns:  0 if ok, 1 on error

<pre>
Notes:
(1) There are two side-effects:
The matrix a is transformed to its inverse A
The rhs vector b is transformed to the solution x
of the linear equation ax = b
(2) The inverse A can then be used to solve the same equation with
different rhs vectors c by multiplication: x = Ac
(3) Adapted from "Numerical Recipes in C, Second Edition", 1992,
pp. 36-41 (gauss-jordan elimination)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gaussjordan(*args)
    
    

    try:
        leptonica.pixAffineSequential.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAffineSequential.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAffineSequential not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAffineSequential(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'bw')       
('l_int32', 'bh')       

:param[in]    pixs:
:param[in]    ptad:   3 pts of final coordinate space
:param[in]    ptas:   3 pts of initial coordinate space
:param[in]    bw:     pixels of additional border width during computation
:param[in]    bh:     pixels of additional border height during computation
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The 3 pts must not be collinear.
(2) The 3 pts must be given in this order:
~ origin
~ a location along the x-axis
~ a location along the y-axis.
(3) You must guess how much border must be added so that no
pixels are lost in the transformations from src to
dest coordinate space.  (This can be calculated but it
is a lot of work!)  For coordinate spaces that are nearly
at right angles, on a 300 ppi scanned page, the addition
of 1000 pixels on each side is usually sufficient.
(4) This is here for pedagogical reasons.  It is about 3x faster
on 1 bpp images than pixAffineSampled(), but the results
on text are much inferior.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAffineSequential(*args)
    




class colormap(object):
    """<pre>

Colormap creation, copy, destruction, addition
PIXCMAP    *pixcmapCreate()
PIXCMAP    *pixcmapCreateRandom()
PIXCMAP    *pixcmapCreateLinear()
PIXCMAP    *pixcmapCopy()
void        pixcmapDestroy()
l_int32     pixcmapIsValid()
l_int32     pixcmapAddColor()
l_int32     pixcmapAddRGBA()
l_int32     pixcmapAddNewColor()
l_int32     pixcmapAddNearestColor()
l_int32     pixcmapUsableColor()
l_int32     pixcmapAddBlackOrWhite()
l_int32     pixcmapSetBlackAndWhite()
l_int32     pixcmapGetCount()
l_int32     pixcmapGetDepth()
l_int32     pixcmapGetMinDepth()
l_int32     pixcmapGetFreeCount()
l_int32     pixcmapClear()

Colormap random access and test
l_int32     pixcmapGetColor()
l_int32     pixcmapGetColor32()
l_int32     pixcmapGetRGBA()
l_int32     pixcmapGetRGBA32()
l_int32     pixcmapResetColor()
l_int32     pixcmapSetAlpha()
l_int32     pixcmapGetIndex()
l_int32     pixcmapHasColor()
l_int32     pixcmapIsOpaque()
l_int32     pixcmapIsBlackAndWhite()
l_int32     pixcmapCountGrayColors()
l_int32     pixcmapGetRankIntensity()
l_int32     pixcmapGetNearestIndex()
l_int32     pixcmapGetNearestGrayIndex()
l_int32     pixcmapGetDistanceToColor()
l_int32     pixcmapGetRangeValues()

Colormap conversion
PIXCMAP    *pixcmapGrayToFalseColor()
PIXCMAP    *pixcmapGrayToColor()
PIXCMAP    *pixcmapColorToGray()
PIXCMAP    *pixcmapConvertTo4()
PIXCMAP    *pixcmapConvertTo8()

Colormap I/O
l_int32     pixcmapRead()
l_int32     pixcmapReadStream()
l_int32     pixcmapReadMem()
l_int32     pixcmapWrite()
l_int32     pixcmapWriteStream()
l_int32     pixcmapWriteMem()

Extract colormap arrays and serialization
l_int32     pixcmapToArrays()
l_int32     pixcmapToRGBTable()
l_int32     pixcmapSerializeToMemory()
PIXCMAP    *pixcmapDeserializeFromMemory()
char       *pixcmapConvertToHex()

Colormap transforms
l_int32     pixcmapGammaTRC()
l_int32     pixcmapContrastTRC()
l_int32     pixcmapShiftIntensity()
l_int32     pixcmapShiftByComponent()

Note:
(1) colormaps in leptonica have a maximum of 256 entries.
(2) nalloc, the allocated size of the palette array, is related
to the depth d of the pixels by:
nalloc = 2^(d)

</pre>




"""
    
    try:
        leptonica.pixcmapCreate.argtypes = [ctypes.c_int32]
        leptonica.pixcmapCreate.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCreate(*args):
        """
        ('l_int32', 'depth')       

:param[in]    depth:    of pix, in bpp
:returns:  cmap, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCreate(*args)
    
    

    try:
        leptonica.pixcmapCreateRandom.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapCreateRandom.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapCreateRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCreateRandom(*args):
        """
        ('l_int32', 'depth')       
('l_int32', 'hasblack')       
('l_int32', 'haswhite')       

:param[in]    depth:      of pix, in bpp: 2, 4 or 8
:param[in]    hasblack:   1 if the first color is black; 0 if no black
:param[in]    haswhite:   1 if the last color is white; 0 if no white
:returns:  cmap, or NULL on error

<pre>
Notes:
(1) This sets up a colormap with random colors,
where the first color is optionally black, the last color
is optionally white, and the remaining colors are
chosen randomly.
(2) The number of randomly chosen colors is:
2^(depth) - haswhite - hasblack
(3) Because rand() is seeded, it might disrupt otherwise
deterministic results if also used elsewhere in a program.
(4) rand() is not threadsafe, and will generate garbage if run
on multiple threads at once -- though garbage is generally
what you want from a random number generator!
(5) Modern rand()s have equal randomness in low and high order
bits, but older ones don't.  Here, we're just using rand()
to choose colors for output.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCreateRandom(*args)
    
    

    try:
        leptonica.pixcmapCreateLinear.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapCreateLinear.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapCreateLinear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCreateLinear(*args):
        """
        ('l_int32', 'd')       
('l_int32', 'nlevels')       

:param[in]    d:          depth of pix for this colormap; 1, 2, 4 or 8
:param[in]    nlevels:    valid in range [2, 2^d]
:returns:  cmap, or NULL on error

<pre>
Notes:
(1) Colormap has equally spaced gray color values
from black (0, 0, 0) to white (255, 255, 255).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCreateLinear(*args)
    
    

    try:
        leptonica.pixcmapCopy.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapCopy.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCopy(*args):
        """
        ('const PIXCMAP', '*cmaps')       

:param[in]    cmaps:
:returns:  cmapd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCopy(*args)
    
    

    try:
        leptonica.pixcmapDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapDestroy(*args):
        """
        ('PIXCMAP', '**pcmap')       

:param[in,out]   pcmap:    set to null on return
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapDestroy(*args)
    
    

    try:
        leptonica.pixcmapIsValid.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapIsValid.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapIsValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapIsValid(*args):
        """
        ('const PIXCMAP', '*cmap')       
('l_int32', '*pvalid')       

:param[in]    cmap:
:param[out]   pvalid:     return 1 if valid; 0 if not
:returns:  0 if OK, 1 on error or if cmap is not valid


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapIsValid(*args)
    
    

    try:
        leptonica.pixcmapAddColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapAddColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapAddColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    cmap:
:param[in]    rval,: gval, bval   colormap entry to be added; each number
is in range [0, ... 255]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This always adds the color if there is room.
(2) The alpha component is 255 (opaque)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddColor(*args)
    
    

    try:
        leptonica.pixcmapAddRGBA.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapAddRGBA.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapAddRGBA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddRGBA(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'aval')       

:param[in]    cmap:
:param[in]    rval,: gval, bval, aval   colormap entry to be added;
each number is in range [0, ... 255]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This always adds the color if there is room.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddRGBA(*args)
    
    

    try:
        leptonica.pixcmapAddNewColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapAddNewColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapAddNewColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddNewColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    rval,: gval, bval    colormap entry to be added; each number
is in range [0, ... 255]
:param[out]   pindex:              index of color
:returns:  0 if OK, 1 on error; 2 if unable to add color

<pre>
Notes:
(1) This only adds color if not already there.
(2) The alpha component is 255 (opaque)
(3) This returns the index of the new (or existing) color.
(4) Returns 2 with a warning if unable to add this color;
the caller should check the return value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddNewColor(*args)
    
    

    try:
        leptonica.pixcmapAddNearestColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapAddNearestColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapAddNearestColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddNearestColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    rval,: gval, bval    colormap entry to be added; each number
is in range [0, ... 255]
:param[out]   pindex:              index of color
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only adds color if not already there.
(2) The alpha component is 255 (opaque)
(3) If it's not in the colormap and there is no room to add
another color, this returns the index of the nearest color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddNearestColor(*args)
    
    

    try:
        leptonica.pixcmapUsableColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapUsableColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapUsableColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapUsableColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pusable')       

:param[in]    cmap:
:param[in]    rval,: gval, bval   colormap entry to be added; each number
is in range [0, ... 255]
:param[out]   pusable:            1 if usable; 0 if not
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This checks if the color already exists or if there is
room to add it.  It makes no change in the colormap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapUsableColor(*args)
    
    

    try:
        leptonica.pixcmapAddBlackOrWhite.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapAddBlackOrWhite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapAddBlackOrWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapAddBlackOrWhite(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'color')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    color:    0 for black, 1 for white
:param[out]   pindex:   [optional] index of color; can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only adds color if not already there.
(2) The alpha component is 255 (opaque)
(3) This sets index to the requested color.
(4) If there is no room in the colormap, returns the index
of the closest color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapAddBlackOrWhite(*args)
    
    

    try:
        leptonica.pixcmapSetBlackAndWhite.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapSetBlackAndWhite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapSetBlackAndWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapSetBlackAndWhite(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'setblack')       
('l_int32', 'setwhite')       

:param[in]    cmap:
:param[in]    setblack:   0 for no operation; 1 to set darkest color to black
:param[in]    setwhite:   0 for no operation; 1 to set lightest color to white
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapSetBlackAndWhite(*args)
    
    

    try:
        leptonica.pixcmapGetCount.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetCount(*args):
        """
        ('const PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetCount(*args)
    
    

    try:
        leptonica.pixcmapGetFreeCount.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapGetFreeCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetFreeCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetFreeCount(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  free entries, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetFreeCount(*args)
    
    

    try:
        leptonica.pixcmapGetDepth.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapGetDepth.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetDepth(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  depth, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetDepth(*args)
    
    

    try:
        leptonica.pixcmapGetMinDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetMinDepth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetMinDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetMinDepth(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pmindepth')       

:param[in]    cmap:
:param[out]   pmindepth:    minimum depth to support the colormap
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) On error, &mindepth is returned as 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetMinDepth(*args)
    
    

    try:
        leptonica.pixcmapClear.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapClear.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapClear(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes the colors by setting the count to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapClear(*args)
    
    

    try:
        leptonica.pixcmapGetColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    cmap:
:param[in]    index:
:param[out]   prval,: pgval, pbval    each color value
:returns:  0 if OK, 1 if not accessible caller should check


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetColor(*args)
    
    

    try:
        leptonica.pixcmapGetColor32.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetColor32.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetColor32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetColor32(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_uint32', '*pval32')       

:param[in]    cmap:
:param[in]    index:
:param[out]   pval32:     32-bit rgb color value
:returns:  0 if OK, 1 if not accessible caller should check

<pre>
Notes:
(1) The returned alpha channel value is 255.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetColor32(*args)
    
    

    try:
        leptonica.pixcmapGetRGBA.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetRGBA.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetRGBA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRGBA(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
('l_int32', '*paval')       

:param[in]    cmap:
:param[in]    index:
:param[out]   prval,: pgval, pbval, paval    each color value
:returns:  0 if OK, 1 if not accessible caller should check


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRGBA(*args)
    
    

    try:
        leptonica.pixcmapGetRGBA32.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetRGBA32.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetRGBA32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRGBA32(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_uint32', '*pval32')       

:param[in]    cmap:
:param[in]    index:
:param[out]   pval32:     32-bit rgba color value
:returns:  0 if OK, 1 if not accessible caller should check


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRGBA32(*args)
    
    

    try:
        leptonica.pixcmapResetColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapResetColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapResetColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapResetColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    cmap:
:param[in]    index:
:param[in]    rval,: gval, bval    colormap entry to be reset; each number
is in range [0, ... 255]
:returns:  0 if OK, 1 if not accessible caller should check

<pre>
Notes:
(1) This resets sets the color of an entry that has already
been set and included in the count of colors.
(2) The alpha component is 255 (opaque)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapResetColor(*args)
    
    

    try:
        leptonica.pixcmapSetAlpha.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapSetAlpha.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapSetAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapSetAlpha(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', 'aval')       

:param[in]    cmap:
:param[in]    index:
:param[in]    aval:     in range [0, ... 255]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This modifies the transparency of one entry in a colormap.
The alpha component by default is 255 (opaque).
This is used when extracting the colormap from a PNG file
without decoding the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapSetAlpha(*args)
    
    

    try:
        leptonica.pixcmapGetIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetIndex.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetIndex(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    rval,: gval, bval   colormap colors to search for; each number
is in range [0, ... 255]
:param[out]   pindex:             value of index found
:returns:  0 if found, 1 if not found caller must check


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetIndex(*args)
    
    

    try:
        leptonica.pixcmapHasColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapHasColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapHasColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapHasColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pcolor')       

:param[in]    cmap:
:param[out]   pcolor:    TRUE if cmap has color; FALSE otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapHasColor(*args)
    
    

    try:
        leptonica.pixcmapIsOpaque.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapIsOpaque.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapIsOpaque not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapIsOpaque(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*popaque')       

:param[in]    cmap:
:param[out]   popaque:     TRUE if fully opaque: all entries are 255
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapIsOpaque(*args)
    
    

    try:
        leptonica.pixcmapIsBlackAndWhite.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapIsBlackAndWhite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapIsBlackAndWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapIsBlackAndWhite(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pblackwhite')       

:param[in]    cmap:
:param[out]   pblackwhite:   TRUE if the cmap has only two colors:
black (0,0,0) and white (255,255,255)
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapIsBlackAndWhite(*args)
    
    

    try:
        leptonica.pixcmapCountGrayColors.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapCountGrayColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapCountGrayColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapCountGrayColors(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', '*pngray')       

:param[in]    cmap:
:param[out]   pngray:     number of gray colors
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This counts the unique gray colors, including black and white.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapCountGrayColors(*args)
    
    

    try:
        leptonica.pixcmapGetRankIntensity.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixcmapGetRankIntensity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetRankIntensity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRankIntensity(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'rankval')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    rankval:   0.0 for darkest, 1.0 for lightest color
:param[out]   pindex:    the index into the colormap that corresponds
to the rank intensity color
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRankIntensity(*args)
    
    

    try:
        leptonica.pixcmapGetNearestIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetNearestIndex.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetNearestIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetNearestIndex(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    rval,: gval, bval   colormap colors to search for; each number
is in range [0, ... 255]
:param[out]   pindex:             the index of the nearest color
:returns:  0 if OK, 1 on error caller must check

<pre>
Notes:
(1) Returns the index of the exact color if possible, otherwise the
index of the color closest to the target color.
(2) Nearest color is that which is the least sum-of-squares distance
from the target color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetNearestIndex(*args)
    
    

    try:
        leptonica.pixcmapGetNearestGrayIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetNearestGrayIndex.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetNearestGrayIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetNearestGrayIndex(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'val')       
('l_int32', '*pindex')       

:param[in]    cmap:
:param[in]    val:       gray value to search for; in range [0, ... 255]
:param[out]   pindex:    the index of the nearest color
:returns:  0 if OK, 1 on error caller must check

<pre>
Notes:
(1) This should be used on gray colormaps.  It uses only the
green value of the colormap.
(2) Returns the index of the exact color if possible, otherwise the
index of the color closest to the target color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetNearestGrayIndex(*args)
    
    

    try:
        leptonica.pixcmapGetDistanceToColor.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcmapGetDistanceToColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetDistanceToColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetDistanceToColor(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'index')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pdist')       

:param[in]    cmap:
:param[in]    index:
:param[in]    rval,:    gval, bval target color
:param[out]   pdist:    the distance from the cmap entry to target
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Returns the L2 distance (squared) between the color at index i
and the target color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetDistanceToColor(*args)
    
    

    try:
        leptonica.pixcmapGetRangeValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapGetRangeValues.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGetRangeValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGetRangeValues(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'select')       
('l_int32', '*pminval')       
('l_int32', '*pmaxval')       
('l_int32', '*pminindex')       
('l_int32', '*pmaxindex')       

:param[in]    cmap:
:param[in]    select:      L_SELECT_RED, L_SELECT_GREEN, L_SELECT_BLUE or
L_SELECT_AVERAGE
:param[out]   pminval:     [optional] minimum value of component
:param[out]   pmaxval:     [optional] maximum value of component
:param[out]   pminindex:   [optional] index of minimum value
:param[out]   pmaxindex:   [optional] index of maximum value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Returns, for selected components (or the average), the
the extreme values (min and/or max) and their indices
that are found in the cmap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGetRangeValues(*args)
    
    

    try:
        leptonica.pixcmapGrayToFalseColor.argtypes = [ctypes.c_float]
        leptonica.pixcmapGrayToFalseColor.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGrayToFalseColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGrayToFalseColor(*args):
        """
        ('l_float32', 'gamma')       

:param[in]    gamma:   (factor) 0.0 or 1.0 for default; > 1.0 for brighter;
2.0 is quite nice
:returns:  cmap, or NULL on error

<pre>
Notes:
(1) This creates a colormap that maps from gray to false colors.
The colormap is modeled after the Matlap "jet" configuration.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGrayToFalseColor(*args)
    
    

    try:
        leptonica.pixcmapGrayToColor.argtypes = [ctypes.c_uint32]
        leptonica.pixcmapGrayToColor.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGrayToColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGrayToColor(*args):
        """
        ('l_uint32', 'color')       

:param[in]    color:
:returns:  cmap, or NULL on error

<pre>
Notes:
(1) This creates a colormap that maps from gray to
a specific color.  In the mapping, each component
is faded to white, depending on the gray value.
(2) In use, this is simply attached to a grayscale pix
to give it the input color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGrayToColor(*args)
    
    

    try:
        leptonica.pixcmapColorToGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixcmapColorToGray.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapColorToGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapColorToGray(*args):
        """
        ('PIXCMAP', '*cmaps')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       

:param[in]    cmaps:
:param[in]    rwt,: gwt, bwt    non-negative; these should add to 1.0
:returns:  cmap gray, or NULL on error

<pre>
Notes:
(1) This creates a gray colormap from an arbitrary colormap.
(2) In use, attach the output gray colormap to the pix
(or a copy of it) that provided the input colormap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapColorToGray(*args)
    
    

    try:
        leptonica.pixcmapConvertTo4.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapConvertTo4.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertTo4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertTo4(*args):
        """
        ('PIXCMAP', '*cmaps')       

:param[in]    cmaps:   colormap for 2 bpp pix
:returns:  cmapd   (4 bpp)

<pre>
Notes:
(1) This converts a 2 bpp colormap to 4 bpp.  The colors
are the same; the output colormap entry array has size 16.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertTo4(*args)
    
    

    try:
        leptonica.pixcmapConvertTo8.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapConvertTo8.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertTo8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertTo8(*args):
        """
        ('PIXCMAP', '*cmaps')       

:param[in]    cmaps:   colormap for 2 bpp or 4 bpp pix
:returns:  cmapd   (8 bpp)

<pre>
Notes:
(1) This converts a 2 bpp or 4 bpp colormap to 8 bpp.  The colors
are the same; the output colormap entry array has size 256.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertTo8(*args)
    
    

    try:
        leptonica.pixcmapRead.argtypes = [ctypes.c_char_p]
        leptonica.pixcmapRead.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  cmap, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapRead(*args)
    
    

    try:
        leptonica.pixcmapReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapReadStream.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:     file stream
:returns:  cmap, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapReadStream(*args)
    
    

    try:
        leptonica.pixcmapReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixcmapReadMem.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:     serialization of pixcmap; in ascii
:param[in]    size:     of data in bytes; can use strlen to get it
:returns:  cmap, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapReadMem(*args)
    
    

    try:
        leptonica.pixcmapWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixcmapWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapWrite(*args):
        """
        ('const char', '*filename')       
('const PIXCMAP', '*cmap')       

:param[in]    filename:
:param[in]    cmap:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapWrite(*args)
    
    

    try:
        leptonica.pixcmapWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapWriteStream(*args):
        """
        ('FILE', '*fp')       
('const PIXCMAP', '*cmap')       

:param[in]    fp:      file stream
:param[in]    cmap:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapWriteStream(*args)
    
    

    try:
        leptonica.pixcmapWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('const PIXCMAP', '*cmap')       

:param[out]   pdata:     data of serialized pixcmap; ascii
:param[out]   psize:     size of returned data
:param[in]    cmap:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a pixcmap in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapWriteMem(*args)
    
    

    try:
        leptonica.pixcmapToArrays.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapToArrays.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapToArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapToArrays(*args):
        """
        ('const PIXCMAP', '*cmap')       
('l_int32', '**prmap')       
('l_int32', '**pgmap')       
('l_int32', '**pbmap')       
('l_int32', '**pamap')       

:param[in]    cmap:     colormap
:param[out]   prmap:    array of red values
:param[out]   pgmap:    array of green values
:param[out]   pbmap:    array of blue values
:param[out]   pamap:    [optional] array of alpha (transparency) values
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapToArrays(*args)
    
    

    try:
        leptonica.pixcmapToRGBTable.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapToRGBTable.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapToRGBTable not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapToRGBTable(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_uint32', '**ptab')       
('l_int32', '*pncolors')       

:param[in]    cmap:       colormap
:param[out]   ptab:       table of rgba values for the colormap
:param[out]   pncolors:   [optional] size of table
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapToRGBTable(*args)
    
    

    try:
        leptonica.pixcmapSerializeToMemory.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcmapSerializeToMemory.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapSerializeToMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapSerializeToMemory(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'cpc')       
('l_int32', '*pncolors')       
('l_uint8', '**pdata')       

:param[in]    cmap:       colormap
:param[in]    cpc:        components/color: 3 for rgb, 4 for rgba
:param[out]   pncolors:   number of colors in table
:param[out]   pdata:      binary string, cpc bytes per color
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) When serializing to store in a pdf, use %cpc = 3.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapSerializeToMemory(*args)
    
    

    try:
        leptonica.pixcmapDeserializeFromMemory.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapDeserializeFromMemory.restype = lambda address: PIXCMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapDeserializeFromMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapDeserializeFromMemory(*args):
        """
        ('l_uint8', '*data')       
('l_int32', 'cpc')       
('l_int32', 'ncolors')       

:param[in]    data:      binary string, 3 or 4 bytes per color
:param[in]    cpc:       components/color: 3 for rgb, 4 for rgba
:param[in]    ncolors:
:returns:  cmap, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapDeserializeFromMemory(*args)
    
    

    try:
        leptonica.pixcmapConvertToHex.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixcmapConvertToHex.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertToHex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertToHex(*args):
        """
        ('l_uint8', '*data')       
('l_int32', 'ncolors')       

:param[in]    data:       binary serialized data
:param[in]    ncolors:    in colormap
:returns:  hexdata bracketed, space-separated ascii hex string,
or NULL on error.

<pre>
Notes:
(1) The number of bytes in %data is 3 * ncolors.
(2) Output is in form:
< r0g0b0 r1g1b1 ... rngnbn >
where r0, g0, b0 ... are each 2 bytes of hex ascii
(3) This is used in pdf files to express the colormap as an
array in ascii (human-readable) format.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertToHex(*args)
    
    

    try:
        leptonica.pixcmapGammaTRC.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapGammaTRC.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapGammaTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapGammaTRC(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       

:param[in]    cmap:      colormap
:param[in]    gamma:     gamma correction; must be > 0.0
:param[in]    minval:    input value that gives 0 for output; can be < 0
:param[in]    maxval:    input value that gives 255 for output; can be > 255
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place transform
(2) See pixGammaTRC() and numaGammaTRC() in enhance.c
for description and use of transform
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapGammaTRC(*args)
    
    

    try:
        leptonica.pixcmapContrastTRC.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixcmapContrastTRC.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapContrastTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapContrastTRC(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'factor')       

:param[in]    cmap:     colormap
:param[in]    factor:   generally between 0.0 [no enhancement]
and 1.0, but can be larger than 1.0
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place transform
(2) See pixContrastTRC() and numaContrastTRC() in enhance.c
for description and use of transform
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapContrastTRC(*args)
    
    

    try:
        leptonica.pixcmapShiftIntensity.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixcmapShiftIntensity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapShiftIntensity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapShiftIntensity(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_float32', 'fraction')       

:param[in]    cmap:       colormap
:param[in]    fraction:   between -1.0 and +1.0
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place transform
(2) It does a proportional shift of the intensity for each color.
(3) If fraction < 0.0, it moves all colors towards (0,0,0).
This darkens the image.
If fraction > 0.0, it moves all colors towards (255,255,255)
This fades the image.
(4) The equivalent transform can be accomplished with pixcmapGammaTRC(),
but it is considerably more difficult (see numaGammaTRC()).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapShiftIntensity(*args)
    
    

    try:
        leptonica.pixcmapShiftByComponent.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixcmapShiftByComponent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapShiftByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapShiftByComponent(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       

:param[in]    cmap:     colormap
:param[in]    srcval:   source color: 0xrrggbb00
:param[in]    dstval:   target color: 0xrrggbb00
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place transform
(2) It implements pixelShiftByComponent() for each color.
The mapping is specified by srcval and dstval.
(3) If a component decreases, the component in the colormap
decreases by the same ratio.  Likewise for increasing, except
all ratios are taken with respect to the distance from 255.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapShiftByComponent(*args)
    




class fpix1(object):
    """<pre>

---------------------------------------------------
This file has these FPix, FPixa and DPix utilities:
- creation and destruction
- accessors
- serialization and deserialization
---------------------------------------------------

FPix Create/copy/destroy
FPIX          *fpixCreate()
FPIX          *fpixCreateTemplate()
FPIX          *fpixClone()
FPIX          *fpixCopy()
l_int32        fpixResizeImageData()
void           fpixDestroy()

FPix accessors
l_int32        fpixGetDimensions()
l_int32        fpixSetDimensions()
l_int32        fpixGetWpl()
l_int32        fpixSetWpl()
l_int32        fpixGetRefcount()
l_int32        fpixChangeRefcount()
l_int32        fpixGetResolution()
l_int32        fpixSetResolution()
l_int32        fpixCopyResolution()
l_float32     *fpixGetData()
l_int32        fpixSetData()
l_int32        fpixGetPixel()
l_int32        fpixSetPixel()

FPixa Create/copy/destroy
FPIXA         *fpixaCreate()
FPIXA         *fpixaCopy()
void           fpixaDestroy()

FPixa addition
l_int32        fpixaAddFPix()
static l_int32 fpixaExtendArray()
static l_int32 fpixaExtendArrayToSize()

FPixa accessors
l_int32        fpixaGetCount()
l_int32        fpixaChangeRefcount()
FPIX          *fpixaGetFPix()
l_int32        fpixaGetFPixDimensions()
l_float32     *fpixaGetData()
l_int32        fpixaGetPixel()
l_int32        fpixaSetPixel()

DPix Create/copy/destroy
DPIX          *dpixCreate()
DPIX          *dpixCreateTemplate()
DPIX          *dpixClone()
DPIX          *dpixCopy()
l_int32        dpixResizeImageData()
void           dpixDestroy()

DPix accessors
l_int32        dpixGetDimensions()
l_int32        dpixSetDimensions()
l_int32        dpixGetWpl()
l_int32        dpixSetWpl()
l_int32        dpixGetRefcount()
l_int32        dpixChangeRefcount()
l_int32        dpixGetResolution()
l_int32        dpixSetResolution()
l_int32        dpixCopyResolution()
l_float64     *dpixGetData()
l_int32        dpixSetData()
l_int32        dpixGetPixel()
l_int32        dpixSetPixel()

FPix serialized I/O
FPIX          *fpixRead()
FPIX          *fpixReadStream()
FPIX          *fpixReadMem()
l_int32        fpixWrite()
l_int32        fpixWriteStream()
l_int32        fpixWriteMem()
FPIX          *fpixEndianByteSwap()

DPix serialized I/O
DPIX          *dpixRead()
DPIX          *dpixReadStream()
DPIX          *dpixReadMem()
l_int32        dpixWrite()
l_int32        dpixWriteStream()
l_int32        dpixWriteMem()
DPIX          *dpixEndianByteSwap()

Print FPix (subsampled, for debugging)
l_int32        fpixPrintStream()
</pre>




"""
    
    try:
        leptonica.fpixCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixCreate.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCreate(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       

:param[in]       width,: height
:returns:  fpixd   with data allocated and initialized to 0, or NULL on error

<pre>
Notes:
(1) Makes a FPix of specified size, with the data array
allocated and initialized to 0.
(2) The number of pixels must be less than 2^29.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCreate(*args)
    
    

    try:
        leptonica.fpixCreateTemplate.argtypes = [ctypes.c_void_p]
        leptonica.fpixCreateTemplate.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixCreateTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCreateTemplate(*args):
        """
        ('FPIX', '*fpixs')       

:param[in]    fpixs:
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) Makes a FPix of the same size as the input FPix, with the
data array allocated and initialized to 0.
(2) Copies the resolution.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCreateTemplate(*args)
    
    

    try:
        leptonica.fpixClone.argtypes = [ctypes.c_void_p]
        leptonica.fpixClone.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixClone(*args):
        """
        ('FPIX', '*fpix')       

:param[in]    fpix:
:returns:  same fpix ptr, or NULL on error

<pre>
Notes:
(1) See pixClone() for definition and usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixClone(*args)
    
    

    try:
        leptonica.fpixCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixCopy.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCopy(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd:    [optional] can be null, or equal to fpixs,
or different from fpixs
:param[in]    fpixs:
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) There are three cases:
(a) fpixd == null  (makes a new fpix; refcount = 1)
(b) fpixd == fpixs  (no-op)
(c) fpixd != fpixs  (data copy; no change in refcount)
If the refcount of fpixd > 1, case (c) will side-effect
these handles.
(2) The general pattern of use is:
fpixd = fpixCopy(fpixd, fpixs);
This will work for all three cases.
For clarity when the case is known, you can use:
(a) fpixd = fpixCopy(NULL, fpixs);
(c) fpixCopy(fpixd, fpixs);
(3) For case (c), we check if fpixs and fpixd are the same size.
If so, the data is copied directly.
Otherwise, the data is reallocated to the correct size
and the copy proceeds.  The refcount of fpixd is unchanged.
(4) This operation, like all others that may involve a pre-existing
fpixd, will side-effect any existing clones of fpixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCopy(*args)
    
    

    try:
        leptonica.fpixResizeImageData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixResizeImageData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixResizeImageData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixResizeImageData(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd,: fpixs
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If the data sizes differ, this destroys the existing
data in fpixd and allocates a new, uninitialized, data array
of the same size as the data in fpixs.  Otherwise, this
doesn't do anything.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixResizeImageData(*args)
    
    

    try:
        leptonica.fpixDestroy.argtypes = [ctypes.c_void_p]
        leptonica.fpixDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function fpixDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixDestroy(*args):
        """
        ('FPIX', '**pfpix')       

:param[in,out]   pfpix:    will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the fpix.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixDestroy(*args)
    
    

    try:
        leptonica.fpixGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetDimensions(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    fpix:
:param[out]   pw,: ph    [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetDimensions(*args)
    
    

    try:
        leptonica.fpixSetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixSetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixSetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetDimensions(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    fpix:
:param[in]    w,: h
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetDimensions(*args)
    
    

    try:
        leptonica.fpixGetWpl.argtypes = [ctypes.c_void_p]
        leptonica.fpixGetWpl.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetWpl not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetWpl(*args):
        """
        ('FPIX', '*fpix')       

:param[in]    fpix:
:returns:  wpl, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetWpl(*args)
    
    

    try:
        leptonica.fpixSetWpl.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixSetWpl.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixSetWpl not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetWpl(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'wpl')       

:param[in]    fpix:
:param[in]    wpl:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetWpl(*args)
    
    

    try:
        leptonica.fpixGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.fpixGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetRefcount(*args):
        """
        ('FPIX', '*fpix')       

:param[in]    fpix:
:returns:  refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetRefcount(*args)
    
    

    try:
        leptonica.fpixChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixChangeRefcount(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'delta')       

:param[in]    fpix:
:param[in]    delta:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixChangeRefcount(*args)
    
    

    try:
        leptonica.fpixGetResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetResolution(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       

:param[in]    fpix:
:param[out]   pxres,: pyres     [optional] x and y resolution
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetResolution(*args)
    
    

    try:
        leptonica.fpixSetResolution.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixSetResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixSetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetResolution(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'xres')       
('l_int32', 'yres')       

:param[in]    fpix:
:param[in]    xres,: yres     x and y resolution
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetResolution(*args)
    
    

    try:
        leptonica.fpixCopyResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixCopyResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixCopyResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixCopyResolution(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd,: fpixs
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixCopyResolution(*args)
    
    

    try:
        leptonica.fpixGetData.argtypes = [ctypes.c_void_p]
        leptonica.fpixGetData.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetData(*args):
        """
        ('FPIX', '*fpix')       

:param[in]    fpix:
:returns:  ptr to fpix data, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetData(*args)
    
    

    try:
        leptonica.fpixSetData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixSetData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixSetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetData(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', '*data')       

:param[in]    fpix:
:param[in]    data:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetData(*args)
    
    

    try:
        leptonica.fpixGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fpixGetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetPixel(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pval')       

:param[in]    fpix:
:param[in]    x,y:     pixel coords
:param[out]   pval:    pixel value
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0.0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetPixel(*args)
    
    

    try:
        leptonica.fpixSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixSetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetPixel(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'val')       

:param[in]    fpix:
:param[in]    x,y:    pixel coords
:param[in]    val:    pixel value
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0.0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetPixel(*args)
    
    

    try:
        leptonica.fpixaCreate.argtypes = [ctypes.c_int32]
        leptonica.fpixaCreate.restype = lambda address: FPIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:     initial number of ptrs
:returns:  fpixa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaCreate(*args)
    
    

    try:
        leptonica.fpixaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaCopy.restype = lambda address: FPIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaCopy(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'copyflag')       

:param[in]    fpixa:
:param[in]    copyflag:     L_COPY, L_CLODE or L_COPY_CLONE
:returns:  new fpixa, or NULL on error

<pre>
Notes:
copyflag may be one of
~ L_COPY makes a new fpixa and copies each fpix
~ L_CLONE gives a new ref-counted handle to the input fpixa
~ L_COPY_CLONE makes a new fpixa with clones of all fpix
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaCopy(*args)
    
    

    try:
        leptonica.fpixaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.fpixaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaDestroy(*args):
        """
        ('FPIXA', '**pfpixa')       

:param[in,out]   pfpixa:    will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the fpixa.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaDestroy(*args)
    
    

    try:
        leptonica.fpixaAddFPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaAddFPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixaAddFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaAddFPix(*args):
        """
        ('FPIXA', '*fpixa')       
('FPIX', '*fpix')       
('l_int32', 'copyflag')       

:param[in]    fpixa:
:param[in]    fpix:        to be added
:param[in]    copyflag:    L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaAddFPix(*args)
    
    

    try:
        leptonica.fpixaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.fpixaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function fpixaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetCount(*args):
        """
        ('FPIXA', '*fpixa')       

:param[in]    fpixa:
:returns:  count, or 0 if no pixa


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetCount(*args)
    
    

    try:
        leptonica.fpixaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaChangeRefcount(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'delta')       

:param[in]    fpixa:
:param[in]    delta:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaChangeRefcount(*args)
    
    

    try:
        leptonica.fpixaGetFPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixaGetFPix.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaGetFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetFPix(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       

:param[in]    fpixa:
:param[in]    index:        to the index-th fpix
:param[in]    accesstype:   L_COPY or L_CLONE
:returns:  fpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetFPix(*args)
    
    

    try:
        leptonica.fpixaGetFPixDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixaGetFPixDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixaGetFPixDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetFPixDimensions(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    fpixa:
:param[in]    index:      to the index-th box
:param[out]   pw,: ph     [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetFPixDimensions(*args)
    
    

    try:
        leptonica.fpixaGetData.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixaGetData.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        sys.stderr.write("Warning - function fpixaGetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetData(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       

:param[in]    fpixa:
:param[in]    index:     into fpixa array
:returns:  data not a copy, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetData(*args)
    
    

    try:
        leptonica.fpixaGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.fpixaGetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixaGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaGetPixel(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pval')       

:param[in]    fpixa:
:param[in]    index:     into fpixa array
:param[in]    x,y:       pixel coords
:param[out]   pval:      pixel value
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaGetPixel(*args)
    
    

    try:
        leptonica.fpixaSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixaSetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixaSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaSetPixel(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'index')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'val')       

:param[in]    fpixa:
:param[in]    index:    into fpixa array
:param[in]    x,y:      pixel coords
:param[in]    val:      pixel value
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaSetPixel(*args)
    
    

    try:
        leptonica.dpixCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixCreate.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCreate(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       

:param[in]     width,: height
:returns:  dpix  with data allocated and initialized to 0, or NULL on error

<pre>
Notes:
(1) Makes a DPix of specified size, with the data array
allocated and initialized to 0.
(2) The number of pixels must be less than 2^28.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCreate(*args)
    
    

    try:
        leptonica.dpixCreateTemplate.argtypes = [ctypes.c_void_p]
        leptonica.dpixCreateTemplate.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixCreateTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCreateTemplate(*args):
        """
        ('DPIX', '*dpixs')       

:param[in]    dpixs:
:returns:  dpixd, or NULL on error

<pre>
Notes:
(1) Makes a DPix of the same size as the input DPix, with the
data array allocated and initialized to 0.
(2) Copies the resolution.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCreateTemplate(*args)
    
    

    try:
        leptonica.dpixClone.argtypes = [ctypes.c_void_p]
        leptonica.dpixClone.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixClone(*args):
        """
        ('DPIX', '*dpix')       

:param[in]    dpix:
:returns:  same dpix ptr, or NULL on error

<pre>
Notes:
(1) See pixClone() for definition and usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixClone(*args)
    
    

    try:
        leptonica.dpixCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixCopy.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCopy(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       

:param[in]    dpixd:    [optional] can be null, or equal to dpixs,
or different from dpixs
:param[in]    dpixs:
:returns:  dpixd, or NULL on error

<pre>
Notes:
(1) There are three cases:
(a) dpixd == null  (makes a new dpix; refcount = 1)
(b) dpixd == dpixs  (no-op)
(c) dpixd != dpixs  (data copy; no change in refcount)
If the refcount of dpixd > 1, case (c) will side-effect
these handles.
(2) The general pattern of use is:
dpixd = dpixCopy(dpixd, dpixs);
This will work for all three cases.
For clarity when the case is known, you can use:
(a) dpixd = dpixCopy(NULL, dpixs);
(c) dpixCopy(dpixd, dpixs);
(3) For case (c), we check if dpixs and dpixd are the same size.
If so, the data is copied directly.
Otherwise, the data is reallocated to the correct size
and the copy proceeds.  The refcount of dpixd is unchanged.
(4) This operation, like all others that may involve a pre-existing
dpixd, will side-effect any existing clones of dpixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCopy(*args)
    
    

    try:
        leptonica.dpixResizeImageData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixResizeImageData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixResizeImageData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixResizeImageData(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       

:param[in]    dpixd,: dpixs
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixResizeImageData(*args)
    
    

    try:
        leptonica.dpixDestroy.argtypes = [ctypes.c_void_p]
        leptonica.dpixDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function dpixDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixDestroy(*args):
        """
        ('DPIX', '**pdpix')       

:param[in,out]   pdpix:    will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the dpix.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixDestroy(*args)
    
    

    try:
        leptonica.dpixGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetDimensions(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    dpix:
:param[out]   pw,: ph     [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetDimensions(*args)
    
    

    try:
        leptonica.dpixSetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixSetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixSetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetDimensions(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    dpix:
:param[in]    w,: h
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetDimensions(*args)
    
    

    try:
        leptonica.dpixGetWpl.argtypes = [ctypes.c_void_p]
        leptonica.dpixGetWpl.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetWpl not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetWpl(*args):
        """
        ('DPIX', '*dpix')       

:param[in]    dpix:
:returns:  wpl, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetWpl(*args)
    
    

    try:
        leptonica.dpixSetWpl.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dpixSetWpl.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixSetWpl not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetWpl(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'wpl')       

:param[in]    dpix:
:param[in]    wpl:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetWpl(*args)
    
    

    try:
        leptonica.dpixGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.dpixGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetRefcount(*args):
        """
        ('DPIX', '*dpix')       

:param[in]    dpix:
:returns:  refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetRefcount(*args)
    
    

    try:
        leptonica.dpixChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dpixChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixChangeRefcount(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'delta')       

:param[in]    dpix:
:param[in]    delta:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixChangeRefcount(*args)
    
    

    try:
        leptonica.dpixGetResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetResolution(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       

:param[in]    dpix:
:param[out]   pxres,: pyres    [optional] x and y resolution
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetResolution(*args)
    
    

    try:
        leptonica.dpixSetResolution.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixSetResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixSetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetResolution(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'xres')       
('l_int32', 'yres')       

:param[in]    dpix:
:param[in]    xres,: yres     x and y resolution
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetResolution(*args)
    
    

    try:
        leptonica.dpixCopyResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixCopyResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixCopyResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixCopyResolution(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       

:param[in]    dpixd,: dpixs
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixCopyResolution(*args)
    
    

    try:
        leptonica.dpixGetData.argtypes = [ctypes.c_void_p]
        leptonica.dpixGetData.restype = ctypes.POINTER(ctypes.c_double)
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetData(*args):
        """
        ('DPIX', '*dpix')       

:param[in]    dpix:
:returns:  ptr to dpix data, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetData(*args)
    
    

    try:
        leptonica.dpixSetData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixSetData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixSetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetData(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', '*data')       

:param[in]    dpix:
:param[in]    data:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetData(*args)
    
    

    try:
        leptonica.dpixGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.dpixGetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetPixel(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float64', '*pval')       

:param[in]    dpix:
:param[in]    x,y:     pixel coords
:param[out]   pval:    pixel value
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0.0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetPixel(*args)
    
    

    try:
        leptonica.dpixSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_double]
        leptonica.dpixSetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetPixel(*args):
        """
        ('DPIX', '*dpix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float64', 'val')       

:param[in]    dpix:
:param[in]    x,y:    pixel coords
:param[in]    val:    pixel value
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0.0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetPixel(*args)
    
    

    try:
        leptonica.fpixRead.argtypes = [ctypes.c_char_p]
        leptonica.fpixRead.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  fpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRead(*args)
    
    

    try:
        leptonica.fpixReadStream.argtypes = [ctypes.c_void_p]
        leptonica.fpixReadStream.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:     file stream
:returns:  fpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixReadStream(*args)
    
    

    try:
        leptonica.fpixReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.fpixReadMem.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    of serialized fpix
:param[in]    size:    of data in bytes
:returns:  fpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixReadMem(*args)
    
    

    try:
        leptonica.fpixWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.fpixWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixWrite(*args):
        """
        ('const char', '*filename')       
('FPIX', '*fpix')       

:param[in]    filename:
:param[in]    fpix:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixWrite(*args)
    
    

    try:
        leptonica.fpixWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixWriteStream(*args):
        """
        ('FILE', '*fp')       
('FPIX', '*fpix')       

:param[in]    fp:       file stream opened for "wb"
:param[in]    fpix:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixWriteStream(*args)
    
    

    try:
        leptonica.fpixWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('FPIX', '*fpix')       

:param[out]   pdata:     data of serialized fpix
:param[out]   psize:     size of returned data
:param[in]    fpix:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a fpix in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixWriteMem(*args)
    
    

    try:
        leptonica.fpixEndianByteSwap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixEndianByteSwap.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixEndianByteSwap(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd:     can be equal to fpixs or NULL
:param[in]    fpixs:
:returns:  fpixd always

<pre>
Notes:
(1) On big-endian hardware, this does byte-swapping on each of
the 4-byte floats in the fpix data.  On little-endians,
the data is unchanged.  This is used for serialization
of fpix; the data is serialized in little-endian byte
order because most hardware is little-endian.
(2) The operation can be either in-place or, if fpixd == NULL,
a new fpix is made.  If not in-place, caller must catch
the returned pointer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixEndianByteSwap(*args)
    
    

    try:
        leptonica.dpixRead.argtypes = [ctypes.c_char_p]
        leptonica.dpixRead.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  dpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixRead(*args)
    
    

    try:
        leptonica.dpixReadStream.argtypes = [ctypes.c_void_p]
        leptonica.dpixReadStream.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:      file stream
:returns:  dpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixReadStream(*args)
    
    

    try:
        leptonica.dpixReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.dpixReadMem.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:     of serialized dpix
:param[in]    size:     of data in bytes
:returns:  dpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixReadMem(*args)
    
    

    try:
        leptonica.dpixWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.dpixWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixWrite(*args):
        """
        ('const char', '*filename')       
('DPIX', '*dpix')       

:param[in]    filename:
:param[in]    dpix:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixWrite(*args)
    
    

    try:
        leptonica.dpixWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixWriteStream(*args):
        """
        ('FILE', '*fp')       
('DPIX', '*dpix')       

:param[in]    fp:      file stream opened for "wb"
:param[in]    dpix:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixWriteStream(*args)
    
    

    try:
        leptonica.dpixWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('DPIX', '*dpix')       

:param[out]   pdata:     data of serialized dpix
:param[out]   psize:     size of returned data
:param[in]    dpix:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a dpix in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixWriteMem(*args)
    
    

    try:
        leptonica.dpixEndianByteSwap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixEndianByteSwap.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixEndianByteSwap(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs')       

:param[in]    dpixd:     can be equal to dpixs or NULL
:param[in]    dpixs:
:returns:  dpixd always

<pre>
Notes:
(1) On big-endian hardware, this does byte-swapping on each of
the 4-byte words in the dpix data.  On little-endians,
the data is unchanged.  This is used for serialization
of dpix; the data is serialized in little-endian byte
order because most hardware is little-endian.
(2) The operation can be either in-place or, if dpixd == NULL,
a new dpix is made.  If not in-place, caller must catch
the returned pointer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixEndianByteSwap(*args)
    
    

    try:
        leptonica.fpixPrintStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixPrintStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixPrintStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixPrintStream(*args):
        """
        ('FILE', '*fp')       
('FPIX', '*fpix')       
('l_int32', 'factor')       

:param[in]    fp:       file stream
:param[in]    fpix:
:param[in]    factor:   for subsampling
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Subsampled printout of fpix for debugging.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixPrintStream(*args)
    




class numafunc2(object):
    """<pre>

--------------------------------------
This file has these Numa utilities:
- morphological operations
- arithmetic transforms
- windowed statistical operations
- histogram extraction
- histogram comparison
- extrema finding
- frequency and crossing analysis
--------------------------------------

Morphological (min/max) operations
NUMA        *numaErode()
NUMA        *numaDilate()
NUMA        *numaOpen()
NUMA        *numaClose()

Other transforms
NUMA        *numaTransform()
l_int32      numaSimpleStats()
l_int32      numaWindowedStats()
NUMA        *numaWindowedMean()
NUMA        *numaWindowedMeanSquare()
l_int32      numaWindowedVariance()
NUMA        *numaWindowedMedian()
NUMA        *numaConvertToInt()

Histogram generation and statistics
NUMA        *numaMakeHistogram()
NUMA        *numaMakeHistogramAuto()
NUMA        *numaMakeHistogramClipped()
NUMA        *numaRebinHistogram()
NUMA        *numaNormalizeHistogram()
l_int32      numaGetStatsUsingHistogram()
l_int32      numaGetHistogramStats()
l_int32      numaGetHistogramStatsOnInterval()
l_int32      numaMakeRankFromHistogram()
l_int32      numaHistogramGetRankFromVal()
l_int32      numaHistogramGetValFromRank()
l_int32      numaDiscretizeRankAndIntensity()
l_int32      numaGetRankBinValues()

Splitting a distribution
l_int32      numaSplitDistribution()

Comparing histograms
l_int32      grayHistogramsToEMD()
l_int32      numaEarthMoverDistance()
l_int32      grayInterHistogramStats()

Extrema finding
NUMA        *numaFindPeaks()
NUMA        *numaFindExtrema()
NUMA        *numaFindLocForThreshold()
l_int32     *numaCountReversals()

Threshold crossings and frequency analysis
l_int32      numaSelectCrossingThreshold()
NUMA        *numaCrossingsByThreshold()
NUMA        *numaCrossingsByPeaks()
NUMA        *numaEvalBestHaarParameters()
l_int32      numaEvalHaarSum()

Generating numbers in a range under constraints
NUMA        *genConstrainedNumaInRange()

Things to remember when using the Numa:

(1) The numa is a struct, not an array.  Always use accessors
(see numabasic.c), never the fields directly.

(2) The number array holds l_float32 values.  It can also
be used to store l_int32 values.  See numabasic.c for
details on using the accessors.  Integers larger than
about 10M will lose accuracy due on retrieval due to round-off.
For large integers, use the dna (array of l_float64) instead.

(3) Occasionally, in the comments we denote the i-th element of a
numa by na[i].  This is conceptual only -- the numa is not an array!

Some general comments on histograms:

(1) Histograms are the generic statistical representation of
the data about some attribute.  Typically they're not
normalized -- they simply give the number of occurrences
within each range of values of the attribute.  This range
of values is referred to as a 'bucket'.  For example,
the histogram could specify how many connected components
are found for each value of their width; in that case,
the bucket size is 1.

(2) In leptonica, all buckets have the same size.  Histograms
are therefore specified by a numa of occurrences, along
with two other numbers: the 'value' associated with the
occupants of the first bucket and the size (i.e., 'width')
of each bucket.  These two numbers then allow us to calculate
the value associated with the occupants of each bucket.
These numbers are fields in the numa, initialized to
a startx value of 0.0 and a binsize of 1.0.  Accessors for
these fields are functions numa*Parameters().  All histograms
must have these two numbers properly set.
</pre>




"""
    
    try:
        leptonica.numaErode.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaErode.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaErode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaErode(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       

:param[in]    nas:
:param[in]    size:   of sel; greater than 0, odd.  The origin
is implicitly in the center.
:returns:  nad eroded, or NULL on error

<pre>
Notes:
(1) The structuring element (sel) is linear, all "hits"
(2) If size == 1, this returns a copy
(3) General comment.  The morphological operations are equivalent
to those that would be performed on a 1-dimensional fpix.
However, because we have not implemented morphological
operations on fpix, we do this here.  Because it is only
1 dimensional, there is no reason to use the more
complicated van Herk/Gil-Werman algorithm, and we do it
by brute force.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaErode(*args)
    
    

    try:
        leptonica.numaDilate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaDilate.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaDilate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDilate(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       

:param[in]    nas:
:param[in]    size:   of sel; greater than 0, odd.  The origin
is implicitly in the center.
:returns:  nad dilated, or NULL on error

<pre>
Notes:
(1) The structuring element (sel) is linear, all "hits"
(2) If size == 1, this returns a copy
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaDilate(*args)
    
    

    try:
        leptonica.numaOpen.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaOpen.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaOpen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaOpen(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       

:param[in]    nas:
:param[in]    size:   of sel; greater than 0, odd.  The origin
is implicitly in the center.
:returns:  nad opened, or NULL on error

<pre>
Notes:
(1) The structuring element (sel) is linear, all "hits"
(2) If size == 1, this returns a copy
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaOpen(*args)
    
    

    try:
        leptonica.numaClose.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaClose.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaClose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaClose(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'size')       

:param[in]    nas:
:param[in]    size:   of sel; greater than 0, odd.  The origin
is implicitly in the center.
:returns:  nad  closed, or NULL on error

<pre>
Notes:
(1) The structuring element (sel) is linear, all "hits"
(2) If size == 1, this returns a copy
(3) We add a border before doing this operation, for the same
reason that we add a border to a pix before doing a safe closing.
Without the border, a small component near the border gets
clipped at the border on dilation, and can be entirely removed
by the following erosion, violating the basic extensivity
property of closing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaClose(*args)
    
    

    try:
        leptonica.numaTransform.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaTransform.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaTransform(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'shift')       
('l_float32', 'scale')       

:param[in]    nas:
:param[in]    shift:    add this to each number
:param[in]    scale:    multiply each number by this
:returns:  nad with all values shifted and scaled, or NULL on error

<pre>
Notes:
(1) Each number is shifted before scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaTransform(*args)
    
    

    try:
        leptonica.numaSimpleStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSimpleStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSimpleStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSimpleStats(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_float32', '*pmean')       
('l_float32', '*pvar')       
('l_float32', '*prvar')       

:param[in]    na:       input numa
:param[in]    first:    first element to use
:param[in]    last:     last element to use; -1 to go to the end
:param[out]   pmean:    [optional] mean value
:param[out]   pvar:     [optional] variance
:param[out]   prvar:    [optional] rms deviation from the mean
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSimpleStats(*args)
    
    

    try:
        leptonica.numaWindowedStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWindowedStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWindowedStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedStats(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'wc')       
('NUMA', '**pnam')       
('NUMA', '**pnams')       
('NUMA', '**pnav')       
('NUMA', '**pnarv')       

:param[in]    nas:     input numa
:param[in]    wc:      half width of the window
:param[out]   pnam:    [optional] mean value in window
:param[out]   pnams:   [optional] mean square value in window
:param[out]   pnav:    [optional] variance in window
:param[out]   pnarv:   [optional] rms deviation from the mean
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a high-level convenience function for calculating
any or all of these derived arrays.
(2) These statistical measures over the values in the
rectangular window are:
~ average value: [x]  (nam)
~ average squared value: [x*x] (nams)
~ variance: [(x - [x])*(x - [x])] = [x*x] - [x]*[x]  (nav)
~ square-root of variance: (narv)
where the brackets [ .. ] indicate that the average value is
to be taken over the window.
(3) Note that the variance is just the mean square difference from
the mean value; and the square root of the variance is the
root mean square difference from the mean, sometimes also
called the 'standard deviation'.
(4) Internally, use mirrored borders to handle values near the
end of each array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedStats(*args)
    
    

    try:
        leptonica.numaWindowedMean.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaWindowedMean.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaWindowedMean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedMean(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'wc')       

:param[in]    nas:
:param[in]    wc:    half width of the convolution window
:returns:  nad after low-pass filtering, or NULL on error

<pre>
Notes:
(1) This is a convolution.  The window has width = 2 * %wc + 1.
(2) We add a mirrored border of size %wc to each end of the array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedMean(*args)
    
    

    try:
        leptonica.numaWindowedMeanSquare.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaWindowedMeanSquare.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaWindowedMeanSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedMeanSquare(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'wc')       

:param[in]    nas:
:param[in]    wc:    half width of the window
:returns:  nad containing windowed mean square values, or NULL on error

<pre>
Notes:
(1) The window has width = 2 * %wc + 1.
(2) We add a mirrored border of size %wc to each end of the array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedMeanSquare(*args)
    
    

    try:
        leptonica.numaWindowedVariance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWindowedVariance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWindowedVariance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedVariance(*args):
        """
        ('NUMA', '*nam')       
('NUMA', '*nams')       
('NUMA', '**pnav')       
('NUMA', '**pnarv')       

:param[in]    nam:    windowed mean values
:param[in]    nams:   windowed mean square values
:param[out]   pnav:   [optional] numa of variance -- the ms deviation
from the mean
:param[out]   pnarv:  [optional] numa of rms deviation from the mean
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The numas of windowed mean and mean square are precomputed,
using numaWindowedMean() and numaWindowedMeanSquare().
(2) Either or both of the variance and square-root of variance
are returned, where the variance is the average over the
window of the mean square difference of the pixel value
from the mean:
[(x - [x])*(x - [x])] = [x*x] - [x]*[x]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedVariance(*args)
    
    

    try:
        leptonica.numaWindowedMedian.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaWindowedMedian.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaWindowedMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWindowedMedian(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'halfwin')       

:param[in]    nas:
:param[in]    halfwin:   half width of window over which the median is found
:returns:  nad after windowed median filtering, or NULL on error

<pre>
Notes:
(1) The requested window has width = 2 * %halfwin + 1.
(2) If the input nas has less then 3 elements, return a copy.
(3) If the filter is too small (%halfwin <= 0), return a copy.
(4) If the filter is too large, it is reduced in size.
(5) We add a mirrored border of size %halfwin to each end of
the array to simplify the calculation by avoiding end-effects.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWindowedMedian(*args)
    
    

    try:
        leptonica.numaConvertToInt.argtypes = [ctypes.c_void_p]
        leptonica.numaConvertToInt.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaConvertToInt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToInt(*args):
        """
        ('NUMA', '*nas')       

:param[in]    nas:   source numa
:returns:  na with all values rounded to nearest integer, or
NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToInt(*args)
    
    

    try:
        leptonica.numaMakeHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaMakeHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeHistogram(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxbins')       
('l_int32', '*pbinsize')       
('l_int32', '*pbinstart')       

:param[in]    na:
:param[in]    maxbins:    max number of histogram bins
:param[out]   pbinsize:   size of histogram bins
:param[out]   pbinstart:  [optional] start val of minimum bin;
input NULL to force start at 0
:returns:  na consisiting of histogram of integerized values,
or NULL on error.

<pre>
Notes:
(1) This simple interface is designed for integer data.
The bins are of integer width and start on integer boundaries,
so the results on float data will not have high precision.
(2) Specify the max number of input bins.   Then %binsize,
the size of bins necessary to accommodate the input data,
is returned.  It is one of the sequence:
{1, 2, 5, 10, 20, 50, ...}.
(3) If &binstart is given, all values are accommodated,
and the min value of the starting bin is returned.
Otherwise, all negative values are discarded and
the histogram bins start at 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeHistogram(*args)
    
    

    try:
        leptonica.numaMakeHistogramAuto.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaMakeHistogramAuto.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeHistogramAuto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeHistogramAuto(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxbins')       

:param[in]    na:       numa of floats; these may be integers
:param[in]    maxbins:  max number of histogram bins; >= 1
:returns:  na consisiting of histogram of quantized float values,
or NULL on error.

<pre>
Notes:
(1) This simple interface is designed for accurate binning
of both integer and float data.
(2) If the array data is integers, and the range of integers
is smaller than %maxbins, they are binned as they fall,
with binsize = 1.
(3) If the range of data, (maxval - minval), is larger than
%maxbins, or if the data is floats, they are binned into
exactly %maxbins bins.
(4) Unlike numaMakeHistogram(), these bins in general have
non-integer location and width, even for integer data.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeHistogramAuto(*args)
    
    

    try:
        leptonica.numaMakeHistogramClipped.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaMakeHistogramClipped.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeHistogramClipped not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeHistogramClipped(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'binsize')       
('l_float32', 'maxsize')       

:param[in]    na:
:param[in]    binsize:    typically 1.0
:param[in]    maxsize:    of histogram ordinate
:returns:  na histogram of bins of size %binsize, starting with
the na[0] (x = 0.0 and going up to a maximum of
x = %maxsize, by increments of %binsize), or NULL on error

<pre>
Notes:
(1) This simple function generates a histogram of values
from na, discarding all values < 0.0 or greater than
min(%maxsize, maxval), where maxval is the maximum value in na.
The histogram data is put in bins of size delx = %binsize,
starting at x = 0.0.  We use as many bins as are
needed to hold the data.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeHistogramClipped(*args)
    
    

    try:
        leptonica.numaRebinHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaRebinHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaRebinHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRebinHistogram(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'newsize')       

:param[in]    nas:      input histogram
:param[in]    newsize:  number of old bins contained in each new bin
:returns:  nad more coarsely re-binned histogram, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRebinHistogram(*args)
    
    

    try:
        leptonica.numaNormalizeHistogram.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.numaNormalizeHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaNormalizeHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaNormalizeHistogram(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'tsum')       

:param[in]    nas:   input histogram
:param[in]    tsum:  target sum of all numbers in dest histogram; e.g., use
%tsum= 1.0 if this represents a probability distribution
:returns:  nad normalized histogram, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaNormalizeHistogram(*args)
    
    

    try:
        leptonica.numaGetStatsUsingHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetStatsUsingHistogram.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetStatsUsingHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetStatsUsingHistogram(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'maxbins')       
('l_float32', '*pmin')       
('l_float32', '*pmax')       
('l_float32', '*pmean')       
('l_float32', '*pvariance')       
('l_float32', '*pmedian')       
('l_float32', 'rank')       
('l_float32', '*prval')       
('NUMA', '**phisto')       

:param[in]    na:        an arbitrary set of numbers; not ordered and not
a histogram
:param[in]    maxbins:   the maximum number of bins to be allowed in
the histogram; use an integer larger than the
largest number in %na for consecutive integer bins
:param[out]   pmin:      [optional] min value of set
:param[out]   pmax:      [optional] max value of set
:param[out]   pmean:     [optional] mean value of set
:param[out]   pvariance: [optional] variance
:param[out]   pmedian:   [optional] median value of set
:param[in]    rank:      in [0.0 ... 1.0]; median has a rank 0.5;
ignored if &rval == NULL
:param[out]   prval:     [optional] value in na corresponding to %rank
:param[out]   phisto:    [optional] Numa histogram; use NULL to prevent
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a simple interface for gathering statistics
from a numa, where a histogram is used 'under the covers'
to avoid sorting if a rank value is requested.  In that case,
by using a histogram we are trading speed for accuracy, because
the values in %na are quantized to the center of a set of bins.
(2) If the median, other rank value, or histogram are not requested,
the calculation is all performed on the input Numa.
(3) The variance is the average of the square of the
difference from the mean.  The median is the value in na
with rank 0.5.
(4) There are two situations where this gives rank results with
accuracy comparable to computing stastics directly on the input
data, without binning into a histogram:
(a) the data is integers and the range of data is less than
%maxbins, and
(b) the data is floats and the range is small compared to
%maxbins, so that the binsize is much less than 1.
(5) If a histogram is used and the numbers in the Numa extend
over a large range, you can limit the required storage by
specifying the maximum number of bins in the histogram.
Use %maxbins == 0 to force the bin size to be 1.
(6) This optionally returns the median and one arbitrary rank value.
If you need several rank values, return the histogram and use
numaHistogramGetValFromRank(nah, rank, &rval)
multiple times.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetStatsUsingHistogram(*args)
    
    

    try:
        leptonica.numaGetHistogramStats.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetHistogramStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetHistogramStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetHistogramStats(*args):
        """
        ('NUMA', '*nahisto')       
('l_float32', 'startx')       
('l_float32', 'deltax')       
('l_float32', '*pxmean')       
('l_float32', '*pxmedian')       
('l_float32', '*pxmode')       
('l_float32', '*pxvariance')       

:param[in]    nahisto:     histogram: y(x(i)), i = 0 ... nbins - 1
:param[in]    startx:      x value of first bin: x(0)
:param[in]    deltax:      x increment between bins; the bin size; x(1) - x(0)
:param[out]   pxmean:      [optional] mean value of histogram
:param[out]   pxmedian:    [optional] median value of histogram
:param[out]   pxmode:      [optional] mode value of histogram:
xmode = x(imode), where y(xmode) >= y(x(i)) for
all i != imode
:param[out]   pxvariance:  [optional] variance of x
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If the histogram represents the relation y(x), the
computed values that are returned are the x values.
These are NOT the bucket indices i; they are related to the
bucket indices by
x(i) = startx + i * deltax
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetHistogramStats(*args)
    
    

    try:
        leptonica.numaGetHistogramStatsOnInterval.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetHistogramStatsOnInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetHistogramStatsOnInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetHistogramStatsOnInterval(*args):
        """
        ('NUMA', '*nahisto')       
('l_float32', 'startx')       
('l_float32', 'deltax')       
('l_int32', 'ifirst')       
('l_int32', 'ilast')       
('l_float32', '*pxmean')       
('l_float32', '*pxmedian')       
('l_float32', '*pxmode')       
('l_float32', '*pxvariance')       

:param[in]    nahisto:    histogram: y(x(i)), i = 0 ... nbins - 1
:param[in]    startx:     x value of first bin: x(0)
:param[in]    deltax:     x increment between bins; the bin size; x(1) - x(0)
:param[in]    ifirst:     first bin to use for collecting stats
:param[in]    ilast:      last bin for collecting stats; -1 to go to the end
:param[out]   pxmean:     [optional] mean value of histogram
:param[out]   pxmedian:   [optional] median value of histogram
:param[out]   pxmode:     [optional] mode value of histogram:
xmode = x(imode), where y(xmode) >= y(x(i)) for
all i != imode
:param[out]   pxvariance: [optional] variance of x
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If the histogram represents the relation y(x), the
computed values that are returned are the x values.
These are NOT the bucket indices i; they are related to the
bucket indices by
x(i) = startx + i * deltax
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetHistogramStatsOnInterval(*args)
    
    

    try:
        leptonica.numaMakeRankFromHistogram.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaMakeRankFromHistogram.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaMakeRankFromHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaMakeRankFromHistogram(*args):
        """
        ('l_float32', 'startx')       
('l_float32', 'deltax')       
('NUMA', '*nasy')       
('l_int32', 'npts')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       

:param[in]    startx:   xval corresponding to first element in nay
:param[in]    deltax:   x increment between array elements in nay
:param[in]    nasy:     input histogram, assumed equally spaced
:param[in]    npts:     number of points to evaluate rank function
:param[out]   pnax:     [optional] array of x values in range
:param[out]   pnay:     rank array of specified npts
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaMakeRankFromHistogram(*args)
    
    

    try:
        leptonica.numaHistogramGetRankFromVal.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaHistogramGetRankFromVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaHistogramGetRankFromVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHistogramGetRankFromVal(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'rval')       
('l_float32', '*prank')       

:param[in]    na:     histogram
:param[in]    rval:   value of input sample for which we want the rank
:param[out]   prank:  fraction of total samples below rval
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If we think of the histogram as a function y(x), normalized
to 1, for a given input value of x, this computes the
rank of x, which is the integral of y(x) from the start
value of x to the input value.
(2) This function only makes sense when applied to a Numa that
is a histogram.  The values in the histogram can be ints and
floats, and are computed as floats.  The rank is returned
as a float between 0.0 and 1.0.
(3) The numa parameters startx and binsize are used to
compute x from the Numa index i.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaHistogramGetRankFromVal(*args)
    
    

    try:
        leptonica.numaHistogramGetValFromRank.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaHistogramGetValFromRank.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaHistogramGetValFromRank not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaHistogramGetValFromRank(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'rank')       
('l_float32', '*prval')       

:param[in]    na:     histogram
:param[in]    rank:   fraction of total samples
:param[out]   prval:  approx. to the bin value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If we think of the histogram as a function y(x), this returns
the value x such that the integral of y(x) from the start
value to x gives the fraction 'rank' of the integral
of y(x) over all bins.
(2) This function only makes sense when applied to a Numa that
is a histogram.  The values in the histogram can be ints and
floats, and are computed as floats.  The val is returned
as a float, even though the buckets are of integer width.
(3) The numa parameters startx and binsize are used to
compute x from the Numa index i.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaHistogramGetValFromRank(*args)
    
    

    try:
        leptonica.numaDiscretizeRankAndIntensity.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaDiscretizeRankAndIntensity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaDiscretizeRankAndIntensity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDiscretizeRankAndIntensity(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'nbins')       
('NUMA', '**pnarbin')       
('NUMA', '**pnam')       
('NUMA', '**pnar')       
('NUMA', '**pnabb')       

:param[in]    na:       normalized histo of probability density vs intensity
:param[in]    nbins:    number of bins at which the rank is divided
:param[out]   pnarbin:  [optional] rank bin value vs intensity
:param[out]   pnam:     [optional] median intensity in a bin vs rank bin
value, with %nbins of discretized rank values
:param[out]   pnar:     [optional] rank vs intensity; this is
a cumulative norm histogram
:param[out]   pnabb:    [optional] intensity at the right bin boundary
vs rank bin
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) We are inverting the rank(intensity) function to get
the intensity(rank) function at %nbins equally spaced
values of rank between 0.0 and 1.0.  We save integer values
for the intensity.
(2) We are using the word "intensity" to describe the type of
array values, but any array of non-negative numbers will work.
(3) The output arrays give the following mappings, where the
input is a normalized histogram of array values:
array values     -->  rank bin number  (narbin)
rank bin number  -->  median array value in bin (nam)
array values     -->  cumulative norm = rank  (nar)
rank bin number  -->  array value at right bin edge (nabb)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaDiscretizeRankAndIntensity(*args)
    
    

    try:
        leptonica.numaGetRankBinValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetRankBinValues.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetRankBinValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetRankBinValues(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'nbins')       
('NUMA', '**pnarbin')       
('NUMA', '**pnam')       

:param[in]    na:       an array of values
:param[in]    nbins:    number of bins at which the rank is divided
:param[out]   pnarbin:  [optional] rank bin value vs array value
:param[out]   pnam:     [optional] median intensity in a bin vs rank bin
value, with %nbins of discretized rank values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Simple interface for getting a binned rank representation
of an input array of values.  This returns two mappings:
array value     -->  rank bin number  (narbin)
rank bin number -->  median array value in each rank bin (nam)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetRankBinValues(*args)
    
    

    try:
        leptonica.numaSplitDistribution.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaSplitDistribution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSplitDistribution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSplitDistribution(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'scorefract')       
('l_int32', '*psplitindex')       
('l_float32', '*pave1')       
('l_float32', '*pave2')       
('l_float32', '*pnum1')       
('l_float32', '*pnum2')       
('NUMA', '**pnascore')       

:param[in]    na:           histogram
:param[in]    scorefract:   fraction of the max score, used to determine
range over which the histogram min is searched
:param[out]   psplitindex:  [optional] index for splitting
:param[out]   pave1:        [optional] average of lower distribution
:param[out]   pave2:        [optional] average of upper distribution
:param[out]   pnum1:        [optional] population of lower distribution
:param[out]   pnum2:        [optional] population of upper distribution
:param[out]   pnascore:     [optional] for debugging; otherwise use NULL
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function is intended to be used on a distribution of
values that represent two sets, such as a histogram of
pixel values for an image with a fg and bg, and the goal
is to determine the averages of the two sets and the
best splitting point.
(2) The Otsu method finds a split point that divides the distribution
into two parts by maximizing a score function that is the
product of two terms:
(a) the square of the difference of centroids, (ave1 - ave2)^2
(b) fract1 * (1 - fract1)
where fract1 is the fraction in the lower distribution.
(3) This works well for images where the fg and bg are
each relatively homogeneous and well-separated in color.
However, if the actual fg and bg sets are very different
in size, and the bg is highly varied, as can occur in some
scanned document images, this will bias the split point
into the larger "bump" (i.e., toward the point where the
(b) term reaches its maximum of 0.25 at fract1 = 0.5.
To avoid this, we define a range of values near the
maximum of the score function, and choose the value within
this range such that the histogram itself has a minimum value.
The range is determined by scorefract: we include all abscissa
values to the left and right of the value that maximizes the
score, such that the score stays above (1 - scorefract) * maxscore.
The intuition behind this modification is to try to find
a split point that both has a high variance score and is
at or near a minimum in the histogram, so that the histogram
slope is small at the split point.
(4) We normalize the score so that if the two distributions
were of equal size and at opposite ends of the numa, the
score would be 1.0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSplitDistribution(*args)
    
    

    try:
        leptonica.grayHistogramsToEMD.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.grayHistogramsToEMD.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function grayHistogramsToEMD not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def grayHistogramsToEMD(*args):
        """
        ('NUMAA', '*naa1')       
('NUMAA', '*naa2')       
('NUMA', '**pnad')       

:param[in]    naa1,: naa2    two numaa, each with one or more 256-element
histograms
:param[out]   pnad:          nad of EM distances for each histogram
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The two numaas must be the same size and have corresponding
256-element histograms.  Pairs do not need to be normalized
to the same sum.
(2) This is typically used on two sets of histograms from
corresponding tiles of two images.  The similarity of two
images can be found with the scoring function used in
pixCompareGrayByHisto():
score S = 1.0 - k * D, where
k is a constant, say in the range 5-10
D = EMD
for each tile; for multiple tiles, take the Min(S) over
the set of tiles to be the final score.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.grayHistogramsToEMD(*args)
    
    

    try:
        leptonica.numaEarthMoverDistance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaEarthMoverDistance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaEarthMoverDistance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEarthMoverDistance(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_float32', '*pdist')       

:param[in]    na1,: na2    two numas of the same size, typically histograms
:param[out]   pdist:       earthmover distance
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The two numas must have the same size.  They do not need to be
normalized to the same sum before applying the function.
(2) For a 1D discrete function, the implementation of the EMD
is trivial.  Just keep filling or emptying buckets in one numa
to match the amount in the other, moving sequentially along
both arrays.
(3) We divide the sum of the absolute value of everything moved
(by 1 unit at a time) by the sum of the numa (amount of "earth")
to get the average distance that the "earth" was moved.
This is the value returned here.
(4) The caller can do a further normalization, by the number of
buckets (minus 1), to get the EM distance as a fraction of
the maximum possible distance, which is n-1.  This fraction
is 1.0 for the situation where all the 'earth' in the first
array is at one end, and all in the second array is at the
other end.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaEarthMoverDistance(*args)
    
    

    try:
        leptonica.grayInterHistogramStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.grayInterHistogramStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function grayInterHistogramStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def grayInterHistogramStats(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'wc')       
('NUMA', '**pnam')       
('NUMA', '**pnams')       
('NUMA', '**pnav')       
('NUMA', '**pnarv')       

:param[in]    naa:      numaa with two or more 256-element histograms
:param[in]    wc:       half-width of the smoothing window
:param[out]   pnam:     [optional] mean values
:param[out]   pnams:    [optional] mean square values
:param[out]   pnav:     [optional] variances
:param[out]   pnarv:    [optional] rms deviations from the mean
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The %naa has two or more 256-element numa histograms, which
are to be compared value-wise at each of the 256 gray levels.
The result are stats (mean, mean square, variance, root variance)
aggregated across the set of histograms, and each is output
as a 256 entry numa.  Think of these histograms as a matrix,
where each histogram is one row of the array.  The stats are
then aggregated column-wise, between the histograms.
(2) These stats are:
~ average value: <v>  (nam)
~ average squared value: <v*v> (nams)
~ variance: <(v - <v>)*(v - <v>)> = <v*v> - <v>*<v>  (nav)
~ square-root of variance: (narv)
where the brackets < .. > indicate that the average value is
to be taken over each column of the array.
(3) The input histograms are optionally smoothed before these
statistical operations.
(4) The input histograms are normalized to a sum of 10000.  By
doing this, the resulting numbers are independent of the
number of samples used in building the individual histograms.
(5) A typical application is on a set of histograms from tiles
of an image, to distinguish between text/tables and photo
regions.  If the tiles are much larger than the text line
spacing, text/table regions typically have smaller variance
across tiles than photo regions.  For this application, it
may be useful to ignore values near white, which are large for
text and would magnify the variance due to variations in
illumination.  However, because the variance of a drawing or
a light photo can be similar to that of grayscale text, this
function is only a discriminator between darker photos/drawings
and light photos/text/line-graphics.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.grayInterHistogramStats(*args)
    
    

    try:
        leptonica.numaFindPeaks.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.numaFindPeaks.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaFindPeaks not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFindPeaks(*args):
        """
        ('NUMA', '*nas')       
('l_int32', 'nmax')       
('l_float32', 'fract1')       
('l_float32', 'fract2')       

:param[in]    nas:      source numa
:param[in]    nmax:     max number of peaks to be found
:param[in]    fract1:   min fraction of peak value
:param[in]    fract2:   min slope
:returns:  peak na, or NULL on error.

<pre>
Notes:
(1) The returned na consists of sets of four numbers representing
the peak, in the following order:
left edge; peak center; right edge; normalized peak area
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaFindPeaks(*args)
    
    

    try:
        leptonica.numaFindExtrema.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaFindExtrema.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaFindExtrema not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFindExtrema(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'delta')       
('NUMA', '**pnav')       

:param[in]    nas:     input values
:param[in]    delta:   relative amount to resolve peaks and valleys
:param[out]   pnav:    [optional] values of extrema
:returns:  nad (locations of extrema, or NULL on error

<pre>
Notes:
(1) This returns a sequence of extrema (peaks and valleys).
(2) The algorithm is analogous to that for determining
mountain peaks.  Suppose we have a local peak, with
bumps on the side.  Under what conditions can we consider
those 'bumps' to be actual peaks?  The answer: if the
bump is separated from the peak by a saddle that is at
least 500 feet below the bump.
(3) Operationally, suppose we are trying to identify a peak.
We have a previous valley, and also the largest value that
we have seen since that valley.  We can identify this as
a peak if we find a value that is delta BELOW it.  When
we find such a value, label the peak, use the current
value to label the starting point for the search for
a valley, and do the same operation in reverse.  Namely,
keep track of the lowest point seen, and look for a value
that is delta ABOVE it.  Once found, the lowest point is
labeled the valley, and continue, looking for the next peak.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaFindExtrema(*args)
    
    

    try:
        leptonica.numaFindLocForThreshold.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaFindLocForThreshold.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaFindLocForThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaFindLocForThreshold(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'skip')       
('l_int32', '*pthresh')       
('l_float32', '*pfract')       

:param[in]    nas:      input histogram
:param[in]    skip:     distance to skip to check for false min; 0 for default
:param[out]   pthresh:  threshold value
:param[out]   pfract:   [optional] fraction below or at threshold
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This finds a good place to set a threshold for a histogram
of values that has two peaks.  The peaks can differ greatly
in area underneath them.  The number of buckets in the
histogram is expected to be 256 (e.g, from an 8 bpp gray image).
(2) The input histogram should have been smoothed with a window
to avoid false peak and valley detection due to noise.  For
example, see pixThresholdByHisto().
(3) A skip value can be input to determine the look-ahead distance
to ignore a false peak on the descent from the first peak.
Input 0 to use the default value (it assumes a histo size of 256).
(4) Optionally, the fractional area under the first peak can
be returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaFindLocForThreshold(*args)
    
    

    try:
        leptonica.numaCountReversals.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaCountReversals.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaCountReversals not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCountReversals(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'minreversal')       
('l_int32', '*pnr')       
('l_float32', '*prd')       

:param[in]    nas:          input values
:param[in]    minreversal:  relative amount to resolve peaks and valleys
:param[out]   pnr:          [optional] number of reversals
:param[out]   prd:          [optional] reversal density: reversals/length
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The input numa is can be generated from pixExtractAlongLine().
If so, the x parameters can be used to find the reversal
frequency along a line.
(2) If the input numa was generated from a 1 bpp pix, the
values will be 0 and 1.  Use %minreversal == 1 to get
the number of pixel flips.  If the only values are 0 and 1,
but %minreversal > 1, set the reversal count to 0 and
issue a warning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaCountReversals(*args)
    
    

    try:
        leptonica.numaSelectCrossingThreshold.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaSelectCrossingThreshold.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSelectCrossingThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSelectCrossingThreshold(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'estthresh')       
('l_float32', '*pbestthresh')       

:param[in]    nax:          [optional] numa of abscissa values; can be NULL
:param[in]    nay:          signal
:param[in]    estthresh:    estimated pixel threshold for crossing:
e.g., for images, white <--> black; typ. ~120
:param[out]   pbestthresh:  robust estimate of threshold to use
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) When a valid threshold is used, the number of crossings is
a maximum, because none are missed.  If no threshold intersects
all the crossings, the crossings must be determined with
numaCrossingsByPeaks().
(2) %estthresh is an input estimate of the threshold that should
be used.  We compute the crossings with 41 thresholds
(20 below and 20 above).  There is a range in which the
number of crossings is a maximum.  Return a threshold
in the center of this stable plateau of crossings.
This can then be used with numaCrossingsByThreshold()
to get a good estimate of crossing locations.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSelectCrossingThreshold(*args)
    
    

    try:
        leptonica.numaCrossingsByThreshold.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.numaCrossingsByThreshold.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCrossingsByThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCrossingsByThreshold(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'thresh')       

:param[in]    nax:     [optional] numa of abscissa values; can be NULL
:param[in]    nay:     numa of ordinate values, corresponding to nax
:param[in]    thresh:  threshold value for nay
:returns:  nad abscissa pts at threshold, or NULL on error

<pre>
Notes:
(1) If nax == NULL, we use startx and delx from nay to compute
the crossing values in nad.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaCrossingsByThreshold(*args)
    
    

    try:
        leptonica.numaCrossingsByPeaks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.numaCrossingsByPeaks.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCrossingsByPeaks not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCrossingsByPeaks(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_float32', 'delta')       

:param[in]    nax:     [optional] numa of abscissa values
:param[in]    nay:     numa of ordinate values, corresponding to nax
:param[in]    delta:   parameter used to identify when a new peak can be found
:returns:  nad abscissa pts at threshold, or NULL on error

<pre>
Notes:
(1) If nax == NULL, we use startx and delx from nay to compute
the crossing values in nad.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaCrossingsByPeaks(*args)
    
    

    try:
        leptonica.numaEvalBestHaarParameters.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaEvalBestHaarParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaEvalBestHaarParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEvalBestHaarParameters(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'relweight')       
('l_int32', 'nwidth')       
('l_int32', 'nshift')       
('l_float32', 'minwidth')       
('l_float32', 'maxwidth')       
('l_float32', '*pbestwidth')       
('l_float32', '*pbestshift')       
('l_float32', '*pbestscore')       

:param[in]    nas:         numa of non-negative signal values
:param[in]    relweight:   relative weight of (-1 comb) / (+1 comb)
contributions to the 'convolution'.  In effect,
the convolution kernel is a comb consisting of
alternating +1 and -weight.
:param[in]    nwidth:      number of widths to consider
:param[in]    nshift:      number of shifts to consider for each width
:param[in]    minwidth:    smallest width to consider
:param[in]    maxwidth:    largest width to consider
:param[out]   pbestwidth:  width giving largest score
:param[out]   pbestshift:  shift giving largest score
:param[out]   pbestscore:  [optional] convolution with "Haar"-like comb
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a linear sweep of widths, evaluating at %nshift
shifts for each width, computing the score from a convolution
with a long comb, and finding the (width, shift) pair that
gives the maximum score.  The best width is the "half-wavelength"
of the signal.
(2) The convolving function is a comb of alternating values
+1 and -1 * relweight, separated by the width and phased by
the shift.  This is similar to a Haar transform, except
there the convolution is performed with a square wave.
(3) The function is useful for finding the line spacing
and strength of line signal from pixel sum projections.
(4) The score is normalized to the size of nas divided by
the number of half-widths.  For image applications, the input is
typically an array of pixel projections, so one should
normalize by dividing the score by the image width in the
pixel projection direction.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaEvalBestHaarParameters(*args)
    
    

    try:
        leptonica.numaEvalHaarSum.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.numaEvalHaarSum.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaEvalHaarSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEvalHaarSum(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'width')       
('l_float32', 'shift')       
('l_float32', 'relweight')       
('l_float32', '*pscore')       

:param[in]    nas:         numa of non-negative signal values
:param[in]    width:       distance between +1 and -1 in convolution comb
:param[in]    shift:       phase of the comb: location of first +1
:param[in]    relweight:   relative weight of (-1 comb) / (+1 comb)
contributions to the 'convolution'.  In effect,
the convolution kernel is a comb consisting of
alternating +1 and -weight.
:param[out]   pscore:      convolution with "Haar"-like comb
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a convolution with a comb of alternating values
+1 and -relweight, separated by the width and phased by the shift.
This is similar to a Haar transform, except that for Haar,
(1) the convolution kernel is symmetric about 0, so the
relweight is 1.0, and
(2) the convolution is performed with a square wave.
(2) The score is normalized to the size of nas divided by
twice the "width".  For image applications, the input is
typically an array of pixel projections, so one should
normalize by dividing the score by the image width in the
pixel projection direction.
(3) To get a Haar-like result, use relweight = 1.0.  For detecting
signals where you expect every other sample to be close to
zero, as with barcodes or filtered text lines, you can
use relweight > 1.0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaEvalHaarSum(*args)
    
    

    try:
        leptonica.genConstrainedNumaInRange.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.genConstrainedNumaInRange.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function genConstrainedNumaInRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def genConstrainedNumaInRange(*args):
        """
        ('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'nmax')       
('l_int32', 'use_pairs')       

:param[in]    first:     first number to choose; >= 0
:param[in]    last:      biggest possible number to reach; >= first
:param[in]    nmax:      maximum number of numbers to select; > 0
:param[in]    use_pairs: 1 = select pairs of adjacent numbers;
0 = select individual numbers
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Selection is made uniformly in the range.  This can be used
to select pages distributed as uniformly as possible
through a book, where you are constrained to:
~ choose between [first, ... biggest],
~ choose no more than nmax numbers, and
and you have the option of requiring pairs of adjacent numbers.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.genConstrainedNumaInRange(*args)
    




class psio2(object):
    """<pre>

|=============================================================|
|                         Important note                      |
|=============================================================|
| Some of these functions require I/O libraries such as       |
| libtiff, libjpeg, and libz.  If you do not have these       |
| libraries, some calls will fail.                            |
|                                                             |
| You can manually deactivate all PostScript writing by       |
| setting this in environ.h:                                  |
| \code                                                       |
|     #define  USE_PSIO     0                                 |
| \endcode                                                    |
| in environ.h.  This will link psio2stub.c                   |
|=============================================================|

These are lower-level functions that implement a PostScript
"device driver" for wrapping images in PostScript.  The images
can be rendered by a PostScript interpreter for viewing,
using evince or gv.  They can also be rasterized for printing,
using gs or an embedded interpreter in a PostScript printer.
And they can be converted to a pdf using gs (ps2pdf).

For uncompressed images
l_int32              pixWritePSEmbed()
l_int32              pixWriteStreamPS()
char                *pixWriteStringPS()
char                *generateUncompressedPS()
static void          getScaledParametersPS()
static l_int32       convertByteToHexAscii()

For jpeg compressed images (use dct compression)
l_int32              convertJpegToPSEmbed()
l_int32              convertJpegToPS()
static l_int32       convertJpegToPSString()
static char         *generateJpegPS()

For g4 fax compressed images (use ccitt g4 compression)
l_int32              convertG4ToPSEmbed()
l_int32              convertG4ToPS()
static l_int32       convertG4ToPSString()
static char         *generateG4PS()

For multipage tiff images
l_int32              convertTiffMultipageToPS()

For flate (gzip) compressed images (e.g., png)
l_int32              convertFlateToPSEmbed()
l_int32              convertFlateToPS()
static l_int32       convertFlateToPSString()
static char         *generateFlatePS()

Write to memory
l_int32              pixWriteMemPS()

Converting resolution
l_int32              getResLetterPage()
static l_int32       getResA4Page()

Setting flag for writing bounding box hint
void                 l_psWriteBoundingBox()

See psio1.c for higher-level functions and their usage.
</pre>




"""
    
    try:
        leptonica.pixWritePSEmbed.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.pixWritePSEmbed.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWritePSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWritePSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       

:param[in]    filein:    input file, all depths, colormap OK
:param[in]    fileout:   output ps file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a simple wrapper function that generates an
uncompressed PS file, with a bounding box.
(2) The bounding box is required when a program such as TeX
(through epsf) places and rescales the image.
(3) The bounding box is sized for fitting the image to an
8.5 x 11.0 inch page.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWritePSEmbed(*args)
    
    

    try:
        leptonica.pixWriteStreamPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixWriteStreamPS.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPS(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'res')       
('l_float32', 'scale')       

:param[in]    fp:      file stream
:param[in]    pix:
:param[in]    box:     [optional]
:param[in]    res:     can use 0 for default of 300 ppi
:param[in]    scale:   to prevent scaling, use either 1.0 or 0.0
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This writes image in PS format, optionally scaled,
adjusted for the printer resolution, and with
a bounding box.
(2) For details on use of parameters, see pixWriteStringPS().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPS(*args)
    
    

    try:
        leptonica.pixWriteStringPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixWriteStringPS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStringPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStringPS(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'res')       
('l_float32', 'scale')       

:param[in]    pixs:   all depths, colormap OK
:param[in]    box:    bounding box; can be NULL
:param[in]    res:    resolution, in printer ppi.  Use 0 for default 300 ppi.
:param[in]    scale:  scale factor.  If no scaling is desired, use
either 1.0 or 0.0.   Scaling just resets the resolution
parameter; the actual scaling is done in the
interpreter at rendering time.  This is important:
it allows you to scale the image up without
increasing the file size.
:returns:  ps string if OK, or NULL on error

<pre>
a) If %box == NULL, image is placed, optionally scaled,
in a standard b.b. at the center of the page.
This is to be used when another program like
TeX through epsf places the image.
b) If %box != NULL, image is placed without a
b.b. at the specified page location and with
optional scaling.  This is to be used when
you want to specify exactly where and optionally
how big you want the image to be.
Note that all coordinates are in PS convention,
with 0,0 at LL corner of the page:
x,y    location of LL corner of image, in mils.
w,h    scaled size, in mils.  Use 0 to
scale with "scale" and "res" input.

%scale: If no scaling is desired, use either 1.0 or 0.0.
Scaling just resets the resolution parameter; the actual
scaling is done in the interpreter at rendering time.
This is important: * it allows you to scale the image up
without increasing the file size.

Notes:
(1) OK, this seems a bit complicated, because there are various
ways to scale and not to scale.  Here's a summary:
(2) If you don't want any scaling at all:
if you are using a box:
set w = 0, h = 0, and use scale = 1.0; it will print
each pixel unscaled at printer resolution
if you are not using a box:
set scale = 1.0; it will print at printer resolution
(3) If you want the image to be a certain size in inches:
you must use a box and set the box (w,h) in mils
(4) If you want the image to be scaled by a scale factor != 1.0:
if you are using a box:
set w = 0, h = 0, and use the desired scale factor;
the higher the printer resolution, the smaller the
image will actually appear.
if you are not using a box:
set the desired scale factor; the higher the printer
resolution, the smaller the image will actually appear.
(5) Another complication is the proliferation of distance units:
The interface distances are in milli-inches.
Three different units are used internally:
~ pixels  (units of 1/res inch)
~ printer pts (units of 1/72 inch)
~ inches
Here is a quiz on volume units from a reviewer:
How many UK milli-cups in a US kilo-teaspoon?
(Hint: 1.0 US cup = 0.75 UK cup + 0.2 US gill;
1.0 US gill = 24.0 US teaspoons)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStringPS(*args)
    
    

    try:
        leptonica.generateUncompressedPS.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.generateUncompressedPS.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function generateUncompressedPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateUncompressedPS(*args):
        """
        ('char', '*hexdata')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'd')       
('l_int32', 'psbpl')       
('l_int32', 'bps')       
('l_float32', 'xpt')       
('l_float32', 'ypt')       
('l_float32', 'wpt')       
('l_float32', 'hpt')       
('l_int32', 'boxflag')       

:param[in]    hexdata:
:param[in]    w,: h       raster image size in pixels
:param[in]    d:          image depth in bpp; rgb is 32
:param[in]    psbpl:      raster bytes/line, when packed to the byte boundary
:param[in]    bps:        bits/sample: either 1 or 8
:param[in]    xpt,: ypt   location of LL corner of image, in pts, relative
to the PostScript origin (0,0) at the LL corner
of the page
:param[in]    wpt,: hpt   rendered image size in pts
:param[in]    boxflag:    1 to print out bounding box hint; 0 to skip
:returns:  PS string, or NULL on error

<pre>
Notes:
(1) Low-level function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generateUncompressedPS(*args)
    
    

    try:
        leptonica.convertJpegToPSEmbed.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertJpegToPSEmbed.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertJpegToPSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertJpegToPSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       

:param[in]    filein:    input jpeg file
:param[in]    fileout:   output ps file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function takes a jpeg file as input and generates a DCT
compressed, ascii85 encoded PS file, with a bounding box.
(2) The bounding box is required when a program such as TeX
(through epsf) places and rescales the image.
(3) The bounding box is sized for fitting the image to an
8.5 x 11.0 inch page.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertJpegToPSEmbed(*args)
    
    

    try:
        leptonica.convertJpegToPS.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertJpegToPS.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertJpegToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertJpegToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*operation')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       

:param[in]    filein:     input jpeg file
:param[in]    fileout:    output ps file
:param[in]    operation:  "w" for write; "a" for append
:param[in]    x,: y       location of LL corner of image, in pixels, relative
to the PostScript origin (0,0) at the LL corner
of the page
:param[in]    res:        resolution of the input image, in ppi;
use 0 for default
:param[in]    scale:      scaling by printer; use 0.0 or 1.0 for no scaling
:param[in]    pageno:     page number; must start with 1; you can use 0
if there is only one page
:param[in]    endpage:    boolean: use TRUE if this is the last image to be
added to the page; FALSE otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is simpler to use than pixWriteStringPS(), and
it outputs in level 2 PS as compressed DCT (overlaid
with ascii85 encoding).
(2) An output file can contain multiple pages, each with
multiple images.  The arguments to convertJpegToPS()
allow you to control placement of jpeg images on multiple
pages within a PostScript file.
(3) For the first image written to a file, use "w", which
opens for write and clears the file.  For all subsequent
images written to that file, use "a".
(4) The (x, y) parameters give the LL corner of the image
relative to the LL corner of the page.  They are in
units of pixels if scale = 1.0.  If you use (e.g.)
scale = 2.0, the image is placed at (2x, 2y) on the page,
and the image dimensions are also doubled.
(5) Display vs printed resolution:
If your display is 75 ppi and your image was created
at a resolution of 300 ppi, you can get the image
to print at the same size as it appears on your display
by either setting scale = 4.0 or by setting  res = 75.
Both tell the printer to make a 4x enlarged image.
If your image is generated at 150 ppi and you use scale = 1,
it will be rendered such that 150 pixels correspond
to 72 pts (1 inch on the printer).  This function does
the conversion from pixels (with or without scaling) to
pts, which are the units that the printer uses.
The printer will choose its own resolution to use
in rendering the image, which will not affect the size
of the rendered image.  That is because the output
PostScript file describes the geometry in terms of pts,
which are defined to be 1/72 inch.  The printer will
only see the size of the image in pts, through the
scale and translate parameters and the affine
transform (the ImageMatrix) of the image.
(6) To render multiple images on the same page, set
endpage = FALSE for each image until you get to the
last, for which you set endpage = TRUE.  This causes the
"showpage" command to be invoked.  Showpage outputs
the entire page and clears the raster buffer for the
next page to be added.  Without a "showpage",
subsequent images from the next page will overlay those
previously put down.
(7) For multiple pages, increment the page number, starting
with page 1.  This allows PostScript (and PDF) to build
a page directory, which viewers use for navigation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertJpegToPS(*args)
    
    

    try:
        leptonica.convertG4ToPSEmbed.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertG4ToPSEmbed.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertG4ToPSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertG4ToPSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       

:param[in]    filein:    input tiff file
:param[in]    fileout:   output ps file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function takes a g4 compressed tif file as input and
generates a g4 compressed, ascii85 encoded PS file, with
a bounding box.
(2) The bounding box is required when a program such as TeX
(through epsf) places and rescales the image.
(3) The bounding box is sized for fitting the image to an
8.5 x 11.0 inch page.
(4) We paint this through a mask, over whatever is below.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertG4ToPSEmbed(*args)
    
    

    try:
        leptonica.convertG4ToPS.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertG4ToPS.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertG4ToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertG4ToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*operation')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'maskflag')       
('l_int32', 'endpage')       

:param[in]    filein:     input tiff g4 file
:param[in]    fileout:    output ps file
:param[in]    operation:  "w" for write; "a" for append
:param[in]    x,: y       location of LL corner of image, in pixels, relative
to the PostScript origin (0,0) at the LL corner
of the page
:param[in]    res:        resolution of the input image, in ppi; typ. values
are 300 and 600; use 0 for automatic determination
based on image size
:param[in]    scale:      scaling by printer; use 0.0 or 1.0 for no scaling
:param[in]    pageno:     page number; must start with 1; you can use 0
if there is only one page.
:param[in]    maskflag:   boolean: use TRUE if just painting through fg;
FALSE if painting both fg and bg.
:param[in]    endpage:    boolean: use TRUE if this is the last image to be
added to the page; FALSE otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See the usage comments in convertJpegToPS(), some of
which are repeated here.
(2) This is a wrapper for tiff g4.  The PostScript that
is generated is expanded by about 5/4 (due to the
ascii85 encoding.  If you convert to pdf (ps2pdf), the
ascii85 decoder is automatically invoked, so that the
pdf wrapped g4 file is essentially the same size as
the original g4 file.  It's useful to have the PS
file ascii85 encoded, because many printers will not
print binary PS files.
(3) For the first image written to a file, use "w", which
opens for write and clears the file.  For all subsequent
images written to that file, use "a".
(4) To render multiple images on the same page, set
endpage = FALSE for each image until you get to the
last, for which you set endpage = TRUE.  This causes the
"showpage" command to be invoked.  Showpage outputs
the entire page and clears the raster buffer for the
next page to be added.  Without a "showpage",
subsequent images from the next page will overlay those
previously put down.
(5) For multiple images to the same page, where you are writing
both jpeg and tiff-g4, you have two options:
(a) write the g4 first, as either image (maskflag == FALSE)
or imagemask (maskflag == TRUE), and then write the
jpeg over it.
(b) write the jpeg first and as the last item, write
the g4 as an imagemask (maskflag == TRUE), to paint
through the foreground only.
We have this flexibility with the tiff-g4 because it is 1 bpp.
(6) For multiple pages, increment the page number, starting
with page 1.  This allows PostScript (and PDF) to build
a page directory, which viewers use for navigation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertG4ToPS(*args)
    
    

    try:
        leptonica.convertTiffMultipageToPS.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_float]
        leptonica.convertTiffMultipageToPS.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertTiffMultipageToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertTiffMultipageToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('l_float32', 'fillfract')       

:param[in]    filein:      input tiff multipage file
:param[in]    fileout:     output ps file
:param[in]    fillfract:   factor for filling 8.5 x 11 inch page;
use 0.0 for DefaultFillFraction
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This converts a multipage tiff file of binary page images
into a ccitt g4 compressed PS file.
(2) If the images are generated from a standard resolution fax,
the vertical resolution is doubled to give a normal-looking
aspect ratio.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertTiffMultipageToPS(*args)
    
    

    try:
        leptonica.convertFlateToPSEmbed.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertFlateToPSEmbed.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertFlateToPSEmbed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFlateToPSEmbed(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       

:param[in]    filein:    input file -- any format
:param[in]    fileout:   output ps file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function takes any image file as input and generates a
flate-compressed, ascii85 encoded PS file, with a bounding box.
(2) The bounding box is required when a program such as TeX
(through epsf) places and rescales the image.
(3) The bounding box is sized for fitting the image to an
8.5 x 11.0 inch page.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertFlateToPSEmbed(*args)
    
    

    try:
        leptonica.convertFlateToPS.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertFlateToPS.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertFlateToPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFlateToPS(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       
('const char', '*operation')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('l_float32', 'scale')       
('l_int32', 'pageno')       
('l_int32', 'endpage')       

:param[in]    filein:    input file -- any format
:param[in]    fileout:    output ps file
:param[in]    operation:  "w" for write; "a" for append
:param[in]    x,: y       location of LL corner of image, in pixels, relative
to the PostScript origin (0,0) at the LL corner
of the page
:param[in]    res:        resolution of the input image, in ppi;
use 0 for default
:param[in]    scale:      scaling by printer; use 0.0 or 1.0 for no scaling
:param[in]    pageno:     page number; must start with 1; you can use 0
if there is only one page.
:param[in]    endpage:    boolean: use TRUE if this is the last image to be
added to the page; FALSE otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This outputs level 3 PS as flate compressed (overlaid
with ascii85 encoding).
(2) An output file can contain multiple pages, each with
multiple images.  The arguments to convertFlateToPS()
allow you to control placement of png images on multiple
pages within a PostScript file.
(3) For the first image written to a file, use "w", which
opens for write and clears the file.  For all subsequent
images written to that file, use "a".
(4) The (x, y) parameters give the LL corner of the image
relative to the LL corner of the page.  They are in
units of pixels if scale = 1.0.  If you use (e.g.)
scale = 2.0, the image is placed at (2x, 2y) on the page,
and the image dimensions are also doubled.
(5) Display vs printed resolution:
If your display is 75 ppi and your image was created
at a resolution of 300 ppi, you can get the image
to print at the same size as it appears on your display
by either setting scale = 4.0 or by setting  res = 75.
Both tell the printer to make a 4x enlarged image.
If your image is generated at 150 ppi and you use scale = 1,
it will be rendered such that 150 pixels correspond
to 72 pts (1 inch on the printer).  This function does
the conversion from pixels (with or without scaling) to
pts, which are the units that the printer uses.
The printer will choose its own resolution to use
in rendering the image, which will not affect the size
of the rendered image.  That is because the output
PostScript file describes the geometry in terms of pts,
which are defined to be 1/72 inch.  The printer will
only see the size of the image in pts, through the
scale and translate parameters and the affine
transform (the ImageMatrix) of the image.
(6) To render multiple images on the same page, set
endpage = FALSE for each image until you get to the
last, for which you set endpage = TRUE.  This causes the
"showpage" command to be invoked.  Showpage outputs
the entire page and clears the raster buffer for the
next page to be added.  Without a "showpage",
subsequent images from the next page will overlay those
previously put down.
(7) For multiple pages, increment the page number, starting
with page 1.  This allows PostScript (and PDF) to build
a page directory, which viewers use for navigation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertFlateToPS(*args)
    
    

    try:
        leptonica.pixWriteMemPS.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixWriteMemPS.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemPS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPS(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'res')       
('l_float32', 'scale')       

:param[out]   pdata:    data of tiff compressed image
:param[out]   psize:    size of returned data
:param[in]    pix:
:param[in]    box:      [optional]
:param[in]    res:      can use 0 for default of 300 ppi
:param[in]    scale:    to prevent scaling, use either 1.0 or 0.0
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteStringPS() for usage.
(2) This is just a wrapper for pixWriteStringPS(), which
writes uncompressed image data to memory.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPS(*args)
    
    

    try:
        leptonica.getResLetterPage.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.getResLetterPage.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function getResLetterPage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getResLetterPage(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'fillfract')       

:param[in]    w:           image width, pixels
:param[in]    h:           image height, pixels
:param[in]    fillfract:   fraction in linear dimension of full page,
not to be exceeded; use 0 for default
:returns:  resolution


        """
        args = _convert_params(*args)
        
        return leptonica.getResLetterPage(*args)
    
    

    try:
        leptonica.getResA4Page.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.getResA4Page.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function getResA4Page not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getResA4Page(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'fillfract')       

:param[in]    w:           image width, pixels
:param[in]    h:           image height, pixels
:param[in]    fillfract:   fraction in linear dimension of full page,
not to be exceeded; use 0 for default
:returns:  resolution


        """
        args = _convert_params(*args)
        
        return leptonica.getResA4Page(*args)
    




class sel2(object):
    """<pre>

Contains definitions of simple structuring elements

Basic brick structuring elements
SELA    *selaAddBasic()
Linear horizontal and vertical
Square
Diagonals

Simple hit-miss structuring elements
SELA    *selaAddHitMiss()
Isolated foreground pixel
Horizontal and vertical edges
Slanted edge
Corners

Structuring elements for comparing with DWA operations
SELA    *selaAddDwaLinear()
SELA    *selaAddDwaCombs()

Structuring elements for the intersection of lines
SELA    *selaAddCrossJunctions()
SELA    *selaAddTJunctions()

Structuring elements for connectivity-preserving thinning operations
SELA    *sela4ccThin()
SELA    *sela8ccThin()
SELA    *sela4and8ccThin()

Other structuring elements
SEL    *selMakePlusSign()
</pre>




"""
    
    try:
        leptonica.selaAddBasic.argtypes = [ctypes.c_void_p]
        leptonica.selaAddBasic.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaAddBasic not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddBasic(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela: [optional]
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds the following sels:
~ all linear (horiz, vert) brick sels that are
necessary for decomposable sels up to size 63
~ square brick sels up to size 10
~ 4 diagonal sels
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddBasic(*args)
    
    

    try:
        leptonica.selaAddHitMiss.argtypes = [ctypes.c_void_p]
        leptonica.selaAddHitMiss.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaAddHitMiss not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddHitMiss(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela:  [optional]
:returns:  sela with additional sels, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddHitMiss(*args)
    
    

    try:
        leptonica.selaAddDwaLinear.argtypes = [ctypes.c_void_p]
        leptonica.selaAddDwaLinear.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaAddDwaLinear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddDwaLinear(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela: [optional]
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds all linear (horizontal, vertical) sels from
2 to 63 pixels in length, which are the sizes over
which dwa code can be generated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddDwaLinear(*args)
    
    

    try:
        leptonica.selaAddDwaCombs.argtypes = [ctypes.c_void_p]
        leptonica.selaAddDwaCombs.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaAddDwaCombs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddDwaCombs(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela: [optional]
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds all comb (horizontal, vertical) Sels that are
used in composite linear morphological operations
up to 63 pixels in length, which are the sizes over
which dwa code can be generated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddDwaCombs(*args)
    
    

    try:
        leptonica.selaAddCrossJunctions.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaAddCrossJunctions.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaAddCrossJunctions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddCrossJunctions(*args):
        """
        ('SELA', '*sela')       
('l_float32', 'hlsize')       
('l_float32', 'mdist')       
('l_int32', 'norient')       
('l_int32', 'debugflag')       

:param[in]    sela: [optional]
:param[in]    hlsize: length of each line of hits from origin
:param[in]    mdist: distance of misses from the origin
:param[in]    norient: number of orientations; max of 8
:param[in]    debugflag: 1 for debug output
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds hitmiss Sels for the intersection of two lines.
If the lines are very thin, they must be nearly orthogonal
to register.
(2) The number of Sels generated is equal to %norient.
(3) If %norient == 2, this generates 2 Sels of crosses, each with
two perpendicular lines of hits.  One Sel has horizontal and
vertical hits; the other has hits along lines at +-45 degrees.
Likewise, if %norient == 3, this generates 3 Sels of crosses
oriented at 30 degrees with each other.
(4) It is suggested that %hlsize be chosen at least 1 greater
than %mdist.  Try values of (%hlsize, %mdist) such as
(6,5), (7,6), (8,7), (9,7), etc.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddCrossJunctions(*args)
    
    

    try:
        leptonica.selaAddTJunctions.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.selaAddTJunctions.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaAddTJunctions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaAddTJunctions(*args):
        """
        ('SELA', '*sela')       
('l_float32', 'hlsize')       
('l_float32', 'mdist')       
('l_int32', 'norient')       
('l_int32', 'debugflag')       

:param[in]    sela: [optional]
:param[in]    hlsize: length of each line of hits from origin
:param[in]    mdist: distance of misses from the origin
:param[in]    norient: number of orientations; max of 8
:param[in]    debugflag: 1 for debug output
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds hitmiss Sels for the T-junction of two lines.
If the lines are very thin, they must be nearly orthogonal
to register.
(2) The number of Sels generated is 4 * %norient.
(3) It is suggested that %hlsize be chosen at least 1 greater
than %mdist.  Try values of (%hlsize, %mdist) such as
(6,5), (7,6), (8,7), (9,7), etc.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaAddTJunctions(*args)
    
    

    try:
        leptonica.sela4ccThin.argtypes = [ctypes.c_void_p]
        leptonica.sela4ccThin.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sela4ccThin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sela4ccThin(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela: [optional]
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds the 9 basic sels for 4-cc thinning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sela4ccThin(*args)
    
    

    try:
        leptonica.sela8ccThin.argtypes = [ctypes.c_void_p]
        leptonica.sela8ccThin.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sela8ccThin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sela8ccThin(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela: [optional]
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds the 9 basic sels for 8-cc thinning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sela8ccThin(*args)
    
    

    try:
        leptonica.sela4and8ccThin.argtypes = [ctypes.c_void_p]
        leptonica.sela4and8ccThin.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sela4and8ccThin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sela4and8ccThin(*args):
        """
        ('SELA', '*sela')       

:param[in]    sela: [optional]
:returns:  sela with additional sels, or NULL on error

<pre>
Notes:
(1) Adds the 2 basic sels for either 4-cc or 8-cc thinning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sela4and8ccThin(*args)
    
    

    try:
        leptonica.selMakePlusSign.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.selMakePlusSign.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selMakePlusSign not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selMakePlusSign(*args):
        """
        ('l_int32', 'size')       
('l_int32', 'linewidth')       

:param[in]    size:        side of containing square
:param[in]    linewidth:   of lines
:returns:  sel, or NULL on error

<pre>
Notes:
(1) Useful for debugging to show location of selected pixels.
(2) See displaySelectedPixels() for an example of use.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selMakePlusSign(*args)
    




class affinecompose(object):
    """<pre>

Composable coordinate transforms
l_float32   *createMatrix2dTranslate()
l_float32   *createMatrix2dScale()
l_float32   *createMatrix2dRotate()

Special coordinate transforms on pta
PTA         *ptaTranslate()
PTA         *ptaScale()
PTA         *ptaRotate()

Special coordinate transforms on boxa
BOXA        *boxaTranslate()
BOXA        *boxaScale()
BOXA        *boxaRotate()

General coordinate transform on pta and boxa
PTA         *ptaAffineTransform()
BOXA        *boxaAffineTransform()

Matrix operations
l_int32      l_productMatVec()
l_int32      l_productMat2()
l_int32      l_productMat3()
l_int32      l_productMat4()
</pre>




"""
    
    try:
        leptonica.createMatrix2dTranslate.argtypes = [ctypes.c_float, ctypes.c_float]
        leptonica.createMatrix2dTranslate.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        sys.stderr.write("Warning - function createMatrix2dTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def createMatrix2dTranslate(*args):
        """
        ('l_float32', 'transx')       
('l_float32', 'transy')       

:param[in]    transx:   x component of translation wrt. the origin
:param[in]    transy:   y component of translation wrt. the origin
:returns:  3x3 transform matrix, or NULL on error

<pre>
Notes:
(1) The translation is equivalent to:
v' = Av
where v and v' are 1x3 column vectors in the form
v = [x, y, 1]^    ^ denotes transpose
and the affine translation matrix is
A = [ 1   0   tx
0   1   ty
0   0    1  ]

(2) We consider translation as with respect to a fixed origin.
In a clipping operation, the origin moves and the points
are fixed, and you use (-tx, -ty) where (tx, ty) is the
translation vector of the origin.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.createMatrix2dTranslate(*args)
    
    

    try:
        leptonica.createMatrix2dScale.argtypes = [ctypes.c_float, ctypes.c_float]
        leptonica.createMatrix2dScale.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        sys.stderr.write("Warning - function createMatrix2dScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def createMatrix2dScale(*args):
        """
        ('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    scalex:    horizontal scale factor
:param[in]    scaley:    vertical scale factor
:returns:  3x3 transform matrix, or NULL on error

<pre>
Notes:
(1) The scaling is equivalent to:
v' = Av
where v and v' are 1x3 column vectors in the form
v = [x, y, 1]^    ^ denotes transpose
and the affine scaling matrix is
A = [ sx  0    0
0   sy   0
0   0    1  ]

(2) We consider scaling as with respect to a fixed origin.
In other words, the origin is the only point that doesn't
move in the scaling transform.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.createMatrix2dScale(*args)
    
    

    try:
        leptonica.createMatrix2dRotate.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.createMatrix2dRotate.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        sys.stderr.write("Warning - function createMatrix2dRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def createMatrix2dRotate(*args):
        """
        ('l_float32', 'xc')       
('l_float32', 'yc')       
('l_float32', 'angle')       

:param[in]    xc,: yc    location of center of rotation
:param[in]    angle:     rotation in radians; clockwise is positive
:returns:  3x3 transform matrix, or NULL on error

<pre>
Notes:
(1) The rotation is equivalent to:
v' = Av
where v and v' are 1x3 column vectors in the form
v = [x, y, 1]^    ^ denotes transpose
and the affine rotation matrix is
A = [ cosa   -sina    xc*1-cosa + yc*sina
sina    cosa    yc*1-cosa - xc*sina
0       0                 1         ]

If the rotation is about the origin, xc, yc) = (0, 0 and
this simplifies to
A = [ cosa   -sina    0
sina    cosa    0
0       0     1 ]

These relations follow from the following equations, which
you can convince yourself are correct as follows.  Draw a
circle centered on xc,yc) and passing through (x,y), with
(x',y') on the arc at an angle 'a' clockwise from (x,y).
[ Hint: cosa + b = cosa * cosb - sina * sinb
sina + b = sina * cosb + cosa * sinb ]

x' - xc =  x - xc) * cosa - (y - yc * sina
y' - yc =  x - xc) * sina + (y - yc * cosa
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.createMatrix2dRotate(*args)
    
    

    try:
        leptonica.ptaTranslate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.ptaTranslate.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTranslate(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'transx')       
('l_float32', 'transy')       

:param[in]    ptas:      for initial points
:param[in]    transx:    x component of translation wrt. the origin
:param[in]    transy:    y component of translation wrt. the origin
:returns:  ptad  translated points, or NULL on error

<pre>
Notes:
(1) See createMatrix2dTranslate() for details of transform.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTranslate(*args)
    
    

    try:
        leptonica.ptaScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.ptaScale.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaScale(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    ptas:      for initial points
:param[in]    scalex:    horizontal scale factor
:param[in]    scaley:    vertical scale factor
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) See createMatrix2dScale() for details of transform.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaScale(*args)
    
    

    try:
        leptonica.ptaRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.ptaRotate.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRotate(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'xc')       
('l_float32', 'yc')       
('l_float32', 'angle')       

:param[in]    ptas:      for initial points
:param[in]    xc,: yc    location of center of rotation
:param[in]    angle:     rotation in radians; clockwise is positive
:returns:  0 if OK; 1 on error

<pre>
Notes;
(1) See createMatrix2dScale() for details of transform.
(2) This transform can be thought of as composed of the
sum of two parts:
a) an (x,y)-dependent rotation about the origin:
xr = x * cosa - y * sina
yr = x * sina + y * cosa
b) an (x,y)-independent translation that depends on the
rotation center and the angle:
xt = xc - xc * cosa + yc * sina
yt = yc - xc * sina - yc * cosa
The translation part (xt,yt) is equal to the difference
between the center (xc,yc) and the location of the
center after it is rotated about the origin.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRotate(*args)
    
    

    try:
        leptonica.boxaTranslate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.boxaTranslate.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaTranslate(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'transx')       
('l_float32', 'transy')       

:param[in]    boxas:
:param[in]    transx:    x component of translation wrt. the origin
:param[in]    transy:    y component of translation wrt. the origin
:returns:  boxad  translated boxas, or NULL on error

Notes:
(1) See createMatrix2dTranslate() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaTranslate(*args)
    
    

    try:
        leptonica.boxaScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.boxaScale.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaScale(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    boxas:
:param[in]    scalex:    horizontal scale factor
:param[in]    scaley:    vertical scale factor
:returns:  boxad  scaled boxas, or NULL on error

Notes:
(1) See createMatrix2dScale() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaScale(*args)
    
    

    try:
        leptonica.boxaRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.boxaRotate.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRotate(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'xc')       
('l_float32', 'yc')       
('l_float32', 'angle')       

:param[in]    boxas:
:param[in]    xc,: yc    location of center of rotation
:param[in]    angle:     rotation in radians; clockwise is positive
:returns:  boxad  scaled boxas, or NULL on error

Notes:
(1) See createMatrix2dRotate() for details of transform.


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRotate(*args)
    
    

    try:
        leptonica.ptaAffineTransform.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaAffineTransform.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaAffineTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaAffineTransform(*args):
        """
        ('PTA', '*ptas')       
('l_float32', '*mat')       

:param[in]    ptas:    for initial points
:param[in]    mat:     3x3 transform matrix; canonical form
:returns:  ptad  transformed points, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaAffineTransform(*args)
    
    

    try:
        leptonica.boxaAffineTransform.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaAffineTransform.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaAffineTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAffineTransform(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', '*mat')       

:param[in]    boxas:
:param[in]    mat:      3x3 transform matrix; canonical form
:returns:  boxad  transformed boxas, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAffineTransform(*args)
    
    

    try:
        leptonica.l_productMatVec.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMatVec.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_productMatVec not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMatVec(*args):
        """
        ('l_float32', '*mat')       
('l_float32', '*vecs')       
('l_float32', '*vecd')       
('l_int32', 'size')       

:param[in]    mat:     square matrix, as a 1-dimensional %size^2 array
:param[in]    vecs:    input column vector of length %size
:param[in]    vecd:    result column vector
:param[in]    size:    matrix is %size x %size; vectors are length %size
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMatVec(*args)
    
    

    try:
        leptonica.l_productMat2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMat2.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_productMat2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMat2(*args):
        """
        ('l_float32', '*mat1')       
('l_float32', '*mat2')       
('l_float32', '*matd')       
('l_int32', 'size')       

:param[in]    mat1:     square matrix, as a 1-dimensional size^2 array
:param[in]    mat2:     square matrix, as a 1-dimensional size^2 array
:param[in]    matd:     square matrix; product stored here
:param[in]    size:     of matrices
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMat2(*args)
    
    

    try:
        leptonica.l_productMat3.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMat3.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_productMat3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMat3(*args):
        """
        ('l_float32', '*mat1')       
('l_float32', '*mat2')       
('l_float32', '*mat3')       
('l_float32', '*matd')       
('l_int32', 'size')       

:param[in]    mat1:    square matrix, as a 1-dimensional size^2 array
:param[in]    mat2:    square matrix, as a 1-dimensional size^2 array
:param[in]    mat3:    square matrix, as a 1-dimensional size^2 array
:param[in]    matd:    square matrix; product stored here
:param[in]    size:    of matrices
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMat3(*args)
    
    

    try:
        leptonica.l_productMat4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_productMat4.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_productMat4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_productMat4(*args):
        """
        ('l_float32', '*mat1')       
('l_float32', '*mat2')       
('l_float32', '*mat3')       
('l_float32', '*mat4')       
('l_float32', '*matd')       
('l_int32', 'size')       

:param[in]    mat1:    square matrix, as a 1-dimensional size^2 array
:param[in]    mat2:    square matrix, as a 1-dimensional size^2 array
:param[in]    mat3:    square matrix, as a 1-dimensional size^2 array
:param[in]    mat4:    square matrix, as a 1-dimensional size^2 array
:param[in]    matd:    square matrix; product stored here
:param[in]    size:    of matrices
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_productMat4(*args)
    




class colormorph(object):
    """<pre>

Top-level color morphological operations

PIX     *pixColorMorph()

Method: Algorithm by van Herk and Gil and Werman, 1992
Apply grayscale morphological operations separately
to each component.
</pre>




"""
    
    try:
        leptonica.pixColorMorph.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorMorph.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorMorph(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:
:param[in]    type:    L_MORPH_DILATE, L_MORPH_ERODE, L_MORPH_OPEN,
or L_MORPH_CLOSE
:param[in]    hsize:   width of Sel; must be odd; origin implicitly in center
:param[in]    vsize:   ditto for height of Sel
:returns:  pixd

<pre>
Notes:
(1) This does the morph operation on each component separately,
and recombines the result.
(2) Sel is a brick with all elements being hits.
(3) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorMorph(*args)
    




class fpix2(object):
    """<pre>

------------------------------------------
This file has these FPix utilities:
~ interconversions with pix, fpix, dpix
~ min and max values
~ integer scaling
~ arithmetic operations
~ set all
~ border functions
~ simple rasterop (source --> dest)
~ geometric transforms
------------------------------------------

Interconversions between Pix, FPix and DPix
FPIX          *pixConvertToFPix()
DPIX          *pixConvertToDPix()
PIX           *fpixConvertToPix()
PIX           *fpixDisplayMaxDynamicRange()  [useful for debugging]
DPIX          *fpixConvertToDPix()
PIX           *dpixConvertToPix()
FPIX          *dpixConvertToFPix()

Min/max value
l_int32        fpixGetMin()
l_int32        fpixGetMax()
l_int32        dpixGetMin()
l_int32        dpixGetMax()

Integer scaling
FPIX          *fpixScaleByInteger()
DPIX          *dpixScaleByInteger()

Arithmetic operations
FPIX          *fpixLinearCombination()
l_int32        fpixAddMultConstant()
DPIX          *dpixLinearCombination()
l_int32        dpixAddMultConstant()

Set all
l_int32        fpixSetAllArbitrary()
l_int32        dpixSetAllArbitrary()

FPix border functions
FPIX          *fpixAddBorder()
FPIX          *fpixRemoveBorder()
FPIX          *fpixAddMirroredBorder()
FPIX          *fpixAddContinuedBorder()
FPIX          *fpixAddSlopeBorder()

FPix simple rasterop
l_int32        fpixRasterop()

FPix rotation by multiples of 90 degrees
FPIX          *fpixRotateOrth()
FPIX          *fpixRotate180()
FPIX          *fpixRotate90()
FPIX          *fpixFlipLR()
FPIX          *fpixFlipTB()

FPix affine and projective interpolated transforms
FPIX          *fpixAffinePta()
FPIX          *fpixAffine()
FPIX          *fpixProjectivePta()
FPIX          *fpixProjective()
l_int32        linearInterpolatePixelFloat()

Thresholding to 1 bpp Pix
PIX           *fpixThresholdToPix()

Generate function from components
FPIX          *pixComponentFunction()
</pre>




"""
    
    try:
        leptonica.pixConvertToFPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertToFPix.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToFPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncomps')       

:param[in]    pixs:      1, 2, 4, 8, 16 or 32 bpp
:param[in]    ncomps:    number of components: 3 for RGB, 1 otherwise
:returns:  fpix, or NULL on error

<pre>
Notes:
(1) If colormapped, remove to grayscale.
(2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
In all other cases the src image is treated as having a single
component of pixel values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToFPix(*args)
    
    

    try:
        leptonica.pixConvertToDPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertToDPix.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToDPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToDPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncomps')       

:param[in]    pixs:      1, 2, 4, 8, 16 or 32 bpp
:param[in]    ncomps:    number of components: 3 for RGB, 1 otherwise
:returns:  dpix, or NULL on error

<pre>
Notes:
(1) If colormapped, remove to grayscale.
(2) If 32 bpp and %ncomps == 3, this is RGB; convert to luminance.
In all other cases the src image is treated as having a single
component of pixel values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToDPix(*args)
    
    

    try:
        leptonica.fpixConvertToPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixConvertToPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixConvertToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvertToPix(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'outdepth')       
('l_int32', 'negvals')       
('l_int32', 'errorflag')       

:param[in]    fpixs:
:param[in]    outdepth:     0, 8, 16 or 32 bpp
:param[in]    negvals:      L_CLIP_TO_ZERO, L_TAKE_ABSVAL
:param[in]    errorflag:    1 to output error stats; 0 otherwise
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Use %outdepth = 0 to programmatically determine the
output depth.  If no values are greater than 255,
it will set outdepth = 8; otherwise to 16 or 32.
(2) Because we are converting a float to an unsigned int
with a specified dynamic range (8, 16 or 32 bits), errors
can occur.  If errorflag == TRUE, output the number
of values out of range, both negative and positive.
(3) If a pixel value is positive and out of range, clip to
the maximum value represented at the outdepth of 8, 16
or 32 bits.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvertToPix(*args)
    
    

    try:
        leptonica.fpixDisplayMaxDynamicRange.argtypes = [ctypes.c_void_p]
        leptonica.fpixDisplayMaxDynamicRange.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixDisplayMaxDynamicRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixDisplayMaxDynamicRange(*args):
        """
        ('FPIX', '*fpixs')       

:param[in]    fpixs:
:returns:  pixd 8 bpp, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixDisplayMaxDynamicRange(*args)
    
    

    try:
        leptonica.fpixConvertToDPix.argtypes = [ctypes.c_void_p]
        leptonica.fpixConvertToDPix.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixConvertToDPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvertToDPix(*args):
        """
        ('FPIX', '*fpix')       

:param[in]    fpix:
:returns:  dpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvertToDPix(*args)
    
    

    try:
        leptonica.dpixConvertToPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.dpixConvertToPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixConvertToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixConvertToPix(*args):
        """
        ('DPIX', '*dpixs')       
('l_int32', 'outdepth')       
('l_int32', 'negvals')       
('l_int32', 'errorflag')       

:param[in]    dpixs:
:param[in]    outdepth:     0, 8, 16 or 32 bpp
:param[in]    negvals:      L_CLIP_TO_ZERO, L_TAKE_ABSVAL
:param[in]    errorflag:    1 to output error stats; 0 otherwise
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Use %outdepth = 0 to programmatically determine the
output depth.  If no values are greater than 255,
it will set outdepth = 8; otherwise to 16 or 32.
(2) Because we are converting a float to an unsigned int
with a specified dynamic range (8, 16 or 32 bits), errors
can occur.  If errorflag == TRUE, output the number
of values out of range, both negative and positive.
(3) If a pixel value is positive and out of range, clip to
the maximum value represented at the outdepth of 8, 16
or 32 bits.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixConvertToPix(*args)
    
    

    try:
        leptonica.dpixConvertToFPix.argtypes = [ctypes.c_void_p]
        leptonica.dpixConvertToFPix.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixConvertToFPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixConvertToFPix(*args):
        """
        ('DPIX', '*dpix')       

:param[in]    dpix:
:returns:  fpix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixConvertToFPix(*args)
    
    

    try:
        leptonica.fpixGetMin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetMin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetMin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetMin(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', '*pminval')       
('l_int32', '*pxminloc')       
('l_int32', '*pyminloc')       

:param[in]    fpix:
:param[out]   pminval:    [optional] min value
:param[out]   pxminloc:   [optional] x location of min
:param[out]   pyminloc:   [optional] y location of min
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetMin(*args)
    
    

    try:
        leptonica.fpixGetMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixGetMax.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixGetMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixGetMax(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', '*pmaxval')       
('l_int32', '*pxmaxloc')       
('l_int32', '*pymaxloc')       

:param[in]    fpix:
:param[out]   pmaxval:    [optional] max value
:param[out]   pxmaxloc:   [optional] x location of max
:param[out]   pymaxloc:   [optional] y location of max
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixGetMax(*args)
    
    

    try:
        leptonica.dpixGetMin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetMin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetMin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetMin(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', '*pminval')       
('l_int32', '*pxminloc')       
('l_int32', '*pyminloc')       

:param[in]    dpix:
:param[out]   pminval:    [optional] min value
:param[out]   pxminloc:   [optional] x location of min
:param[out]   pyminloc:   [optional] y location of min
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetMin(*args)
    
    

    try:
        leptonica.dpixGetMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dpixGetMax.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixGetMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixGetMax(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', '*pmaxval')       
('l_int32', '*pxmaxloc')       
('l_int32', '*pymaxloc')       

:param[in]    dpix:
:param[out]   pmaxval:    [optional] max value
:param[out]   pxmaxloc:   [optional] x location of max
:param[out]   pymaxloc:   [optional] y location of max
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixGetMax(*args)
    
    

    try:
        leptonica.fpixScaleByInteger.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixScaleByInteger.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixScaleByInteger not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixScaleByInteger(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'factor')       

:param[in]    fpixs:     typically low resolution
:param[in]    factor:    integer scaling factor
:returns:  fpixd interpolated result, or NULL on error

<pre>
Notes:
(1) The width wd of fpixd is related to ws of fpixs by:
wd = factor * (ws - 1) + 1   (and ditto for the height)
We avoid special-casing boundary pixels in the interpolation
by constructing fpixd by inserting (factor - 1) interpolated
pixels between each pixel in fpixs.  Then
wd = ws + (ws - 1) * (factor - 1)    (same as above)
This also has the advantage that if we subsample by %factor,
throwing out all the interpolated pixels, we regain the
original low resolution fpix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixScaleByInteger(*args)
    
    

    try:
        leptonica.dpixScaleByInteger.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dpixScaleByInteger.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixScaleByInteger not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixScaleByInteger(*args):
        """
        ('DPIX', '*dpixs')       
('l_int32', 'factor')       

:param[in]    dpixs:     typically low resolution
:param[in]    factor:    integer scaling factor
:returns:  dpixd interpolated result, or NULL on error

<pre>
Notes:
(1) The width wd of dpixd is related to ws of dpixs by:
wd = factor * (ws - 1) + 1   (and ditto for the height)
We avoid special-casing boundary pixels in the interpolation
by constructing fpixd by inserting (factor - 1) interpolated
pixels between each pixel in fpixs.  Then
wd = ws + (ws - 1) * (factor - 1)    (same as above)
This also has the advantage that if we subsample by %factor,
throwing out all the interpolated pixels, we regain the
original low resolution dpix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixScaleByInteger(*args)
    
    

    try:
        leptonica.fpixLinearCombination.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.fpixLinearCombination.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixLinearCombination not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixLinearCombination(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs1')       
('FPIX', '*fpixs2')       
('l_float32', 'a')       
('l_float32', 'b')       

:param[in]    fpixd:    [optional] this can be null, equal to fpixs1, or
different from fpixs1
:param[in]    fpixs1:   can be equal to fpixd
:param[in]    fpixs2:
:param[in]    a,: b     multiplication factors on fpixs1 and fpixs2, rsp.
:returns:  fpixd always

<pre>
Notes:
(1) Computes pixelwise linear combination: a * src1 + b * src2
(2) Alignment is to UL corner.
(3) There are 3 cases.  The result can go to a new dest,
in-place to fpixs1, or to an existing input dest:
fpixd == null:   (src1 + src2) --> new fpixd
fpixd == fpixs1:  (src1 + src2) --> src1  (in-place)
fpixd != fpixs1: (src1 + src2) --> input fpixd
(4) fpixs2 must be different from both fpixd and fpixs1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixLinearCombination(*args)
    
    

    try:
        leptonica.fpixAddMultConstant.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.fpixAddMultConstant.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixAddMultConstant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddMultConstant(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', 'addc')       
('l_float32', 'multc')       

:param[in]    fpix:
:param[in]    addc:     use 0.0 to skip the operation
:param[in]    multc:    use 1.0 to skip the operation
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) It can be used to multiply each pixel by a constant,
and also to add a constant to each pixel.  Multiplication
is done first.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddMultConstant(*args)
    
    

    try:
        leptonica.dpixLinearCombination.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.dpixLinearCombination.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dpixLinearCombination not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixLinearCombination(*args):
        """
        ('DPIX', '*dpixd')       
('DPIX', '*dpixs1')       
('DPIX', '*dpixs2')       
('l_float32', 'a')       
('l_float32', 'b')       

:param[in]    dpixd:    [optional] this can be null, equal to dpixs1, or
different from dpixs1
:param[in]    dpixs1:   can be equal to dpixd
:param[in]    dpixs2:
:param[in]    a,: b     multiplication factors on dpixs1 and dpixs2, rsp.
:returns:  dpixd always

<pre>
Notes:
(1) Computes pixelwise linear combination: a * src1 + b * src2
(2) Alignment is to UL corner.
(3) There are 3 cases.  The result can go to a new dest,
in-place to dpixs1, or to an existing input dest:
dpixd == null:   (src1 + src2) --> new dpixd
dpixd == dpixs1:  (src1 + src2) --> src1  (in-place)
dpixd != dpixs1: (src1 + src2) --> input dpixd
(4) dpixs2 must be different from both dpixd and dpixs1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixLinearCombination(*args)
    
    

    try:
        leptonica.dpixAddMultConstant.argtypes = [ctypes.c_void_p, ctypes.c_double, ctypes.c_double]
        leptonica.dpixAddMultConstant.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixAddMultConstant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixAddMultConstant(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', 'addc')       
('l_float64', 'multc')       

:param[in]    dpix:
:param[in]    addc:     use 0.0 to skip the operation
:param[in]    multc:    use 1.0 to skip the operation
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) It can be used to multiply each pixel by a constant,
and also to add a constant to each pixel.  Multiplication
is done first.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dpixAddMultConstant(*args)
    
    

    try:
        leptonica.fpixSetAllArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixSetAllArbitrary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixSetAllArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixSetAllArbitrary(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', 'inval')       

:param[in]    fpix:
:param[in]    inval:    to set at each pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixSetAllArbitrary(*args)
    
    

    try:
        leptonica.dpixSetAllArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_double]
        leptonica.dpixSetAllArbitrary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dpixSetAllArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dpixSetAllArbitrary(*args):
        """
        ('DPIX', '*dpix')       
('l_float64', 'inval')       

:param[in]    dpix:
:param[in]    inval:    to set at each pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dpixSetAllArbitrary(*args)
    
    

    try:
        leptonica.fpixAddBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddBorder.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAddBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    fpixs:
:param[in]    left,: right, top, bot     pixels on each side to be added
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) Adds border of '0' 32-bit pixels
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddBorder(*args)
    
    

    try:
        leptonica.fpixRemoveBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixRemoveBorder.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixRemoveBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRemoveBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    fpixs:
:param[in]    left,: right, top, bot     pixels on each side to be removed
:returns:  fpixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRemoveBorder(*args)
    
    

    try:
        leptonica.fpixAddMirroredBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddMirroredBorder.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAddMirroredBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddMirroredBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    fpixs:
:param[in]    left,: right, top, bot      pixels on each side to be added
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) See pixAddMirroredBorder() for situations of usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddMirroredBorder(*args)
    
    

    try:
        leptonica.fpixAddContinuedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddContinuedBorder.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAddContinuedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddContinuedBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    fpixs:
:param[in]    left,: right, top, bot     pixels on each side to be added
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This adds pixels on each side whose values are equal to
the value on the closest boundary pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddContinuedBorder(*args)
    
    

    try:
        leptonica.fpixAddSlopeBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixAddSlopeBorder.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAddSlopeBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAddSlopeBorder(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    fpixs:
:param[in]    left,: right, top, bot     pixels on each side to be added
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This adds pixels on each side whose values have a normal
derivative equal to the normal derivative at the boundary
of fpixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAddSlopeBorder(*args)
    
    

    try:
        leptonica.fpixRasterop.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixRasterop.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fpixRasterop not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRasterop(*args):
        """
        ('FPIX', '*fpixd')       
('l_int32', 'dx')       
('l_int32', 'dy')       
('l_int32', 'dw')       
('l_int32', 'dh')       
('FPIX', '*fpixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       

:param[in]    fpixd:    dest fpix
:param[in]    dx:       x val of UL corner of dest rectangle
:param[in]    dy:       y val of UL corner of dest rectangle
:param[in]    dw:       width of dest rectangle
:param[in]    dh:       height of dest rectangle
:param[in]    fpixs:    src fpix
:param[in]    sx:       x val of UL corner of src rectangle
:param[in]    sy:       y val of UL corner of src rectangle
:returns:  0 if OK; 1 on error.

<pre>
Notes:
(1) This is similar in structure to pixRasterop(), except
it only allows copying from the source into the destination.
For that reason, no op code is necessary.  Additionally,
all pixels are 32 bit words (float values), which makes
the copy very simple.
(2) Clipping of both src and dest fpix are done automatically.
(3) This allows in-place copying, without checking to see if
the result is valid:  use for in-place with caution!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRasterop(*args)
    
    

    try:
        leptonica.fpixRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixRotateOrth.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRotateOrth(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'quads')       

:param[in]    fpixs:
:param[in]    quads:    0-3; number of 90 degree cw rotations
:returns:  fpixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRotateOrth(*args)
    
    

    try:
        leptonica.fpixRotate180.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixRotate180.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixRotate180 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRotate180(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd:    [optional] can be null, equal to fpixs,
or different from fpixs
:param[in]    fpixs:
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This does a 180 rotation of the image about the center,
which is equivalent to a left-right flip about a vertical
line through the image center, followed by a top-bottom
flip about a horizontal line through the image center.
(2) There are 3 cases for input:
(a) fpixd == null (creates a new fpixd)
(b) fpixd == fpixs (in-place operation)
(c) fpixd != fpixs (existing fpixd)
(3) For clarity, use these three patterns, respectively:
(a) fpixd = fpixRotate180(NULL, fpixs);
(b) fpixRotate180(fpixs, fpixs);
(c) fpixRotate180(fpixd, fpixs);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRotate180(*args)
    
    

    try:
        leptonica.fpixRotate90.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixRotate90.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixRotate90 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRotate90(*args):
        """
        ('FPIX', '*fpixs')       
('l_int32', 'direction')       

:param[in]    fpixs:
:param[in]    direction:     1 = clockwise; -1 = counter-clockwise
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This does a 90 degree rotation of the image about the center,
either cw or ccw, returning a new pix.
(2) The direction must be either 1 (cw) or -1 (ccw).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRotate90(*args)
    
    

    try:
        leptonica.fpixFlipLR.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixFlipLR.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixFlipLR not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixFlipLR(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd:    [optional] can be null, equal to fpixs,
or different from fpixs
:param[in]    fpixs:
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This does a left-right flip of the image, which is
equivalent to a rotation out of the plane about a
vertical line through the image center.
(2) There are 3 cases for input:
(a) fpixd == null (creates a new fpixd)
(b) fpixd == fpixs (in-place operation)
(c) fpixd != fpixs (existing fpixd)
(3) For clarity, use these three patterns, respectively:
(a) fpixd = fpixFlipLR(NULL, fpixs);
(b) fpixFlipLR(fpixs, fpixs);
(c) fpixFlipLR(fpixd, fpixs);
(4) If an existing fpixd is not the same size as fpixs, the
image data will be reallocated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixFlipLR(*args)
    
    

    try:
        leptonica.fpixFlipTB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.fpixFlipTB.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixFlipTB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixFlipTB(*args):
        """
        ('FPIX', '*fpixd')       
('FPIX', '*fpixs')       

:param[in]    fpixd:    [optional] can be null, equal to fpixs,
or different from fpixs
:param[in]    fpixs:
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This does a top-bottom flip of the image, which is
equivalent to a rotation out of the plane about a
horizontal line through the image center.
(2) There are 3 cases for input:
(a) fpixd == null (creates a new fpixd)
(b) fpixd == fpixs (in-place operation)
(c) fpixd != fpixs (existing fpixd)
(3) For clarity, use these three patterns, respectively:
(a) fpixd = fpixFlipTB(NULL, fpixs);
(b) fpixFlipTB(fpixs, fpixs);
(c) fpixFlipTB(fpixd, fpixs);
(4) If an existing fpixd is not the same size as fpixs, the
image data will be reallocated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixFlipTB(*args)
    
    

    try:
        leptonica.fpixAffinePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixAffinePta.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAffinePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAffinePta(*args):
        """
        ('FPIX', '*fpixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'border')       
('l_float32', 'inval')       

:param[in]    fpixs:     8 bpp
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    border:    size of extension with constant normal derivative
:param[in]    inval:     value brought in; typ. 0
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) If %border > 0, all four sides are extended by that distance,
and removed after the transformation is finished.  Pixels
that would be brought in to the trimmed result from outside
the extended region are assigned %inval.  The purpose of
extending the image is to avoid such assignments.
(2) On the other hand, you may want to give all pixels that
are brought in from outside fpixs a specific value.  In that
case, set %border == 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAffinePta(*args)
    
    

    try:
        leptonica.fpixAffine.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixAffine.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAffine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAffine(*args):
        """
        ('FPIX', '*fpixs')       
('l_float32', '*vc')       
('l_float32', 'inval')       

:param[in]    fpixs:    8 bpp
:param[in]    vc:       vector of 8 coefficients for projective transformation
:param[in]    inval:    value brought in; typ. 0
:returns:  fpixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAffine(*args)
    
    

    try:
        leptonica.fpixProjectivePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.fpixProjectivePta.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixProjectivePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixProjectivePta(*args):
        """
        ('FPIX', '*fpixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'border')       
('l_float32', 'inval')       

:param[in]    fpixs:     8 bpp
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    border:    size of extension with constant normal derivative
:param[in]    inval:     value brought in; typ. 0
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) If %border > 0, all four sides are extended by that distance,
and removed after the transformation is finished.  Pixels
that would be brought in to the trimmed result from outside
the extended region are assigned %inval.  The purpose of
extending the image is to avoid such assignments.
(2) On the other hand, you may want to give all pixels that
are brought in from outside fpixs a specific value.  In that
case, set %border == 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixProjectivePta(*args)
    
    

    try:
        leptonica.fpixProjective.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixProjective.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixProjective not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixProjective(*args):
        """
        ('FPIX', '*fpixs')       
('l_float32', '*vc')       
('l_float32', 'inval')       

:param[in]    fpixs:     8 bpp
:param[in]    vc:        vector of 8 coefficients for projective transform
:param[in]    inval:     value brought in; typ. 0
:returns:  fpixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.fpixProjective(*args)
    
    

    try:
        leptonica.linearInterpolatePixelFloat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.linearInterpolatePixelFloat.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function linearInterpolatePixelFloat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearInterpolatePixelFloat(*args):
        """
        ('l_float32', '*datas')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_float32', 'inval')       
('l_float32', '*pval')       

:param[in]    datas:     ptr to beginning of float image data
:param[in]    w,: h      dimensions of image
:param[in]    x,: y      floating pt location for evaluation
:param[in]    inval:     float value brought in from the outside when the
input x,y location is outside the image
:param[out]   pval:      interpolated float value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a standard linear interpolation function.  It is
equivalent to area weighting on each component, and
avoids "jaggies" when rendering sharp edges.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.linearInterpolatePixelFloat(*args)
    
    

    try:
        leptonica.fpixThresholdToPix.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.fpixThresholdToPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixThresholdToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixThresholdToPix(*args):
        """
        ('FPIX', '*fpix')       
('l_float32', 'thresh')       

:param[in]    fpix:
:param[in]    thresh:
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) For all values of fpix that are <= thresh, sets the pixel
in pixd to 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixThresholdToPix(*args)
    
    

    try:
        leptonica.pixComponentFunction.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixComponentFunction.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixComponentFunction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixComponentFunction(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'rnum')       
('l_float32', 'gnum')       
('l_float32', 'bnum')       
('l_float32', 'rdenom')       
('l_float32', 'gdenom')       
('l_float32', 'bdenom')       

:param[in]    pix:                       32 bpp rgb
:param[in]    rnum,: gnum, bnum          coefficients for numerator
:param[in]    rdenom,: gdenom, bdenom    coefficients for denominator
:returns:  fpixd, or NULL on error

<pre>
Notes:
(1) This stores a function of the component values of each
input pixel in %fpixd.
(2) The function is a ratio of linear combinations of component values.
There are two special cases for denominator coefficients:
(a) The denominator is 1.0: input 0 for all denominator coefficients
(b) Only one component is used in the denominator: input 1.0
for that denominator component and 0.0 for the other two.
(3) If the denominator is 0, multiply by an arbitrary number that
is much larger than 1.  Choose 256 "arbitrarily".

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixComponentFunction(*args)
    




class pageseg(object):
    """<pre>

Top level page segmentation
l_int32   pixGetRegionsBinary()

Halftone region extraction
PIX      *pixGenHalftoneMask()    **Deprecated wrapper
PIX      *pixGenerateHalftoneMask()


Textline extraction
PIX      *pixGenTextlineMask()

Textblock extraction
PIX      *pixGenTextblockMask()

Location of page foreground
PIX      *pixFindPageForeground()

Extraction of characters from image with only text
l_int32   pixSplitIntoCharacters()
BOXA     *pixSplitComponentWithProfile()

Extraction of lines of text
PIXA     *pixExtractTextlines()
PIXA     *pixExtractRawTextlines()

How many text columns
l_int32   pixCountTextColumns()

Decision: text vs photo
l_int32   pixDecideIfText()
l_int32   pixFindThreshFgExtent()

Decision: table vs text
l_int32   pixDecideIfTable()
Pix      *pixPrepare1bpp()

Estimate the grayscale background value
l_int32   pixEstimateBackground()

Largest white or black rectangles in an image
l_int32   pixFindLargeRectangles()
l_int32   pixFindLargestRectangle()

Generate rectangle inside connected component
BOX      *pixFindRectangleInCC()

Automatic photoinvert for OCR
PIX      *pixAutoPhotoinvert()
</pre>




"""
    
    try:
        leptonica.pixGetRegionsBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRegionsBinary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRegionsBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRegionsBinary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixhm')       
('PIX', '**ppixtm')       
('PIX', '**ppixtb')       
('PIXA', '*pixadb')       

:param[in]    pixs:      1 bpp, assumed to be 300 to 400 ppi
:param[out]   ppixhm:    [optional] halftone mask
:param[out]   ppixtm:    [optional] textline mask
:param[out]   ppixtb:    [optional] textblock mask
:param[in]    pixadb:    input for collecting debug pix; use NULL to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is best to deskew the image before segmenting.
(2) Passing in %pixadb enables debug output.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRegionsBinary(*args)
    
    

    try:
        leptonica.pixGenHalftoneMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGenHalftoneMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenHalftoneMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenHalftoneMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixtext')       
('l_int32', '*phtfound')       
('l_int32', 'debug')       

<pre>
Deprecated:
This wrapper avoids an ABI change with tesseract 3.0.4.
It should be removed when we no longer need to support 3.0.4.
The debug parameter is ignored (assumed 0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenHalftoneMask(*args)
    
    

    try:
        leptonica.pixGenerateHalftoneMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGenerateHalftoneMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateHalftoneMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateHalftoneMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixtext')       
('l_int32', '*phtfound')       
('PIXA', '*pixadb')       

:param[in]    pixs:      1 bpp, assumed to be 150 to 200 ppi
:param[out]   ppixtext:  [optional] text part of pixs
:param[out]   phtfound:  [optional] 1 if the mask is not empty
:param[in]    pixadb:    input for collecting debug pix; use NULL to skip
:returns:  pixd halftone mask, or NULL on error

<pre>
Notes:
(1) This is not intended to work on small thumbnails.  The
dimensions of pixs must be at least MinWidth x MinHeight.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateHalftoneMask(*args)
    
    

    try:
        leptonica.pixGenTextlineMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGenTextlineMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenTextlineMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenTextlineMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixvws')       
('l_int32', '*ptlfound')       
('PIXA', '*pixadb')       

:param[in]    pixs:      1 bpp, assumed to be 150 to 200 ppi
:param[out]   ppixvws:   vertical whitespace mask
:param[out]   ptlfound:  [optional] 1 if the mask is not empty
:param[in]    pixadb:    input for collecting debug pix; use NULL to skip
:returns:  pixd textline mask, or NULL on error

<pre>
Notes:
(1) The input pixs should be deskewed.
(2) pixs should have no halftone pixels.
(3) This is not intended to work on small thumbnails.  The
dimensions of pixs must be at least MinWidth x MinHeight.
(4) Both the input image and the returned textline mask
are at the same resolution.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenTextlineMask(*args)
    
    

    try:
        leptonica.pixGenTextblockMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGenTextblockMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenTextblockMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenTextblockMask(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixvws')       
('PIXA', '*pixadb')       

:param[in]    pixs:     1 bpp, textline mask, assumed to be 150 to 200 ppi
:param[in]    pixvws:   vertical white space mask
:param[in]    pixadb:   input for collecting debug pix; use NULL to skip
:returns:  pixd textblock mask, or NULL if empty or on error

<pre>
Notes:
(1) Both the input masks (textline and vertical white space) and
the returned textblock mask are at the same resolution.
(2) This is not intended to work on small thumbnails.  The
dimensions of pixs must be at least MinWidth x MinHeight.
(3) The result is somewhat noisy, in that small "blocks" of
text may be included.  These can be removed by post-processing,
using, e.g.,
pixSelectBySize(pix, 60, 60, 4, L_SELECT_IF_EITHER,
L_SELECT_IF_GTE, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenTextblockMask(*args)
    
    

    try:
        leptonica.pixFindPageForeground.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFindPageForeground.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindPageForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindPageForeground(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'threshold')       
('l_int32', 'mindist')       
('l_int32', 'erasedist')       
('l_int32', 'showmorph')       
('PIXAC', '*pixac')       

:param[in]    pixs:       full resolution (any type or depth
:param[in]    threshold:  for binarization; typically about 128
:param[in]    mindist:    min distance of text from border to allow
cleaning near border; at 2x reduction, this
should be larger than 50; typically about 70
:param[in]    erasedist:  when conditions are satisfied, erase anything
within this distance of the edge;
typically 20-30 at 2x reduction
:param[in]    showmorph:  debug: set to a negative integer to show steps
in generating masks; this is typically used
for debugging region extraction
:param[in]    pixac:      debug: allocate outside and pass this in to
accumulate results of each call to this function,
which can be displayed in a mosaic or a pdf.
:returns:  box region including foreground, with some pixel noise
removed, or NULL if not found

<pre>
Notes:
(1) This doesn't simply crop to the fg.  It attempts to remove
pixel noise and junk at the edge of the image before cropping.
The input %threshold is used if pixs is not 1 bpp.
(2) This is not intended to work on small thumbnails.  The
dimensions of pixs must be at least MinWidth x MinHeight.
(3) Debug: set showmorph to display the intermediate image in
the morphological operations on this page.
(4) Debug: to get pdf output of results when called repeatedly,
call with an existing pixac, which will add an image of this page,
with the fg outlined.  If no foreground is found, there is
no output for this page image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindPageForeground(*args)
    
    

    try:
        leptonica.pixSplitIntoCharacters.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSplitIntoCharacters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSplitIntoCharacters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitIntoCharacters(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('BOXA', '**pboxa')       
('PIXA', '**ppixa')       
('PIX', '**ppixdebug')       

:param[in]    pixs:      1 bpp, contains only deskewed text
:param[in]    minw:      min component width for initial filtering; typ. 4
:param[in]    minh:      min component height for initial filtering; typ. 4
:param[out]   pboxa:     [optional] character bounding boxes
:param[out]   ppixa:     [optional] character images
:param[out]   ppixdebug: [optional] showing splittings

:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a simple function that attempts to find split points
based on vertical pixel profiles.
(2) It should be given an image that has an arbitrary number
of text characters.
(3) The returned pixa includes the boxes from which the
(possibly split) components are extracted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitIntoCharacters(*args)
    
    

    try:
        leptonica.pixSplitComponentWithProfile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSplitComponentWithProfile.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSplitComponentWithProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitComponentWithProfile(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'delta')       
('l_int32', 'mindel')       
('PIX', '**ppixdebug')       

:param[in]    pixs:       1 bpp, exactly one connected component
:param[in]    delta:      distance used in extrema finding in a numa; typ. 10
:param[in]    mindel:     minimum required difference between profile
minimum and profile values +2 and -2 away; typ. 7
:param[out]   ppixdebug:  [optional] debug image of splitting
:returns:  boxa of c.c. after splitting, or NULL on error

<pre>
Notes:
(1) This will split the most obvious cases of touching characters.
The split points it is searching for are narrow and deep
minimima in the vertical pixel projection profile, after a
large vertical closing has been applied to the component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitComponentWithProfile(*args)
    
    

    try:
        leptonica.pixExtractTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixExtractTextlines.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractTextlines(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxw')       
('l_int32', 'maxh')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('l_int32', 'adjw')       
('l_int32', 'adjh')       
('PIXA', '*pixadb')       

:param[in]    pixs:        any depth, assumed to have nearly horizontal text
:param[in]    maxw,: maxh  initial filtering: remove any components in pixs
with components larger than maxw or maxh
:param[in]    minw,: minh  final filtering: remove extracted 'lines'
with sizes smaller than minw or minh; use
0 for default.
:param[in]    adjw,: adjh  final adjustment of boxes representing each
text line.  If > 0, these increase the box
size at each edge by this amount.
:param[in]    pixadb:      pixa for saving intermediate steps; NULL to omit
:returns:  pixa of textline images, including bounding boxes, or
NULL on error

<pre>
Notes:
(1) This function assumes that textline fragments have sufficient
vertical separation and small enough skew so that a
horizontal dilation sufficient to join words will not join
textlines.  It does not guarantee that horizontally adjacent
textline fragments on the same line will be joined.
(2) For images with multiple columns, it attempts to avoid joining
textlines across the space between columns.  If that is not
a concern, you can also use pixExtractRawTextlines(),
which will join them with alacrity.
(3) This first removes components from pixs that are either
wide (> %maxw) or tall (> %maxh).
(4) A final filtering operation removes small components, such
that width < %minw or height < %minh.
(5) For reasonable accuracy, the resolution of pixs should be
at least 100 ppi.  For reasonable efficiency, the resolution
should not exceed 600 ppi.
(6) This can be used to determine if some region of a scanned
image is horizontal text.
(7) As an example, for a pix with resolution 300 ppi, a reasonable
set of parameters is:
pixExtractTextlines(pix, 150, 150, 36, 20, 5, 5, NULL);
The defaults minw and minh for 300 ppi are about 36 and 20,
so the same result is obtained with:
pixExtractTextlines(pix, 150, 150, 0, 0, 5, 5, NULL);
(8) The output pixa is composed of subimages, one for each textline,
and the boxa in the pixa tells where in %pixs each textline goes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractTextlines(*args)
    
    

    try:
        leptonica.pixExtractRawTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixExtractRawTextlines.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractRawTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractRawTextlines(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxw')       
('l_int32', 'maxh')       
('l_int32', 'adjw')       
('l_int32', 'adjh')       
('PIXA', '*pixadb')       

:param[in]    pixs:        any depth, assumed to have nearly horizontal text
:param[in]    maxw,: maxh  initial filtering: remove any components in pixs
with components larger than maxw or maxh;
use 0 for default values.
:param[in]    adjw,: adjh  final adjustment of boxes representing each
text line.  If > 0, these increase the box
size at each edge by this amount.
:param[in]    pixadb:      pixa for saving intermediate steps; NULL to omit
:returns:  pixa of textline images, including bounding boxes, or
NULL on error

<pre>
Notes:
(1) This function assumes that textlines have sufficient
vertical separation and small enough skew so that a
horizontal dilation sufficient to join words will not join
textlines.  It aggressively joins textlines across multiple
columns, so if that is not desired, you must either (a) make
sure that %pixs is a single column of text or (b) use instead
pixExtractTextlines(), which is more conservative
about joining text fragments that have vertical overlap.
(2) This first removes components from pixs that are either
very wide (> %maxw) or very tall (> %maxh).
(3) For reasonable accuracy, the resolution of pixs should be
at least 100 ppi.  For reasonable efficiency, the resolution
should not exceed 600 ppi.
(4) This can be used to determine if some region of a scanned
image is horizontal text.
(5) As an example, for a pix with resolution 300 ppi, a reasonable
set of parameters is:
pixExtractRawTextlines(pix, 150, 150, 0, 0, NULL);
(6) The output pixa is composed of subimages, one for each textline,
and the boxa in the pixa tells where in %pixs each textline goes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractRawTextlines(*args)
    
    

    try:
        leptonica.pixCountTextColumns.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountTextColumns.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountTextColumns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountTextColumns(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'deltafract')       
('l_float32', 'peakfract')       
('l_float32', 'clipfract')       
('l_int32', '*pncols')       
('PIXA', '*pixadb')       

:param[in]    pixs:        1 bpp
:param[in]    deltafract:  fraction of (max - min) to be used in the delta
for extrema finding; typ 0.3
:param[in]    peakfract:   fraction of (max - min) to be used to threshold
the peak value; typ. 0.5
:param[in]    clipfract:   fraction of image dimension removed on each side;
typ. 0.1, which leaves w and h reduced by 0.8
:param[out]   pncols:      number of columns; -1 if not determined
:param[in]    pixadb:      [optional] pre-allocated, for showing
intermediate computation; use null to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is assumed that pixs has the correct resolution set.
If the resolution is 0, we set to 300 and issue a warning.
(2) If necessary, the image is scaled to between 37 and 75 ppi;
most of the processing is done at this resolution.
(3) If no text is found (essentially a blank page),
this returns ncols = 0.
(4) For debug output, input a pre-allocated pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountTextColumns(*args)
    
    

    try:
        leptonica.pixDecideIfText.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDecideIfText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDecideIfText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDecideIfText(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', '*pistext')       
('PIXA', '*pixadb')       

:param[in]    pixs:     any depth
:param[in]    box:      [optional]  if null, use entire pixs
:param[out]   pistext:  1 if text; 0 if photo; -1 if not determined or empty
:param[in]    pixadb:   [optional] pre-allocated, for showing intermediate
computation; use NULL to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is assumed that pixs has the correct resolution set.
If the resolution is 0, we set to 300 and issue a warning.
(2) If necessary, the image is scaled to 300 ppi; most of the
processing is done at this resolution.
(3) Text is assumed to be in horizontal lines.
(4) Because thin vertical lines are removed before filtering for
text lines, this should identify tables as text.
(5) If %box is null and pixs contains both text lines and line art,
this function might return %istext == true.
(6) If the input pixs is empty, or for some other reason the
result can not be determined, return -1.
(7) For debug output, input a pre-allocated pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDecideIfText(*args)
    
    

    try:
        leptonica.pixFindThreshFgExtent.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindThreshFgExtent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindThreshFgExtent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindThreshFgExtent(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('l_int32', '*ptop')       
('l_int32', '*pbot')       

:param[in]    pixs:     1 bpp
:param[in]    thresh:   threshold number of pixels in row
:param[out]   ptop:     [optional] location of top of region
:param[out]   pbot:     [optional] location of bottom of region
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindThreshFgExtent(*args)
    
    

    try:
        leptonica.pixDecideIfTable.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDecideIfTable.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDecideIfTable not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDecideIfTable(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'orient')       
('l_int32', '*pscore')       
('PIXA', '*pixadb')       

:param[in]    pixs:      any depth, any resolution >= 75 ppi
:param[in]    box:       [optional] if null, use entire pixs
:param[in]    orient:    L_PORTRAIT_MODE, L_LANDSCAPE_MODE
:param[out]   pscore:    0 - 4; -1 if not determined
:param[in]    pixadb:    [optional] pre-allocated, for showing intermediate
computation; use NULL to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is assumed that pixs has the correct resolution set.
If the resolution is 0, we assume it is 300 ppi and issue a warning.
(2) If %orient == L_LANDSCAPE_MODE, the image is rotated 90 degrees
clockwise before being analyzed.
(3) The interpretation of the returned score:
-1     undetermined
0     no table
1     unlikely to have a table
2     likely to have a table
3     even more likely to have a table
4     extremely likely to have a table
Setting the condition for finding a table at score >= 2 works
well, except for false positives on kanji and landscape text.
These false positives can be removed by setting the condition
at score >= 3, but recall is lowered because it will not find
tables without either horizontal or vertical lines.
(4) Most of the processing takes place at 75 ppi.
(5) Internally, three numbers are determined, for horizontal and
vertical fg lines, and for vertical bg lines.  From these,
four tests are made to decide if there is a table occupying
a significant part of the image.
(6) Images have arbitrary content and would be likely to trigger
this detector, so they are checked for first, and if found,
return with a 0 (no table) score.
(7) Musical scores (tablature) are likely to trigger the detector.
(8) Tables of content with more than 2 columns are likely to
trigger the detector.
(9) For debug output, input a pre-allocated pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDecideIfTable(*args)
    
    

    try:
        leptonica.pixPrepare1bpp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixPrepare1bpp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixPrepare1bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPrepare1bpp(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_float32', 'cropfract')       
('l_int32', 'outres')       

:param[in]    pixs:       any depth
:param[in]    box:        [optional] if null, use entire pixs
:param[in]    cropfract:  fraction to be removed from the boundary;
use 0.0 to retain the entire image
:param[in]    outres:     desired resolution of output image; if the
input image resolution is not set, assume
300 ppi; use 0 to skip scaling.
:returns:  pixd if OK, NULL on error

<pre>
Notes:
(1) This handles some common pre-processing operations,
where the page segmentation algorithm takes a 1 bpp image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPrepare1bpp(*args)
    
    

    try:
        leptonica.pixEstimateBackground.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixEstimateBackground.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixEstimateBackground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEstimateBackground(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'darkthresh')       
('l_float32', 'edgecrop')       
('l_int32', '*pbg')       

:param[in]    pixs:         8 bpp, with or without colormap
:param[in]    darkthresh:   pixels below this value are never considered
part of the background; typ. 70; use 0 to skip
:param[in]    edgecrop:     fraction of half-width on each side, and of
half-height at top and bottom, that are cropped
:param[out]   pbg:          estimated background, or 0 on error
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Caller should check that return bg value is > 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEstimateBackground(*args)
    
    

    try:
        leptonica.pixFindLargeRectangles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindLargeRectangles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindLargeRectangles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindLargeRectangles(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'polarity')       
('l_int32', 'nrect')       
('BOXA', '**pboxa')       
('PIX', '**ppixdb')       

:param[in]    pixs:       1 bpp
:param[in]    polarity:   0 within background, 1 within foreground
:param[in]    nrect:      number of rectangles to be found
:param[out]   pboxa:      largest rectangles, sorted by decreasing area
:param[in,out]  ppixdb:   optional return output with rectangles drawn on it
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a greedy search to find the largest rectangles,
either black or white and without overlaps, in %pix.
(2) See pixFindLargestRectangle(), which is called multiple
times, for details.  On each call, the largest rectangle
found is painted, so that none of its pixels can be
used later, before calling it again.
(3) This function is surprisingly fast.  Although
pixFindLargestRectangle() runs at about 50 MPix/sec, when it
is run multiple times by pixFindLargeRectangles(), it processes
at 150 - 250 MPix/sec, and the time is approximately linear
in %nrect.  For example, for a 1 MPix image, searching for
the largest 50 boxes takes about 0.2 seconds.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindLargeRectangles(*args)
    
    

    try:
        leptonica.pixFindLargestRectangle.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindLargestRectangle.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindLargestRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindLargestRectangle(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'polarity')       
('BOX', '**pbox')       
('PIX', '**ppixdb')       

:param[in]    pixs:       1 bpp
:param[in]    polarity:   0 within background, 1 within foreground
:param[out]   pbox:       largest area rectangle
:param[in,out]  ppixdb:   optional return output with rectangle drawn on it
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a simple and elegant solution to a problem in
computational geometry that at first appears to be quite
difficult: what is the largest rectangle that can be
placed in the image, covering only pixels of one polarity
(bg or fg)?  The solution is O(n), where n is the number
of pixels in the image, and it requires nothing more than
using a simple recursion relation in a single sweep of the image.
(2) In a sweep from UL to LR with left-to-right being the fast
direction, calculate the largest white rectangle at (x, y),
using previously calculated values at pixels #1 and #2:
#1:    (x, y - 1)
#2:    (x - 1, y)
We also need the most recent "black" pixels that were seen
in the current row and column.
Consider the largest area.  There are only two possibilities:
(a)  Min(w(1), horizdist) * (h(1) + 1)
(b)  Min(h(2), vertdist) * (w(2) + 1)
where
horizdist: the distance from the rightmost "black" pixel seen
in the current row across to the current pixel
vertdist: the distance from the lowest "black" pixel seen
in the current column down to the current pixel
and we choose the Max of (a) and (b).
(3) To convince yourself that these recursion relations are correct,
it helps to draw the maximum rectangles at #1 and #2.
Then for #1, you try to extend the rectangle down one line,
so that the height is h(1) + 1.  Do you get the full
width of #1, w(1)?  It depends on where the black pixels are
in the current row.  You know the final width is bounded by w(1)
and w(2) + 1, but the actual value depends on the distribution
of black pixels in the current row that are at a distance
from the current pixel that is between these limits.
We call that value "horizdist", and the area is then given
by the expression (a) above.  Using similar reasoning for #2,
where you attempt to extend the rectangle to the right
by 1 pixel, you arrive at (b).  The largest rectangle is
then found by taking the Max.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindLargestRectangle(*args)
    
    

    try:
        leptonica.pixFindRectangleInCC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFindRectangleInCC.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindRectangleInCC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindRectangleInCC(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*boxs')       
('l_float32', 'fract')       
('l_int32', 'dir')       
('l_int32', 'select')       
('l_int32', 'debug')       

:param[in]    pixs:     1 bpp, with sufficient closings to make the fg be
a single c.c. that is a convex hull
:param[in]    boxs:     [optional] if NULL, %pixs should be a minimum
container of a single c.c.
:param[in]    fract:    first and all consecutive lines found must be at
least this fraction of the fast scan dimension
:param[in]    dir:      L_SCAN_HORIZONTAL, L_SCAN_VERTICAL; direction of
fast scan
:param[in]    select:   L_GEOMETRIC_UNION, L_GEOMETRIC_INTERSECTION,
L_LARGEST_AREA, L_SMALEST_AREA
:param[in]    debug:    if 1, generates output pdf showing intermediate
computation and final result
:returns:  box  of included rectangle, or NULL on error

<pre>
Notes:
(1) Computation is similar to pixFindLargestRectangle(), but allows
a different set of results to choose from.
(2) Select the fast scan direction.  Then, scanning in the slow
direction, finds the longest run of ON pixels in the fast
scan direction and look for the first first run that is longer
than %fract of the dimension.  Continues until a shorter run
is found.  This generates a box of ON pixels fitting into the c.c.
(3) Do this from both slow scan directions and use %select to get
a resulting box from these two.
(4) The extracted rectangle is not necessarily the largest that
can fit in the c.c.  To get that, use pixFindLargestRectangle().


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindRectangleInCC(*args)
    
    

    try:
        leptonica.pixAutoPhotoinvert.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAutoPhotoinvert.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAutoPhotoinvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAutoPhotoinvert(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('PIX', '**ppixm')       
('PIXA', '*pixadb')       

:param[in]    pixs:       any depth, colormap ok
:param[in]    thresh:     binarization threshold; use 0 for default
:param[out]   ppixm:      [optional] image regions to be inverted
:param[out]   pixadb:     [optional] debug; input NULL to skip
:returns:  pixd   1 bpp image to be sent to OCR, or NULL on error

<pre>
Notes:
(1) A 1 bpp image is returned, where pixels in image regions are
photo-inverted.
(2) If there is light text with a dark background, this will
identify the region and photoinvert the pixels there if
there are at least 60% fg pixels in the region.
(3) For debug output, input a (typically empty) %pixadb.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAutoPhotoinvert(*args)
    




class psio2stub(object):
    """<pre>

Stubs for psio2.c functions
</pre>




"""
    



class selgen(object):
    """<pre>

This file contains functions that generate hit-miss Sels
for doing a loose match to a small bitmap.  The hit-miss
Sel is made from a given bitmap.  Several "knobs"
are available to control the looseness of the match.
In general, a tight match will have fewer false positives
(bad matches) but more false negatives (missed patterns).
The values to be used depend on the quality and variation
of the image in which the pattern is to be searched,
and the relative penalties of false positives and
false negatives.  Default values for the three knobs --
minimum distance to boundary pixels, number of extra pixels
added to selected sides, and minimum acceptable runlength
in eroded version -- are provided.

The generated hit-miss Sels can always be used in the
rasterop implementation of binary morphology (in morph.h).
If they are small enough (not more than 31 pixels extending
in any direction from the Sel origin), they can also be used
to auto-generate dwa code (fmorphauto.c).


Generate a subsampled structuring element
SEL     *pixGenerateSelWithRuns()
SEL     *pixGenerateSelRandom()
SEL     *pixGenerateSelBoundary()

Accumulate data on runs along lines
NUMA    *pixGetRunCentersOnLine()
NUMA    *pixGetRunsOnLine()

Subsample boundary pixels in relatively ordered way
PTA     *pixSubsampleBoundaryPixels()
PTA     *adjacentOnPixelInRaster()

Display generated sel with originating image
PIX     *pixDisplayHitMissSel()
</pre>




"""
    
    try:
        leptonica.pixGenerateSelWithRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateSelWithRuns.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateSelWithRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateSelWithRuns(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nhlines')       
('l_int32', 'nvlines')       
('l_int32', 'distance')       
('l_int32', 'minlength')       
('l_int32', 'toppix')       
('l_int32', 'botpix')       
('l_int32', 'leftpix')       
('l_int32', 'rightpix')       
('PIX', '**ppixe')       

:param[in]    pixs:        1 bpp, typically small, to be used as a pattern
:param[in]    nhlines:     number of hor lines along which elements are found
:param[in]    nvlines:     number of vert lines along which elements are found
:param[in]    distance:    min distance from boundary pixel; use 0 for default
:param[in]    minlength:   min runlength to set hit or miss; use 0 for default
:param[in]    toppix:      number of extra pixels of bg added above
:param[in]    botpix:      number of extra pixels of bg added below
:param[in]    leftpix:     number of extra pixels of bg added to left
:param[in]    rightpix:    number of extra pixels of bg added to right
:param[out]   ppixe:       [optional] input pix expanded by extra pixels
:returns:  sel hit-miss for input pattern, or NULL on error

<pre>
Notes:
(1) The horizontal and vertical lines along which elements are
selected are roughly equally spaced.  The actual locations of
the hits and misses are the centers of respective run-lengths.
(2) No elements are selected that are less than 'distance' pixels away
from a boundary pixel of the same color.  This makes the
match much more robust to edge noise.  Valid inputs of
'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
greater than 4, we reset it to the default value.
(3) The 4 numbers for adding rectangles of pixels outside the fg
can be use if the pattern is expected to be surrounded by bg
(white) pixels.  On the other hand, if the pattern may be near
other fg (black) components on some sides, use 0 for those sides.
(4) The pixels added to a side allow you to have miss elements there.
There is a constraint between distance, minlength, and
the added pixels for this to work.  We illustrate using the
default values.  If you add 5 pixels to the top, and use a
distance of 1, then you end up with a vertical run of at least
4 bg pixels along the top edge of the image.  If you use a
minimum runlength of 3, each vertical line will always find
a miss near the center of its run.  However, if you use a
minimum runlength of 5, you will not get a miss on every vertical
line.  As another example, if you have 7 added pixels and a
distance of 2, you can use a runlength up to 5 to guarantee
that the miss element is recorded.  We give a warning if the
constraint does not guarantee a miss element outside the
image proper.
(5) The input pix, as extended by the extra pixels on selected sides,
can optionally be returned.  For debugging, call
pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
on the generating bitmap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateSelWithRuns(*args)
    
    

    try:
        leptonica.pixGenerateSelRandom.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateSelRandom.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateSelRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateSelRandom(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'hitfract')       
('l_float32', 'missfract')       
('l_int32', 'distance')       
('l_int32', 'toppix')       
('l_int32', 'botpix')       
('l_int32', 'leftpix')       
('l_int32', 'rightpix')       
('PIX', '**ppixe')       

:param[in]    pixs:        1 bpp, typically small, to be used as a pattern
:param[in]    hitfract:    fraction of allowable fg pixels that are hits
:param[in]    missfract:   fraction of allowable bg pixels that are misses
:param[in]    distance:    min distance from boundary pixel; use 0 for default
:param[in]    toppix:      number of extra pixels of bg added above
:param[in]    botpix:      number of extra pixels of bg added below
:param[in]    leftpix:     number of extra pixels of bg added to left
:param[in]    rightpix:    number of extra pixels of bg added to right
:param[out]   ppixe:       [optional] input pix expanded by extra pixels
:returns:  sel hit-miss for input pattern, or NULL on error

<pre>
Notes:
(1) Either of hitfract and missfract can be zero.  If both are zero,
the sel would be empty, and NULL is returned.
(2) No elements are selected that are less than 'distance' pixels away
from a boundary pixel of the same color.  This makes the
match much more robust to edge noise.  Valid inputs of
'distance' are 0, 1, 2, 3 and 4.  If distance is either 0 or
greater than 4, we reset it to the default value.
(3) The 4 numbers for adding rectangles of pixels outside the fg
can be use if the pattern is expected to be surrounded by bg
(white) pixels.  On the other hand, if the pattern may be near
other fg (black) components on some sides, use 0 for those sides.
(4) The input pix, as extended by the extra pixels on selected sides,
can optionally be returned.  For debugging, call
pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
on the generating bitmap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateSelRandom(*args)
    
    

    try:
        leptonica.pixGenerateSelBoundary.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateSelBoundary.restype = lambda address: SEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateSelBoundary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateSelBoundary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hitdist')       
('l_int32', 'missdist')       
('l_int32', 'hitskip')       
('l_int32', 'missskip')       
('l_int32', 'topflag')       
('l_int32', 'botflag')       
('l_int32', 'leftflag')       
('l_int32', 'rightflag')       
('PIX', '**ppixe')       

:param[in]    pixs:        1 bpp, typically small, to be used as a pattern
:param[in]    hitdist:     min distance from fg boundary pixel
:param[in]    missdist:    min distance from bg boundary pixel
:param[in]    hitskip:     number of boundary pixels skipped between hits
:param[in]    missskip:    number of boundary pixels skipped between misses
:param[in]    topflag:     flag for extra pixels of bg added above
:param[in]    botflag:     flag for extra pixels of bg added below
:param[in]    leftflag:    flag for extra pixels of bg added to left
:param[in]    rightflag:   flag for extra pixels of bg added to right
:param[out]   ppixe:       [optional] input pix expanded by extra pixels
:returns:  sel hit-miss for input pattern, or NULL on error

<pre>
Notes:
(1) All fg elements selected are exactly hitdist pixels away from
the nearest fg boundary pixel, and ditto for bg elements.
Valid inputs of hitdist and missdist are 0, 1, 2, 3 and 4.
For example, a hitdist of 0 puts the hits at the fg boundary.
Usually, the distances should be > 0 avoid the effect of
noise at the boundary.
(2) Set hitskip < 0 if no hits are to be used.  Ditto for missskip.
If both hitskip and missskip are < 0, the sel would be empty,
and NULL is returned.
(3) The 4 flags determine whether the sel is increased on that side
to allow bg misses to be placed all along that boundary.
The increase in sel size on that side is the minimum necessary
to allow the misses to be placed at mindist.  For text characters,
the topflag and botflag are typically set to 1, and the leftflag
and rightflag to 0.
(4) The input pix, as extended by the extra pixels on selected sides,
can optionally be returned.  For debugging, call
pixDisplayHitMissSel() to visualize the hit-miss sel superimposed
on the generating bitmap.
(5) This is probably the best of the three sel generators, in the
sense that you have the most flexibility with the smallest number
of hits and misses.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateSelBoundary(*args)
    
    

    try:
        leptonica.pixGetRunCentersOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetRunCentersOnLine.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRunCentersOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRunCentersOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'minlength')       

:param[in]    pixs:        1 bpp
:param[in]    x,: y        set one of these to -1; see notes
:param[in]    minlength:   minimum length of acceptable run
:returns:  numa of fg runs, or NULL on error

<pre>
Notes:
(1) Action: this function computes the fg (black) and bg (white)
pixel runlengths along the specified horizontal or vertical line,
and returns a Numa of the "center" pixels of each fg run
whose length equals or exceeds the minimum length.
(2) This only works on horizontal and vertical lines.
(3) For horizontal runs, set x = -1 and y to the value
for all points along the raster line.  For vertical runs,
set y = -1 and x to the value for all points along the
pixel column.
(4) For horizontal runs, the points in the Numa are the x
values in the center of fg runs that are of length at
least 'minlength'.  For vertical runs, the points in the
Numa are the y values in the center of fg runs, again
of length 'minlength' or greater.
(5) If there are no fg runs along the line that satisfy the
minlength constraint, the returned Numa is empty.  This
is not an error.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRunCentersOnLine(*args)
    
    

    try:
        leptonica.pixGetRunsOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetRunsOnLine.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRunsOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRunsOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       

:param[in]    pixs:    1 bpp
:param[in]    x1,: y1, x2, y2
:returns:  numa, or NULL on error

<pre>
Notes:
(1) Action: this function uses the bresenham algorithm to compute
the pixels along the specified line.  It returns a Numa of the
runlengths of the fg (black) and bg (white) runs, always
starting with a white run.
(2) If the first pixel on the line is black, the length of the
first returned run (which is white) is 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRunsOnLine(*args)
    
    

    try:
        leptonica.pixSubsampleBoundaryPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSubsampleBoundaryPixels.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSubsampleBoundaryPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSubsampleBoundaryPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'skip')       

:param[in]    pixs:   1 bpp, with only boundary pixels in fg
:param[in]    skip:   number to skip between samples as you traverse boundary
:returns:  pta, or NULL on error

<pre>
Notes:
(1) If skip = 0, we take all the fg pixels.
(2) We try to traverse the boundaries in a regular way.
Some pixels may be missed, and these are then subsampled
randomly with a fraction determined by 'skip'.
(3) The most natural approach is to use a depth first (stack-based)
method to find the fg pixels.  However, the pixel runs are
4-connected and there are relatively few branches.  So
instead of doing a proper depth-first search, we get nearly
the same result using two nested while loops: the outer
one continues a raster-based search for the next fg pixel,
and the inner one does a reasonable job running along
each 4-connected coutour.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSubsampleBoundaryPixels(*args)
    
    

    try:
        leptonica.adjacentOnPixelInRaster.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.adjacentOnPixelInRaster.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function adjacentOnPixelInRaster not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def adjacentOnPixelInRaster(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxa')       
('l_int32', '*pya')       

:param[in]    pixs:        1 bpp
:param[in]    x,: y        current pixel
:param[out]   pxa,: pya    adjacent ON pixel, found by simple CCW search
:returns:  1 if a pixel is found; 0 otherwise or on error

<pre>
Notes:
(1) Search is in 4-connected directions first; then on diagonals.
This allows traversal along a 4-connected boundary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.adjacentOnPixelInRaster(*args)
    
    

    try:
        leptonica.pixDisplayHitMissSel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixDisplayHitMissSel.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayHitMissSel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayHitMissSel(*args):
        """
        ('PIX', '*pixs')       
('SEL', '*sel')       
('l_int32', 'scalefactor')       
('l_uint32', 'hitcolor')       
('l_uint32', 'misscolor')       

:param[in]    pixs:          1 bpp
:param[in]    sel:           hit-miss in general
:param[in]    scalefactor:   an integer >= 1; use 0 for default
:param[in]    hitcolor:      RGB0 color for center of hit pixels
:param[in]    misscolor:     RGB0 color for center of miss pixels
:returns:  pixd RGB showing both pixs and sel, or NULL on error
<pre>
Notes:
(1) We don't allow scalefactor to be larger than MaxSelScalefactor
(2) The colors are conveniently given as 4 bytes in hex format,
such as 0xff008800.  The least significant byte is ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayHitMissSel(*args)
    




class colorquant1(object):
    """<pre>

Octcube color quantization

There are several different octcube/octree based quantizations.
These can be classified, in the order in which they appear in this
file, as follows:

-----------------------------------------------------------------
(1) General adaptive octree
(2) Adaptive octree by population at fixed level
(3) Adaptive octree using population and with specified number
of output colors
(4) Octcube with colormap representation of mixed color/gray
(5) 256 fixed octcubes covering color space
(6) Octcubes at fixed level for ncolors <= 256
(7) Octcubes at fixed level with RGB output
(8) Quantizing an rgb image using a specified colormap
-----------------------------------------------------------------

(1) Two-pass adaptive octree color quantization
PIX              *pixOctreeColorQuant()
PIX              *pixOctreeColorQuantGeneral()

which calls
static CQCELL  ***octreeGenerateAndPrune()
static PIX       *pixOctreeQuantizePixels()

which calls
static l_int32    octreeFindColorCell()

Helper cqcell functions
static CQCELL  ***cqcellTreeCreate()
static void       cqcellTreeDestroy()

Helper index functions
l_int32           makeRGBToIndexTables()
void              getOctcubeIndexFromRGB()
static void       getRGBFromOctcube()
static l_int32    getOctcubeIndices()
static l_int32    octcubeGetCount()

(2) Adaptive octree quantization based on population at a fixed level
PIX              *pixOctreeQuantByPopulation()
static l_int32    pixDitherOctindexWithCmap()

(3) Adaptive octree quantization to 4 and 8 bpp with specified
number of output colors in colormap
PIX              *pixOctreeQuantNumColors()

(4) Mixed color/gray quantization with specified number of colors
PIX              *pixOctcubeQuantMixedWithGray()

(5) Fixed partition octcube quantization with 256 cells
PIX              *pixFixedOctcubeQuant256()

(6) Fixed partition quantization for images with few colors
PIX              *pixFewColorsOctcubeQuant1()
PIX              *pixFewColorsOctcubeQuant2()
PIX              *pixFewColorsOctcubeQuantMixed()

(7) Fixed partition octcube quantization at specified level
with quantized output to RGB
PIX              *pixFixedOctcubeQuantGenRGB()

(8) Color quantize RGB image using existing colormap
PIX              *pixQuantFromCmap()  [high-level wrapper]
PIX              *pixOctcubeQuantFromCmap()
static PIX       *pixOctcubeQuantFromCmapLUT()

Generation of octcube histogram
NUMA             *pixOctcubeHistogram()

Get filled octcube table from colormap
l_int32          *pixcmapToOctcubeLUT()

Strip out unused elements in colormap
l_int32           pixRemoveUnusedColors()

Find number of occupied octcubes at the specified level
l_int32           pixNumberOccupiedOctcubes()

Notes:
Leptonica also provides color quantization using a modified
form of median cut.  See colorquant2.c for details.
</pre>




"""
    
    try:
        leptonica.pixOctreeColorQuant.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctreeColorQuant.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctreeColorQuant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeColorQuant(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'colors')       
('l_int32', 'ditherflag')       

:param[in]    pixs:         32 bpp; 24-bit color
:param[in]    colors:       in colormap; some number in range [128 ... 256];
the actual number of colors used will be smaller
:param[in]    ditherflag:   1 to dither, 0 otherwise
:returns:  pixd 8 bpp with colormap, or NULL on error

<pre>
I found one description in the literature of octree color
quantization, using progressive truncation of the octree,
by M. Gervautz and W. Purgathofer in Graphics Gems, pp.
287-293, ed. A. Glassner, Academic Press, 1990.
Rather than setting up a fixed partitioning of the color
space ab initio, as we do here, they allow the octree to be
progressively truncated as new pixels are added.  They
need to set up some data structures that are traversed
with the addition of each 24 bit pixel, in order to decide
either 1) in which cluster (sub-branch of the octree to put
the pixel, or 2 whether to truncate the octree further
to place the pixel in an existing cluster, or 3 which
two existing clusters should be merged so that the pixel
can be left to start a truncated leaf of the octree.  Such dynamic
truncation is considerably more complicated, and Gervautz et
al. did not explain how they did it in anywhere near the
detail required to check their implementation.

The simple method in pixFixedOctcubeQuant256 is very
fast, and with dithering the results are good, but you
can do better if the color clusters are selected adaptively
from the image.  We want a method that makes much better
use of color samples in regions of color space with high
pixel density, while also fairly representing small numbers
of color pixels in low density regions.  Such adaptation
requires two passes through the image: the first for generating
the pruned tree of color cubes and the second for computing the index
into the color table for each pixel.

A relatively simple adaptive method is pixOctreeQuantByPopulation.
That function first determines if the image has very few colors,
and, if so, quantizes to those colors.  If there are more than
256 colors, it generates a histogram of octcube leaf occupancy
at level 4, chooses the 192 most populated such leaves as
the first 192 colors, and sets the remaining 64 colors to the
residual average pixel values in each of the 64 level 2 octcubes.
This is a bit faster than pixOctreeColorQuant, and does very
well without dithering, but for most images with dithering it
is clearly inferior.

We now describe pixOctreeColorQuant.  The first pass is done
on a subsampled image, because we do not need to use all the
pixels in the image to generate the tree.  Subsampling
down to 0.25 1/16 of the pixels makes the program run
about 1.3 times faster.

Instead of dividing the color space into 256 equal-sized
regions, we initially divide it into 2^12 or 2^15 or 2^18
equal-sized octcubes.  Suppose we choose to use 2^18 octcubes.
This gives us 6 octree levels.  We then prune back,
starting from level 6.  For every cube at level 6, there
are 8 cubes at level 5.  Call the operation of putting a
cube aside as a color table entry CTE a "saving."
We use a in general level-dependent threshold, and save
those level 6 cubes that are above threshold.
The rest are combined into the containing level 5 cube.
If between 1 and 7 level 6 cubes within a level 5
cube have been saved by thresholding, then the remaining
level 6 cubes in that level 5 cube are automatically
saved as well, without applying a threshold.  This greatly
simplifies both the description of the CTEs and the later
classification of each pixel as belonging to a CTE.
This procedure is iterated through every cube, starting at
level 5, and then 4, 3, and 2, successively.  The result is that
each CTE contains the entirety of a set of from 1 to 7 cubes
from a given level that all belong to a single cube at the
level above.   We classify the CTEs in terms of the
condition in which they are made as either being "threshold"
or "residual."  They are "threshold" CTEs if no subcubes
are CTEs that is, they contain every pixel within the cube
and the number of pixels exceeds the threshold for making
a CTE.  They are "residual" CTEs if at least one but not more
than 7 of the subcubes have already been determined to be CTEs;
this happens automatically -- no threshold is applied.
If all 8 subcubes are determined to be CTEs, the cube is
marked as having all pixels accounted for 'bleaf' = 1 but
is not saved as a CTE.

We stop the pruning at level 2, at which there are 64
sub-cubes.  Any pixels not already claimed in a CTE are
put in these cubes.

As the cubes are saved as color samples in the color table,
the number of remaining pixels P and the number of
remaining colors in the color table N are recomputed,
along with the average number of pixels P/N ppc to go in
each of the remaining colors.  This running average number is
used to set the threshold at the current level.

Because we are going to very small cubes at levels 6 or 5,
and will dither the colors for errors, it is not necessary
to compute the color center of each cluster; we can simply
use the center of the cube.  This gives us a minimax error
condition: the maximum error is half the width of the
level 2 cubes -- 32 color values out of 256 -- for each color
sample.  In practice, most of the pixels will be very much
closer to the center of their cells.  And with dithering,
the average pixel color in a small region will be closer still.
Thus with the octree quantizer, we are able to capture
regions of high color pdf probability density function in small
but accurate CTEs, and to have only a small number of pixels
that end up a significant distance with a guaranteed maximum
from their true color.

How should the threshold factor vary?  Threshold factors
are required for levels 2, 3, 4 and 5 in the pruning stage.
The threshold for level 5 is actually applied to cubes at
level 6, etc.  From various experiments, it appears that
the results do not vary appreciably for threshold values near 1.0.
If you want more colors in smaller cubes, the threshold
factors can be set lower than 1.0 for cubes at levels 4 and 5.
However, if the factor is set much lower than 1.0 for
levels 2 and 3, we can easily run out of colors.
We put aside 64 colors in the calculation of the threshold
values, because we must have 64 color centers at level 2,
that will have very few pixels in most of them.
If we reduce the factor for level 5 to 0.4, this will
generate many level 6 CTEs, and consequently
many residual cells will be formed up from those leaves,
resulting in the possibility of running out of colors.
Remember, the residual CTEs are mandatory, and are formed
without using the threshold, regardless of the number of
pixels that are absorbed.

The implementation logically has four parts:

1 accumulation into small, fixed cells
2 pruning back into selected CTE cubes
3 organizing the CTEs for fast search to find
the CTE to which any image pixel belongs
4 doing a second scan to code the image pixels by CTE

Step 1 is straightforward; we use 2^15 cells.

We've already discussed how the pruning step 2 will be performed.

Steps 3) and (4 are related, in that the organization
used by step 3 determines how the search actually
takes place for each pixel in step 4.

There are many ways to do step 3.  Let's explore a few.

a The simplest is to order the cubes from highest occupancy
to lowest, and traverse the list looking for the deepest
match.  To make this more efficient, so that we know when
to stop looking, any cube that has separate CTE subcubes
would be marked as such, so that we know when we hit a
true leaf.

b Alternatively, we can order the cubes by highest
occupancy separately each level, and work upward,
starting at level 5, so that when we find a match we
know that it will be correct.

c Another approach would be to order the cubes by
"address" and use a hash table to find the cube
corresponding to a pixel color.  I don't know how to
do this with a variable length address, as each CTE
will have 3*n bits, where n is the level.

d Another approach entirely is to put the CTE cubes into
a tree, in such a way that starting from the root, and
using 3 bits of address at a time, the correct branch of
each octree can be taken until a leaf is found.  Because
a given cube can be both a leaf and also have branches
going to sub-cubes, the search stops only when no
marked subcubes have addresses that match the given pixel.

In the tree method, we can start with a dense infrastructure,
and place the leaves corresponding to the N colors
in the tree, or we can grow from the root only those
branches that end directly on leaves.

What we do here is to take approach d, and implement the tree
"virtually", as a set of arrays, one array for each level
of the tree.   Initially we start at level 5, an array with
2^15 cubes, each with 8 subcubes.  We then build nodes at
levels closer to the root; at level 4 there are 2^12 nodes
each with 8 subcubes; etc.  Using these arrays has
several advantages:

~  We don't need to keep track of links between cubes
and subcubes, because we can use the canonical
addressing on the cell arrays directly to determine
which nodes are parent cubes and which are sub-cubes.

~  We can prune directly on this tree

~  We can navigate the pruned tree quickly to classify
each pixel in the image.

Canonical addressing guarantees that the i-th node at level k
has 8 subnodes given by the 8*i ... 8*i+7 nodes at level k+1.

The pruning step works as follows.  We go from the lowest
level up.  At each level, the threshold is found from the
product of a factor near 1.0 and the ratio of unmarked pixels
to remaining colors minus the 64.  We march through
the space, sequentially considering a cube and its 8 subcubes.
We first check those subcubes that are not already
marked as CTE to see if any are above threshold, and if so,
generate a CTE and mark them as such.
We then determine if any of the subcubes have been marked.
If so, and there are subcubes that are not marked,
we generate a CTE for the cube from the remaining unmarked
subcubes; this is mandatory and does not depend on how many
pixels are in the set of subcubes.  If none of the subcubes
are marked, we aggregate their pixels into the cube
containing them, but do not mark it as a CTE; that
will be determined when iterating through the next level up.

When all the pixels in a cube are accounted for in one or more
colors, we set the boolean 'bleaf' to true.  This is the
flag used to mark the cubes in the pruning step.  If a cube
is marked, and all 8 subcubes are marked, then it is not
itself given a CTE because all pixels have already been
accounted for.

Note that the pruning of the tree and labelling of the CTEs
step 2 accomplishes step 3 implicitly, because the marked
and pruned tree is ready for use in labelling each pixel
in step 4.  We now, for every pixel in the image, traverse
the tree from the root, looking for the lowest cube that is a leaf.
At each level we have a cube and subcube.  If we reach a subcube
leaf that is marked 0, we know that the color is stored in the
cube above, and we've found the CTE.  Otherwise, the subcube
leaf is marked 1.  If we're at the last level, we've reached
the final leaf and must use it.  Otherwise, continue the
process at the next level down.

For robustness, efficiency and high quality output, we do the following:

(1) Measure the color content of the image.  If there is very little
color, quantize in grayscale.
(2) For efficiency, build the octree with a subsampled image if the
image is larger than some threshold size.
(3) Reserve an extra set of colors to prevent running out of colors
when pruning the octree; specifically, during the assignment
of those level 2 cells out of the 64 that have unassigned
pixels.  The problem of running out is more likely to happen
with small images, because the estimation we use for the
number of pixels available is not accurate.
(4) In the unlikely event that we run out of colors, the dithered
image can be very poor.  As this would only happen with very
small images, and dithering is not particularly noticeable with
such images, turn it off.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeColorQuant(*args)
    
    

    try:
        leptonica.pixOctreeColorQuantGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixOctreeColorQuantGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctreeColorQuantGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeColorQuantGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'colors')       
('l_int32', 'ditherflag')       
('l_float32', 'validthresh')       
('l_float32', 'colorthresh')       

:param[in]    pixs:          32 bpp; 24-bit color
:param[in]    colors:        in colormap; some number in range [128 ... 240];
the actual number of colors used will be smaller
:param[in]    ditherflag:    1 to dither, 0 otherwise
:param[in]    validthresh:   minimum fraction of pixels neither near white
nor black, required for color quantization;
typically ~0.01, but smaller for images that have
color but are nearly all white
:param[in]    colorthresh:   minimum fraction of pixels with color that are
not near white or black, that are required
for color quantization; typ. ~0.01, but smaller
for images that have color along with a
significant fraction of gray
:returns:  pixd 8 bit with colormap, or NULL on error

<pre>
Notes:
(1) The parameters %validthresh and %colorthresh are used to
determine if color quantization should be used on an image,
or whether, instead, it should be quantized in grayscale.
If the image has very few non-white and non-black pixels, or
if those pixels that are non-white and non-black are all
very close to either white or black, it is usually better
to treat the color as accidental and to quantize the image
to gray only.  These parameters are useful if you know
something a priori about the image.  Perhaps you know that
there is only a very small fraction of color pixels, but they're
important to preserve; then you want to use a smaller value for
these parameters.  To disable conversion to gray and force
color quantization, use %validthresh = 0.0 and %colorthresh = 0.0.
(2) See pixOctreeColorQuant() for algorithmic and implementation
details.  This function has a more general interface.
(3) See pixColorFraction() for computing the fraction of pixels
that are neither white nor black, and the fraction of those
pixels that have little color.  From the documentation there:
If pixfract is very small, there are few pixels that are
neither black nor white.  If colorfract is very small,
the pixels that are neither black nor white have very
little color content.  The product 'pixfract * colorfract'
gives the fraction of pixels with significant color content.
We test against the product %validthresh * %colorthresh
to find color in images that have either very few
intermediate gray pixels or that have many such gray pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeColorQuantGeneral(*args)
    
    

    try:
        leptonica.makeRGBToIndexTables.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.makeRGBToIndexTables.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function makeRGBToIndexTables not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeRGBToIndexTables(*args):
        """
        ('l_int32', 'cqlevels')       
('l_uint32', '**prtab')       
('l_uint32', '**pgtab')       
('l_uint32', '**pbtab')       

:param[in]    cqlevels:               can be 1, 2, 3, 4, 5 or 6
:param[out]   prtab,: pgtab, pbtab    tables
:returns:  0 if OK; 1 on error

<pre>
Set up tables.  e.g., for cqlevels = 5, we need an integer 0 < i < 2^15:
rtab = 0  i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0   0
gtab = 0  0   i7  0   0  i6  0   0  i5  0   0   i4  0   0   i3  0
btab = 0  0   0   i7  0  0   i6  0  0   i5  0   0   i4  0   0   i3

The tables are then used to map from rbg --> index as follows:
index = 0  r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4  r3  g3  b3

e.g., for cqlevels = 4, we map to
index = 0  0   0   0   r7  g7  b7  r6  g6  b6  r5  g5  b5  r4  g4  b4

This may look a bit strange.  The notation 'r7' means the MSBit of
the r value which has 8 bits, going down from r7 to r0.
Keep in mind that r7 is actually the r component bit for level 1 of
the octtree.  Level 1 is composed of 8 octcubes, represented by
the bits r7 g7 b7, which divide the entire color space into
8 cubes.  At level 2, each of these 8 octcubes is further divided into
8 cubes, each labeled by the second most significant bits r6 g6 b6
of the rgb color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeRGBToIndexTables(*args)
    
    

    try:
        leptonica.getOctcubeIndexFromRGB.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getOctcubeIndexFromRGB.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function getOctcubeIndexFromRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getOctcubeIndexFromRGB(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_uint32', '*rtab')       
('l_uint32', '*gtab')       
('l_uint32', '*btab')       
('l_uint32', '*pindex')       

:param[in]    rval,: gval, bval
:param[in]    rtab,: gtab, btab    generated with makeRGBToIndexTables()
:param[out]   pindex: found index
:returns:  void

<pre>
Notes:
No error checking!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getOctcubeIndexFromRGB(*args)
    
    

    try:
        leptonica.pixOctreeQuantByPopulation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctreeQuantByPopulation.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctreeQuantByPopulation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeQuantByPopulation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_int32', 'ditherflag')       

:param[in]    pixs:         32 bpp rgb
:param[in]    level:        significant bits for each of RGB; valid for {3,4}.
Use 0 for default (level 4; recommended
:param[in]    ditherflag:   1 to dither, 0 otherwise
:returns:  pixd quantized to octcubes or NULL on error

<pre>
Notes:
(1) This color quantization method works very well without
dithering, using octcubes at two different levels:
(a) the input %level, which is either 3 or 4
(b) level 2 (64 octcubes to cover the entire color space)
(2) For best results, using %level = 4 is recommended.
Why do we provide an option for using level 3?  Because
there are 512 octcubes at level 3, and for many images
not more than 256 are filled.  As a result, on some images
a very accurate quantized representation is possible using
%level = 3.
(3) This first breaks up the color space into octcubes at the
input %level, and computes, for each octcube, the average
value of the pixels that are in it.
(4) Then there are two possible situations:
(a) If there are not more than 256 populated octcubes,
it returns a cmapped pix with those values assigned.
(b) Otherwise, it selects 192 octcubes containing the largest
number of pixels and quantizes pixels within those octcubes
to their average.  Then, to handle the residual pixels
that are not in those 192 octcubes, it generates a
level 2 octree consisting of 64 octcubes, and within
each octcube it quantizes the residual pixels to their
average within each of those level 2 octcubes.
(5) Unpopulated level 2 octcubes are represented in the colormap
by their centers.  This, of course, has no effect unless
dithering is used for the output image.
(6) The depth of pixd is the minimum required to support the
number of colors found at %level; namely, 2, 4 or 8.
(7) This function works particularly well on images such as maps,
where there are a relatively small number of well-populated
colors, but due to antialiasing and compression artifacts
there may be a large number of different colors.  This will
pull out and represent accurately the highly populated colors,
while still making a reasonable approximation for the others.
(8) The highest level of octcubes allowed is 4.  Use of higher
levels typically results in having a small fraction of
pixels in the most populated 192 octcubes.  As a result,
most of the pixels are represented at level 2, which is
not sufficiently accurate.
(9) Dithering shows artifacts on some images.  If you plan to
dither, pixOctreeColorQuant() and pixFixedOctcubeQuant256()
usually give better results.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeQuantByPopulation(*args)
    
    

    try:
        leptonica.pixOctreeQuantNumColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctreeQuantNumColors.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctreeQuantNumColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctreeQuantNumColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxcolors')       
('l_int32', 'subsample')       

:param[in]    pixs:        32 bpp rgb
:param[in]    maxcolors:   8 to 256; the actual number of colors used
may be less than this
:param[in]    subsample:   factor for computing color distribution;
use 0 for default
:returns:  pixd 4 or 8 bpp, colormapped, or NULL on error

<pre>
pixOctreeColorQuant is very flexible in terms of the relative
depth of different cubes of the octree.   By contrast, this function,
pixOctreeQuantNumColors is also adaptive, but it supports octcube
leaves at only two depths: a smaller depth that guarantees
full coverage of the color space and octcubes at one level
deeper for more accurate colors.  Its main virutes are simplicity
and speed, which are both derived from the natural indexing of
the octcubes from the RGB values.

Before describing pixOctreeQuantNumColors, consider an even simpler
approach for 4 bpp with either 8 or 16 colors.  With 8 colors,
you simply go to level 1 octcubes and use the average color
found in each cube.  For 16 colors, you find which of the three
colors has the largest variance at the second level, and use two
indices for that color.  The result is quite poor, because 1 some
of the cubes are nearly empty and 2 you don't get much color
differentiation for the extra 8 colors.  Trust me, this method may
be simple, but it isn't worth anything.

In pixOctreeQuantNumColors, we generate colormapped images at
either 4 bpp or 8 bpp.  For 4 bpp, we have a minimum of 8 colors
for the level 1 octcubes, plus up to 8 additional colors that
are determined from the level 2 popularity.  If the number of colors
is between 8 and 16, the output is a 4 bpp image.  If the number of
colors is greater than 16, the output is a 8 bpp image.

We use a priority queue, implemented with a heap, to select the
requisite number of most populated octcubes at the deepest level
level 2 for 64 or fewer colors; level 3 for more than 64 colors.
These are combined with one color for each octcube one level above,
which is used to span the color space of octcubes that were not
included at the deeper level.

If the deepest level is 2, we combine the popular level 2 octcubes
out of a total of 64 with the 8 level 1 octcubes.  If the deepest
level is 3, we combine the popular level 3 octcubes out of a
total 512 with the 64 level 2 octcubes that span the color space.
In the latter case, we require a minimum of 64 colors for the level 2
octcubes, plus up to 192 additional colors determined from level 3
popularity.

The parameter 'maxlevel' is the deepest octcube level that is used.
The implementation also uses two LUTs, which are employed in
two successive traversals of the dest image.  The first maps
from the src octindex at 'maxlevel' to the color table index,
which is the value that is stored in the 4 or 8 bpp dest pixel.
The second LUT maps from that colormap value in the dest to a
new colormap value for a minimum sized colormap, stored back in
the dest.  It is used to remove any color map entries that
correspond to color space regions that have no pixels in the
source image.  These regions can be either from the higher level
e.g., level 1 for 4 bpp, or from octcubes at 'maxlevel' that
are unoccupied.  This remapping results in the minimum number
of colors used according to the constraints induced by the
input 'maxcolors'.  We also compute the average R, G and B color
values in each region of the color space represented by a
colormap entry, and store them in the colormap.

The maximum number of colors is input, which determines the
following properties of the dest image and octcube regions used:

Number of colors      dest image depth      maxlevel
----------------      ----------------      --------
8 to 16                  4 bpp               2
17 to 64                 8 bpp               2
65 to 256                8 bpp               3

It may turn out that the number of extra colors, beyond the
minimum 8 and 64 for maxlevel 2 and 3, respectively, is larger
than the actual number of occupied cubes at these levels
In that case, all the pixels are contained in this
subset of cubes at maxlevel, and no colormap colors are needed
to represent the remainder pixels one level above.  Thus, for
example, in use one often finds that the pixels in an image
occupy less than 192 octcubes at level 3, so they can be represented
by a colormap for octcubes at level 3 only.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctreeQuantNumColors(*args)
    
    

    try:
        leptonica.pixOctcubeQuantMixedWithGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctcubeQuantMixedWithGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctcubeQuantMixedWithGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeQuantMixedWithGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'depth')       
('l_int32', 'graylevels')       
('l_int32', 'delta')       

:param[in]    pixs:        32 bpp rgb
:param[in]    depth:       of output pix
:param[in]    graylevels:  graylevels (must be > 1)
:param[in]    delta:       threshold for deciding if a pix is color or gray
:returns:  pixd     quantized to octcube and gray levels or NULL on error

<pre>
Notes:
(1) Generates a colormapped image, where the colormap table values
have two components: octcube values representing pixels with
color content, and grayscale values for the rest.
(2) The threshold (delta) is the maximum allowable difference of
the max abs value of | r - g |, | r - b | and | g - b |.
(3) The octcube values are the averages of all pixels that are
found in the octcube, and that are far enough from gray to
be considered color.  This can roughly be visualized as all
the points in the rgb color cube that are not within a "cylinder"
of diameter approximately 'delta' along the main diagonal.
(4) We want to guarantee full coverage of the rgb color space; thus,
if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes)
and if the output depth is 8, the octlevel is 2 (4 x 4 x 4
= 64 cubes).
(5) Consequently, we have the following constraint on the number
of allowed gray levels: for 4 bpp, 8; for 8 bpp, 192.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeQuantMixedWithGray(*args)
    
    

    try:
        leptonica.pixFixedOctcubeQuant256.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFixedOctcubeQuant256.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFixedOctcubeQuant256 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFixedOctcubeQuant256(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       

:param[in]    pixs:         32 bpp; 24-bit color
:param[in]    ditherflag:   1 for dithering; 0 for no dithering
:returns:  pixd 8 bit with colormap, or NULL on error

<pre>
Notes:
This simple 1-pass color quantization works by breaking the
color space into 256 pieces, with 3 bits quantized for each of
red and green, and 2 bits quantized for blue.  We shortchange
blue because the eye is least sensitive to blue.  This
division of the color space is into two levels of octrees,
followed by a further division by 4 not 8, where both
blue octrees have been combined in the third level.

The color map is generated from the 256 color centers by
taking the representative color to be the center of the
cell volume.  This gives a maximum error in the red and
green values of 16 levels, and a maximum error in the
blue sample of 32 levels.

Each pixel in the 24-bit color image is placed in its containing
cell, given by the relevant MSbits of the red, green and blue
samples.  An error-diffusion dithering is performed on each
color sample to give the appearance of good average local color.
Dithering is required; without it, the contouring and visible
color errors are very bad.

I originally implemented this algorithm in two passes,
where the first pass was used to compute the weighted average
of each sample in each pre-allocated region of color space.
The idea was to use these centroids in the dithering algorithm
of the second pass, to reduce the average error that was
being dithered.  However, with dithering, there is
virtually no difference, so there is no reason to make the
first pass.  Consequently, this 1-pass version just assigns
the pixels to the centers of the pre-allocated cells.
We use dithering to spread the difference between the sample
value and the location of the center of the cell.  For speed
and simplicity, we use integer dithering and propagate only
to the right, down, and diagonally down-right, with ratios
3/8, 3/8 and 1/4, respectively.  The results should be nearly
as good, and a bit faster, with propagation only to the right
and down.

The algorithm is very fast, because there is no search,
only fast generation of the cell index for each pixel.
We use a simple mapping from the three 8 bit rgb samples
to the 8 bit cell index; namely, r7 r6 r5 g7 g6 g5 b7 b6.
This is not in an octcube format, but it doesn't matter.
There are no storage requirements.  We could keep a
running average of the center of each sample in each
cluster, rather than using the center of the cell, but
this is just extra work, esp. with dithering.

This method gives surprisingly good results with dithering.
However, without dithering, the loss of color accuracy is
evident in regions that are very light or that have subtle
blending of colors.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFixedOctcubeQuant256(*args)
    
    

    try:
        leptonica.pixFewColorsOctcubeQuant1.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFewColorsOctcubeQuant1.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFewColorsOctcubeQuant1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsOctcubeQuant1(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       

:param[in]    pixs:    32 bpp rgb
:param[in]    level:   significant bits for each of RGB; valid in [1...6]
:returns:  pixd quantized to octcube or NULL on error

<pre>
Notes:
(1) Generates a colormapped image, where the colormap table values
are the averages of all pixels that are found in the octcube.
(2) This fails if there are more than 256 colors (i.e., more
than 256 occupied octcubes).
(3) Often level 3 (512 octcubes) will succeed because not more
than half of them are occupied with 1 or more pixels.
(4) The depth of the result, which is either 2, 4 or 8 bpp,
is the minimum required to hold the number of colors that
are found.
(5) This can be useful for quantizing orthographically generated
images such as color maps, where there may be more than 256 colors
because of aliasing or jpeg artifacts on text or lines, but
there are a relatively small number of solid colors.  Then,
use with level = 3 can often generate a compact and accurate
representation of the original RGB image.  For this purpose,
it is better than pixFewColorsOctcubeQuant2(), because it
uses the average value of pixels in the octcube rather
than the first found pixel.  It is also simpler to use,
because it generates the histogram internally.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsOctcubeQuant1(*args)
    
    

    try:
        leptonica.pixFewColorsOctcubeQuant2.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFewColorsOctcubeQuant2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFewColorsOctcubeQuant2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsOctcubeQuant2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('NUMA', '*na')       
('l_int32', 'ncolors')       
('l_int32', '*pnerrors')       

:param[in]    pixs:       32 bpp rgb
:param[in]    level:      of octcube indexing, for histogram: 3, 4, 5, 6
:param[in]    na:         histogram of pixel occupation in octree leaves
at given level
:param[in]    ncolors:    number of occupied octree leaves at given level
:param[out]   pnerrors:   [optional] num of pixels not exactly
represented in the colormap
:returns:  pixd 2, 4 or 8 bpp with colormap, or NULL on error

<pre>
Notes:
(1) Generates a colormapped image, where the colormap table values
are the averages of all pixels that are found in the octcube.
(2) This fails if there are more than 256 colors (i.e., more
than 256 occupied octcubes).
(3) Often level 3 (512 octcubes) will succeed because not more
than half of them are occupied with 1 or more pixels.
(4) For an image with not more than 256 colors, it is unlikely
that two pixels of different color will fall in the same
octcube at level = 4.   However it is possible, and this
function optionally returns %nerrors, the number of pixels
where, because more than one color is in the same octcube,
the pixel color is not exactly reproduced in the colormap.
The colormap for an occupied leaf of the octree contains
the color of the first pixel encountered in that octcube.
(5) This differs from pixFewColorsOctcubeQuant1(), which also
requires not more than 256 occupied leaves, but represents
the color of each leaf by an average over the pixels in
that leaf.  This also requires precomputing the histogram
of occupied octree leaves, which is generated using
pixOctcubeHistogram().
(6) This is used in pixConvertRGBToColormap() for images that
are determined, by their histogram, to have relatively few
colors.  This typically happens with orthographically
produced images (as oppopsed to natural images), where
it is expected that most of the pixels within a leaf
octcube have exactly the same color, and quantization to
that color is lossless.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsOctcubeQuant2(*args)
    
    

    try:
        leptonica.pixFewColorsOctcubeQuantMixed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixFewColorsOctcubeQuantMixed.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFewColorsOctcubeQuantMixed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsOctcubeQuantMixed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       
('l_float32', 'minfract')       
('l_int32', 'maxspan')       

:param[in]    pixs:          32 bpp rgb
:param[in]    level:         significant octcube bits for each of RGB;
valid in [1...6]; use 0 for default
:param[in]    darkthresh:    threshold near black; if the lightest component
is below this, the pixel is not considered to
be gray or color; uses 0 for default
:param[in]    lightthresh:   threshold near white; if the darkest component
is above this, the pixel is not considered to
be gray or color; use 0 for default
:param[in]    diffthresh:    thresh for the max difference between component
values; for differences below this, the pixel
is considered to be gray; use 0 for default
:param[in]    minfract:      min fraction of pixels for gray histo bin;
use 0.0 for default
:param[in]    maxspan:       max size of gray histo bin; use 0 for default
:returns:  pixd 8 bpp, quantized to octcube for pixels that are
not gray; gray pixels are quantized separately
over the full gray range, or NULL on error

<pre>
Notes:
(1) First runs pixFewColorsOctcubeQuant1().  If this succeeds,
it separates the color from gray(ish) entries in the cmap,
and re-quantizes the gray pixels.  The result has some pixels
in color and others in gray.
(2) This fails if there are more than 256 colors (i.e., more
than 256 occupied octcubes in the color quantization).
(3) Level 3 (512 octcubes) will usually succeed because not more
than half of them are occupied with 1 or more pixels.
(4) This uses the criterion from pixColorFraction() for deciding
if a colormap entry is color; namely, if the color components
are not too close to either black or white, and the maximum
difference between component values equals or exceeds a threshold.
(5) For quantizing the gray pixels, it uses a histogram-based
method where input parameters determining the buckets are
the minimum population fraction and the maximum allowed size.
(6) Recommended input parameters are:
%level:  3 or 4  (3 is default)
%darkthresh:  20
%lightthresh: 244
%diffthresh: 20
%minfract: 0.05
%maxspan: 15
These numbers are intended to be conservative (somewhat over-
sensitive) in color detection,  It's usually better to pay
extra with octcube quantization of a grayscale image than
to use grayscale quantization on an image that has some
actual color.  Input 0 on any of these to get the default.
(7) This can be useful for quantizing orthographically generated
images such as color maps, where there may be more than 256 colors
because of aliasing or jpeg artifacts on text or lines, but
there are a relatively small number of solid colors.  It usually
gives results that are better than pixOctcubeQuantMixedWithGray(),
both in size and appearance.  But it is a bit slower.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsOctcubeQuantMixed(*args)
    
    

    try:
        leptonica.pixFixedOctcubeQuantGenRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFixedOctcubeQuantGenRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFixedOctcubeQuantGenRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFixedOctcubeQuantGenRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       

:param[in]    pixs:    32 bpp rgb
:param[in]    level:   significant bits for each of r,g,b
:returns:  pixd rgb; quantized to octcube centers, or NULL on error

<pre>
Notes:
(1) Unlike the other color quantization functions, this one
generates an rgb image.
(2) The pixel values are quantized to the center of each octcube
(at the specified level) containing the pixel.  They are
not quantized to the average of the pixels in that octcube.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFixedOctcubeQuantGenRGB(*args)
    
    

    try:
        leptonica.pixQuantFromCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuantFromCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixQuantFromCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuantFromCmap(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       
('l_int32', 'level')       
('l_int32', 'metric')       

:param[in]    pixs:       8 bpp grayscale without cmap, or 32 bpp rgb
:param[in]    cmap:       to quantize to; insert copy into dest pix
:param[in]    mindepth:   minimum depth of pixd: can be 2, 4 or 8 bpp
:param[in]    level:      of octcube used for finding nearest color in cmap
:param[in]    metric:     L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE
:returns:  pixd  2, 4 or 8 bpp, colormapped, or NULL on error

<pre>
Notes:
(1) This is a top-level wrapper for quantizing either grayscale
or rgb images to a specified colormap.
(2) The actual output depth is constrained by %mindepth and
by the number of colors in %cmap.
(3) For grayscale, %level and %metric are ignored.
(4) If the cmap has color and pixs is grayscale, the color is
removed from the cmap before quantizing pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuantFromCmap(*args)
    
    

    try:
        leptonica.pixOctcubeQuantFromCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOctcubeQuantFromCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctcubeQuantFromCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeQuantFromCmap(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       
('l_int32', 'level')       
('l_int32', 'metric')       

:param[in]    pixs:       32 bpp rgb
:param[in]    cmap:       to quantize to; insert copy into dest pix
:param[in]    mindepth:   minimum depth of pixd: can be 2, 4 or 8 bpp
:param[in]    level:      of octcube used for finding nearest color in cmap
:param[in]    metric:     L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE
:returns:  pixd  2, 4 or 8 bpp, colormapped, or NULL on error

<pre>
Notes:
(1) In typical use, we are doing an operation, such as
interpolative scaling, on a colormapped pix, where it is
necessary to remove the colormap before the operation.
We then want to re-quantize the RGB result using the same
colormap.
(2) The level is used to divide the color space into octcubes.
Each input pixel is, in effect, placed at the center of an
octcube at the given level, and it is mapped into the
exact color (given in the colormap) that is the closest
to that location.  We need to know that distance, for each color
in the colormap.  The higher the level of the octtree, the smaller
the octcubes in the color space, and hence the more accurately
we can determine the closest color in the colormap; however,
the size of the LUT, which is the total number of octcubes,
increases by a factor of 8 for each increase of 1 level.
The time required to acquire a level 4 mapping table, which has
about 4K entries, is less than 1 msec, so that is the
recommended minimum size to be used.  At that size, the
octcubes have their centers 16 units apart in each (r,g,b)
direction.  If two colors are in the same octcube, the one
closest to the center will always be chosen.  The maximum
error for any component occurs when the correct color is
at a cube corner and there is an incorrect color just inside
the cube next to the opposite corner, giving an error of
14 units (out of 256) for each component.   Using a level 5
mapping table reduces the maximum error to 6 units.
(3) Typically you should use the Euclidean metric, because the
resulting voronoi cells (which are generated using the actual
colormap values as seeds) are convex for Euclidean distance
but not for Manhattan distance.  In terms of the octcubes,
convexity of the voronoi cells means that if the 8 corners
of any cube (of which the octcubes are special cases)
are all within a cell, then every point in the cube will
lie within the cell.
(4) The depth of the output pixd is equal to the maximum of
(a) %mindepth and (b) the minimum (2, 4 or 8 bpp) necessary
to hold the indices in the colormap.
(5) We build a mapping table from octcube to colormap index so
that this function can run in a time (otherwise) independent
of the number of colors in the colormap.  This avoids a
brute-force search for the closest colormap color to each
pixel in the image.
(6) This is similar to the function pixAssignToNearestColor()
used for color segmentation.
(7) Except for very small images or when using level > 4,
it takes very little time to generate the tables,
compared to the generation of the colormapped dest pix,
so one would not typically use the low-level version.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeQuantFromCmap(*args)
    
    

    try:
        leptonica.pixOctcubeHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixOctcubeHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOctcubeHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOctcubeHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_int32', '*pncolors')       

:param[in]    pixs:       32 bpp rgb
:param[in]    level:      significant bits for each of RGB; valid in [1...6]
:param[out]   pncolors:   [optional] number of occupied cubes
:returns:  numa histogram of color pixels, or NULL on error

<pre>
Notes:
(1) Input NULL for &ncolors to prevent computation and return value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOctcubeHistogram(*args)
    
    

    try:
        leptonica.pixcmapToOctcubeLUT.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixcmapToOctcubeLUT.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapToOctcubeLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapToOctcubeLUT(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'level')       
('l_int32', 'metric')       

:param[in]    cmap:
:param[in]    level:    significant bits for each of RGB; valid in [1...6]
:param[in]    metric:   L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE
:returns:  tab[2**3 * level]

<pre>
Notes:
(1) This function is used to quickly find the colormap color
that is closest to any rgb color.  It is used to assign
rgb colors to an existing colormap.  It can be very expensive
to search through the entire colormap for the closest color
to each pixel.  Instead, we first set up this table, which is
populated by the colormap index nearest to each octcube
color.  Then we go through the image; for each pixel,
do two table lookups: first to generate the octcube index
from rgb and second to use this table to read out the
colormap index.
(2) Do a slight modification for white and black.  For level = 4,
each octcube size is 16.  The center of the whitest octcube
is at (248, 248, 248), which is closer to 242 than 255.
Consequently, any gray color between 242 and 254 will
be selected, even if white (255, 255, 255) exists.  This is
typically not optimal, because the original color was
likely white.  Therefore, if white exists in the colormap,
use it for any rgb color that falls into the most white octcube.
Do the similar thing for black.
(3) Here are the actual function calls for quantizing to a
specified colormap:
~ first make the tables that map from rgb --> octcube index
makeRGBToIndexTables()
~ then for each pixel:
use the tables to get the octcube index
getOctcubeIndexFromRGB()
use this table to get the nearest color in the colormap
cmap_index = tab[index]
(4) Distance can be either manhattan or euclidean.
(5) In typical use, level = 4 gives reasonable results, and
level = 5 is slightly better.  When this function is used
for color segmentation, there are typically a small number
of colors and the number of levels can be small (e.g., level = 3).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapToOctcubeLUT(*args)
    
    

    try:
        leptonica.pixRemoveUnusedColors.argtypes = [ctypes.c_void_p]
        leptonica.pixRemoveUnusedColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveUnusedColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveUnusedColors(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   colormapped
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) If the image doesn't have a colormap, returns without error.
(3) Unusued colors are removed from the colormap, and the
image pixels are re-numbered.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveUnusedColors(*args)
    
    

    try:
        leptonica.pixNumberOccupiedOctcubes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixNumberOccupiedOctcubes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixNumberOccupiedOctcubes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixNumberOccupiedOctcubes(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'level')       
('l_int32', 'mincount')       
('l_float32', 'minfract')       
('l_int32', '*pncolors')       

:param[in]    pix:        32 bpp
:param[in]    level:      of octcube
:param[in]    mincount:   minimum num pixels in an octcube to be counted;
-1 to not use
:param[in]    minfract:   minimum fract of pixels in an octcube to be
counted; -1 to not use
:param[out]   pncolors:   number of occupied octcubes
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Exactly one of (%mincount, %minfract) must be -1, so, e.g.,
if %mincount == -1, then we use %minfract.
(2) If all occupied octcubes are to count, set %mincount == 1.
Setting %minfract == 0.0 is taken to mean the same thing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixNumberOccupiedOctcubes(*args)
    




class paintcmap(object):
    """<pre>

These in-place functions paint onto colormap images.

Repaint selected pixels in region
l_int32     pixSetSelectCmap()

Repaint non-white pixels in region
l_int32     pixColorGrayRegionsCmap()
l_int32     pixColorGrayCmap()
l_int32     pixColorGrayMaskedCmap()
l_int32     addColorizedGrayToCmap()

Repaint selected pixels through mask
l_int32     pixSetSelectMaskedCmap()

Repaint all pixels through mask
l_int32     pixSetMaskedCmap()


The 'set select' functions condition the setting on a specific
pixel value (i.e., index into the colormap) of the underyling
Pix that is being modified.  The same conditioning is used in
pixBlendCmap().

The pixColorGrayCmap() function sets all truly gray (r = g = b) pixels,
with the exception of either black or white pixels, to a new color.

The pixSetSelectMaskedCmap() function conditions pixel painting
on both a specific pixel value and location within the fg mask.
By contrast, pixSetMaskedCmap() sets all pixels under the
mask foreground, without considering the initial pixel values.
</pre>




"""
    
    try:
        leptonica.pixSetSelectCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetSelectCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetSelectCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetSelectCmap(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'sindex')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:              1, 2, 4 or 8 bpp, with colormap
:param[in]    box:               [optional] region to set color; can be NULL
:param[in]    sindex:            colormap index of pixels to be changed
:param[in]    rval,: gval, bval  new color to paint
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) It sets all pixels in region that have the color specified
by the colormap index %sindex to the new color.
(3) %sindex must be in the existing colormap; otherwise an
error is returned.
(4) If the new color exists in the colormap, it is used;
otherwise, it is added to the colormap.  If it cannot be
added because the colormap is full, an error is returned.
(5) If %box is NULL, applies function to the entire image; otherwise,
clips the operation to the intersection of the box and pix.
(6) An example of use would be to set to a specific color all
the light (background) pixels within a certain region of
a 3-level 2 bpp image, while leaving light pixels outside
this region unchanged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetSelectCmap(*args)
    
    

    try:
        leptonica.pixColorGrayRegionsCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayRegionsCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorGrayRegionsCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayRegionsCmap(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:               8 bpp, with colormap
:param[in]    boxa:               of regions in which to apply color
:param[in]    type:               L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    rval,: gval, bval   target color
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) If %type == L_PAINT_LIGHT, it colorizes non-black pixels,
preserving antialiasing.
If %type == L_PAINT_DARK, it colorizes non-white pixels,
preserving antialiasing.  See pixColorGrayCmap() for details.
(3) This can also be called through pixColorGrayRegions().
(4) This increases the colormap size by the number of
different gray (non-black or non-white) colors in the
selected regions of pixs.  If there is not enough room in
the colormap for this expansion, it returns 1 (error),
and the caller should check the return value.
(5) Because two boxes in %boxa can overlap, pixels that
are colorized in the first box must be excluded in the
second because their value exceeds the size of the map.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayRegionsCmap(*args)
    
    

    try:
        leptonica.pixColorGrayCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorGrayCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayCmap(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:               2, 4 or 8 bpp, with colormap
:param[in]    box:                [optional] region to set color; can be NULL
:param[in]    type:               L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    rval,: gval, bval   target color
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) If %type == L_PAINT_LIGHT, it colorizes non-black pixels,
preserving antialiasing.
If %type == L_PAINT_DARK, it colorizes non-white pixels,
preserving antialiasing.
(3) %box gives the region to apply color; if NULL, this
colorizes the entire image.
(4) If the cmap is only 2 or 4 bpp, pixs is converted in-place
to an 8 bpp cmap.  A 1 bpp cmap is not a valid input pix.
(5) This can also be called through pixColorGray().
(6) This operation increases the colormap size by the number of
different gray (non-black or non-white) colors in the
input colormap.  If there is not enough room in the colormap
for this expansion, it returns 1 (error), and the caller
should check the return value.
(7) Using the darkness of each original pixel in the rect,
it generates a new color (based on the input rgb values).
If %type == L_PAINT_LIGHT, the new color is a (generally)
darken-to-black version of the input rgb color, where the
amount of darkening increases with the darkness of the
original pixel color.
If %type == L_PAINT_DARK, the new color is a (generally)
faded-to-white version of the input rgb color, where the
amount of fading increases with the brightness of the
original pixel color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayCmap(*args)
    
    

    try:
        leptonica.pixColorGrayMaskedCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayMaskedCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorGrayMaskedCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayMaskedCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:               8 bpp, with colormap
:param[in]    pixm:               1 bpp mask, through which to apply color
:param[in]    type:               L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    rval,: gval, bval   target color
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) If %type == L_PAINT_LIGHT, it colorizes non-black pixels,
preserving antialiasing.
If %type == L_PAINT_DARK, it colorizes non-white pixels,
preserving antialiasing.  See pixColorGrayCmap() for details.
(3) This increases the colormap size by the number of
different gray (non-black or non-white) colors in the
input colormap.  If there is not enough room in the colormap
for this expansion, it returns 1 (error).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayMaskedCmap(*args)
    
    

    try:
        leptonica.addColorizedGrayToCmap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.addColorizedGrayToCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function addColorizedGrayToCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def addColorizedGrayToCmap(*args):
        """
        ('PIXCMAP', '*cmap')       
('l_int32', 'type')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('NUMA', '**pna')       

:param[in]    cmap:              from 2 or 4 bpp pix
:param[in]    type:              L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    rval,: gval, bval  target color
:param[out]   pna:               [optional] table for mapping new cmap entries
:returns:  0 if OK; 1 on error; 2 if new colors will not fit in cmap.

<pre>
Notes:
(1) If %type == L_PAINT_LIGHT, it colorizes non-black pixels,
preserving antialiasing.
If %type == L_PAINT_DARK, it colorizes non-white pixels,
preserving antialiasing.
(2) This increases the colormap size by the number of
different gray (non-black or non-white) colors in the
input colormap.  If there is not enough room in the colormap
for this expansion, it returns 1 (treated as a warning);
the caller should check the return value.
(3) This can be used to determine if the new colors will fit in
the cmap, using null for &na.  Returns 0 if they fit; 2 if
they don't fit.
(4) The mapping table contains, for each gray color found, the
index of the corresponding colorized pixel.  Non-gray
pixels are assigned the invalid index 256.
(5) See pixColorGrayCmap() for usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.addColorizedGrayToCmap(*args)
    
    

    try:
        leptonica.pixSetSelectMaskedCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetSelectMaskedCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetSelectMaskedCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetSelectMaskedCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'sindex')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:               2, 4 or 8 bpp, with colormap
:param[in]    pixm:               [optional] 1 bpp mask; no-op if NULL
:param[in]    x,: y               UL corner of mask relative to pixs
:param[in]    sindex:             cmap index of pixels in pixs to be changed
:param[in]    rval,: gval, bval   new color to substitute
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) This paints through the fg of pixm and replaces all pixels
in pixs that have the value %sindex with the new color.
(3) If pixm == NULL, a warning is given.
(4) %sindex must be in the existing colormap; otherwise an
error is returned.
(5) If the new color exists in the colormap, it is used;
otherwise, it is added to the colormap.  If the colormap
is full, an error is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetSelectMaskedCmap(*args)
    
    

    try:
        leptonica.pixSetMaskedCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetMaskedCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetMaskedCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMaskedCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:               2, 4 or 8 bpp, colormapped
:param[in]    pixm:               [optional] 1 bpp mask; no-op if NULL
:param[in]    x,: y               origin of pixm relative to pixs;
can be negative
:param[in]    rval,: gval, bval   new color to set at each masked pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) It paints a single color through the mask (as a stencil).
(3) The mask origin is placed at (%x,%y) on %pixs, and the
operation is clipped to the intersection of the mask and pixs.
(4) If %pixm == NULL, a warning is given.
(5) Typically, %pixm is a small binary mask located somewhere
on the larger %pixs.
(6) If the color is in the colormap, it is used.  Otherwise,
it is added if possible; an error is returned if the
colormap is already full.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMaskedCmap(*args)
    




class ptabasic(object):
    """<pre>

Pta creation, destruction, copy, clone, empty
PTA            *ptaCreate()
PTA            *ptaCreateFromNuma()
void            ptaDestroy()
PTA            *ptaCopy()
PTA            *ptaCopyRange()
PTA            *ptaClone()
l_int32         ptaEmpty()

Pta array extension
l_int32         ptaAddPt()
static l_int32  ptaExtendArrays()

Pta insertion and removal
l_int32         ptaInsertPt()
l_int32         ptaRemovePt()

Pta accessors
l_int32         ptaGetRefcount()
l_int32         ptaChangeRefcount()
l_int32         ptaGetCount()
l_int32         ptaGetPt()
l_int32         ptaGetIPt()
l_int32         ptaSetPt()
l_int32         ptaGetArrays()

Pta serialized for I/O
PTA            *ptaRead()
PTA            *ptaReadStream()
PTA            *ptaReadMem()
l_int32         ptaWriteDebug()
l_int32         ptaWrite()
l_int32         ptaWriteStream()
l_int32         ptaWriteMem()

Ptaa creation, destruction
PTAA           *ptaaCreate()
void            ptaaDestroy()

Ptaa array extension
l_int32         ptaaAddPta()
static l_int32  ptaaExtendArray()

Ptaa accessors
l_int32         ptaaGetCount()
l_int32         ptaaGetPta()
l_int32         ptaaGetPt()

Ptaa array modifiers
l_int32         ptaaInitFull()
l_int32         ptaaReplacePta()
l_int32         ptaaAddPt()
l_int32         ptaaTruncate()

Ptaa serialized for I/O
PTAA           *ptaaRead()
PTAA           *ptaaReadStream()
PTAA           *ptaaReadMem()
l_int32         ptaaWrite()
l_int32         ptaaWriteStream()
l_int32         ptaaWriteMem()
</pre>




"""
    
    try:
        leptonica.ptaCreate.argtypes = [ctypes.c_int32]
        leptonica.ptaCreate.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial array sizes
:returns:  pta, or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCreate(*args)
    
    

    try:
        leptonica.ptaCreateFromNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaCreateFromNuma.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaCreateFromNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCreateFromNuma(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       

:param[in]    nax:   [optional] can be null
:param[in]    nay:
:returns:  pta, or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCreateFromNuma(*args)
    
    

    try:
        leptonica.ptaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ptaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ptaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaDestroy(*args):
        """
        ('PTA', '**ppta')       

:param[in,out]   ppta:   will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the pta.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaDestroy(*args)
    
    

    try:
        leptonica.ptaCopy.argtypes = [ctypes.c_void_p]
        leptonica.ptaCopy.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCopy(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  copy of pta, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCopy(*args)
    
    

    try:
        leptonica.ptaCopyRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaCopyRange.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaCopyRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCopyRange(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    ptas:
:param[in]    istart:    starting index in ptas
:param[in]    iend:      ending index in ptas; use 0 to copy to end
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCopyRange(*args)
    
    

    try:
        leptonica.ptaClone.argtypes = [ctypes.c_void_p]
        leptonica.ptaClone.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaClone(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  ptr to same pta, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaClone(*args)
    
    

    try:
        leptonica.ptaEmpty.argtypes = [ctypes.c_void_p]
        leptonica.ptaEmpty.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaEmpty not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaEmpty(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  0 if OK, 1 on error

<pre>
Notes:
This only resets the Pta::n field, for reuse
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaEmpty(*args)
    
    

    try:
        leptonica.ptaAddPt.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.ptaAddPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaAddPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaAddPt(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'x')       
('l_float32', 'y')       

:param[in]    pta:
:param[in]    x,: y
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaAddPt(*args)
    
    

    try:
        leptonica.ptaInsertPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaInsertPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaInsertPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaInsertPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pta:
:param[in]    index:   at which pt is to be inserted
:param[in]    x,: y    point values
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaInsertPt(*args)
    
    

    try:
        leptonica.ptaRemovePt.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaRemovePt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaRemovePt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRemovePt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       

:param[in]    pta:
:param[in]    index:    of point to be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts pta[i] --> pta[i - 1] for all i > index.
(2) It should not be used repeatedly on large arrays,
because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRemovePt(*args)
    
    

    try:
        leptonica.ptaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.ptaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetCount(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  count, or 0 if no pta


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetCount(*args)
    
    

    try:
        leptonica.ptaGetPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_float32', '*px')       
('l_float32', '*py')       

:param[in]    pta:
:param[in]    index:    into arrays
:param[out]   px:       [optional] float x value
:param[out]   py:       [optional] float y value
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetPt(*args)
    
    

    try:
        leptonica.ptaGetIPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetIPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetIPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetIPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       

:param[in]    pta:
:param[in]    index:    into arrays
:param[out]   px:       [optional] integer x value
:param[out]   py:       [optional] integer y value
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetIPt(*args)
    
    

    try:
        leptonica.ptaSetPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.ptaSetPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaSetPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSetPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'index')       
('l_float32', 'x')       
('l_float32', 'y')       

:param[in]    pta:
:param[in]    index:    into arrays
:param[in]    x,: y
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSetPt(*args)
    
    

    try:
        leptonica.ptaGetArrays.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetArrays.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetArrays(*args):
        """
        ('PTA', '*pta')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       

:param[in]    pta:
:param[out]   pnax:    [optional] numa of x array
:param[out]   pnay:    [optional] numa of y array
:returns:  0 if OK; 1 on error or if pta is empty

<pre>
Notes:
(1) This copies the internal arrays into new Numas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetArrays(*args)
    
    

    try:
        leptonica.ptaRead.argtypes = [ctypes.c_char_p]
        leptonica.ptaRead.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  pta, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRead(*args)
    
    

    try:
        leptonica.ptaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.ptaReadStream.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  pta, or NULL on error

<pre>
Notes:
(1) It is OK for the pta to be empty (n == 0).
</pre>



        """
        args = _convert_params(*args)
        
        return leptonica.ptaReadStream(*args)
    
    

    try:
        leptonica.ptaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.ptaReadMem.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    serialization in ascii
:param[in]    size:    of data in bytes; can use strlen to get it
:returns:  pta, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaReadMem(*args)
    
    

    try:
        leptonica.ptaWriteDebug.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaWriteDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaWriteDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaWriteDebug(*args):
        """
        ('const char', '*filename')       
('PTA', '*pta')       
('l_int32', 'type')       

:param[in]    filename:
:param[in]    pta:
:param[in]    type:       0 for float values; 1 for integer values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Debug version, intended for use in the library when writing
to files in a temp directory with names that are compiled in.
This is used instead of ptaWrite() for all such library calls.
(2) The global variable LeptDebugOK defaults to 0, and can be set
or cleared by the function setLeptDebugOK().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaWriteDebug(*args)
    
    

    try:
        leptonica.ptaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaWrite(*args):
        """
        ('const char', '*filename')       
('PTA', '*pta')       
('l_int32', 'type')       

:param[in]    filename:
:param[in]    pta:
:param[in]    type:       0 for float values; 1 for integer values
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaWrite(*args)
    
    

    try:
        leptonica.ptaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PTA', '*pta')       
('l_int32', 'type')       

:param[in]    fp:      file stream
:param[in]    pta:
:param[in]    type:    0 for float values; 1 for integer values
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaWriteStream(*args)
    
    

    try:
        leptonica.ptaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PTA', '*pta')       
('l_int32', 'type')       

:param[out]   pdata:    data of serialized pta; ascii
:param[out]   psize:    size of returned data
:param[in]    pta:
:param[in]    type:     0 for float values; 1 for integer values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a pta in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaWriteMem(*args)
    
    

    try:
        leptonica.ptaaCreate.argtypes = [ctypes.c_int32]
        leptonica.ptaaCreate.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial number of ptrs
:returns:  ptaa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaCreate(*args)
    
    

    try:
        leptonica.ptaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ptaaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaDestroy(*args):
        """
        ('PTAA', '**pptaa')       

:param[in,out]   pptaa:   will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaDestroy(*args)
    
    

    try:
        leptonica.ptaaAddPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaAddPta.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaAddPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaAddPta(*args):
        """
        ('PTAA', '*ptaa')       
('PTA', '*pta')       
('l_int32', 'copyflag')       

:param[in]    ptaa:
:param[in]    pta:         to be added
:param[in]    copyflag:    L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaAddPta(*args)
    
    

    try:
        leptonica.ptaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.ptaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function ptaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetCount(*args):
        """
        ('PTAA', '*ptaa')       

:param[in]    ptaa:
:returns:  count, or 0 if no ptaa


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetCount(*args)
    
    

    try:
        leptonica.ptaaGetPta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaaGetPta.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaGetPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetPta(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    ptaa:
:param[in]    index:         to the i-th pta
:param[in]    accessflag:    L_COPY or L_CLONE
:returns:  pta, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetPta(*args)
    
    

    try:
        leptonica.ptaaGetPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaGetPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaGetPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetPt(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'ipta')       
('l_int32', 'jpt')       
('l_float32', '*px')       
('l_float32', '*py')       

:param[in]    ptaa:
:param[in]    ipta:   to the i-th pta
:param[in]    jpt:    index to the j-th pt in the pta
:param[out]   px:     [optional] float x value
:param[out]   py:     [optional] float y value
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetPt(*args)
    
    

    try:
        leptonica.ptaaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaInitFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaInitFull(*args):
        """
        ('PTAA', '*ptaa')       
('PTA', '*pta')       

:param[in]    ptaa:    can have non-null ptrs in the ptr array
:param[in]    pta:     to be replicated into the entire ptr array
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaInitFull(*args)
    
    

    try:
        leptonica.ptaaReplacePta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaaReplacePta.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaReplacePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaReplacePta(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'index')       
('PTA', '*pta')       

:param[in]    ptaa:
:param[in]    index:   to the index-th pta
:param[in]    pta:     insert and replace any existing one
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Any existing pta is destroyed, and the input one
is inserted in its place.
(2) If %index is invalid, return 1 (error)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaReplacePta(*args)
    
    

    try:
        leptonica.ptaaAddPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.ptaaAddPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaAddPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaAddPt(*args):
        """
        ('PTAA', '*ptaa')       
('l_int32', 'ipta')       
('l_float32', 'x')       
('l_float32', 'y')       

:param[in]    ptaa:
:param[in]    ipta:   to the i-th pta
:param[in]    x,y:    point coordinates
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaAddPt(*args)
    
    

    try:
        leptonica.ptaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.ptaaTruncate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaTruncate(*args):
        """
        ('PTAA', '*ptaa')       

:param[in]    ptaa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This identifies the largest index containing a pta that
has any points within it, destroys all pta above that index,
and resets the count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaTruncate(*args)
    
    

    try:
        leptonica.ptaaRead.argtypes = [ctypes.c_char_p]
        leptonica.ptaaRead.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  ptaa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaRead(*args)
    
    

    try:
        leptonica.ptaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.ptaaReadStream.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  ptaa, or NULL on error

<pre>
Notes:
(1) It is OK for the ptaa to be empty (n == 0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaReadStream(*args)
    
    

    try:
        leptonica.ptaaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.ptaaReadMem.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    serialization in ascii
:param[in]    size:    of data in bytes; can use strlen to get it
:returns:  ptaa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaReadMem(*args)
    
    

    try:
        leptonica.ptaaWriteDebug.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaWriteDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaWriteDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaWriteDebug(*args):
        """
        ('const char', '*filename')       
('PTAA', '*ptaa')       
('l_int32', 'type')       

:param[in]    filename:
:param[in]    ptaa:
:param[in]    type:      0 for float values; 1 for integer values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Debug version, intended for use in the library when writing
to files in a temp directory with names that are compiled in.
This is used instead of ptaaWrite() for all such library calls.
(2) The global variable LeptDebugOK defaults to 0, and can be set
or cleared by the function setLeptDebugOK().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaWriteDebug(*args)
    
    

    try:
        leptonica.ptaaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaWrite(*args):
        """
        ('const char', '*filename')       
('PTAA', '*ptaa')       
('l_int32', 'type')       

:param[in]    filename:
:param[in]    ptaa:
:param[in]    type:      0 for float values; 1 for integer values
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaWrite(*args)
    
    

    try:
        leptonica.ptaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PTAA', '*ptaa')       
('l_int32', 'type')       

:param[in]    fp:      file stream
:param[in]    ptaa:
:param[in]    type:    0 for float values; 1 for integer values
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaWriteStream(*args)
    
    

    try:
        leptonica.ptaaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PTAA', '*ptaa')       
('l_int32', 'type')       

:param[out]   pdata:    data of serialized ptaa; ascii
:param[out]   psize:    size of returned data
:param[in]    ptaa:
:param[in]    type:     0 for float values; 1 for integer values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes %ptaa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaWriteMem(*args)
    




class shear(object):
    """<pre>

About arbitrary lines
PIX      *pixHShear()
PIX      *pixVShear()

About special 'points': UL corner and center
PIX      *pixHShearCorner()
PIX      *pixVShearCorner()
PIX      *pixHShearCenter()
PIX      *pixVShearCenter()

In place about arbitrary lines
l_int32   pixHShearIP()
l_int32   pixVShearIP()

Linear interpolated shear about arbitrary lines
PIX      *pixHShearLI()
PIX      *pixVShearLI()

Static helper
static l_float32  normalizeAngleForShear()
</pre>




"""
    
    try:
        leptonica.pixHShear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShear(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'yloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixd:      [optional] this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:      any depth; cmap ok
:param[in]    yloc:      location of horizontal line, measured from origin
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, always

<pre>
Notes:
(1) There are 3 cases:
(a) pixd == null (make a new pixd)
(b) pixd == pixs (in-place)
(c) pixd != pixs
(2) For these three cases, use these patterns, respectively:
pixd = pixHShear(NULL, pixs, ...);
pixHShear(pixs, pixs, ...);
pixHShear(pixd, pixs, ...);
(3) This shear leaves the horizontal line of pixels at y = yloc
invariant.  For a positive shear angle, pixels above this
line are shoved to the right, and pixels below this line
move to the left.
(4) With positive shear angle, this can be used, along with
pixVShear(), to perform a cw rotation, either with 2 shears
(for small angles) or in the general case with 3 shears.
(5) Changing the value of yloc is equivalent to translating
the result horizontally.
(6) This brings in %incolor pixels from outside the image.
(7) In-place shears do not work on cmapped pix, because the
in-place operation cannot initialize to the requested %incolor,
so we shear from a copy.
(8) The angle is brought into the range [-pi, -pi].  It is
not permitted to be within MinDiffFromHalfPi radians
from either -pi/2 or pi/2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShear(*args)
    
    

    try:
        leptonica.pixVShear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShear(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'xloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixd:      [optional], this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:      any depth; cmap ok
:param[in]    xloc:      location of vertical line, measured from origin
:param[in]    radang:    angle in radians; not too close to +-(pi / 2)
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) There are 3 cases:
(a) pixd == null (make a new pixd)
(b) pixd == pixs (in-place)
(c) pixd != pixs
(2) For these three cases, use these patterns, respectively:
pixd = pixVShear(NULL, pixs, ...);
pixVShear(pixs, pixs, ...);
pixVShear(pixd, pixs, ...);
(3) This shear leaves the vertical line of pixels at x = xloc
invariant.  For a positive shear angle, pixels to the right
of this line are shoved downward, and pixels to the left
of the line move upward.
(4) With positive shear angle, this can be used, along with
pixHShear(), to perform a cw rotation, either with 2 shears
(for small angles) or in the general case with 3 shears.
(5) Changing the value of xloc is equivalent to translating
the result vertically.
(6) This brings in %incolor pixels from outside the image.
(7) In-place shears do not work on cmapped pix, because the
in-place operation cannot initialize to the requested %incolor,
so we shear from a copy.
(8) The angle is brought into the range [-pi, -pi].  It is
not permitted to be within MinDiffFromHalfPi radians
from either -pi/2 or pi/2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShear(*args)
    
    

    try:
        leptonica.pixHShearCorner.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearCorner.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHShearCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearCorner(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixd:      [optional], if not null, must be equal to pixs
:param[in]    pixs:      any depth
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) See pixHShear() for usage.
(2) This does a horizontal shear about the UL corner, with (+) shear
pushing increasingly leftward (-x) with increasing y.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearCorner(*args)
    
    

    try:
        leptonica.pixVShearCorner.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearCorner.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVShearCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearCorner(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixd:      [optional], if not null, must be equal to pixs
:param[in]    pixs:      any depth
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) See pixVShear() for usage.
(2) This does a vertical shear about the UL corner, with (+) shear
pushing increasingly downward (+y) with increasing x.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearCorner(*args)
    
    

    try:
        leptonica.pixHShearCenter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearCenter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHShearCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearCenter(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixd:      [optional] if not null, must be equal to pixs
:param[in]    pixs:      any depth
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) See pixHShear() for usage.
(2) This does a horizontal shear about the center, with (+) shear
pushing increasingly leftward (-x) with increasing y.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearCenter(*args)
    
    

    try:
        leptonica.pixVShearCenter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearCenter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVShearCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearCenter(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixd:      [optional] if not null, must be equal to pixs
:param[in]    pixs:      any depth
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) See pixVShear() for usage.
(2) This does a vertical shear about the center, with (+) shear
pushing increasingly downward (+y) with increasing x.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearCenter(*args)
    
    

    try:
        leptonica.pixHShearIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearIP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixHShearIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearIP(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'yloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixs:      any depth; no cmap
:param[in]    yloc:      location of horizontal line, measured from origin
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place version of pixHShear(); see comments there.
(2) This brings in 'incolor' pixels from outside the image.
(3) pixs cannot be colormapped, because the in-place operation
only blits in 0 or 1 bits, not an arbitrary colormap index.
(4) Does a horizontal full-band shear about the line with (+) shear
pushing increasingly leftward (-x) with increasing y.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearIP(*args)
    
    

    try:
        leptonica.pixVShearIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearIP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixVShearIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearIP(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixs:      any depth; no cmap
:param[in]    xloc:      location of vertical line, measured from origin
:param[in]    radang:    angle in radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place version of pixVShear(); see comments there.
(2) This brings in 'incolor' pixels from outside the image.
(3) pixs cannot be colormapped, because the in-place operation
only blits in 0 or 1 bits, not an arbitrary colormap index.
(4) Does a vertical full-band shear about the line with (+) shear
pushing increasingly downward (+y) with increasing x.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearIP(*args)
    
    

    try:
        leptonica.pixHShearLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixHShearLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHShearLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHShearLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'yloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixs:      8 bpp or 32 bpp, or colormapped
:param[in]    yloc:      location of horizontal line, measured from origin
:param[in]    radang:    angle in radians, in range (-pi/2 ... pi/2)
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd sheared, or NULL on error

<pre>
Notes:
(1) This does horizontal shear with linear interpolation for
accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
It is relatively slow compared to the sampled version
implemented by rasterop, but the result is much smoother.
(2) This shear leaves the horizontal line of pixels at y = yloc
invariant.  For a positive shear angle, pixels above this
line are shoved to the right, and pixels below this line
move to the left.
(3) Any colormap is removed.
(4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
where del == MinDiffFromHalfPi.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHShearLI(*args)
    
    

    try:
        leptonica.pixVShearLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixVShearLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVShearLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVShearLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xloc')       
('l_float32', 'radang')       
('l_int32', 'incolor')       

:param[in]    pixs:      8 bpp or 32 bpp, or colormapped
:param[in]    xloc:      location of vertical line, measured from origin
:param[in]    radang:    angle in radians, in range (-pi/2 ... pi/2)
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd sheared, or NULL on error

<pre>
Notes:
(1) This does vertical shear with linear interpolation for
accurate results on 8 bpp gray, 32 bpp rgb, or cmapped images.
It is relatively slow compared to the sampled version
implemented by rasterop, but the result is much smoother.
(2) This shear leaves the vertical line of pixels at x = xloc
invariant.  For a positive shear angle, pixels to the right
of this line are shoved downward, and pixels to the left
of the line move upward.
(3) Any colormap is removed.
(4) The angle is brought into the range [-pi/2 + del, pi/2 - del],
where del == MinDiffFromHalfPi.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVShearLI(*args)
    




class arrayaccess(object):
    """<pre>

Access within an array of 32-bit words

l_int32     l_getDataBit()
void        l_setDataBit()
void        l_clearDataBit()
void        l_setDataBitVal()
l_int32     l_getDataDibit()
void        l_setDataDibit()
void        l_clearDataDibit()
l_int32     l_getDataQbit()
void        l_setDataQbit()
void        l_clearDataQbit()
l_int32     l_getDataByte()
void        l_setDataByte()
l_int32     l_getDataTwoBytes()
void        l_setDataTwoBytes()
l_int32     l_getDataFourBytes()
void        l_setDataFourBytes()

Note that these all require 32-bit alignment, and hence an input
ptr to l_uint32.  However, this is not enforced by the compiler.
Instead, we allow the use of a void* ptr, because the line ptrs
are an efficient way to get random access (see pixGetLinePtrs()).
It is then necessary to cast internally within each function
because ptr arithmetic requires knowing the size of the units
being referenced.
</pre>




"""
    
    try:
        leptonica.l_getDataBit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataBit.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getDataBit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataBit(*args):
        """
        ('const void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  val of the nth 1-bit pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataBit(*args)
    
    

    try:
        leptonica.l_setDataBit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_setDataBit.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataBit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataBit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  void

Action: sets the pixel to 1


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataBit(*args)
    
    

    try:
        leptonica.l_clearDataBit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_clearDataBit.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_clearDataBit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_clearDataBit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  void

Action: sets the 1-bit pixel to 0


        """
        args = _convert_params(*args)
        
        return leptonica.l_clearDataBit(*args)
    
    

    try:
        leptonica.l_setDataBitVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataBitVal.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataBitVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataBitVal(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:param[in]    val:   val to be inserted: 0 or 1
:returns:  void

<pre>
Notes:
(1) This is an accessor for a 1 bpp pix.
(2) It is actually a little slower than using:
if (val == 0)
l_ClearDataBit(line, n);
else
l_SetDataBit(line, n);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataBitVal(*args)
    
    

    try:
        leptonica.l_getDataDibit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataDibit.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getDataDibit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataDibit(*args):
        """
        ('const void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  val of the nth 2-bit pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataDibit(*args)
    
    

    try:
        leptonica.l_setDataDibit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataDibit.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataDibit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataDibit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:param[in]    val:   val to be inserted: 0 - 3
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataDibit(*args)
    
    

    try:
        leptonica.l_clearDataDibit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_clearDataDibit.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_clearDataDibit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_clearDataDibit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  void

Action: sets the 2-bit pixel to 0


        """
        args = _convert_params(*args)
        
        return leptonica.l_clearDataDibit(*args)
    
    

    try:
        leptonica.l_getDataQbit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataQbit.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getDataQbit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataQbit(*args):
        """
        ('const void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  val of the nth 4-bit pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataQbit(*args)
    
    

    try:
        leptonica.l_setDataQbit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataQbit.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataQbit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataQbit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:param[in]    val:   val to be inserted: 0 - 0xf
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataQbit(*args)
    
    

    try:
        leptonica.l_clearDataQbit.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_clearDataQbit.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_clearDataQbit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_clearDataQbit(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  void

Action: sets the 4-bit pixel to 0


        """
        args = _convert_params(*args)
        
        return leptonica.l_clearDataQbit(*args)
    
    

    try:
        leptonica.l_getDataByte.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataByte.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getDataByte not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataByte(*args):
        """
        ('const void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  value of the n-th byte pixel


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataByte(*args)
    
    

    try:
        leptonica.l_setDataByte.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataByte.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataByte not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataByte(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:param[in]    val:   val to be inserted: 0 - 0xff
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataByte(*args)
    
    

    try:
        leptonica.l_getDataTwoBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataTwoBytes.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getDataTwoBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataTwoBytes(*args):
        """
        ('const void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  value of the n-th 2-byte pixel


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataTwoBytes(*args)
    
    

    try:
        leptonica.l_setDataTwoBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataTwoBytes.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataTwoBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataTwoBytes(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:param[in]    val:   val to be inserted: 0 - 0xffff
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataTwoBytes(*args)
    
    

    try:
        leptonica.l_getDataFourBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_getDataFourBytes.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getDataFourBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getDataFourBytes(*args):
        """
        ('const void', '*line')       
('l_int32', 'n')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:returns:  value of the n-th 4-byte pixel


        """
        args = _convert_params(*args)
        
        return leptonica.l_getDataFourBytes(*args)
    
    

    try:
        leptonica.l_setDataFourBytes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setDataFourBytes.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setDataFourBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setDataFourBytes(*args):
        """
        ('void', '*line')       
('l_int32', 'n')       
('l_int32', 'val')       

:param[in]    line:  ptr to beginning of data line
:param[in]    n:     pixel index
:param[in]    val:   val to be inserted: 0 - 0xffffffff
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_setDataFourBytes(*args)
    




class colorquant2(object):
    """<pre>

Modified median cut color quantization

High level
PIX              *pixMedianCutQuant()
PIX              *pixMedianCutQuantGeneral()
PIX              *pixMedianCutQuantMixed()
PIX              *pixFewColorsMedianCutQuantMixed()

Median cut indexed histogram
l_int32          *pixMedianCutHisto()

Static helpers
static PIXCMAP   *pixcmapGenerateFromHisto()
static PIX       *pixQuantizeWithColormap()
static void       getColorIndexMedianCut()
static L_BOX3D   *pixGetColorRegion()
static l_int32    medianCutApply()
static PIXCMAP   *pixcmapGenerateFromMedianCuts()
static l_int32    vboxGetAverageColor()
static l_int32    vboxGetCount()
static l_int32    vboxGetVolume()
static L_BOX3D   *box3dCreate();
static L_BOX3D   *box3dCopy();

Paul Heckbert published the median cut algorithm, "Color Image
Quantization for Frame Buffer Display," in Proc. SIGGRAPH '82,
Boston, July 1982, pp. 297-307.  See:
http://delivery.acm.org/10.1145/810000/801294/p297-heckbert.pdf

Median cut starts with either the full color space or the occupied
region of color space.  If you're not dithering, the occupied region
can be used, but with dithering, pixels can end up in any place
in the color space, so you must represent the entire color space in
the final colormap.

Color components are quantized to typically 5 or 6 significant
bits (for each of r, g and b).   Call a 3D region of color
space a 'vbox'.  Any color in this quantized space is represented
by an element of a linear histogram array, indexed by rgb value.
The initial region is then divided into two regions that have roughly
equal pixel occupancy (hence the name "median cut").  Subdivision
continues until the requisite number of vboxes has been generated.

But the devil is in the details of the subdivision process.
Here are some choices that you must make:
(1) Along which axis to subdivide?
(2) Which box to put the bin with the median pixel?
(3) How to order the boxes for subdivision?
(4) How to adequately handle boxes with very small numbers of pixels?
(5) How to prevent a little-represented but highly visible color
from being masked out by other colors in its vbox.

Taking these in order:
(1) Heckbert suggests using either the largest vbox side, or the vbox
side with the largest variance in pixel occupancy.  We choose
to divide based on the largest vbox side.
(2) Suppose you've chosen a side.  Then you have a histogram
of pixel occupancy in 2D slices of the vbox.  One of those
slices includes the median pixel.  Suppose there are L bins
to the left (smaller index) and R bins to the right.  Then
this slice (or bin) should be assigned to the box containing
the smaller of L and R.  This both shortens the larger
of the subdivided dimensions and helps a low-count color
far from the subdivision boundary to better express itself.
(2a) One can also ask if the boundary should be moved even
farther into the longer side.  This is feasible if we have
a method for doing extra subdivisions on the high count
vboxes.  And we do (see (3)).
(3) To make sure that the boxes are subdivided toward equal
occupancy, use an occupancy-sorted priority queue, rather
than a simple queue.
(4) With a priority queue, boxes with small number of pixels
won't be repeatedly subdivided.  This is good.
(5) Use of a priority queue allows tricks such as in (2a) to let
small occupancy clusters be better expressed.  In addition,
rather than splitting near the median, small occupancy colors
are best reproduced by cutting half-way into the longer side.

However, serious problems can arise with dithering if a priority
queue is used based on population alone.  If the picture has
large regions of nearly constant color, some vboxes can be very
large and have a sizeable population (but not big enough to get to
the head of the queue).  If one of these large, occupied vboxes
is near in color to a nearly constant color region of the
image, dithering can inject pixels from the large vbox into
the nearly uniform region.  These pixels can be very far away
in color, and the oscillations are highly visible.  To prevent
this, we can take either or both of these actions:

(1) Subdivide a fraction (< 1.0) based on population, and
do the rest of the subdivision based on the product of
the vbox volume and its population.  By using the product,
we avoid further subdivision of nearly empty vboxes, and
directly target large vboxes with significant population.

(2) Threshold the excess color transferred in dithering to
neighboring pixels.

Doing either of these will stop the most annoying oscillations
in dithering.  Furthermore, by doing (1), we also improve the
rendering of regions of nearly constant color, both with and
without dithering.  It turns out that the image quality is
not sensitive to the value of the parameter in (1); values
between 0.3 and 0.9 give very good results.

Here's the lesson: subdivide the color space into vboxes such
that (1) the most populated vboxes that can be further
subdivided (i.e., that occupy more than one quantum volume
in color space) all have approximately the same population,
and (2) all large vboxes have no significant population.
If these conditions are met, the quantization will be excellent.

Once the subdivision has been made, the colormap is generated,
with one color for each vbox and using the average color in the vbox.
At the same time, the histogram array is converted to an inverse
colormap table, storing the colormap index in every cell in the
vbox.  Finally, using both the colormap and the inverse colormap,
a colormapped pix is quickly generated from the original rgb pix.

In the present implementation, subdivided regions of colorspace
that are not occupied are retained, but not further subdivided.
This is required for our inverse colormap lookup table for
dithering, because dithered pixels may fall into these unoccupied
regions.  For such empty regions, we use the center as the rgb
colormap value.

This variation on median cut can be referred to as "Modified Median
Cut" quantization, or MMCQ.  Overall, the undithered MMCQ gives
comparable results to the two-pass Octcube Quantizer (OQ).
Comparing the two methods on the test24.jpg painting, we see:

(1) For rendering spot color (the various reds and pinks in
the image), MMCQ is not as good as OQ.

(2) For rendering majority color regions, MMCQ does a better
job of avoiding posterization.  That is, it does better
dividing the color space up in the most heavily populated regions.
</pre>




"""
    
    try:
        leptonica.pixMedianCutQuant.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMedianCutQuant.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMedianCutQuant not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutQuant(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       

:param[in]    pixs:         32 bpp; rgb color
:param[in]    ditherflag:   1 for dither; 0 for no dither
:returns:  pixd 8 bit with colormap, or NULL on error

<pre>
Notes:
(1) Simple interface.  See pixMedianCutQuantGeneral() for
use of defaulted parameters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutQuant(*args)
    
    

    try:
        leptonica.pixMedianCutQuantGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianCutQuantGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMedianCutQuantGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutQuantGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       
('l_int32', 'outdepth')       
('l_int32', 'maxcolors')       
('l_int32', 'sigbits')       
('l_int32', 'maxsub')       
('l_int32', 'checkbw')       

:param[in]    pixs:         32 bpp; rgb color
:param[in]    ditherflag:   1 for dither; 0 for no dither
:param[in]    outdepth:     output depth; valid: 0, 1, 2, 4, 8
:param[in]    maxcolors:    between 2 and 256
:param[in]    sigbits:      valid: 5 or 6; use 0 for default
:param[in]    maxsub:       max subsampling, integer; use 0 for default;
1 for no subsampling
:param[in]    checkbw:      1 to check if color content is very small,
0 to assume there is sufficient color
:returns:  pixd   8 bit with colormap, or NULL on error

<pre>
Notes:
(1) %maxcolors must be in the range [2 ... 256].
(2) Use %outdepth = 0 to have the output depth computed as the
minimum required to hold the actual colors found, given
the %maxcolors constraint.
(3) Use %outdepth = 1, 2, 4 or 8 to specify the output depth.
In that case, %maxcolors must not exceed 2^(outdepth).
(4) If there are fewer quantized colors in the image than %maxcolors,
the colormap is simply generated from those colors.
(5) %maxsub is the maximum allowed subsampling to be used in the
computation of the color histogram and region of occupied
color space.  The subsampling is chosen internally for
efficiency, based on the image size, but this parameter
limits it.  Use %maxsub = 0 for the internal default, which is the
maximum allowed subsampling.  Use %maxsub = 1 to prevent
subsampling.  In general use %maxsub >= 1 to specify the
maximum subsampling to be allowed, where the actual subsampling
will be the minimum of this value and the internally
determined default value.
(6) %sigbits can be 5 or 6.  There are 2^24 colors in the color space.
sigbits     # of volume elems    # of colors in a volume elem
--------------------------------------------------------------
5              2^15                  2^9 = 512
6              2^18                  2^6 = 64
Volume in color space is measured in the number of volume elements.
(7) If the image appears gray because either most of the pixels
are gray or most of the pixels are essentially black or white,
the image is trivially quantized with a grayscale colormap.  The
reason is that median cut divides the color space into rectangular
regions, and it does a very poor job if all the pixels are
near the diagonal of the color space cube.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutQuantGeneral(*args)
    
    

    try:
        leptonica.pixMedianCutQuantMixed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianCutQuantMixed.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMedianCutQuantMixed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutQuantMixed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncolor')       
('l_int32', 'ngray')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       

:param[in]    pixs:          32 bpp; rgb color
:param[in]    ncolor:        maximum number of colors assigned to
pixels with significant color
:param[in]    ngray:          number of gray colors to be used; must be >= 2
:param[in]    darkthresh:    threshold near black; if the lightest component
is below this, the pixel is not considered to
be gray or color; uses 0 for default
:param[in]    lightthresh:   threshold near white; if the darkest component
is above this, the pixel is not considered to
be gray or color; use 0 for default
:param[in]    diffthresh:    thresh for the max difference between component
values; for differences below this, the pixel
is considered to be gray; use 0 for default
:returns:  pixd   8 bpp cmapped, or NULL on error

<pre>
Notes:
(1) ncolor + ngray must not exceed 255.
(2) The method makes use of pixMedianCutQuantGeneral() with
minimal addition.
(a) Preprocess the image, setting all pixels with little color
to black, and populating an auxiliary 8 bpp image with the
expected colormap values corresponding to the set of
quantized gray values.
(b) Color quantize the altered input image to n + 1 colors.
(c) Augment the colormap with the gray indices, and
substitute the gray quantized values from the auxiliary
image for those in the color quantized output that had
been quantized as black.
(3) Median cut color quantization is relatively poor for grayscale
images with many colors, when compared to octcube quantization.
Thus, for images with both gray and color, it is important
to quantize the gray pixels by another method.  Here, we
are conservative in detecting color, preferring to use
a few extra bits to encode colorful pixels that push them
to gray.  This is particularly reasonable with this function,
because it handles the gray and color pixels separately,
using median cut color quantization for the color pixels
and equal-bin grayscale quantization for the non-color pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutQuantMixed(*args)
    
    

    try:
        leptonica.pixFewColorsMedianCutQuantMixed.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFewColorsMedianCutQuantMixed.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFewColorsMedianCutQuantMixed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFewColorsMedianCutQuantMixed(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ncolor')       
('l_int32', 'ngray')       
('l_int32', 'maxncolors')       
('l_int32', 'darkthresh')       
('l_int32', 'lightthresh')       
('l_int32', 'diffthresh')       

:param[in]    pixs:          32 bpp rgb
:param[in]    ncolor:        number of colors to be assigned to pixels
with significant color
:param[in]    ngray:         number of gray colors to be used; must be >= 2
:param[in]    maxncolors:    maximum number of colors to be returned from
pixColorsForQuantization(); use 0 for default
:param[in]    darkthresh:    threshold near black; if the lightest component
is below this, the pixel is not considered to
be gray or color; use 0 for default
:param[in]    lightthresh:   threshold near white; if the darkest component
is above this, the pixel is not considered to
be gray or color; use 0 for default
:param[in]    diffthresh:    thresh for the max difference between component
values; for differences below this, the pixel
is considered to be gray; use 0 for default
:returns:  pixd   8 bpp, median cut quantized for pixels that are
not gray; gray pixels are quantized separately over
the full gray range; null if too many colors or on error

<pre>
Notes:
(1) This is the "few colors" version of pixMedianCutQuantMixed().
It fails (returns NULL) if it finds more than maxncolors, but
otherwise it gives the same result.
(2) Recommended input parameters are:
%maxncolors:  20
%darkthresh:  20
%lightthresh: 244
%diffthresh:  15  (any higher can miss colors differing
slightly from gray)
(3) Both ncolor and ngray should be at least equal to maxncolors.
If they're not, they are automatically increased, and a
warning is given.
(4) If very little color content is found, the input is
converted to gray and quantized in equal intervals.
(5) This can be useful for quantizing orthographically generated
images such as color maps, where there may be more than 256 colors
because of aliasing or jpeg artifacts on text or lines, but
there are a relatively small number of solid colors.
(6) Example of usage:
// Try to quantize, using default values for mixed med cut
Pix *pixq = pixFewColorsMedianCutQuantMixed(pixs, 100, 20,
0, 0, 0, 0);
if (!pixq)  // too many colors; don't quantize
pixq = pixClone(pixs);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFewColorsMedianCutQuantMixed(*args)
    
    

    try:
        leptonica.pixMedianCutHisto.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianCutHisto.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function pixMedianCutHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianCutHisto(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sigbits')       
('l_int32', 'subsample')       

:param[in]    pixs:        32 bpp; rgb color
:param[in]    sigbits:     valid: 5 or 6
:param[in]    subsample:   integer > 0
:returns:  histo    1-d array, giving the number of pixels in each
quantized region of color space, or NULL on error

<pre>
Notes:
(1) Array is indexed by (3 * sigbits) bits.  The array size
is 2^(3 * sigbits).
(2) Indexing into the array from rgb uses red sigbits as
most significant and blue as least.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianCutHisto(*args)
    




class gifio(object):
    """<pre>

Reading gif
PIX            *pixReadStreamGif()
PIX            *pixReadMemGif()
static l_int32  gifReadFunc()
static PIX     *gifToPix()

Writing gif
l_int32         pixWriteStreamGif()
l_int32         pixWriteMemGif()
static l_int32  gifWriteFunc()
static l_int32  pixToGif()

The initial version of this module was generously contribued by
Antony Dovgal.

The functions that read and write from pix to gif-compressed memory,
using gif internal functions DGifOpen() and EGifOpen() that are
available in 5.1 and later, were contributed by Tobias Peirick.

Version information:

(1) This supports the gif library, version 5.1 or later, for which
gif read-from-mem and write-to-mem allow these operations
without writing temporary files.
(2) There has never been a gif stream interface.  For versions
before 5.1, it was necessary to use a file descriptor, and to
generate a file stream from the low-level descriptor.  With the
memory interface in 5.1 that can be used on all platforms, it
is no longer necessary to use any API code with file descriptors.
(3) The public interface changed with 5.0 and with 5.1, and we
no longer support 4.6.1 and 5.0.
(4) Version 5.1.2 came out on Jan 7, 2016.  Leptonica cannot
successfully read gif files that it writes with this version;
DGifSlurp() gets an internal error from an uninitialized array
and returns failure.  The problem was fixed in 5.1.3.
</pre>




"""
    
    try:
        leptonica.pixReadStreamGif.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamGif.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamGif(*args):
        """
        ('FILE', '*fp')       

:param[in]  fp:   file stream opened for reading
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamGif(*args)
    
    

    try:
        leptonica.pixReadMemGif.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemGif.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemGif(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       

:param[in]  cdata:    const; gif-encoded
:param[in]  size:     bytes data
:returns:  pix, or NULL on error

<pre>
Notes:
(1) For libgif version >= 5.1, this uses the DGifOpen() buffer
interface.  No temp files are required.
(2) For libgif version < 5.1, it was necessary to write the compressed
data to file and read it back, and we couldn't use the GNU
runtime extension fmemopen() because libgif doesn't have a file
stream interface.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemGif(*args)
    
    

    try:
        leptonica.pixWriteStreamGif.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamGif.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamGif(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       

:param[in]  fp:    file stream opened for writing
:param[in]  pix:   1, 2, 4, 8, 16 or 32 bpp
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) All output gif have colormaps.  If the pix is 32 bpp rgb,
this quantizes the colors and writes out 8 bpp.
If the pix is 16 bpp grayscale, it converts to 8 bpp first.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamGif(*args)
    
    

    try:
        leptonica.pixWriteMemGif.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemGif.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemGif not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemGif(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       

:param[out]   pdata: data of gif compressed image
:param[out]   psize: size of returned data
:param[in]    pix:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See comments in pixReadMemGif()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemGif(*args)
    




class parseprotos(object):
    """"""
    



class ptafunc1(object):
    """<pre>

--------------------------------------
This file has these Pta utilities:
- simple rearrangements
- geometric analysis
- min/max and filtering
- least squares fitting
- interconversions with Pix and Numa
- display into a pix
--------------------------------------

Simple rearrangements
PTA      *ptaSubsample()
l_int32   ptaJoin()
l_int32   ptaaJoin()
PTA      *ptaReverse()
PTA      *ptaTranspose()
PTA      *ptaCyclicPerm()
PTA      *ptaSelectRange()

Geometric
BOX      *ptaGetBoundingRegion()
l_int32  *ptaGetRange()
PTA      *ptaGetInsideBox()
PTA      *pixFindCornerPixels()
l_int32   ptaContainsPt()
l_int32   ptaTestIntersection()
PTA      *ptaTransform()
l_int32   ptaPtInsidePolygon()
l_float32 l_angleBetweenVectors()

Min/max and filtering
l_int32   ptaGetMinMax()
PTA      *ptaSelectByValue()
PTA      *ptaCropToMask()

Least Squares Fit
l_int32   ptaGetLinearLSF()
l_int32   ptaGetQuadraticLSF()
l_int32   ptaGetCubicLSF()
l_int32   ptaGetQuarticLSF()
l_int32   ptaNoisyLinearLSF()
l_int32   ptaNoisyQuadraticLSF()
l_int32   applyLinearFit()
l_int32   applyQuadraticFit()
l_int32   applyCubicFit()
l_int32   applyQuarticFit()

Interconversions with Pix
l_int32   pixPlotAlongPta()
PTA      *ptaGetPixelsFromPix()
PIX      *pixGenerateFromPta()
PTA      *ptaGetBoundaryPixels()
PTAA     *ptaaGetBoundaryPixels()
PTAA     *ptaaIndexLabeledPixels()
PTA      *ptaGetNeighborPixLocs()

Interconversion with Numa
PTA      *numaConvertToPta1()
PTA      *numaConvertToPta2()
l_int32   ptaConvertToNuma()

Display Pta and Ptaa
PIX      *pixDisplayPta()
PIX      *pixDisplayPtaaPattern()
PIX      *pixDisplayPtaPattern()
PTA      *ptaReplicatePattern()
PIX      *pixDisplayPtaa()
</pre>




"""
    
    try:
        leptonica.ptaSubsample.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaSubsample.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaSubsample not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSubsample(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'subfactor')       

:param[in]    ptas:
:param[in]    subfactor:    subsample factor, >= 1
:returns:  ptad evenly sampled pt values from ptas, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSubsample(*args)
    
    

    try:
        leptonica.ptaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaJoin(*args):
        """
        ('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    ptad:     dest pta; add to this one
:param[in]    ptas:     source pta; add from this one
:param[in]    istart:   starting index in ptas
:param[in]    iend:     ending index in ptas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) istart < 0 is taken to mean 'read from the start' (istart = 0)
(2) iend < 0 means 'read to the end'
(3) if ptas == NULL, this is a no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaJoin(*args)
    
    

    try:
        leptonica.ptaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaJoin(*args):
        """
        ('PTAA', '*ptaad')       
('PTAA', '*ptaas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    ptaad:    dest ptaa; add to this one
:param[in]    ptaas:    source ptaa; add from this one
:param[in]    istart:   starting index in ptaas
:param[in]    iend:     ending index in ptaas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) istart < 0 is taken to mean 'read from the start' (istart = 0)
(2) iend < 0 means 'read to the end'
(3) if ptas == NULL, this is a no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaJoin(*args)
    
    

    try:
        leptonica.ptaReverse.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaReverse.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReverse(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'type')       

:param[in]    ptas:
:param[in]    type:     0 for float values; 1 for integer values
:returns:  ptad reversed pta, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaReverse(*args)
    
    

    try:
        leptonica.ptaTranspose.argtypes = [ctypes.c_void_p]
        leptonica.ptaTranspose.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaTranspose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTranspose(*args):
        """
        ('PTA', '*ptas')       

:param[in]    ptas:
:returns:  ptad with x and y values swapped, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTranspose(*args)
    
    

    try:
        leptonica.ptaCyclicPerm.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaCyclicPerm.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaCyclicPerm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCyclicPerm(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'xs')       
('l_int32', 'ys')       

:param[in]    ptas:
:param[in]    xs,: ys     start point; must be in ptas
:returns:  ptad cyclic permutation, starting and ending at (xs, ys,
or NULL on error

<pre>
Notes:
(1) Check to insure that (a) ptas is a closed path where
the first and last points are identical, and (b) the
resulting pta also starts and ends on the same point
(which in this case is (xs, ys).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCyclicPerm(*args)
    
    

    try:
        leptonica.ptaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaSelectRange.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSelectRange(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'first')       
('l_int32', 'last')       

:param[in]    ptas:
:param[in]    first:    use 0 to select from the beginning
:param[in]    last:     use -1 to select to the end
:returns:  ptad, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSelectRange(*args)
    
    

    try:
        leptonica.ptaGetBoundingRegion.argtypes = [ctypes.c_void_p]
        leptonica.ptaGetBoundingRegion.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetBoundingRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetBoundingRegion(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  box, or NULL on error

<pre>
Notes:
(1) This is used when the pta represents a set of points in
a two-dimensional image.  It returns the box of minimum
size containing the pts in the pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetBoundingRegion(*args)
    
    

    try:
        leptonica.ptaGetRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetRange(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pminx')       
('l_float32', '*pmaxx')       
('l_float32', '*pminy')       
('l_float32', '*pmaxy')       

:param[in]    pta:
:param[out]   pminx:    [optional] min value of x
:param[out]   pmaxx:    [optional] max value of x
:param[out]   pminy:    [optional] min value of y
:param[out]   pmaxy:    [optional] max value of y
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) We can use pts to represent pairs of floating values, that
are not necessarily tied to a two-dimension region.  For
example, the pts can represent a general function y(x).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetRange(*args)
    
    

    try:
        leptonica.ptaGetInsideBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetInsideBox.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetInsideBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetInsideBox(*args):
        """
        ('PTA', '*ptas')       
('BOX', '*box')       

:param[in]    ptas:    input pts
:param[in]    box:
:returns:  ptad of pts in ptas that are inside the box, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetInsideBox(*args)
    
    

    try:
        leptonica.pixFindCornerPixels.argtypes = [ctypes.c_void_p]
        leptonica.pixFindCornerPixels.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindCornerPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindCornerPixels(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1 bpp
:returns:  pta, or NULL on error

<pre>
Notes:
(1) Finds the 4 corner-most pixels, as defined by a search
inward from each corner, using a 45 degree line.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindCornerPixels(*args)
    
    

    try:
        leptonica.ptaContainsPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaContainsPt.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function ptaContainsPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaContainsPt(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pta:
:param[in]    x,: y     point
:returns:  1 if contained, 0 otherwise or on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaContainsPt(*args)
    
    

    try:
        leptonica.ptaTestIntersection.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaTestIntersection.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function ptaTestIntersection not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTestIntersection(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       

:param[in]    pta1,: pta2
:returns:  bval which is 1 if they have any elements in common;
0 otherwise or on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTestIntersection(*args)
    
    

    try:
        leptonica.ptaTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.ptaTransform.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaTransform(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    ptas:
:param[in]    shiftx,: shifty
:param[in]    scalex,: scaley
:returns:  pta, or NULL on error

<pre>
Notes:
(1) Shift first, then scale.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaTransform(*args)
    
    

    try:
        leptonica.ptaPtInsidePolygon.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.ptaPtInsidePolygon.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function ptaPtInsidePolygon not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaPtInsidePolygon(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', '*pinside')       

:param[in]    pta:       vertices of a polygon
:param[in]    x,: y      point to be tested
:param[out]   pinside:   1 if inside; 0 if outside or on boundary
:returns:  1 if OK, 0 on error

The abs value of the sum of the angles subtended from a point by
the sides of a polygon, when taken in order traversing the polygon,
is 0 if the point is outside the polygon and 2*pi if inside.
The sign will be positive if traversed cw and negative if ccw.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaPtInsidePolygon(*args)
    
    

    try:
        leptonica.l_angleBetweenVectors.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.l_angleBetweenVectors.restype = ctypes.c_float
    except AttributeError:
        sys.stderr.write("Warning - function l_angleBetweenVectors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_angleBetweenVectors(*args):
        """
        ('l_float32', 'x1')       
('l_float32', 'y1')       
('l_float32', 'x2')       
('l_float32', 'y2')       

:param[in]    x1,: y1     end point of first vector
:param[in]    x2,: y2     end point of second vector
:returns:  angle radians, or 0.0 on error

<pre>
Notes:
(1) This gives the angle between two vectors, going between
vector1 (x1,y1) and vector2 (x2,y2).  The angle is swept
out from 1 --> 2.  If this is clockwise, the angle is
positive, but the result is folded into the interval [-pi, pi].
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_angleBetweenVectors(*args)
    
    

    try:
        leptonica.ptaGetMinMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetMinMax.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetMinMax(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pxmin')       
('l_float32', '*pymin')       
('l_float32', '*pxmax')       
('l_float32', '*pymax')       

:param[in]    pta:
:param[out]   pxmin:   [optional] min of x
:param[out]   pymin:   [optional] min of y
:param[out]   pxmax:   [optional] max of x
:param[out]   pymax:   [optional] max of y
:returns:  0 if OK, 1 on error.  If pta is empty, requested
values are returned as -1.0.


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetMinMax(*args)
    
    

    try:
        leptonica.ptaSelectByValue.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaSelectByValue.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaSelectByValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSelectByValue(*args):
        """
        ('PTA', '*ptas')       
('l_float32', 'xth')       
('l_float32', 'yth')       
('l_int32', 'type')       
('l_int32', 'relation')       

:param[in]    ptas:
:param[in]    xth,: yth    threshold values
:param[in]    type:        L_SELECT_XVAL, L_SELECT_YVAL,
L_SELECT_IF_EITHER, L_SELECT_IF_BOTH
:param[in]    relation:    L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:  ptad filtered set, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSelectByValue(*args)
    
    

    try:
        leptonica.ptaCropToMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaCropToMask.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaCropToMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaCropToMask(*args):
        """
        ('PTA', '*ptas')       
('PIX', '*pixm')       

:param[in]    ptas:    input pta
:param[in]    pixm:    1 bpp mask
:returns:  ptad  with only pts under the mask fg, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaCropToMask(*args)
    
    

    try:
        leptonica.ptaGetLinearLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetLinearLSF.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetLinearLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetLinearLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('NUMA', '**pnafit')       

:param[in]    pta:
:param[out]   pa:      [optional] slope a of least square fit: y = ax + b
:param[out]   pb:      [optional] intercept b of least square fit
:param[out]   pnafit:  [optional] numa of least square fit
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Either or both &a and &b must be input.  They determine the
type of line that is fit.
(2) If both &a and &b are defined, this returns a and b that minimize:

sum (yi - axi -b)^2
i

The method is simple: differentiate this expression w/rt a and b,
and solve the resulting two equations for a and b in terms of
various sums over the input data (xi, yi).
(3) We also allow two special cases, where either a = 0 or b = 0:
(a) If &a is given and &b = null, find the linear LSF that
goes through the origin (b = 0).
(b) If &b is given and &a = null, find the linear LSF with
zero slope (a = 0).
(4) If &nafit is defined, this returns an array of fitted values,
corresponding to the two implicit Numa arrays (nax and nay) in pta.
Thus, just as you can plot the data in pta as nay vs. nax,
you can plot the linear least square fit as nafit vs. nax.
Get the nax array using ptaGetArrays(pta, &nax, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetLinearLSF(*args)
    
    

    try:
        leptonica.ptaGetQuadraticLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetQuadraticLSF.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetQuadraticLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetQuadraticLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('NUMA', '**pnafit')       

:param[in]    pta:
:param[out]   pa:      [optional] coeff a of LSF: y = ax^2 + bx + c
:param[out]   pb:      [optional] coeff b of LSF: y = ax^2 + bx + c
:param[out]   pc:      [optional] coeff c of LSF: y = ax^2 + bx + c
:param[out]   pnafit:  [optional] numa of least square fit
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a quadratic least square fit to the set of points
in %pta.  That is, it finds coefficients a, b and c that minimize:

sum (yi - a*xi*xi -b*xi -c)^2
i

The method is simple: differentiate this expression w/rt
a, b and c, and solve the resulting three equations for these
coefficients in terms of various sums over the input data (xi, yi).
The three equations are in the form:
f[0][0]a + f[0][1]b + f[0][2]c = g[0]
f[1][0]a + f[1][1]b + f[1][2]c = g[1]
f[2][0]a + f[2][1]b + f[2][2]c = g[2]
(2) If &nafit is defined, this returns an array of fitted values,
corresponding to the two implicit Numa arrays (nax and nay) in pta.
Thus, just as you can plot the data in pta as nay vs. nax,
you can plot the linear least square fit as nafit vs. nax.
Get the nax array using ptaGetArrays(pta, &nax, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetQuadraticLSF(*args)
    
    

    try:
        leptonica.ptaGetCubicLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetCubicLSF.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetCubicLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetCubicLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('l_float32', '*pd')       
('NUMA', '**pnafit')       

:param[in]    pta:
:param[out]   pa:      [optional] coeff a of LSF: y = ax^3 + bx^2 + cx + d
:param[out]   pb:      [optional] coeff b of LSF
:param[out]   pc:      [optional] coeff c of LSF
:param[out]   pd:      [optional] coeff d of LSF
:param[out]   pnafit:  [optional] numa of least square fit
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a cubic least square fit to the set of points
in %pta.  That is, it finds coefficients a, b, c and d
that minimize:

sum (yi - a*xi*xi*xi -b*xi*xi -c*xi - d)^2
i

Differentiate this expression w/rt a, b, c and d, and solve
the resulting four equations for these coefficients in
terms of various sums over the input data (xi, yi).
The four equations are in the form:
f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] = g[0]
f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] = g[1]
f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] = g[2]
f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] = g[3]
(2) If &nafit is defined, this returns an array of fitted values,
corresponding to the two implicit Numa arrays (nax and nay) in pta.
Thus, just as you can plot the data in pta as nay vs. nax,
you can plot the linear least square fit as nafit vs. nax.
Get the nax array using ptaGetArrays(pta, &nax, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetCubicLSF(*args)
    
    

    try:
        leptonica.ptaGetQuarticLSF.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetQuarticLSF.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetQuarticLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetQuarticLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('l_float32', '*pd')       
('l_float32', '*pe')       
('NUMA', '**pnafit')       

:param[in]    pta:
:param[out]   pa:      [optional] coeff a of LSF:
y = ax^4 + bx^3 + cx^2 + dx + e
:param[out]   pb:      [optional] coeff b of LSF
:param[out]   pc:      [optional] coeff c of LSF
:param[out]   pd:      [optional] coeff d of LSF
:param[out]   pe:      [optional] coeff e of LSF
:param[out]   pnafit:  [optional] numa of least square fit
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a quartic least square fit to the set of points
in %pta.  That is, it finds coefficients a, b, c, d and 3
that minimize:

sum (yi - a*xi*xi*xi*xi -b*xi*xi*xi -c*xi*xi - d*xi - e)^2
i

Differentiate this expression w/rt a, b, c, d and e, and solve
the resulting five equations for these coefficients in
terms of various sums over the input data (xi, yi).
The five equations are in the form:
f[0][0]a + f[0][1]b + f[0][2]c + f[0][3] + f[0][4] = g[0]
f[1][0]a + f[1][1]b + f[1][2]c + f[1][3] + f[1][4] = g[1]
f[2][0]a + f[2][1]b + f[2][2]c + f[2][3] + f[2][4] = g[2]
f[3][0]a + f[3][1]b + f[3][2]c + f[3][3] + f[3][4] = g[3]
f[4][0]a + f[4][1]b + f[4][2]c + f[4][3] + f[4][4] = g[4]
(2) If &nafit is defined, this returns an array of fitted values,
corresponding to the two implicit Numa arrays (nax and nay) in pta.
Thus, just as you can plot the data in pta as nay vs. nax,
you can plot the linear least square fit as nafit vs. nax.
Get the nax array using ptaGetArrays(pta, &nax, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetQuarticLSF(*args)
    
    

    try:
        leptonica.ptaNoisyLinearLSF.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaNoisyLinearLSF.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaNoisyLinearLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaNoisyLinearLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'factor')       
('PTA', '**pptad')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pmederr')       
('NUMA', '**pnafit')       

:param[in]    pta:
:param[in]    factor:    reject outliers with error greater than this
number of medians; typically ~ 3
:param[out]   pptad:     [optional] with outliers removed
:param[out]   pa:        [optional] slope a of least square fit: y = ax + b
:param[out]   pb:        [optional] intercept b of least square fit
:param[out]   pmederr:   [optional] median error
:param[out]   pnafit:    [optional] numa of least square fit to ptad
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a linear least square fit to the set of points
in %pta.  It then evaluates the errors and removes points
whose error is >= factor * median_error.  It then re-runs
the linear LSF on the resulting points.
(2) Either or both &a and &b must be input.  They determine the
type of line that is fit.
(3) The median error can give an indication of how good the fit
is likely to be.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaNoisyLinearLSF(*args)
    
    

    try:
        leptonica.ptaNoisyQuadraticLSF.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaNoisyQuadraticLSF.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaNoisyQuadraticLSF not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaNoisyQuadraticLSF(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'factor')       
('PTA', '**pptad')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_float32', '*pc')       
('l_float32', '*pmederr')       
('NUMA', '**pnafit')       

:param[in]    pta:
:param[in]    factor:    reject outliers with error greater than this
number of medians; typically ~ 3
:param[out]   pptad:     [optional] with outliers removed
:param[out]   pa:        [optional] coeff a of LSF: y = ax^2 + bx + c
:param[out]   pb:        [optional] coeff b of LSF: y = ax^2 + bx + c
:param[out]   pc:        [optional] coeff c of LSF: y = ax^2 + bx + c
:param[out]   pmederr:   [optional] median error
:param[out]   pnafit:    [optional] numa of least square fit to ptad
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a quadratic least square fit to the set of points
in %pta.  It then evaluates the errors and removes points
whose error is >= factor * median_error.  It then re-runs
a quadratic LSF on the resulting points.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaNoisyQuadraticLSF(*args)
    
    

    try:
        leptonica.applyLinearFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyLinearFit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function applyLinearFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyLinearFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'x')       
('l_float32', '*py')       

:param[in]   a,: b    linear fit coefficients
:param[in]   x:
:param[out]  py:      y = a * x + b
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyLinearFit(*args)
    
    

    try:
        leptonica.applyQuadraticFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyQuadraticFit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function applyQuadraticFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyQuadraticFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'c')       
('l_float32', 'x')       
('l_float32', '*py')       

:param[in]   a,: b, c    quadratic fit coefficients
:param[in]   x:
:param[out]  py:         y = a * x^2 + b * x + c
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyQuadraticFit(*args)
    
    

    try:
        leptonica.applyCubicFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyCubicFit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function applyCubicFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyCubicFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'c')       
('l_float32', 'd')       
('l_float32', 'x')       
('l_float32', '*py')       

:param[in]   a,: b, c, d   cubic fit coefficients
:param[in]   x:
:param[out]  py:           y = a * x^3 + b * x^2  + c * x + d
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyCubicFit(*args)
    
    

    try:
        leptonica.applyQuarticFit.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.applyQuarticFit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function applyQuarticFit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def applyQuarticFit(*args):
        """
        ('l_float32', 'a')       
('l_float32', 'b')       
('l_float32', 'c')       
('l_float32', 'd')       
('l_float32', 'e')       
('l_float32', 'x')       
('l_float32', '*py')       

:param[in]   a,: b, c, d, e   quartic fit coefficients
:param[in]   x:
:param[out]  py:              y = a * x^4 + b * x^3  + c * x^2 + d * x + e
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.applyQuarticFit(*args)
    
    

    try:
        leptonica.pixPlotAlongPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixPlotAlongPta.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixPlotAlongPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPlotAlongPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*pta')       
('l_int32', 'outformat')       
('const char', '*title')       

:param[in]   pixs:        any depth
:param[in]   pta:         set of points on which to plot
:param[in]   outformat:   GPLOT_PNG, GPLOT_PS, GPLOT_EPS, GPLOT_LATEX
:param[in]   title:       [optional] for plot; can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a debugging function.
(2) Removes existing colormaps and clips the pta to the input %pixs.
(3) If the image is RGB, three separate plots are generated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPlotAlongPta(*args)
    
    

    try:
        leptonica.ptaGetPixelsFromPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaGetPixelsFromPix.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetPixelsFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetPixelsFromPix(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       

:param[in]    pixs:     1 bpp
:param[in]    box:      [optional] can be null
:returns:  pta, or NULL on error

<pre>
Notes:
(1) Generates a pta of fg pixels in the pix, within the box.
If box == NULL, it uses the entire pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetPixelsFromPix(*args)
    
    

    try:
        leptonica.pixGenerateFromPta.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGenerateFromPta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateFromPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateFromPta(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    pta:
:param[in]    w,: h    of pix
:returns:  pix 1 bpp, or NULL on error

<pre>
Notes:
(1) Points are rounded to nearest ints.
(2) Any points outside (w,h) are silently discarded.
(3) Output 1 bpp pix has values 1 for each point in the pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateFromPta(*args)
    
    

    try:
        leptonica.ptaGetBoundaryPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaGetBoundaryPixels.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetBoundaryPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetBoundaryPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:    1 bpp
:param[in]    type:    L_BOUNDARY_FG, L_BOUNDARY_BG
:returns:  pta, or NULL on error

<pre>
Notes:
(1) This generates a pta of either fg or bg boundary pixels.
(2) See also pixGeneratePtaBoundary() for rendering of
fg boundary pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetBoundaryPixels(*args)
    
    

    try:
        leptonica.ptaaGetBoundaryPixels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaGetBoundaryPixels.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaGetBoundaryPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaGetBoundaryPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('BOXA', '**pboxa')       
('PIXA', '**ppixa')       

:param[in]    pixs:          1 bpp
:param[in]    type:          L_BOUNDARY_FG, L_BOUNDARY_BG
:param[in]    connectivity:  4 or 8
:param[out]   pboxa:         [optional] bounding boxes of the c.c.
:param[out]   ppixa:         [optional] pixa of the c.c.
:returns:  ptaa, or NULL on error

<pre>
Notes:
(1) This generates a ptaa of either fg or bg boundary pixels,
where each pta has the boundary pixels for a connected
component.
(2) We can't simply find all the boundary pixels and then select
those within the bounding box of each component, because
bounding boxes can overlap.  It is necessary to extract and
dilate or erode each component separately.  Note also that
special handling is required for bg pixels when the
component touches the pix boundary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaGetBoundaryPixels(*args)
    
    

    try:
        leptonica.ptaaIndexLabeledPixels.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaIndexLabeledPixels.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaIndexLabeledPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaIndexLabeledPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pncc')       

:param[in]    pixs:     32 bpp, of indices of c.c.
:param[out]   pncc:     [optional] number of connected components
:returns:  ptaa, or NULL on error

<pre>
Notes:
(1) The pixel values in %pixs are the index of the connected component
to which the pixel belongs; %pixs is typically generated from
a 1 bpp pix by pixConnCompTransform().  Background pixels in
the generating 1 bpp pix are represented in %pixs by 0.
We do not check that the pixel values are correctly labelled.
(2) Each pta in the returned ptaa gives the pixel locations
correspnding to a connected component, with the label of each
given by the index of the pta into the ptaa.
(3) Initialize with the first pta in ptaa being empty and
representing the background value (index 0) in the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaIndexLabeledPixels(*args)
    
    

    try:
        leptonica.ptaGetNeighborPixLocs.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaGetNeighborPixLocs.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetNeighborPixLocs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetNeighborPixLocs(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'conn')       

:param[in]    pixs:    any depth
:param[in]    x,: y    pixel from which we search for nearest neighbors
:param[in]    conn:    4 or 8 connectivity
:returns:  pta, or NULL on error

<pre>
Notes:
(1) Generates a pta of all valid neighbor pixel locations,
or NULL on error.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetNeighborPixLocs(*args)
    
    

    try:
        leptonica.numaConvertToPta1.argtypes = [ctypes.c_void_p]
        leptonica.numaConvertToPta1.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaConvertToPta1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToPta1(*args):
        """
        ('NUMA', '*na')       

:param[in]   na:    numa with implicit y(x)
:returns:  pta if OK; null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToPta1(*args)
    
    

    try:
        leptonica.numaConvertToPta2.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaConvertToPta2.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaConvertToPta2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToPta2(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       

:param[in]   nax:
:param[in]   nay:
:returns:  pta if OK; null on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToPta2(*args)
    
    

    try:
        leptonica.ptaConvertToNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaConvertToNuma.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaConvertToNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaConvertToNuma(*args):
        """
        ('PTA', '*pta')       
('NUMA', '**pnax')       
('NUMA', '**pnay')       

:param[in]   pta:
:param[out]  pnax:    addr of nax
:param[out]  pnay:    addr of nay
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaConvertToNuma(*args)
    
    

    try:
        leptonica.pixDisplayPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDisplayPta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPta(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PTA', '*pta')       

:param[in]    pixd:    can be same as pixs or NULL; 32 bpp if in-place
:param[in]    pixs:    1, 2, 4, 8, 16 or 32 bpp
:param[in]    pta:     of path to be plotted
:returns:  pixd 32 bpp RGB version of pixs, with path in green.

<pre>
Notes:
(1) To write on an existing pixs, pixs must be 32 bpp and
call with pixd == pixs:
pixDisplayPta(pixs, pixs, pta);
To write to a new pix, use pixd == NULL and call:
pixd = pixDisplayPta(NULL, pixs, pta);
(2) On error, returns pixd to avoid losing pixs if called as
pixs = pixDisplayPta(pixs, pixs, pta);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPta(*args)
    
    

    try:
        leptonica.pixDisplayPtaaPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDisplayPtaaPattern.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayPtaaPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPtaaPattern(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PTAA', '*ptaa')       
('PIX', '*pixp')       
('l_int32', 'cx')       
('l_int32', 'cy')       

:param[in]    pixd:     32 bpp
:param[in]    pixs:     1, 2, 4, 8, 16 or 32 bpp; 32 bpp if in place
:param[in]    ptaa:     giving locations at which the pattern is displayed
:param[in]    pixp:     1 bpp pattern to be placed such that its reference
point co-locates with each point in pta
:param[in]    cx,: cy   reference point in pattern
:returns:  pixd 32 bpp RGB version of pixs.

<pre>
Notes:
(1) To write on an existing pixs, pixs must be 32 bpp and
call with pixd == pixs:
pixDisplayPtaPattern(pixs, pixs, pta, ...);
To write to a new pix, use pixd == NULL and call:
pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
(2) Puts a random color on each pattern associated with a pta.
(3) On error, returns pixd to avoid losing pixs if called as
pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
(4) A typical pattern to be used is a circle, generated with
generatePtaFilledCircle()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPtaaPattern(*args)
    
    

    try:
        leptonica.pixDisplayPtaPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixDisplayPtaPattern.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayPtaPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPtaPattern(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PTA', '*pta')       
('PIX', '*pixp')       
('l_int32', 'cx')       
('l_int32', 'cy')       
('l_uint32', 'color')       

:param[in]    pixd:     can be same as pixs or NULL; 32 bpp if in-place
:param[in]    pixs:     1, 2, 4, 8, 16 or 32 bpp
:param[in]    pta:      giving locations at which the pattern is displayed
:param[in]    pixp:     1 bpp pattern to be placed such that its reference
point co-locates with each point in pta
:param[in]    cx,: cy   reference point in pattern
:param[in]    color:    in 0xrrggbb00 format
:returns:  pixd 32 bpp RGB version of pixs.

<pre>
Notes:
(1) To write on an existing pixs, pixs must be 32 bpp and
call with pixd == pixs:
pixDisplayPtaPattern(pixs, pixs, pta, ...);
To write to a new pix, use pixd == NULL and call:
pixd = pixDisplayPtaPattern(NULL, pixs, pta, ...);
(2) On error, returns pixd to avoid losing pixs if called as
pixs = pixDisplayPtaPattern(pixs, pixs, pta, ...);
(3) A typical pattern to be used is a circle, generated with
generatePtaFilledCircle()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPtaPattern(*args)
    
    

    try:
        leptonica.ptaReplicatePattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptaReplicatePattern.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaReplicatePattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaReplicatePattern(*args):
        """
        ('PTA', '*ptas')       
('PIX', '*pixp')       
('PTA', '*ptap')       
('l_int32', 'cx')       
('l_int32', 'cy')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    ptas:    "sparse" input pta
:param[in]    pixp:    [optional] 1 bpp pattern, to be replicated
in output pta
:param[in]    ptap:    [optional] set of pts, to be replicated in output pta
:param[in]    cx,: cy  reference point in pattern
:param[in]    w,: h    clipping sizes for output pta
:returns:  ptad with all points of replicated pattern, or NULL on error

<pre>
Notes:
(1) You can use either the image %pixp or the set of pts %ptap.
(2) The pattern is placed with its reference point at each point
in ptas, and all the fg pixels are colleced into ptad.
For %pixp, this is equivalent to blitting pixp at each point
in ptas, and then converting the resulting pix to a pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaReplicatePattern(*args)
    
    

    try:
        leptonica.pixDisplayPtaa.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDisplayPtaa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayPtaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayPtaa(*args):
        """
        ('PIX', '*pixs')       
('PTAA', '*ptaa')       

:param[in]    pixs:    1, 2, 4, 8, 16 or 32 bpp
:param[in]    ptaa:    array of paths to be plotted
:returns:  pixd 32 bpp RGB version of pixs, with paths plotted
in different colors, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayPtaa(*args)
    




class skew(object):
    """<pre>

Top-level deskew interfaces
PIX       *pixDeskewBoth()
PIX       *pixDeskew()
PIX       *pixFindSkewAndDeskew()
PIX       *pixDeskewGeneral()

Top-level angle-finding interface
l_int32    pixFindSkew()

Basic angle-finding functions
l_int32    pixFindSkewSweep()
l_int32    pixFindSkewSweepAndSearch()
l_int32    pixFindSkewSweepAndSearchScore()
l_int32    pixFindSkewSweepAndSearchScorePivot()

Search over arbitrary range of angles in orthogonal directions
l_int32    pixFindSkewOrthogonalRange()

Differential square sum function for scoring
l_int32    pixFindDifferentialSquareSum()

Measures of variance of row sums
l_int32    pixFindNormalizedSquareSum()


==============================================================
Page skew detection

Skew is determined by pixel profiles, which are computed
as pixel sums along the raster line for each line in the
image.  By vertically shearing the image by a given angle,
the sums can be computed quickly along the raster lines
rather than along lines at that angle.  The score is
computed from these line sums by taking the square of
the DIFFERENCE between adjacent line sums, summed over
all lines.  The skew angle is then found as the angle
that maximizes the score.  The actual computation for
any sheared image is done in the function
pixFindDifferentialSquareSum().

The search for the angle that maximizes this score is
most efficiently performed by first sweeping coarsely
over angles, using a significantly reduced image (say, 4x
reduction), to find the approximate maximum within a half
degree or so, and then doing an interval-halving binary
search at higher resolution to get the skew angle to
within 1/20 degree or better.

The differential signal is used (rather than just using
that variance of line sums) because it rejects the
background noise due to total number of black pixels,
and has maximum contributions from the baselines and
x-height lines of text when the textlines are aligned
with the raster lines.  It also works well in multicolumn
pages where the textlines do not line up across columns.

The method is fast, accurate to within an angle (in radians)
of approximately the inverse width in pixels of the image,
and will work on a surprisingly small amount of text data
(just a couple of text lines).  Consequently, it can
also be used to find local skew if the skew were to vary
significantly over the page.  Local skew determination
is not very important except for locating lines of
handwritten text that may be mixed with printed text.
</pre>




"""
    
    try:
        leptonica.pixDeskewBoth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDeskewBoth.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDeskewBoth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewBoth(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsearch')       

:param[in]    pixs:         any depth
:param[in]    redsearch:    for binary search: reduction factor = 1, 2 or 4;
use 0 for default
:returns:  pixd deskewed pix, or NULL on error

<pre>
Notes:
(1) This binarizes if necessary and does both horizontal
and vertical deskewing, using the default parameters in
the underlying pixDeskew().  See usage there.
(2) This may return a clone.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewBoth(*args)
    
    

    try:
        leptonica.pixDeskew.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDeskew.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDeskew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskew(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsearch')       

:param[in]    pixs:        any depth
:param[in]    redsearch:   for binary search: reduction factor = 1, 2 or 4;
use 0 for default
:returns:  pixd deskewed pix, or NULL on error

<pre>
Notes:
(1) This binarizes if necessary and finds the skew angle.  If the
angle is large enough and there is sufficient confidence,
it returns a deskewed image; otherwise, it returns a clone.
(2) Typical values at 300 ppi for %redsearch are 2 and 4.
At 75 ppi, one should use %redsearch = 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskew(*args)
    
    

    try:
        leptonica.pixFindSkewAndDeskew.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindSkewAndDeskew.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindSkewAndDeskew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewAndDeskew(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsearch')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       

:param[in]    pixs:        any depth
:param[in]    redsearch:   for binary search: reduction factor = 1, 2 or 4;
use 0 for default
:param[out]   pangle:      [optional] angle required to deskew,
in degrees; use NULL to skip
:param[out]   pconf:       [optional] conf value is ratio
of max/min scores; use NULL to skip
:returns:  pixd deskewed pix, or NULL on error

<pre>
Notes:
(1) This binarizes if necessary and finds the skew angle.  If the
angle is large enough and there is sufficient confidence,
it returns a deskewed image; otherwise, it returns a clone.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewAndDeskew(*args)
    
    

    try:
        leptonica.pixDeskewGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDeskewGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDeskewGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'redsweep')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_int32', 'redsearch')       
('l_int32', 'thresh')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       

:param[in]    pixs:         any depth
:param[in]    redsweep:     for linear search: reduction factor = 1, 2 or 4;
use 0 for default
:param[in]    sweeprange:   in degrees in each direction from 0;
use 0.0 for default
:param[in]    sweepdelta:   in degrees; use 0.0 for default
:param[in]    redsearch:    for binary search: reduction factor = 1, 2 or 4;
use 0 for default;
:param[in]    thresh:       for binarizing the image; use 0 for default
:param[out]   pangle:       [optional] angle required to deskew,
in degrees; use NULL to skip
:param[out]   pconf:        [optional] conf value is ratio
of max/min scores; use NULL to skip
:returns:  pixd deskewed pix, or NULL on error

<pre>
Notes:
(1) This binarizes if necessary and finds the skew angle.  If the
angle is large enough and there is sufficient confidence,
it returns a deskewed image; otherwise, it returns a clone.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewGeneral(*args)
    
    

    try:
        leptonica.pixFindSkew.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindSkew.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindSkew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkew(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       

:param[in]    pixs:     1 bpp
:param[out]   pangle:   angle required to deskew, in degrees
:param[out]   pconf:    confidence value is ratio max/min scores
:returns:  0 if OK, 1 on error or if angle measurement not valid

<pre>
Notes:
(1) This is a simple high-level interface, that uses default
values of the parameters for reasonable speed and accuracy.
(2) The angle returned is the negative of the skew angle of
the image.  It is the angle required for deskew.
Clockwise rotations are positive angles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkew(*args)
    
    

    try:
        leptonica.pixFindSkewSweep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixFindSkewSweep.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindSkewSweep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweep(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_int32', 'reduction')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       

:param[in]    pixs:         1 bpp
:param[out]   pangle:       angle required to deskew, in degrees
:param[in]    reduction:    factor = 1, 2, 4 or 8
:param[in]    sweeprange:   half the full range; assumed about 0; in degrees
:param[in]    sweepdelta:   angle increment of sweep; in degrees
:returns:  0 if OK, 1 on error or if angle measurement not valid

<pre>
Notes:
(1) This examines the 'score' for skew angles with equal intervals.
(2) Caller must check the return value for validity of the result.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweep(*args)
    
    

    try:
        leptonica.pixFindSkewSweepAndSearch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixFindSkewSweepAndSearch.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindSkewSweepAndSearch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweepAndSearch(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       

:param[in]    pixs:         1 bpp
:param[out]   pangle:       angle required to deskew; in degrees
:param[out]   pconf:        confidence given by ratio of max/min score
:param[in]    redsweep:     sweep reduction factor = 1, 2, 4 or 8
:param[in]    redsearch:    binary search reduction factor = 1, 2, 4 or 8;
and must not exceed redsweep
:param[in]    sweeprange:   half the full range, assumed about 0; in degrees
:param[in]    sweepdelta:   angle increment of sweep; in degrees
:param[in]    minbsdelta:   min binary search increment angle; in degrees
:returns:  0 if OK, 1 on error or if angle measurement not valid

<pre>
Notes:
(1) This finds the skew angle, doing first a sweep through a set
of equal angles, and then doing a binary search until
convergence.
(2) Caller must check the return value for validity of the result.
(3) In computing the differential line sum variance score, we sum
the result over scanlines, but we always skip:
~ at least one scanline
~ not more than 10% of the image height
~ not more than 5% of the image width
(4) See also notes in pixFindSkewSweepAndSearchScore()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweepAndSearch(*args)
    
    

    try:
        leptonica.pixFindSkewSweepAndSearchScore.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixFindSkewSweepAndSearchScore.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindSkewSweepAndSearchScore not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweepAndSearchScore(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
('l_float32', '*pendscore')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweepcenter')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       

:param[in]    pixs:         1 bpp
:param[out]   pangle:       angle required to deskew; in degrees
:param[out]   pconf:        confidence given by ratio of max/min score
:param[out]   pendscore:    [optional] max score; use NULL to ignore
:param[in]    redsweep:     sweep reduction factor = 1, 2, 4 or 8
:param[in]    redsearch:    binary search reduction factor = 1, 2, 4 or 8;
and must not exceed redsweep
:param[in]    sweepcenter:  angle about which sweep is performed; in degrees
:param[in]    sweeprange:   half the full range, taken about sweepcenter;
in degrees
:param[in]    sweepdelta:   angle increment of sweep; in degrees
:param[in]    minbsdelta:   min binary search increment angle; in degrees
:returns:  0 if OK, 1 on error or if angle measurement not valid

<pre>
Notes:
(1) This finds the skew angle, doing first a sweep through a set
of equal angles, and then doing a binary search until convergence.
(2) There are two built-in constants that determine if the
returned confidence is nonzero:
~ MinValidMaxscore (minimum allowed maxscore)
~ MinscoreThreshFactor (determines minimum allowed
minscore, by multiplying by (height * width^2)
If either of these conditions is not satisfied, the returned
confidence value will be zero.  The maxscore is optionally
returned in this function to allow evaluation of the
resulting angle by a method that is independent of the
returned confidence value.
(3) The larger the confidence value, the greater the probability
that the proper alignment is given by the angle that maximizes
variance.  It should be compared to a threshold, which depends
on the application.  Values between 3.0 and 6.0 are common.
(4) By default, the shear is about the UL corner.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweepAndSearchScore(*args)
    
    

    try:
        leptonica.pixFindSkewSweepAndSearchScorePivot.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixFindSkewSweepAndSearchScorePivot.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindSkewSweepAndSearchScorePivot not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindSkewSweepAndSearchScorePivot(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       
('l_float32', '*pendscore')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweepcenter')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
('l_int32', 'pivot')       

:param[in]    pixs:         1 bpp
:param[out]   pangle:       angle required to deskew; in degrees
:param[out]   pconf:        confidence given by ratio of max/min score
:param[out]   pendscore:    [optional] max score; use NULL to ignore
:param[in]    redsweep:     sweep reduction factor = 1, 2, 4 or 8
:param[in]    redsearch:    binary search reduction factor = 1, 2, 4 or 8;
and must not exceed redsweep
:param[in]    sweepcenter:  angle about which sweep is performed; in degrees
:param[in]    sweeprange:   half the full range, taken about sweepcenter;
in degrees
:param[in]    sweepdelta:   angle increment of sweep; in degrees
:param[in]    minbsdelta:   min binary search increment angle; in degrees
:param[in]    pivot:        L_SHEAR_ABOUT_CORNER, L_SHEAR_ABOUT_CENTER
:returns:  0 if OK, 1 on error or if angle measurement not valid

<pre>
Notes:
(1) See notes in pixFindSkewSweepAndSearchScore().
(2) This allows choice of shear pivoting from either the UL corner
or the center.  For small angles, the ability to discriminate
angles is better with shearing from the UL corner.  However,
for large angles (say, greater than 20 degrees), it is better
to shear about the center because a shear from the UL corner
loses too much of the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindSkewSweepAndSearchScorePivot(*args)
    
    

    try:
        leptonica.pixFindDifferentialSquareSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindDifferentialSquareSum.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindDifferentialSquareSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindDifferentialSquareSum(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*psum')       

:param[in]    pixs:
:param[out]   psum:    result
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) At the top and bottom, we skip:
~ at least one scanline
~ not more than 10% of the image height
~ not more than 5% of the image width
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindDifferentialSquareSum(*args)
    
    

    try:
        leptonica.pixFindNormalizedSquareSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindNormalizedSquareSum.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindNormalizedSquareSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindNormalizedSquareSum(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*phratio')       
('l_float32', '*pvratio')       
('l_float32', '*pfract')       

:param[in]    pixs:
:param[out]   phratio:   [optional] ratio of normalized horiz square sum
to result if the pixel distribution were uniform
:param[out]   pvratio:   [optional] ratio of normalized vert square sum
to result if the pixel distribution were uniform
:param[out]   pfract:    [optional] ratio of fg pixels to total pixels
:returns:  0 if OK, 1 on error or if there are no fg pixels

<pre>
Notes:
(1) Let the image have h scanlines and N fg pixels.
If the pixels were uniformly distributed on scanlines,
the sum of squares of fg pixels on each scanline would be
h * (N / h)^2.  However, if the pixels are not uniformly
distributed (e.g., for text), the sum of squares of fg
pixels will be larger.  We return in hratio and vratio the
ratio of these two values.
(2) If there are no fg pixels, hratio and vratio are returned as 0.0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindNormalizedSquareSum(*args)
    




class colorseg(object):
    """<pre>

Unsupervised color segmentation

PIX     *pixColorSegment()
PIX     *pixColorSegmentCluster()
static  l_int32  pixColorSegmentTryCluster()
l_int32  pixAssignToNearestColor()
l_int32  pixColorSegmentClean()
l_int32  pixColorSegmentRemoveColors()
</pre>




"""
    
    try:
        leptonica.pixColorSegment.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorSegment.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorSegment not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegment(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxdist')       
('l_int32', 'maxcolors')       
('l_int32', 'selsize')       
('l_int32', 'finalcolors')       
('l_int32', 'debugflag')       

:param[in]    pixs:  32 bpp; 24-bit color
:param[in]    maxdist: max euclidean dist to existing cluster
:param[in]    maxcolors: max number of colors allowed in first pass
:param[in]    selsize: linear size of sel for closing to remove noise
:param[in]    finalcolors: max number of final colors allowed after 4th pass
:param[in]    debugflag:  1 for debug output; 0 otherwise
:returns:  pixd 8 bit with colormap, or NULL on error

<pre>
Color segmentation proceeds in four phases:

Phase 1:  pixColorSegmentCluster()
The image is traversed in raster order.  Each pixel either
becomes the representative for a new cluster or is assigned to an
existing cluster.  Assignment is greedy.  The data is stored in
a colormapped image.  Three auxiliary arrays are used to hold
the colors of the representative pixels, for fast lookup.
The average color in each cluster is computed.

Phase 2.  pixAssignToNearestColor()
A second non-greedy clustering pass is performed, where each pixel
is assigned to the nearest cluster average.  We also keep track
of how many pixels are assigned to each cluster.

Phase 3.  pixColorSegmentClean()
For each cluster, starting with the largest, do a morphological
closing to eliminate small components within larger ones.

Phase 4.  pixColorSegmentRemoveColors()
Eliminate all colors except the most populated 'finalcolors'.
Then remove unused colors from the colormap, and reassign those
pixels to the nearest remaining cluster, using the original pixel values.

Notes:
(1) The goal is to generate a small number of colors.
Typically this would be specified by 'finalcolors',
a number that would be somewhere between 3 and 6.
The parameter 'maxcolors' specifies the maximum number of
colors generated in the first phase.  This should be
larger than finalcolors, perhaps twice as large.
If more than 'maxcolors' are generated in the first phase
using the input 'maxdist', the distance is repeatedly
increased by a multiplicative factor until the condition
is satisfied.  The implicit relation between 'maxdist'
and 'maxcolors' is thus adjusted programmatically.
(2) As a very rough guideline, given a target value of 'finalcolors',
here are approximate values of 'maxdist' and 'maxcolors'
to start with:

finalcolors    maxcolors    maxdist
-----------    ---------    -------
3             6          100
4             8           90
5            10           75
6            12           60

For a given number of finalcolors, if you use too many
maxcolors, the result will be noisy.  If you use too few,
the result will be a relatively poor assignment of colors.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegment(*args)
    
    

    try:
        leptonica.pixColorSegmentCluster.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorSegmentCluster.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorSegmentCluster not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegmentCluster(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxdist')       
('l_int32', 'maxcolors')       
('l_int32', 'debugflag')       

:param[in]    pixs:  32 bpp; 24-bit color
:param[in]    maxdist: max euclidean dist to existing cluster
:param[in]    maxcolors: max number of colors allowed in first pass
:param[in]    debugflag:  1 for debug output; 0 otherwise
:returns:  pixd 8 bit with colormap, or NULL on error

<pre>
Notes:
(1) This is phase 1.  See description in pixColorSegment().
(2) Greedy unsupervised classification.  If the limit 'maxcolors'
is exceeded, the computation is repeated with a larger
allowed cluster size.
(3) On each successive iteration, 'maxdist' is increased by a
constant factor.  See comments in pixColorSegment() for
a guideline on parameter selection.
Note that the diagonal of the 8-bit rgb color cube is about
440, so for 'maxdist' = 440, you are guaranteed to get 1 color!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegmentCluster(*args)
    
    

    try:
        leptonica.pixAssignToNearestColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAssignToNearestColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAssignToNearestColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAssignToNearestColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'level')       
('l_int32', '*countarray')       

:param[in]    pixd:  8 bpp, colormapped
:param[in]    pixs:  32 bpp; 24-bit color
:param[in]    pixm:  [optional] 1 bpp
:param[in]    level: of octcube used for finding nearest color in cmap
:param[in]    countarray: [optional] ptr to array, in which we can store
the number of pixels found in each color in
the colormap in pixd
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is used in phase 2 of color segmentation, where pixs
is the original input image to pixColorSegment(), and
pixd is the colormapped image returned from
pixColorSegmentCluster().  It is also used, with a mask,
in phase 4.
(2) This is an in-place operation.
(3) The colormap in pixd is unchanged.
(4) pixs and pixd must be the same size (w, h).
(5) The selection mask pixm can be null.  If it exists, it must
be the same size as pixs and pixd, and only pixels
corresponding to fg in pixm are assigned.  Set to
NULL if all pixels in pixd are to be assigned.
(6) The countarray can be null.  If it exists, it is pre-allocated
and of a size at least equal to the size of the colormap in pixd.
(7) This does a best-fit (non-greedy) assignment of pixels to
existing clusters.  Specifically, it assigns each pixel
in pixd to the color index in the pixd colormap that has a
color closest to the corresponding rgb pixel in pixs.
(8) 'level' is the octcube level used to quickly find the nearest
color in the colormap for each pixel.  For color segmentation,
this parameter is set to LEVEL_IN_OCTCUBE.
(9) We build a mapping table from octcube to colormap index so
that this function can run in a time (otherwise) independent
of the number of colors in the colormap.  This avoids a
brute-force search for the closest colormap color to each
pixel in the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAssignToNearestColor(*args)
    
    

    try:
        leptonica.pixColorSegmentClean.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixColorSegmentClean.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorSegmentClean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegmentClean(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'selsize')       
('l_int32', '*countarray')       

:param[in]    pixs:  8 bpp, colormapped
:param[in]    selsize: for closing
:param[in]    countarray: ptr to array containing the number of pixels
found in each color in the colormap
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This operation is in-place.
(2) This is phase 3 of color segmentation.  It is the first
part of a two-step noise removal process.  Colors with a
large population are closed first; this operation absorbs
small sets of intercolated pixels of a different color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegmentClean(*args)
    
    

    try:
        leptonica.pixColorSegmentRemoveColors.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixColorSegmentRemoveColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorSegmentRemoveColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorSegmentRemoveColors(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'finalcolors')       

:param[in]    pixd:  8 bpp, colormapped
:param[in]    pixs:  32 bpp rgb, with initial pixel values
:param[in]    finalcolors: max number of colors to retain
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This operation is in-place.
(2) This is phase 4 of color segmentation, and the second part
of the 2-step noise removal.  Only 'finalcolors' different
colors are retained, with colors with smaller populations
being replaced by the nearest color of the remaining colors.
For highest accuracy, for pixels that are being replaced,
we find the nearest colormap color  to the original rgb color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorSegmentRemoveColors(*args)
    




class coloring(object):
    """<pre>

Coloring "gray" pixels
PIX             *pixColorGrayRegions()
l_int32          pixColorGray()
PIX             *pixColorGrayMasked()

Adjusting one or more colors to a target color
PIX             *pixSnapColor()
PIX             *pixSnapColorCmap()

Piecewise linear color mapping based on a source/target pair
PIX             *pixLinearMapToTargetColor()
l_int32          pixelLinearMapToTargetColor()

Fractional shift of RGB towards black or white
PIX             *pixShiftByComponent()
l_int32          pixelShiftByComponent()
l_int32          pixelFractionalShift()
PIX             *pixShiftWithInvariantHue()

There are quite a few "coloring" functions in leptonica.
You can find them in these files:
coloring.c
paintcmap.c
pix2.c
blend.c
enhance.c

They fall into the following categories:

(1) Moving either the light or dark pixels toward a
specified color. (pixColorGray, pixColorGrayMasked)
(2) Forcing all pixels whose color is within some delta of a
specified color to move to that color. (pixSnapColor)
(3) Doing a piecewise linear color shift specified by a source
and a target color.  Each component shifts independently.
(pixLinearMapToTargetColor, pixMapWithInvariantHue).
(4) Shifting all colors by a given fraction of their distance
from 0 (if shifting down) or from 255 (if shifting up).
This is useful for colorizing either the background or
the foreground of a grayscale image. (pixShiftByComponent)
(5) Shifting all colors by a component-dependent fraction of
their distance from 0 (if shifting down) or from 255 (if
shifting up).  This is useful for modifying the color to
compensate for color shifts in acquisition or printing.
(enhance.c: pixColorShiftRGB, pixMosaicColorShiftRGB).
(6) Repainting selected pixels. (paintcmap.c: pixSetSelectMaskedCmap)
(7) Blending a fraction of a specific color with the existing RGB
color.  (pix2.c: pixBlendInRect())
(8) Changing selected colors in a colormap.
(paintcmap.c: pixSetSelectCmap, pixSetSelectMaskedCmap)
(9) Shifting all the pixels towards black or white depending on
the gray value of a second image.  (blend.c: pixFadeWithGray)
(10) Changing the hue, saturation or brightness, by changing one of
these parameters in HSV color space by a fraction of the distance
toward its end-point, but leaving the other two parameters
invariant.  For example, you can change the brightness by moving
each pixel's v-parameter a specified fraction of the distance
toward 0 (darkening) or toward 255 (brightening), without altering
the hue or saturation.  (enhance.c: pixModifySaturation,
pixModifyHue, pixModifyBrightness)
</pre>




"""
    
    try:
        leptonica.pixColorGrayRegions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayRegions.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorGrayRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayRegions(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:       2, 4 or 8 bpp gray, rgb, or colormapped
:param[in]    boxa:       of regions in which to apply color
:param[in]    type:       L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    thresh:     average value below/above which pixel is unchanged
:param[in]    rval,: gval, bval new color to paint
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This generates a new image, where some of the pixels in each
box in the boxa are colorized.  See pixColorGray() for usage
with %type and %thresh.  Note that %thresh is only used for
rgb; it is ignored for colormapped images.
(2) If the input image is colormapped, the new image will be 8 bpp
colormapped if possible; otherwise, it will be converted
to 32 bpp rgb.  Only pixels that are strictly gray will be
colorized.
(3) If the input image is not colormapped, it is converted to rgb.
A "gray" value for a pixel is determined by averaging the
components, and the output rgb value is determined from this.
(4) This can be used in conjunction with pixHasHighlightRed() to
add highlight color to a grayscale image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayRegions(*args)
    
    

    try:
        leptonica.pixColorGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGray(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:     8 bpp gray, rgb or colormapped image
:param[in]    box:      [optional] region in which to apply color; can be NULL
:param[in]    type:     L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    thresh:   average value below/above which pixel is unchanged
:param[in]    rval,: gval, bval    new color to paint
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place operation; pixs is modified.
If pixs is colormapped, the operation will add colors to the
colormap.  Otherwise, pixs will be converted to 32 bpp rgb if
it is initially 8 bpp gray.
(2) If type == L_PAINT_LIGHT, it colorizes non-black pixels,
preserving antialiasing.
If type == L_PAINT_DARK, it colorizes non-white pixels,
preserving antialiasing.
(3) If box is NULL, applies function to the entire image; otherwise,
clips the operation to the intersection of the box and pix.
(4) If colormapped, calls pixColorGrayCmap(), which applies the
coloring algorithm only to pixels that are strictly gray.
(5) For RGB, determines a "gray" value by averaging; then uses this
value, plus the input rgb target, to generate the output
pixel values.
(6) thresh is only used for rgb; it is ignored for colormapped pix.
If type == L_PAINT_LIGHT, use thresh = 0 if all pixels are to
be colored (black pixels will be unaltered).
In situations where there are a lot of black pixels,
setting thresh > 0 will make the function considerably
more efficient without affecting the final result.
If type == L_PAINT_DARK, use thresh = 255 if all pixels
are to be colored (white pixels will be unaltered).
In situations where there are a lot of white pixels,
setting thresh < 255 will make the function considerably
more efficient without affecting the final result.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGray(*args)
    
    

    try:
        leptonica.pixColorGrayMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorGrayMasked.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorGrayMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorGrayMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pixs:      8 bpp gray, rgb or colormapped image
:param[in]    pixm:      1 bpp mask, through which to apply color
:param[in]    type:      L_PAINT_LIGHT, L_PAINT_DARK
:param[in]    thresh:    average value below/above which pixel is unchanged
:param[in]    rval,: gval, bval    new color to paint
:returns:  pixd colorized, or NULL on error

<pre>
Notes:
(1) This generates a new image, where some of the pixels under
FG in the mask are colorized.
(2) See pixColorGray() for usage with %type and %thresh.  Note
that %thresh is only used for rgb; it is ignored for
colormapped images.  In most cases, the mask will be over
the darker parts and %type == L_PAINT_DARK.
(3) If pixs is colormapped this calls pixColorMaskedCmap(),
which adds colors to the colormap for pixd; it only adds
colors corresponding to strictly gray colors in the colormap.
Otherwise, if pixs is 8 bpp gray, pixd will be 32 bpp rgb.
(4) If pixs is 32 bpp rgb, for each pixel a "gray" value is
found by averaging.  This average is then used with the
input rgb target to generate the output pixel values.
(5) This can be used in conjunction with pixHasHighlightRed() to
add highlight color to a grayscale image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorGrayMasked(*args)
    
    

    try:
        leptonica.pixSnapColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSnapColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSnapColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSnapColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       
('l_int32', 'diff')       

:param[in]    pixd:     [optional]; either NULL or equal to pixs for in-place
:param[in]    pixs:     colormapped or 8 bpp gray or 32 bpp rgb
:param[in]    srcval:   color center to be selected for change: 0xrrggbb00
:param[in]    dstval:   target color for pixels: 0xrrggbb00
:param[in]    diff:     max absolute difference, applied to all components
:returns:  pixd   with all pixels within diff of pixval set to pixval,
or pixd on error

<pre>
Notes:
(1) For inplace operation, call it this way:
pixSnapColor(pixs, pixs, ... )
(2) For generating a new pixd:
pixd = pixSnapColor(NULL, pixs, ...)
(3) If pixs has a colormap, it is handled by pixSnapColorCmap().
(4) All pixels within 'diff' of 'srcval', componentwise,
will be changed to 'dstval'.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSnapColor(*args)
    
    

    try:
        leptonica.pixSnapColorCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSnapColorCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSnapColorCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSnapColorCmap(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       
('l_int32', 'diff')       

:param[in]    pixd:     [optional]; either NULL or equal to pixs for in-place
:param[in]    pixs:     colormapped
:param[in]    srcval:   color center to be selected for change: 0xrrggbb00
:param[in]    dstval:   target color for pixels: 0xrrggbb00
:param[in]    diff:     max absolute difference, applied to all components
:returns:  pixd   with all pixels within diff of srcval set to dstval,
or pixd on error

<pre>
Notes:
(1) For inplace operation, call it this way:
pixSnapCcmap(pixs, pixs, ... )
(2) For generating a new pixd:
pixd = pixSnapCmap(NULL, pixs, ...)
(3) pixs must have a colormap.
(4) All colors within 'diff' of 'srcval', componentwise,
will be changed to 'dstval'.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSnapColorCmap(*args)
    
    

    try:
        leptonica.pixLinearMapToTargetColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixLinearMapToTargetColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixLinearMapToTargetColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLinearMapToTargetColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       

:param[in]    pixd:     [optional]; either NULL or equal to pixs for in-place
:param[in]    pixs:     32 bpp rgb
:param[in]    srcval:   source color: 0xrrggbb00
:param[in]    dstval:   target color: 0xrrggbb00
:returns:  pixd   with all pixels mapped based on the srcval/destval mapping,
or pixd on error

<pre>
Notes:
(1) For each component (r, b, g) separately, this does a piecewise
linear mapping of the colors in pixs to colors in pixd.
If rs and rd are the red src and dest components in %srcval and
%dstval, then the range [0 ... rs] in pixs is mapped to
[0 ... rd] in pixd.  Likewise, the range [rs ... 255] in pixs
is mapped to [rd ... 255] in pixd.  And similarly for green
and blue.
(2) The mapping will in general change the hue of the pixels.
However, if the src and dst targets are related by
a transformation given by pixelFractionalShift(), the hue
is invariant.  A special case is where the dest in the
map is white (255, 255, 255) for an arbitrary srcval.
(3) For inplace operation, call it this way:
pixLinearMapToTargetColor(pixs, pixs, ... );
For generating a new pixd:
pixd = pixLinearMapToTargetColor(NULL, pixs, ...);
(4) See pixShiftWithInvariantHue() for a special case of this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixLinearMapToTargetColor(*args)
    
    

    try:
        leptonica.pixelLinearMapToTargetColor.argtypes = [ctypes.c_uint32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_void_p]
        leptonica.pixelLinearMapToTargetColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixelLinearMapToTargetColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixelLinearMapToTargetColor(*args):
        """
        ('l_uint32', 'scolor')       
('l_uint32', 'srcmap')       
('l_uint32', 'dstmap')       
('l_uint32', '*pdcolor')       

:param[in]    scolor:    rgb source color: 0xrrggbb00
:param[in]    srcmap:    source mapping color: 0xrrggbb00
:param[in]    dstmap:    target mapping color: 0xrrggbb00
:param[out]   pdcolor:   rgb dest color: 0xrrggbb00
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does this does a piecewise linear mapping of each
component of %scolor to %dcolor, based on the relation
between the components of %srcmap and %dstmap.  It is the
same transformation, performed on a single color, as mapped
on every pixel in a pix by pixLinearMapToTargetColor().
(2) For each component, if the sval is larger than the smap,
the dval will be pushed up from dmap towards white.
Otherwise, dval will be pushed down from dmap towards black.
This is because you can visualize the transformation as
a linear stretching where smap moves to dmap, and everything
else follows linearly with 0 and 255 fixed.
(3) The mapping will in general change the hue of %scolor.
However, if the %srcmap and %dstmap targets are related by
a transformation given by pixelFractionalShift(), the hue
will be invariant.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixelLinearMapToTargetColor(*args)
    
    

    try:
        leptonica.pixShiftByComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixShiftByComponent.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixShiftByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixShiftByComponent(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       

:param[in]    pixd:     [optional]; either NULL or equal to pixs for in-place
:param[in]    pixs:     32 bpp rgb, cmap OK
:param[in]    srcval:   source color: 0xrrggbb00
:param[in]    dstval:   target color: 0xrrggbb00
:returns:  pixd   with all pixels mapped based on the srcval/destval mapping,
or pixd on error

<pre>
Notes:
(1) For each component (r, b, g) separately, this does a linear
mapping of the colors in pixs to colors in pixd.
Let rs and rd be the red src and dest components in %srcval and
%dstval, and rval is the red component of the src pixel.
Then for all pixels in pixs, the mapping for the red
component from pixs to pixd is:
if (rd <= rs)   (shift toward black)
rval --> (rd/rs) * rval
if (rd > rs)    (shift toward white)
(255 - rval) --> ((255 - rs)/(255 - rd)) * (255 - rval)
Thus if rd <= rs, the red component of all pixels is
mapped by the same fraction toward white, and if rd > rs,
they are mapped by the same fraction toward black.
This is essentially a different linear TRC (gamma = 1)
for each component.  The source and target color inputs are
just used to generate the three fractions.
(2) Note that this mapping differs from that in
pixLinearMapToTargetColor(), which maps rs --> rd and does
a piecewise stretching in between.
(3) For inplace operation, call it this way:
pixFractionalShiftByComponent(pixs, pixs, ... )
(4) For generating a new pixd:
pixd = pixLinearMapToTargetColor(NULL, pixs, ...)
(5) A simple application is to color a grayscale image.
A light background can be colored using srcval = 0xffffff00
and picking a target background color for dstval.
A dark foreground can be colored by using srcval = 0x0
and choosing a target foreground color for dstval.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixShiftByComponent(*args)
    
    

    try:
        leptonica.pixelShiftByComponent.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_void_p]
        leptonica.pixelShiftByComponent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixelShiftByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixelShiftByComponent(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_uint32', 'srcval')       
('l_uint32', 'dstval')       
('l_uint32', '*ppixel')       

:param[in]    rval,: gval, bval
:param[in]    srcval:    source color: 0xrrggbb00
:param[in]    dstval:    target color: 0xrrggbb00
:param[out]   ppixel:    rgb value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a linear transformation that gives the same result
on a single pixel as pixShiftByComponent() gives
on a pix.  Each component is handled separately.  If
the dest component is larger than the src, then the
component is pushed toward 255 by the same fraction as
the src --> dest shift.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixelShiftByComponent(*args)
    
    

    try:
        leptonica.pixelFractionalShift.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixelFractionalShift.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixelFractionalShift not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixelFractionalShift(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', 'fract')       
('l_uint32', '*ppixel')       

:param[in]    rval:      red source component
:param[in]    gval:      green source component
:param[in]    bval:      blue source component
:param[in]    fract:     negative toward black; positive toward white
:param[out]   ppixel:    resulting rgb value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This linear transformation shifts each component a fraction
toward either black (%fract < 0) or white (%fract > 0).
(2) It changes the saturation and intensity, but leaves the hue
invariant.  See usage in pixLinearMapToTargetColor() and
pixMapWithInvariantHue().
(3) %fract is in the range [-1 .... +1].  If %fract < 0,
saturation is increased and brightness is reduced.  The
opposite results if %fract > 0.  If %fract == -1,
the resulting pixel is black; %fract == 1 results in white.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixelFractionalShift(*args)
    
    

    try:
        leptonica.pixMapWithInvariantHue.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_float]
        leptonica.pixMapWithInvariantHue.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMapWithInvariantHue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMapWithInvariantHue(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'srcval')       
('l_float32', 'fract')       

:param[in]    pixd:      [optional]; either NULL or equal to pixs for in-place
:param[in]    pixs:      32 bpp rgb
:param[in]    srcval:    reference source color: 0xrrggbb00
:param[in]    fract:     fraction toward white of dest color
:returns:  pixd   with all pixels mapped based on the srcval/destval mapping,
or pixd on error

<pre>
Notes:
(1) The combination of %srcval and %fract define the linear
hue-preserving transformation, that is applied to all pixels.
(2) %fract is in the range [-1 .... +1].  If %fract < 0,
saturation is increased and brightness is reduced.  The
opposite results if %fract > 0.  If %fract == -1,
%srcval is mapped to black; if %fract == 1, it is mapped to white.
(3) For inplace operation, call it this way:
pixMapWithInvariatHue(pixs, pixs, ... );
For generating a new pixd:
pixd = pixMapWithInvariantHue(NULL, pixs, ...);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMapWithInvariantHue(*args)
    




class colorspace(object):
    """<pre>

Colorspace conversion between RGB and HSV
PIX        *pixConvertRGBToHSV()
PIX        *pixConvertHSVToRGB()
l_int32     convertRGBToHSV()
l_int32     convertHSVToRGB()
l_int32     pixcmapConvertRGBToHSV()
l_int32     pixcmapConvertHSVToRGB()
PIX        *pixConvertRGBToHue()
PIX        *pixConvertRGBToSaturation()
PIX        *pixConvertRGBToValue()

Selection and display of range of colors in HSV space
PIX        *pixMakeRangeMaskHS()
PIX        *pixMakeRangeMaskHV()
PIX        *pixMakeRangeMaskSV()
PIX        *pixMakeHistoHS()
PIX        *pixMakeHistoHV()
PIX        *pixMakeHistoSV()
PIX        *pixFindHistoPeaksHSV()
PIX        *displayHSVColorRange()

Colorspace conversion between RGB and YUV
PIX        *pixConvertRGBToYUV()
PIX        *pixConvertYUVToRGB()
l_int32     convertRGBToYUV()
l_int32     convertYUVToRGB()
l_int32     pixcmapConvertRGBToYUV()
l_int32     pixcmapConvertYUVToRGB()

Colorspace conversion between RGB and XYZ
FPIXA      *pixConvertRGBToXYZ()
PIX        *fpixaConvertXYZToRGB()
l_int32     convertRGBToXYZ()
l_int32     convertXYZToRGB()

Colorspace conversion between XYZ and LAB
FPIXA      *fpixaConvertXYZToLAB()
PIX        *fpixaConvertLABToXYZ()
l_int32     convertXYZToLAB()
l_int32     convertLABToXYZ()
static l_float32  lab_forward()
static l_float32  lab_reverse()

Colorspace conversion between RGB and LAB
FPIXA      *pixConvertRGBToLAB()
PIX        *fpixaConvertLABToRGB()
l_int32     convertRGBToLAB()
l_int32     convertLABToRGB()

Gamut display of RGB color space
PIX        *pixMakeGamutRGB()
</pre>




"""
    
    try:
        leptonica.pixConvertRGBToHSV.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvertRGBToHSV.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToHSV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToHSV(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:    can be NULL; if not NULL, must == pixs
:param[in]    pixs:
:returns:  pixd always

<pre>
Notes:
(1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
(2) The definition of our HSV space is given in convertRGBToHSV().
(3) The h, s and v values are stored in the same places as
the r, g and b values, respectively.  Here, they are explicitly
placed in the 3 MS bytes in the pixel.
(4) Normalizing to 1 and considering the r,g,b components,
a simple way to understand the HSV space is:
~ v = max(r,g,b)
~ s = (max - min) / max
~ h ~ (mid - min) / (max - min)  [apart from signs and constants]
(5) Normalizing to 1, some properties of the HSV space are:
~ For gray values (r = g = b) along the continuum between
black and white:
s = 0  (becoming undefined as you approach black)
h is undefined everywhere
~ Where one component is saturated and the others are zero:
v = 1
s = 1
h = 0 (r = max), 1/3 (g = max), 2/3 (b = max)
~ Where two components are saturated and the other is zero:
v = 1
s = 1
h = 1/2 (if r = 0), 5/6 (if g = 0), 1/6 (if b = 0)
(6) Dividing each component by a constant c > 1 reduces the
brightness v, but leaves the saturation and hue invariant.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToHSV(*args)
    
    

    try:
        leptonica.pixConvertHSVToRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvertHSVToRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertHSVToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertHSVToRGB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:    can be NULL; if not NULL, must == pixs
:param[in]    pixs:
:returns:  pixd always

<pre>
Notes:
(1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
(2) The user takes responsibility for making sure that pixs is
in our HSV space.  The definition of our HSV space is given
in convertRGBToHSV().
(3) The h, s and v values are stored in the same places as
the r, g and b values, respectively.  Here, they are explicitly
placed in the 3 MS bytes in the pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertHSVToRGB(*args)
    
    

    try:
        leptonica.convertRGBToHSV.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertRGBToHSV.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertRGBToHSV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertRGBToHSV(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*phval')       
('l_int32', '*psval')       
('l_int32', '*pvval')       

:param[in]    rval,: gval, bval      RGB input
:param[out]   phval,: psval, pvval   comparable HSV values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The range of returned values is:
h [0 ... 239]
s [0 ... 255]
v [0 ... 255]
(2) If r = g = b, the pixel is gray (s = 0), and we define h = 0.
(3) h wraps around, so that h = 0 and h = 240 are equivalent
in hue space.
(4) h has the following correspondence to color:
h = 0         magenta
h = 40        red
h = 80        yellow
h = 120       green
h = 160       cyan
h = 200       blue
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertRGBToHSV(*args)
    
    

    try:
        leptonica.convertHSVToRGB.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertHSVToRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertHSVToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertHSVToRGB(*args):
        """
        ('l_int32', 'hval')       
('l_int32', 'sval')       
('l_int32', 'vval')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    hval,: sval, vval      HSV input
:param[out]   prval,: pgval, pbval   comparable RGB values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See convertRGBToHSV() for valid input range of HSV values
and their interpretation in color space.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertHSVToRGB(*args)
    
    

    try:
        leptonica.pixcmapConvertRGBToHSV.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapConvertRGBToHSV.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertRGBToHSV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertRGBToHSV(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  0 if OK; 1 on error

<pre>
Notes:
~ in-place transform
~ See convertRGBToHSV() for def'n of HSV space.
~ replaces: r --> h, g --> s, b --> v
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertRGBToHSV(*args)
    
    

    try:
        leptonica.pixcmapConvertHSVToRGB.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapConvertHSVToRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertHSVToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertHSVToRGB(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  0 if OK; 1 on error

<pre>
Notes:
~ in-place transform
~ See convertRGBToHSV() for def'n of HSV space.
~ replaces: h --> r, s --> g, v --> b
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertHSVToRGB(*args)
    
    

    try:
        leptonica.pixConvertRGBToHue.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToHue.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToHue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToHue(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp RGB, or 8 bpp with colormap
:returns:  pixd   8 bpp hue of HSV, or NULL on error

<pre>
Notes:
(1) The conversion to HSV hue is in-lined here.
(2) If there is a colormap, it is removed.
(3) If you just want the hue component, this does it
at about 10 Mpixels/sec/GHz, which is about
2x faster than using pixConvertRGBToHSV()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToHue(*args)
    
    

    try:
        leptonica.pixConvertRGBToSaturation.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToSaturation.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToSaturation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToSaturation(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   32 bpp RGB, or 8 bpp with colormap
:returns:  pixd   8 bpp sat of HSV, or NULL on error

<pre>
Notes:
(1) The conversion to HSV sat is in-lined here.
(2) If there is a colormap, it is removed.
(3) If you just want the saturation component, this does it
at about 12 Mpixels/sec/GHz.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToSaturation(*args)
    
    

    try:
        leptonica.pixConvertRGBToValue.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToValue.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToValue(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp RGB,or 8 bpp with colormap
:returns:  pixd   8 bpp max component intensity of HSV, or NULL on error

<pre>
Notes:
(1) The conversion to HSV sat is in-lined here.
(2) If there is a colormap, it is removed.
(3) If you just want the value component, this does it
at about 35 Mpixels/sec/GHz.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToValue(*args)
    
    

    try:
        leptonica.pixMakeRangeMaskHS.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMakeRangeMaskHS.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeRangeMaskHS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeRangeMaskHS(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'huecenter')       
('l_int32', 'huehw')       
('l_int32', 'satcenter')       
('l_int32', 'sathw')       
('l_int32', 'regionflag')       

:param[in]    pixs:         32 bpp rgb
:param[in]    huecenter:    center value of hue range
:param[in]    huehw:        half-width of hue range
:param[in]    satcenter:    center value of saturation range
:param[in]    sathw:        half-width of saturation range
:param[in]    regionflag:   L_INCLUDE_REGION, L_EXCLUDE_REGION
:returns:  pixd   1 bpp mask over selected pixels, or NULL on error

<pre>
Notes:
(1) The pixels are selected based on the specified ranges of
hue and saturation.  For selection or exclusion, the pixel
HS component values must be within both ranges.  Care must
be taken in finding the hue range because of wrap-around.
(2) Use %regionflag == L_INCLUDE_REGION to take only those
pixels within the rectangular region specified in HS space.
Use %regionflag == L_EXCLUDE_REGION to take all pixels except
those within the rectangular region specified in HS space.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeRangeMaskHS(*args)
    
    

    try:
        leptonica.pixMakeRangeMaskHV.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMakeRangeMaskHV.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeRangeMaskHV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeRangeMaskHV(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'huecenter')       
('l_int32', 'huehw')       
('l_int32', 'valcenter')       
('l_int32', 'valhw')       
('l_int32', 'regionflag')       

:param[in]    pixs:         32 bpp rgb
:param[in]    huecenter:    center value of hue range
:param[in]    huehw:        half-width of hue range
:param[in]    valcenter:    center value of max intensity range
:param[in]    valhw:        half-width of max intensity range
:param[in]    regionflag:   L_INCLUDE_REGION, L_EXCLUDE_REGION
:returns:  pixd   1 bpp mask over selected pixels, or NULL on error

<pre>
Notes:
(1) The pixels are selected based on the specified ranges of
hue and max intensity values.  For selection or exclusion,
the pixel HV component values must be within both ranges.
Care must be taken in finding the hue range because of wrap-around.
(2) Use %regionflag == L_INCLUDE_REGION to take only those
pixels within the rectangular region specified in HV space.
Use %regionflag == L_EXCLUDE_REGION to take all pixels except
those within the rectangular region specified in HV space.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeRangeMaskHV(*args)
    
    

    try:
        leptonica.pixMakeRangeMaskSV.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMakeRangeMaskSV.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeRangeMaskSV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeRangeMaskSV(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'satcenter')       
('l_int32', 'sathw')       
('l_int32', 'valcenter')       
('l_int32', 'valhw')       
('l_int32', 'regionflag')       

:param[in]    pixs:         32 bpp rgb
:param[in]    satcenter:    center value of saturation range
:param[in]    sathw:        half-width of saturation range
:param[in]    valcenter:    center value of max intensity range
:param[in]    valhw:        half-width of max intensity range
:param[in]    regionflag:   L_INCLUDE_REGION, L_EXCLUDE_REGION
:returns:  pixd   1 bpp mask over selected pixels, or NULL on error

<pre>
Notes:
(1) The pixels are selected based on the specified ranges of
saturation and max intensity (val).  For selection or
exclusion, the pixel SV component values must be within both ranges.
(2) Use %regionflag == L_INCLUDE_REGION to take only those
pixels within the rectangular region specified in SV space.
Use %regionflag == L_EXCLUDE_REGION to take all pixels except
those within the rectangular region specified in SV space.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeRangeMaskSV(*args)
    
    

    try:
        leptonica.pixMakeHistoHS.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMakeHistoHS.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeHistoHS not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeHistoHS(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('NUMA', '**pnahue')       
('NUMA', '**pnasat')       

:param[in]    pixs:     HSV colorspace
:param[in]    factor:   subsampling factor; integer
:param[out]   pnahue:   [optional] hue histogram
:param[out]   pnasat:   [optional] saturation histogram
:returns:  pixd   32 bpp histogram in hue and saturation, or NULL on error

<pre>
Notes:
(1) pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
byte, saturation is in the "green" byte.
(2) In pixd, hue is displayed vertically; saturation horizontally.
The dimensions of pixd are w = 256, h = 240, and the depth
is 32 bpp.  The value at each point is simply the number
of pixels found at that value of hue and saturation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeHistoHS(*args)
    
    

    try:
        leptonica.pixMakeHistoHV.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMakeHistoHV.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeHistoHV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeHistoHV(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('NUMA', '**pnahue')       
('NUMA', '**pnaval')       

:param[in]    pixs:     HSV colorspace
:param[in]    factor:   subsampling factor; integer
:param[out]   pnahue:   [optional] hue histogram
:param[out]   pnaval:   [optional] max intensity (value) histogram
:returns:  pixd   32 bpp histogram in hue and value, or NULL on error

<pre>
Notes:
(1) %pixs is a 32 bpp image in HSV colorspace; hue is in the "red"
byte, max intensity ("value") is in the "blue" byte.
(2) In %pixd, hue is displayed vertically; intensity horizontally.
The dimensions of %pixd are w = 256, h = 240, and the depth
is 32 bpp.  The value at each point is simply the number
of pixels found at that value of hue and intensity.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeHistoHV(*args)
    
    

    try:
        leptonica.pixMakeHistoSV.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMakeHistoSV.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeHistoSV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeHistoSV(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('NUMA', '**pnasat')       
('NUMA', '**pnaval')       

:param[in]    pixs:     HSV colorspace
:param[in]    factor:   subsampling factor; integer
:param[out]   pnasat:   [optional] sat histogram
:param[out]   pnaval:   [optional] max intensity (value) histogram
:returns:  pixd   32 bpp histogram in sat and value, or NULL on error

<pre>
Notes:
(1) %pixs is a 32 bpp image in HSV colorspace; sat is in the "green"
byte, max intensity ("value") is in the "blue" byte.
(2) In %pixd, sat is displayed vertically; intensity horizontally.
The dimensions of %pixd are w = 256, h = 256, and the depth
is 32 bpp.  The value at each point is simply the number
of pixels found at that value of saturation and intensity.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeHistoSV(*args)
    
    

    try:
        leptonica.pixFindHistoPeaksHSV.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindHistoPeaksHSV.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindHistoPeaksHSV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindHistoPeaksHSV(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'npeaks')       
('l_float32', 'erasefactor')       
('PTA', '**ppta')       
('NUMA', '**pnatot')       
('PIXA', '**ppixa')       

:param[in]    pixs:          32 bpp; HS, HV or SV histogram; not changed
:param[in]    type:          L_HS_HISTO, L_HV_HISTO or L_SV_HISTO
:param[in]    width:         half width of sliding window
:param[in]    height:        half height of sliding window
:param[in]    npeaks:        number of peaks to look for
:param[in]    erasefactor:   ratio of erase window size to sliding window size
:param[out]   ppta:          locations of max for each integrated peak area
:param[out]   pnatot:        integrated peak areas
:param[out]   ppixa:         [optional] pixa for debugging; NULL to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) %pixs is a 32 bpp histogram in a pair of HSV colorspace.  It
should be thought of as a single sample with 32 bps (bits/sample).
(2) After each peak is found, the peak is erased with a window
that is centered on the peak and scaled from the sliding
window by %erasefactor.  Typically, %erasefactor is chosen
to be > 1.0.
(3) Data for a maximum of %npeaks is returned in %pta and %natot.
(4) For debugging, after the pixa is returned, display with:
pixd = pixaDisplayTiledInRows(pixa, 32, 1000, 1.0, 0, 30, 2);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindHistoPeaksHSV(*args)
    
    

    try:
        leptonica.displayHSVColorRange.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.displayHSVColorRange.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function displayHSVColorRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def displayHSVColorRange(*args):
        """
        ('l_int32', 'hval')       
('l_int32', 'sval')       
('l_int32', 'vval')       
('l_int32', 'huehw')       
('l_int32', 'sathw')       
('l_int32', 'nsamp')       
('l_int32', 'factor')       

:param[in]    hval:     hue center value; in range [0 ... 240]
:param[in]    sval:     saturation center value; in range [0 ... 255]
:param[in]    vval:     max intensity value; in range [0 ... 255]
:param[in]    huehw:    half-width of hue range; > 0
:param[in]    sathw:    half-width of saturation range; > 0
:param[in]    nsamp:    number of samplings in each half-width in hue and sat
:param[in]    factor:   linear size of each color square, in pixels; > 3
:returns:  pixd   32 bpp set of color squares over input range; NULL on error

<pre>
Notes:
(1) The total number of color samplings in each of the hue
and saturation directions is 2 * nsamp + 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.displayHSVColorRange(*args)
    
    

    try:
        leptonica.pixConvertRGBToYUV.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvertRGBToYUV.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToYUV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToYUV(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:   can be NULL; if not NULL, must == pixs
:param[in]    pixs:
:returns:  pixd always

<pre>
Notes:
(1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
(2) The Y, U and V values are stored in the same places as
the r, g and b values, respectively.  Here, they are explicitly
placed in the 3 MS bytes in the pixel.
(3) Normalizing to 1 and considering the r,g,b components,
a simple way to understand the YUV space is:
~ Y = weighted sum of (r,g,b)
~ U = weighted difference between Y and B
~ V = weighted difference between Y and R
(4) Following video conventions, Y, U and V are in the range:
Y: [16, 235]
U: [16, 240]
V: [16, 240]
(5) For the coefficients in the transform matrices, see eq. 4 in
"Frequently Asked Questions about Color" by Charles Poynton,
//http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToYUV(*args)
    
    

    try:
        leptonica.pixConvertYUVToRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvertYUVToRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertYUVToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertYUVToRGB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:   can be NULL; if not NULL, must == pixs
:param[in]    pixs:
:returns:  pixd always

<pre>
Notes:
(1) For pixs = pixd, this is in-place; otherwise pixd must be NULL.
(2) The user takes responsibility for making sure that pixs is
in YUV space.
(3) The Y, U and V values are stored in the same places as
the r, g and b values, respectively.  Here, they are explicitly
placed in the 3 MS bytes in the pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertYUVToRGB(*args)
    
    

    try:
        leptonica.convertRGBToYUV.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertRGBToYUV.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertRGBToYUV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertRGBToYUV(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', '*pyval')       
('l_int32', '*puval')       
('l_int32', '*pvval')       

:param[in]    rval,: gval, bval      RGB input
:param[out]   pyval,: puval, pvval   equivalent YUV values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The range of returned values is:
Y [16 ... 235]
U [16 ... 240]
V [16 ... 240]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertRGBToYUV(*args)
    
    

    try:
        leptonica.convertYUVToRGB.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertYUVToRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertYUVToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertYUVToRGB(*args):
        """
        ('l_int32', 'yval')       
('l_int32', 'uval')       
('l_int32', 'vval')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    yval,: uval, vval      YUV input
:param[out]   prval,: pgval, pbval   equivalent RGB values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The range of valid input values is:
Y [16 ... 235]
U [16 ... 240]
V [16 ... 240]
(2) Conversion of RGB --> YUV --> RGB leaves the image unchanged.
(3) The YUV gamut is larger than the RBG gamut; many YUV values
will result in an invalid RGB value.  We clip individual
r,g,b components to the range [0, 255], and do not test input.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertYUVToRGB(*args)
    
    

    try:
        leptonica.pixcmapConvertRGBToYUV.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapConvertRGBToYUV.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertRGBToYUV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertRGBToYUV(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  0 if OK; 1 on error

<pre>
Notes:
~ in-place transform
~ See convertRGBToYUV() for def'n of YUV space.
~ replaces: r --> y, g --> u, b --> v
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertRGBToYUV(*args)
    
    

    try:
        leptonica.pixcmapConvertYUVToRGB.argtypes = [ctypes.c_void_p]
        leptonica.pixcmapConvertYUVToRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcmapConvertYUVToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcmapConvertYUVToRGB(*args):
        """
        ('PIXCMAP', '*cmap')       

:param[in]    cmap:
:returns:  0 if OK; 1 on error

<pre>
Notes:
~ in-place transform
~ See convertRGBToYUV() for def'n of YUV space.
~ replaces: y --> r, u --> g, v --> b
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcmapConvertYUVToRGB(*args)
    
    

    try:
        leptonica.pixConvertRGBToXYZ.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToXYZ.restype = lambda address: FPIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToXYZ not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToXYZ(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp rgb
:returns:  fpixa xyz

<pre>
Notes:
(1) The [x,y,z] values are stored as float values in three fpix
that are returned in a fpixa.
(2) The XYZ color space was defined in 1931 as a reference model that
simulates human color perception.  When Y is taken as luminance,
the values of X and Z constitute a color plane representing
all the hues that can be perceived.  This gamut of colors
is larger than the gamuts that can be displayed or printed.
For example, although all rgb values map to XYZ, the converse
is not true.
(3) The value of the coefficients depends on the illuminant.  We use
coefficients for converting sRGB under D65 (the spectrum from
a 6500 degree K black body; an approximation to daylight color).
See, e.g.,
http://www.cs.rit.edu/~ncs/color/t_convert.html
For more general information on color transforms, see:
http://www.brucelindbloom.com/
http://user.engineering.uiowa.edu/~aip/Misc/ColorFAQ.html
http://en.wikipedia.org/wiki/CIE_1931_color_space
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToXYZ(*args)
    
    

    try:
        leptonica.fpixaConvertXYZToRGB.argtypes = [ctypes.c_void_p]
        leptonica.fpixaConvertXYZToRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaConvertXYZToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaConvertXYZToRGB(*args):
        """
        ('FPIXA', '*fpixa')       

:param[in]    fpixa:    three fpix: x,y,z
:returns:  pixd   32 bpp rgb

<pre>
Notes:
(1) The xyz image is stored in three fpix.
(2) For values of xyz that are out of gamut for rgb, the rgb
components are set to the closest valid color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaConvertXYZToRGB(*args)
    
    

    try:
        leptonica.convertRGBToXYZ.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertRGBToXYZ.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertRGBToXYZ not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertRGBToXYZ(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', '*pfxval')       
('l_float32', '*pfyval')       
('l_float32', '*pfzval')       

:param[in]    rval,: gval, bval         rgb input
:param[out]   pfxval,: pfyval, pfzval   equivalent xyz values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) These conversions are for illuminant D65 acting on linear sRGB
values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertRGBToXYZ(*args)
    
    

    try:
        leptonica.convertXYZToRGB.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertXYZToRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertXYZToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertXYZToRGB(*args):
        """
        ('l_float32', 'fxval')       
('l_float32', 'fyval')       
('l_float32', 'fzval')       
('l_int32', 'blackout')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    fxval,: fyval, fzval
:param[in]    blackout:    0 to output nearest color if out of gamut;
1 to output black
:param[out]   prval,: pgval, pbval   32 bpp rgb values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For values of xyz that are out of gamut for rgb, at least
one of the r, g or b components will be either less than 0
or greater than 255.  For that situation:
if %blackout == 0, the individual component(s) that are out
of gamut will be set to 0 or 255, respectively.
if %blackout == 1, the output color will be set to black
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertXYZToRGB(*args)
    
    

    try:
        leptonica.fpixaConvertXYZToLAB.argtypes = [ctypes.c_void_p]
        leptonica.fpixaConvertXYZToLAB.restype = lambda address: FPIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaConvertXYZToLAB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaConvertXYZToLAB(*args):
        """
        ('FPIXA', '*fpixas')       

:param[in]    fpixas:    xyz
:returns:  fpixa lab

<pre>
Notes:
(1) The input [x,y,z] and output [l,a,b] values are stored as
float values, each set in three fpix.
(2) The CIE LAB color space was invented in 1976, as an
absolute reference for specifying colors that we can
perceive, independently of the rendering device.  It was
invented to align color display and print images.
For information, see:
http://www.brucelindbloom.com/
http://en.wikipedia.org/wiki/Lab_color_space
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaConvertXYZToLAB(*args)
    
    

    try:
        leptonica.fpixaConvertLABToXYZ.argtypes = [ctypes.c_void_p]
        leptonica.fpixaConvertLABToXYZ.restype = lambda address: FPIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaConvertLABToXYZ not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaConvertLABToXYZ(*args):
        """
        ('FPIXA', '*fpixas')       

:param[in]    fpixas:    lab
:returns:  fpixa    xyz

<pre>
Notes:
(1) The input [l,a,b] and output [x,y,z] values are stored as
float values, each set in three fpix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaConvertLABToXYZ(*args)
    
    

    try:
        leptonica.convertXYZToLAB.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertXYZToLAB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertXYZToLAB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertXYZToLAB(*args):
        """
        ('l_float32', 'xval')       
('l_float32', 'yval')       
('l_float32', 'zval')       
('l_float32', '*plval')       
('l_float32', '*paval')       
('l_float32', '*pbval')       

:param[in]    xval,: yval, zval      input xyz
:param[out]   plval,: paval, pbval   equivalent lab values
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.convertXYZToLAB(*args)
    
    

    try:
        leptonica.convertLABToXYZ.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertLABToXYZ.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertLABToXYZ not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertLABToXYZ(*args):
        """
        ('l_float32', 'lval')       
('l_float32', 'aval')       
('l_float32', 'bval')       
('l_float32', '*pxval')       
('l_float32', '*pyval')       
('l_float32', '*pzval')       

:param[in]    lval,: aval, bval      input lab
:param[out]   pxval,: pyval, pzval   equivalent xyz values
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.convertLABToXYZ(*args)
    
    

    try:
        leptonica.pixConvertRGBToLAB.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToLAB.restype = lambda address: FPIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToLAB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToLAB(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   32 bpp rgb
:returns:  fpixa lab

<pre>
Notes:
(1) The [l,a,b] values are stored as float values in three fpix
that are returned in a fpixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToLAB(*args)
    
    

    try:
        leptonica.fpixaConvertLABToRGB.argtypes = [ctypes.c_void_p]
        leptonica.fpixaConvertLABToRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaConvertLABToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaConvertLABToRGB(*args):
        """
        ('FPIXA', '*fpixa')       

:param[in]    fpixa:    three fpix: l,a,b
:returns:  pixd  32 bpp rgb

<pre>
Notes:
(1) The lab image is stored in three fpix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaConvertLABToRGB(*args)
    
    

    try:
        leptonica.convertRGBToLAB.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertRGBToLAB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertRGBToLAB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertRGBToLAB(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', '*pflval')       
('l_float32', '*pfaval')       
('l_float32', '*pfbval')       

:param[in]    rval,: gval, bval        rgb input
:param[out]   pflval,: pfaval, pfbval  equivalent lab values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) These conversions are for illuminant D65 acting on linear sRGB
values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertRGBToLAB(*args)
    
    

    try:
        leptonica.convertLABToRGB.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertLABToRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertLABToRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertLABToRGB(*args):
        """
        ('l_float32', 'flval')       
('l_float32', 'faval')       
('l_float32', 'fbval')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    flval,: faval, fbval   input lab
:param[out]   prval,: pgval, pbval   equivalent rgb values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For values of lab that are out of gamut for rgb, the rgb
components are set to the closest valid color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertLABToRGB(*args)
    
    

    try:
        leptonica.pixMakeGamutRGB.argtypes = [ctypes.c_int32]
        leptonica.pixMakeGamutRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeGamutRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeGamutRGB(*args):
        """
        ('l_int32', 'scale')       

:param[in]    scale:    default = 4
:returns:  pix2   32 bpp rgb

<pre>
Notes:
(1) This is an image that has all RGB colors, divided into 2^15
cubical cells with 8x8x8 = 512 pixel values.  Each of the 32
subimages has a constant value of B, with R and G varying over
their gamut in 32 steps of size 8.
(2) The %scale parameter determines the replication in both x and y
of each of the 2^15 colors.  With a scale factor of 4, the
output image has 4 * 4 * 2^15 = 0.5M pixels.
(3) This useful for visualizing how filters, such as
pixMakeArbMaskFromRGB(), separate colors into sets.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeGamutRGB(*args)
    




class colorinfo(object):
    """<pre>

Determine color content using proximity.  What can we say about the
color in an image from growing regions with nearly the same color?

L_COLORINFO  *l_colorinfoCreate()
void          l_colorinfoDestroy()

L_COLORINFO  *pixColorContentByLocation()
PIX          *pixColorFill()

Generate data for testing
PIXA         *makeColorinfoTestData()

Static helpers
static COLOREL      *colorelCreate()
static void          pixColorFillFromSeed()
static void          pixGetVisitedNeighbors()
static l_int32       findNextUnvisited()
static l_int32       colorsAreSimilarForFill()
static void          pixelColorIsValid()
static l_int32       pixelIsOnColorBoundary()
static l_int32       evalColorinfoData()

See colorcontent.c for location-independent measures of the amount
of color in an image.
</pre>




"""
    
    try:
        leptonica.l_colorinfoCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_colorinfoCreate.restype = lambda address: L_COLORINFO(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_colorinfoCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_colorinfoCreate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nx')       
('l_int32', 'ny')       

:param[in]    pixs:   input RGB image
:param[in]    nx:     requested number of tiles in each row
:param[in]    ny:     requested number of tiles in each column
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) Tiles must at least 10 pixels in each dimension.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_colorinfoCreate(*args)
    
    

    try:
        leptonica.l_colorinfoDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_colorinfoDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_colorinfoDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_colorinfoDestroy(*args):
        """
        ('L_COLORINFO', '**pci')       

:param[in,out]   pci:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_colorinfoDestroy(*args)
    
    

    try:
        leptonica.pixColorContentByLocation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorContentByLocation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixColorContentByLocation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorContentByLocation(*args):
        """
        ('L_COLORINFO', '*ci')       
('l_int32', 'rref')       
('l_int32', 'gref')       
('l_int32', 'bref')       
('l_int32', 'minmax')       
('l_int32', 'maxdiff')       
('l_int32', 'minarea')       
('l_int32', 'smooth')       
('l_int32', 'debug')       

:param[in]    ci:        colorinfo
:param[in]    rref:      reference value for red component
:param[in]    gref:      reference value for green component
:param[in]    bref:      reference value for blue component
:param[in]    minmax:    min of max component for possible color region
:param[in]    maxdiff:   max component diff to be in same color region
:param[in]    minarea:   min number of pixels for a color region
:param[in]    smooth:    low-pass kernel size (1,3,5); use 1 to skip
:param[in]    debug:     generates debug images and info
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes color information in each tile, identifying
regions of approximately constant color.  It does this
independently for each tile, using flood fills.  Regions
of low intensity are considered 'not colorful'.
(2) The three numbers (rref, gref and bref) can be thought
of in two ways:
(a) as rgb values in the image corresponding to white,
to compensate for an unbalanced color white point.
(b) as the median or mean values of the background color
of a scan.
The gamma TRC transformation, which does not change hue, is used
to modify all colors so that these reference values become white.
These three numbers must either be all 0 or all non-zero.
To skip the TRC transform, set them all to 0.
(3) If the maximum component after white point correction,
max(r,g,b), is less than minmax, the pixel color is invalid, and it
is assigned its neighbor's value in the filling operation.
Use %minmax = 0 for a default value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorContentByLocation(*args)
    
    

    try:
        leptonica.pixColorFill.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorFill.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorFill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorFill(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minmax')       
('l_int32', 'maxdiff')       
('l_int32', 'smooth')       
('l_int32', 'minarea')       
('l_int32', 'debug')       

:param[in]    pixs:      32 bpp RGB
:param[in]    minmax:    min of max component for possible color region
:param[in]    maxdiff:   max component diff to be in same color region
:param[in]    smooth:    low-pass kernel size (1,3,5); use 1 to skip
:param[in]    minarea:   min number of pixels for a color region
:param[in]    debug:     generates debug images and info
:returns:  pixm   mask showing connected regions of similar color,
or null on error

<pre>
Notes:
(1) This is the basic color filling operation.  It sets the
non-color pixel to black, optionally does a low-pass filter,
and grows the 8-connected color components.  Finally, it
removes components that have a small area.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorFill(*args)
    
    

    try:
        leptonica.makeColorinfoTestData.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makeColorinfoTestData.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeColorinfoTestData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeColorinfoTestData(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'nseeds')       
('l_int32', 'range')       

:param[in]       w:         width of generated pix
:param[in]       h:         height of generated pix
:param[in]       nseeds:    number of regions
:param[in]       range:     of color component values
:returns:  pixa   various pix with filled regions of random color,
or NULL on error

<pre>
Notes:
(1) The seeds are random points.  The colors are assigned
randomly from a restricted range of component values,
in [128 - range/2 ... 128 + range/2]
(2) Output is pixa:
pixa[0] cmapped, with color regions shown
- pixa[1] cmapped, additionally with boundary pixels set to black
- pixa[2] cmapped, as in pixa[1] with all non-black pixels
in the same color
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeColorinfoTestData(*args)
    




class gifiostub(object):
    """<pre>

Stubs for gifio.c functions
</pre>




"""
    



class partition(object):
    """<pre>

Whitespace block extraction
BOXA            *boxaGetWhiteblocks()

Helpers
static PARTEL   *partelCreate()
static void      partelDestroy()
static l_int32   partelSetSize()
static BOXA     *boxaGenerateSubboxes()
static BOX      *boxaSelectPivotBox()
static l_int32   boxaCheckIfOverlapIsSmall()
BOXA            *boxaPruneSortedOnOverlap()
</pre>




"""
    
    try:
        leptonica.boxaGetWhiteblocks.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaGetWhiteblocks.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetWhiteblocks not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetWhiteblocks(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       
('l_int32', 'sortflag')       
('l_int32', 'maxboxes')       
('l_float32', 'maxoverlap')       
('l_int32', 'maxperim')       
('l_float32', 'fract')       
('l_int32', 'maxpops')       

:param[in]    boxas:        typ. a set of bounding boxes of fg components
:param[in]    box:          initial region; typically including all boxes
in boxas; if null, it computes the region to
include all boxes in boxas
:param[in]    sortflag:     L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,
L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,
L_SORT_BY_PERIMETER, L_SORT_BY_AREA
:param[in]    maxboxes:     max number of output whitespace boxes; e.g., 100
:param[in]    maxoverlap:   maximum fractional overlap of a box by any
of the larger boxes; e.g., 0.2
:param[in]    maxperim:     maximum half-perimeter, in pixels, for which
pivot is selected by proximity to box centroid;
e.g., 200
:param[in]    fract:        fraction of box diagonal that is an acceptable
distance from the box centroid to select
the pivot; e.g., 0.2
:param[in]    maxpops:      max number of pops from the heap; use 0 as default
:returns:  boxa  of sorted whitespace boxes, or NULL on error

<pre>
Notes:
(1) This uses the elegant Breuel algorithm, found in "Two
Geometric Algorithms for Layout Analysis", 2002,
url: "citeseer.ist.psu.edu/breuel02two.html".
It starts with the bounding boxes (b.b.) of the connected
components (c.c.) in a region, along with the rectangle
representing that region.  It repeatedly divides the
rectangle into four maximal rectangles that exclude a
pivot rectangle, sorting them in a priority queue
according to one of the six sort flags.  It returns a boxa
of the "largest" set that have no intersection with boxes
from the input boxas.
(2) If box == NULL, the initial region is the minimal region
that includes the origin and every box in boxas.
(3) maxboxes is the maximum number of whitespace boxes that will
be returned.  The actual number will depend on the image
and the values chosen for maxoverlap and maxpops.  In many
cases, the actual number will be 'maxboxes'.
(4) maxoverlap allows pruning of whitespace boxes depending on
the overlap.  To avoid all pruning, use maxoverlap = 1.0.
To select only boxes that have no overlap with each other
(maximal pruning), choose maxoverlap = 0.0.
Otherwise, no box can have more than the 'maxoverlap' fraction
of its area overlapped by any larger (in the sense of the
sortflag) box.
(5) Choose maxperim (actually, maximum half-perimeter) to
represent a c.c. that is small enough so that you don't care
about the white space that could be inside of it.  For all such
c.c., the pivot for 'quadfurcation' of a rectangle is selected
as having a reasonable proximity to the rectangle centroid.
(6) Use fract in the range [0.0 ... 1.0].  Set fract = 0.0
to choose the small box nearest the centroid as the pivot.
If you choose fract > 0.0, it is suggested that you call
boxaPermuteRandom() first, to permute the boxes (see usage below).
This should reduce the search time for each of the pivot boxes.
(7) Choose maxpops to be the maximum number of rectangles that
are popped from the heap.  This is an indirect way to limit the
execution time.  Use 0 for default (a fairly large number).
At any time, you can expect the heap to contain about
2.5 times as many boxes as have been popped off.
(8) The output result is a sorted set of overlapping
boxes, constrained by 'maxboxes', 'maxoverlap' and 'maxpops'.
(9) The main defect of the method is that it abstracts out the
actual components, retaining only the b.b. for analysis.
Consider a component with a large b.b.  If this is chosen
as a pivot, all white space inside is immediately taken
out of consideration.  Furthermore, even if it is never chosen
as a pivot, as the partitioning continues, at no time will
any of the whitespace inside this component be part of a
rectangle with zero overlapping boxes.  Thus, the interiors
of all boxes are necessarily excluded from the union of
the returned whitespace boxes.
(10) It should be noted that the algorithm puts a large number
of partels on the queue.  Setting a limit of X partels to
remove from the queue, one typically finds that there will be
several times that number (say, 2X - 3X) left on the queue.
For an efficient algorithm to find the largest white or
or black rectangles, without permitting them to overlap,
see pixFindLargeRectangles().
(11) USAGE: One way to accommodate to this weakness is to remove such
large b.b. before starting the computation.  For example,
if 'box' is an input image region containing 'boxa' b.b. of c.c.:

// Faster pivot choosing
boxaPermuteRandom(boxa, boxa);

// Remove anything either large width or height
boxat = boxaSelectBySize(boxa, maxwidth, maxheight,
L_SELECT_IF_BOTH, L_SELECT_IF_LT,
NULL);

boxad = boxaGetWhiteblocks(boxat, box, type, maxboxes,
maxoverlap, maxperim, fract,
maxpops);

The result will be rectangular regions of "white space" that
extend into (and often through) the excluded components.
(11) As a simple example, suppose you wish to find the columns on a page.
First exclude large c.c. that may block the columns, and then call:

boxad = boxaGetWhiteblocks(boxa, box, L_SORT_BY_HEIGHT,
20, 0.15, 200, 0.2, 2000);

to get the 20 tallest boxes with no more than 0.15 overlap
between a box and any of the taller ones, and avoiding the
use of any c.c. with a b.b. half perimeter greater than 200
as a pivot.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetWhiteblocks(*args)
    
    

    try:
        leptonica.boxaPruneSortedOnOverlap.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.boxaPruneSortedOnOverlap.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaPruneSortedOnOverlap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaPruneSortedOnOverlap(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'maxoverlap')       

:param[in]    boxas:        sorted by size in decreasing order
:param[in]    maxoverlap:   maximum fractional overlap of a box by any
of the larger boxes
:returns:  boxad pruned, or NULL on error

<pre>
Notes:
(1) This selectively removes smaller boxes when they are overlapped
by any larger box by more than the input 'maxoverlap' fraction.
(2) To avoid all pruning, use maxoverlap = 1.0.  To select only
boxes that have no overlap with each other (maximal pruning),
set maxoverlap = 0.0.
(3) If there are no boxes in boxas, returns an empty boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaPruneSortedOnOverlap(*args)
    




class ptra(object):
    """<pre>

Ptra creation and destruction
L_PTRA      *ptraCreate()
void        *ptraDestroy()

Add/insert/remove/replace generic ptr object
l_int32      ptraAdd()
static l_int32  ptraExtendArray()
l_int32      ptraInsert()
void        *ptraRemove()
void        *ptraRemoveLast()
void        *ptraReplace()
l_int32      ptraSwap()
l_int32      ptraCompactArray()

Other array operations
l_int32      ptraReverse()
l_int32      ptraJoin()

Simple Ptra accessors
l_int32      ptraGetMaxIndex()
l_int32      ptraGetActualCount()
void        *ptraGetPtrToItem()

Ptraa creation and destruction
L_PTRAA     *ptraaCreate()
void        *ptraaDestroy()

Ptraa accessors
l_int32      ptraaGetSize()
l_int32      ptraaInsertPtra()
L_PTRA      *ptraaGetPtra()

Ptraa conversion
L_PTRA      *ptraaFlattenToPtra()

Notes on the Ptra:

(1) The Ptra is a struct, not an array.  Always use the accessors
in this file, never the fields directly.
(2) Items can be placed anywhere in the allocated ptr array,
including one index beyond the last ptr (in which case the
ptr array is realloc'd).
(3) Thus, the items on the ptr array need not be compacted.  In
general there will be null pointers in the ptr array.
(4) A compacted array will remain compacted on removal if
arbitrary items are removed with compaction, or if items
are removed from the end of the array.
(5) For addition to and removal from the end of the array, this
functions exactly like a stack, and with the same O(1) cost.
(6) This differs from the generic stack in that we allow
random access for insertion, removal and replacement.
Removal can be done without compacting the array.
Insertion into a null ptr in the array has no effect on
the other pointers, but insertion into a location already
occupied by an item has a cost proportional to the
distance to the next null ptr in the array.
(7) Null ptrs are valid input args for both insertion and
replacement; this allows arbitrary swapping.
(8) The item in the array with the largest index is at pa->imax.
This can be any value from -1 (initialized; all array ptrs
are null) up to pa->nalloc - 1 (the last ptr in the array).
(9) In referring to the array: the first ptr is the "top" or
"beginning"; the last pointer is the "bottom" or "end";
items are shifted "up" towards the top when compaction occurs;
and items are shifted "down" towards the bottom when forced to
move due to an insertion.
(10) It should be emphasized that insertion, removal and replacement
are general:
You can insert an item into any ptr location in the
allocated ptr array, as well as into the next ptr address
beyond the allocated array (in which case a realloc will occur).
You can remove or replace an item from any ptr location
in the allocated ptr array.
When inserting into an occupied location, you have
three options for downshifting.
When removing, you can either leave the ptr null or
compact the array.

Notes on the Ptraa:

(1) The Ptraa is a fixed size ptr array for holding Ptra.
In that respect, it is different from other pointer arrays, which
are extensible and grow using the *Add*() functions.
(2) In general, the Ptra ptrs in the Ptraa can be randomly occupied.
A typical usage is to allow an O(n) horizontal sort of Pix,
where the size of the Ptra array is the width of the image,
and each Ptra is an array of all the Pix at a specific x location.
</pre>




"""
    
    try:
        leptonica.ptraCreate.argtypes = [ctypes.c_int32]
        leptonica.ptraCreate.restype = lambda address: L_PTRA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptraCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:     size of ptr array to be alloc'd; use 0 for default
:returns:  pa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraCreate(*args)
    
    

    try:
        leptonica.ptraDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ptraDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraDestroy(*args):
        """
        ('L_PTRA', '**ppa')       
('l_int32', 'freeflag')       
('l_int32', 'warnflag')       

:param[in,out]   ppa:        will be set to null before returning
:param[in]       freeflag:   TRUE to free each remaining item in the array
:param[in]       warnflag:   TRUE to warn if any remaining items
are not destroyed
:returns:  void

<pre>
Notes:
(1) If %freeflag == TRUE, frees each item in the array.
(2) If %freeflag == FALSE and %warnflag == TRUE, and there are
items on the array, this gives a warning and destroys the array.
If these items are not owned elsewhere, this will cause
a memory leak of all the items that were on the array.
So if the items are not owned elsewhere and require their
own destroy function, they must be destroyed before the ptra.
(3) If %warnflag == FALSE, no warnings will be issued.  This is
useful if the items are owned elsewhere, such as a
PixMemoryStore().
(4) To destroy the ptra, we destroy the ptr array, then
the ptra, and then null the contents of the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraDestroy(*args)
    
    

    try:
        leptonica.ptraAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraAdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraAdd(*args):
        """
        ('L_PTRA', '*pa')       
('void', '*item')       

:param[in]    pa:      ptra
:param[in]    item:    generic ptr to a struct
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This adds the element to the next location beyond imax,
which is the largest occupied ptr in the array.  This is
what you expect from a stack, where all ptrs up to and
including imax are occupied, but here the occuption of
items in the array is entirely arbitrary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraAdd(*args)
    
    

    try:
        leptonica.ptraInsert.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptraInsert.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraInsert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraInsert(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
('void', '*item')       
('l_int32', 'shiftflag')       

:param[in]    pa:          ptra
:param[in]    index:       location in ptra to insert new value
:param[in]    item:        generic ptr to a struct; can be null
:param[in]    shiftflag:   L_AUTO_DOWNSHIFT, L_MIN_DOWNSHIFT, L_FULL_DOWNSHIFT
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This checks first to see if the location is valid, and
then if there is presently an item there.  If there is not,
it is simply inserted into that location.
(2) If there is an item at the insert location, items must be
moved down to make room for the insert.  In the downward
shift there are three options, given by %shiftflag.
~ If %shiftflag == L_AUTO_DOWNSHIFT, a decision is made
whether, in a cascade of items, to downshift a minimum
amount or for all items above %index.  The decision is
based on the expectation of finding holes (null ptrs)
between %index and the bottom of the array.
Assuming the holes are distributed uniformly, if 2 or more
holes are expected, we do a minimum shift.
~ If %shiftflag == L_MIN_DOWNSHIFT, the downward shifting
cascade of items progresses a minimum amount, until
the first empty slot is reached.  This mode requires
some computation before the actual shifting is done.
~ If %shiftflag == L_FULL_DOWNSHIFT, a shifting cascade is
performed where pa[i] --> pa[i + 1] for all i >= index.
Then, the item is inserted at pa[index].
(3) If you are not using L_AUTO_DOWNSHIFT, the rule of thumb is
to use L_FULL_DOWNSHIFT if the array is compacted (each
element points to an item), and to use L_MIN_DOWNSHIFT
if there are a significant number of null pointers.
There is no penalty to using L_MIN_DOWNSHIFT for a
compacted array, however, because the full shift is required
and we don't do the O(n) computation to look for holes.
(4) This should not be used repeatedly on large arrays,
because the function is generally O(n).
(5) However, it can be used repeatedly if we start with an empty
ptr array and insert only once at each location.  For example,
you can support an array of Numa, where at each ptr location
you store either 0 or 1 Numa, and the Numa can be added
randomly to the ptr array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraInsert(*args)
    
    

    try:
        leptonica.ptraRemove.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function ptraRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraRemove(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
('l_int32', 'flag')       

:param[in]    pa:       ptra
:param[in]    index:    element to be removed
:param[in]    flag:     L_NO_COMPACTION, L_COMPACTION
:returns:  item, or NULL on error

<pre>
Notes:
(1) If flag == L_NO_COMPACTION, this removes the item and
nulls the ptr on the array.  If it takes the last item
in the array, pa->n is reduced to the next item.
(2) If flag == L_COMPACTION, this compacts the array for
for all i >= index.  It should not be used repeatedly on
large arrays, because compaction is O(n).
(3) The ability to remove without automatic compaction allows
removal with cost O(1).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraRemove(*args)
    
    

    try:
        leptonica.ptraRemoveLast.argtypes = [ctypes.c_void_p]
        leptonica.ptraRemoveLast.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function ptraRemoveLast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraRemoveLast(*args):
        """
        ('L_PTRA', '*pa')       

:param[in]    pa:    ptra
:returns:  item, or NULL on error or if the array is empty


        """
        args = _convert_params(*args)
        
        return leptonica.ptraRemoveLast(*args)
    
    

    try:
        leptonica.ptraReplace.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptraReplace.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function ptraReplace not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraReplace(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       
('void', '*item')       
('l_int32', 'freeflag')       

:param[in]    pa:          ptra
:param[in]    index:       element to be replaced
:param[in]    item:        new generic ptr to a struct; can be null
:param[in]    freeflag:    TRUE to free old item; FALSE to return it
:returns:  item  old item, if it exists and is not freed,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraReplace(*args)
    
    

    try:
        leptonica.ptraSwap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraSwap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraSwap(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index1')       
('l_int32', 'index2')       

:param[in]    pa: ptra
:param[in]    index1:
:param[in]    index2:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraSwap(*args)
    
    

    try:
        leptonica.ptraCompactArray.argtypes = [ctypes.c_void_p]
        leptonica.ptraCompactArray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraCompactArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraCompactArray(*args):
        """
        ('L_PTRA', '*pa')       

:param[in]    pa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This compacts the items on the array, filling any empty ptrs.
(2) This does not change the size of the array of ptrs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraCompactArray(*args)
    
    

    try:
        leptonica.ptraReverse.argtypes = [ctypes.c_void_p]
        leptonica.ptraReverse.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraReverse(*args):
        """
        ('L_PTRA', '*pa')       

:param[in]    pa:     ptra
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraReverse(*args)
    
    

    try:
        leptonica.ptraJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraJoin(*args):
        """
        ('L_PTRA', '*pa1')       
('L_PTRA', '*pa2')       

:param[in]    pa1:    add to this one
:param[in]    pa2:    appended to pa1, and emptied of items; can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraJoin(*args)
    
    

    try:
        leptonica.ptraGetMaxIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraGetMaxIndex.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraGetMaxIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraGetMaxIndex(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', '*pmaxindex')       

:param[in]    pa:          ptra
:param[out]   pmaxindex:   index of last item in the array;
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The largest index to an item in the array is %maxindex.
%maxindex is one less than the number of items that would be
in the array if there were no null pointers between 0
and %maxindex - 1.  However, because the internal ptr array
need not be compacted, there may be NULL pointers at
indices below %maxindex; for example, if items have
been removed.
(2) When an item is added to the end of the array, it goes
into pa->array[maxindex + 1], and maxindex is then
incremented by 1.
(3) If there are no items in the array, this returns %maxindex = -1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraGetMaxIndex(*args)
    
    

    try:
        leptonica.ptraGetActualCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraGetActualCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraGetActualCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraGetActualCount(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', '*pcount')       

:param[in]    pa:        ptra
:param[out]   pcount:    actual number of items on the ptr array
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The actual number of items on the ptr array, pa->nactual,
will be smaller than pa->n if the array is not compacted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraGetActualCount(*args)
    
    

    try:
        leptonica.ptraGetPtrToItem.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptraGetPtrToItem.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function ptraGetPtrToItem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraGetPtrToItem(*args):
        """
        ('L_PTRA', '*pa')       
('l_int32', 'index')       

:param[in]    pa:       ptra
:param[in]    index:    of element to be retrieved
:returns:  a ptr to the element, or NULL on error

<pre>
Notes:
(1) This returns a ptr to the item.  You must cast it to
the type of item.  Do not destroy it; the item belongs
to the Ptra.
(2) This can access all possible items on the ptr array.
If an item doesn't exist, it returns null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraGetPtrToItem(*args)
    
    

    try:
        leptonica.ptraaCreate.argtypes = [ctypes.c_int32]
        leptonica.ptraaCreate.restype = lambda address: L_PTRAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptraaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    size of ptr array to be alloc'd
:returns:  paa, or NULL on error

<pre>
Notes:
(1) The ptraa is generated with a fixed size, that can not change.
The ptra can be generated and inserted randomly into this array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaCreate(*args)
    
    

    try:
        leptonica.ptraaDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ptraaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaDestroy(*args):
        """
        ('L_PTRAA', '**ppaa')       
('l_int32', 'freeflag')       
('l_int32', 'warnflag')       

:param[in,out]   ppaa:       will be set to null before returning
:param[in]       freeflag:   TRUE to free each remaining item in each ptra
:param[in]       warnflag:   TRUE to warn if any remaining items
are not destroyed
:returns:  void

<pre>
Notes:
(1) See ptraDestroy() for use of %freeflag and %warnflag.
(2) To destroy the ptraa, we destroy each ptra, then the ptr array,
then the ptraa, and then null the contents of the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaDestroy(*args)
    
    

    try:
        leptonica.ptraaGetSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraaGetSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraaGetSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaGetSize(*args):
        """
        ('L_PTRAA', '*paa')       
('l_int32', '*psize')       

:param[in]    paa:
:param[out]   psize:    size of ptr array
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaGetSize(*args)
    
    

    try:
        leptonica.ptraaInsertPtra.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptraaInsertPtra.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraaInsertPtra not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaInsertPtra(*args):
        """
        ('L_PTRAA', '*paa')       
('l_int32', 'index')       
('L_PTRA', '*pa')       

:param[in]    paa:      ptraa
:param[in]    index:    location in array for insertion
:param[in]    pa:       to be inserted
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Caller should check return value.  On success, the Ptra
is inserted in the Ptraa and is owned by it.  However,
on error, the Ptra remains owned by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaInsertPtra(*args)
    
    

    try:
        leptonica.ptraaGetPtra.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.ptraaGetPtra.restype = lambda address: L_PTRA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptraaGetPtra not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaGetPtra(*args):
        """
        ('L_PTRAA', '*paa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    paa:          ptraa
:param[in]    index:        location in array
:param[in]    accessflag:   L_HANDLE_ONLY, L_REMOVE
:returns:  ptra at index location, or NULL on error or if there
is no ptra there.

<pre>
Notes:
(1) This returns the ptra ptr.  If %accessflag == L_HANDLE_ONLY,
the ptra is left on the ptraa.  If %accessflag == L_REMOVE,
the ptr in the ptraa is set to NULL, and the caller
is responsible for disposing of the ptra (either putting it
back on the ptraa, or destroying it).
(2) This returns NULL if there is no Ptra at the index location.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaGetPtra(*args)
    
    

    try:
        leptonica.ptraaFlattenToPtra.argtypes = [ctypes.c_void_p]
        leptonica.ptraaFlattenToPtra.restype = lambda address: L_PTRA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptraaFlattenToPtra not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraaFlattenToPtra(*args):
        """
        ('L_PTRAA', '*paa')       

:param[in]    paa:    ptraa
:returns:  ptra, or NULL on error

<pre>
Notes:
(1) This 'flattens' the ptraa to a ptra, taking the items in
each ptra, in order, starting with the first ptra, etc.
(2) As a side-effect, the ptra are all removed from the ptraa
and destroyed, leaving an empty ptraa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraaFlattenToPtra(*args)
    




class spixio(object):
    """<pre>

This does fast serialization of a pix in memory to file,
copying the raw data for maximum speed.  The underlying
function serializes it to memory, and it is wrapped to be
callable from standard pixRead() and pixWrite() file functions.

Reading spix from file
PIX        *pixReadStreamSpix()
l_int32     readHeaderSpix()
l_int32     freadHeaderSpix()
l_int32     sreadHeaderSpix()

Writing spix to file
l_int32     pixWriteStreamSpix()

Low-level serialization of pix to/from memory (uncompressed)
PIX        *pixReadMemSpix()
l_int32     pixWriteMemSpix()
l_int32     pixSerializeToMemory()
PIX        *pixDeserializeFromMemory()

Note: these functions have not been extensively tested for fuzzing
(bad input data that can result in, e.g., memory faults).
The spix serialization format is only defined here, in leptonica.
The image data is uncompressed and the serialization is not intended
to be a secure file format from untrusted sources.
</pre>




"""
    
    try:
        leptonica.pixReadStreamSpix.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamSpix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamSpix(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:     file stream
:returns:  pix, or NULL on error.

<pre>
Notes:
(1) If called from pixReadStream(), the stream is positioned
at the beginning of the file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamSpix(*args)
    
    

    try:
        leptonica.readHeaderSpix.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderSpix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderSpix(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    filename:
:param[out]   pwidth:     width
:param[out]   pheight:    height
:param[out]   pbps:       bits/sample
:param[out]   pspp:       samples/pixel
:param[out]   piscmap:    [optional]  input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there is a colormap, iscmap is returned as 1; else 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderSpix(*args)
    
    

    try:
        leptonica.freadHeaderSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderSpix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function freadHeaderSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderSpix(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    fp:        file stream
:param[out]   pwidth:    width
:param[out]   pheight:   height
:param[out]   pbps:      bits/sample
:param[out]   pspp:      samples/pixel
:param[out]   piscmap:   [optional]  input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there is a colormap, iscmap is returned as 1; else 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderSpix(*args)
    
    

    try:
        leptonica.sreadHeaderSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sreadHeaderSpix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sreadHeaderSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sreadHeaderSpix(*args):
        """
        ('const l_uint32', '*data')       
('l_int32', '*pwidth')       
('l_int32', '*pheight')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    data:
:param[out]   pwidth:    width
:param[out]   pheight:   height
:param[out]   pbps:      bits/sample
:param[out]   pspp:      samples/pixel
:param[out]   piscmap:   [optional]  input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there is a colormap, iscmap is returned as 1; else 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sreadHeaderSpix(*args)
    
    

    try:
        leptonica.pixWriteStreamSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamSpix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamSpix(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       

:param[in]    fp:     file stream
:param[in]    pix:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamSpix(*args)
    
    

    try:
        leptonica.pixReadMemSpix.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemSpix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemSpix(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    const; uncompressed
:param[in]    size:    bytes of data
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemSpix(*args)
    
    

    try:
        leptonica.pixWriteMemSpix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemSpix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemSpix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemSpix(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       

:param[out]   pdata:    data of serialized, uncompressed pix
:param[out]   psize:    size of returned data
:param[in]    pix:      all depths; colormap OK
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemSpix(*args)
    
    

    try:
        leptonica.pixSerializeToMemory.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSerializeToMemory.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSerializeToMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSerializeToMemory(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pixs:     all depths, colormap OK
:param[out]   pdata:    serialized data in memory
:param[out]   pnbytes:  number of bytes in data string
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a fast serialization of the principal elements
of the pix, as follows:
"spix"    (4 bytes) -- ID for file type
w         (4 bytes)
h         (4 bytes)
d         (4 bytes)
wpl       (4 bytes)
ncolors   (4 bytes) -- in colormap; 0 if there is no colormap
cdata     (4 * ncolors)  -- size of serialized colormap array
rdatasize (4 bytes) -- size of serialized raster data
= 4 * wpl * h
rdata     (rdatasize)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSerializeToMemory(*args)
    
    

    try:
        leptonica.pixDeserializeFromMemory.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixDeserializeFromMemory.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDeserializeFromMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeserializeFromMemory(*args):
        """
        ('const l_uint32', '*data')       
('size_t', 'nbytes')       

:param[in]    data:     serialized data in memory
:param[in]    nbytes:   number of bytes in data string
:returns:  pix, or NULL on error

<pre>
Notes:
(1) See pixSerializeToMemory() for the binary format.
(2) Note the image size limits.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeserializeFromMemory(*args)
    




class bardecode(object):
    """<pre>

Dispatcher
char            *barcodeDispatchDecoder()

Format Determination
static l_int32   barcodeFindFormat()
l_int32          barcodeFormatIsSupported()
static l_int32   barcodeVerifyFormat()

Decode 2 of 5
static char     *barcodeDecode2of5()

Decode Interleaved 2 of 5
static char     *barcodeDecodeI2of5()

Decode Code 93
static char     *barcodeDecode93()

Decode Code 39
static char     *barcodeDecode39()

Decode Codabar
static char     *barcodeDecodeCodabar()

Decode UPC-A
static char     *barcodeDecodeUpca()

Decode EAN 13
static char     *barcodeDecodeEan13()
</pre>




"""
    
    try:
        leptonica.barcodeDispatchDecoder.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.barcodeDispatchDecoder.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function barcodeDispatchDecoder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def barcodeDispatchDecoder(*args):
        """
        ('char', '*barstr')       
('l_int32', 'format')       
('l_int32', 'debugflag')       

:param[in]    barstr:      string of integers in set {1,2,3,4} of bar widths
:param[in]    format:      L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...
:param[in]    debugflag:   use 1 to generate debug output
:returns:  data string of decoded barcode data, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.barcodeDispatchDecoder(*args)
    
    

    try:
        leptonica.barcodeFormatIsSupported.argtypes = [ctypes.c_int32]
        leptonica.barcodeFormatIsSupported.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function barcodeFormatIsSupported not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def barcodeFormatIsSupported(*args):
        """
        ('l_int32', 'format')       

:param[in]    format:
:returns:  1 if format is one of those supported; 0 otherwise



        """
        args = _convert_params(*args)
        
        return leptonica.barcodeFormatIsSupported(*args)
    




class compare(object):
    """<pre>

Test for pix equality
l_int32     pixEqual()
l_int32     pixEqualWithAlpha()
l_int32     pixEqualWithCmap()
l_int32     cmapEqual()
l_int32     pixUsesCmapColor()

Binary correlation
l_int32     pixCorrelationBinary()

Difference of two images of same size
l_int32     pixDisplayDiffBinary()
l_int32     pixCompareBinary()
l_int32     pixCompareGrayOrRGB()
l_int32     pixCompareGray()
l_int32     pixCompareRGB()
l_int32     pixCompareTiled()

Other measures of the difference of two images of the same size
NUMA       *pixCompareRankDifference()
l_int32     pixTestForSimilarity()
l_int32     pixGetDifferenceStats()
NUMA       *pixGetDifferenceHistogram()
l_int32     pixGetPerceptualDiff()
l_int32     pixGetPSNR()

Comparison of photo regions by histogram
l_int32     pixaComparePhotoRegionsByHisto()  -- top-level
l_int32     pixComparePhotoRegionsByHisto()  -- top-level for 2
l_int32     pixGenPhotoHistos()
PIX        *pixPadToCenterCentroid()
l_int32     pixCentroid8()
l_int32     pixDecideIfPhotoImage()
static l_int32  findHistoGridDimensions()
l_int32     compareTilesByHisto()

l_int32     pixCompareGrayByHisto()  -- top-level for 2
static l_int32  pixCompareTilesByHisto()
l_int32     pixCropAlignedToCentroid()

l_uint8    *l_compressGrayHistograms()
NUMAA      *l_uncompressGrayHistograms()

Translated images at the same resolution
l_int32     pixCompareWithTranslation()
l_int32     pixBestCorrelation()

For comparing images using tiled histograms, essentially all the
computation goes into deciding if a region of an image is a photo,
whether that photo region is amenable to similarity measurements
using histograms, and finally the calculation of the gray histograms
for each of the tiled regions.  The actual comparison is essentially
instantaneous.  Therefore, with a large number of images to compare
with each other, it is important to first calculate the histograms
for each image.  Then the comparisons, which go as the square of the
number of images, actually takes no time.

A high level function that takes a pixa of images and does
all comparisons, pixaComparePhotosByHisto(), uses this split
approach.  It pads the images so that the centroid is in the center,
which will allow the tiles to be better aligned.

For testing purposes, two functions are given that do all the work
to compare just two photo regions:
pixComparePhotoRegionsByHisto() uses the split approach, qualifying
the images first with pixGenPhotoHistos(), and then comparing
with compareTilesByHisto().
pixCompareGrayByHisto() aligns the two images by centroid
and calls pixCompareTilesByHisto() to generate the histograms
and do the comparison.

</pre>




"""
    
    try:
        leptonica.pixEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixEqual.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqual(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', '*psame')       

:param[in]    pix1:
:param[in]    pix2:
:param[out]   psame:  1 if same; 0 if different
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Equality is defined as having the same pixel values for
each respective image pixel.
(2) This works on two pix of any depth.  If one or both pix
have a colormap, the depths can be different and the
two pix can still be equal.
(3) This ignores the alpha component for 32 bpp images.
(4) If both pix have colormaps and the depths are equal,
use the pixEqualWithCmap() function, which does a fast
comparison if the colormaps are identical and a relatively
slow comparison otherwise.
(5) In all other cases, any existing colormaps must first be
removed before doing pixel comparison.  After the colormaps
are removed, the resulting two images must have the same depth.
The "lowest common denominator" is RGB, but this is only
chosen when necessary, or when both have colormaps but
different depths.
(6) For images without colormaps that are not 32 bpp, all bits
in the image part of the data array must be identical.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqual(*args)
    
    

    try:
        leptonica.pixEqualWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixEqualWithAlpha.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixEqualWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqualWithAlpha(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'use_alpha')       
('l_int32', '*psame')       

:param[in]    pix1:
:param[in]    pix2:
:param[in]    use_alpha:   1 to compare alpha in RGBA; 0 to ignore
:param[out]   psame:       1 if same; 0 if different
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) See notes in pixEqual().
(2) This is more general than pixEqual(), in that for 32 bpp
RGBA images, where spp = 4, you can optionally include
the alpha component in the comparison.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqualWithAlpha(*args)
    
    

    try:
        leptonica.pixEqualWithCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixEqualWithCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixEqualWithCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqualWithCmap(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', '*psame')       

:param[in]    pix1:
:param[in]    pix2:
:param[out]   psame:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns same = TRUE if the images have identical content.
(2) Both pix must have a colormap, and be of equal size and depth.
If these conditions are not satisfied, it is not an error;
the returned result is same = FALSE.
(3) We then check whether the colormaps are the same; if so,
the comparison proceeds 32 bits at a time.
(4) If the colormaps are different, the comparison is done by
slow brute force.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqualWithCmap(*args)
    
    

    try:
        leptonica.cmapEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.cmapEqual.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function cmapEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def cmapEqual(*args):
        """
        ('PIXCMAP', '*cmap1')       
('PIXCMAP', '*cmap2')       
('l_int32', 'ncomps')       
('l_int32', '*psame')       

:param[in]    cmap1:
:param[in]    cmap2:
:param[in]    ncomps:  3 for RGB, 4 for RGBA
:param[out]   psame:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns %same = TRUE if the colormaps have identical entries.
(2) If %ncomps == 4, the alpha components of the colormaps are also
compared.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.cmapEqual(*args)
    
    

    try:
        leptonica.pixUsesCmapColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixUsesCmapColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixUsesCmapColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUsesCmapColor(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pcolor')       

:param[in]    pixs:     any depth, colormap
:param[out]   pcolor:   TRUE if color found
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns color = TRUE if three things are obtained:
(a) the pix has a colormap
(b) the colormap has at least one color entry
(c) a color entry is actually used
(2) It is used in pixEqual() for comparing two images, in a
situation where it is required to know if the colormap
has color entries that are actually used in the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUsesCmapColor(*args)
    
    

    try:
        leptonica.pixCorrelationBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationBinary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCorrelationBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationBinary(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_float32', '*pval')       

:param[in]    pix1:    1 bpp
:param[in]    pix2:    1 bpp
:param[out]   pval:    correlation
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The correlation is a number between 0.0 and 1.0,
based on foreground similarity:
(|1 AND 2|)**2
correlation =  --------------
|1| * |2|
where |x| is the count of foreground pixels in image x.
If the images are identical, this is 1.0.
If they have no fg pixels in common, this is 0.0.
If one or both images have no fg pixels, the correlation is 0.0.
(2) Typically the two images are of equal size, but this
is not enforced.  Instead, the UL corners are aligned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationBinary(*args)
    
    

    try:
        leptonica.pixDisplayDiffBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDisplayDiffBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayDiffBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayDiffBinary(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       

:param[in]    pix1:    1 bpp
:param[in]    pix2:    1 bpp
:returns:  pixd 4 bpp cmapped, or NULL on error

<pre>
Notes:
(1) This gives a color representation of the difference between
pix1 and pix2.  The color difference depends on the order.
The pixels in pixd have 4 colors:
unchanged:  black (on), white (off)
on in pix1, off in pix2: red
on in pix2, off in pix1: green
(2) This aligns the UL corners of pix1 and pix2, and crops
to the overlapping pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayDiffBinary(*args)
    
    

    try:
        leptonica.pixCompareBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareBinary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareBinary(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_float32', '*pfract')       
('PIX', '**ppixdiff')       

:param[in]    pix1:       1 bpp
:param[in]    pix2:       1 bpp
:param[in]    comptype:   L_COMPARE_XOR, L_COMPARE_SUBTRACT
:param[out]   pfract:     fraction of pixels that are different
:param[out]   ppixdiff:   [optional] pix of difference
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The two images are aligned at the UL corner, and do not
need to be the same size.
(2) If using L_COMPARE_SUBTRACT, pix2 is subtracted from pix1.
(3) The total number of pixels is determined by pix1.
(4) On error, the returned fraction is 1.0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareBinary(*args)
    
    

    try:
        leptonica.pixCompareGrayOrRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareGrayOrRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareGrayOrRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareGrayOrRGB(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_int32', 'plottype')       
('l_int32', '*psame')       
('l_float32', '*pdiff')       
('l_float32', '*prmsdiff')       
('PIX', '**ppixdiff')       

:param[in]    pix1:      2,4,8,16 bpp gray, 32 bpp rgb, or colormapped
:param[in]    pix2:      2,4,8,16 bpp gray, 32 bpp rgb, or colormapped
:param[in]    comptype:  L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF
:param[in]    plottype:  gplot plot output type, or 0 for no plot
:param[out]   psame:     [optional] 1 if pixel values are identical
:param[out]   pdiff:     [optional] average difference
:param[out]   prmsdiff:  [optional] rms of difference
:param[out]   ppixdiff:  [optional] pix of difference
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The two images are aligned at the UL corner, and do not
need to be the same size.  If they are not the same size,
the comparison will be made over overlapping pixels.
(2) If there is a colormap, it is removed and the result
is either gray or RGB depending on the colormap.
(3) If RGB, each component is compared separately.
(4) If type is L_COMPARE_ABS_DIFF, pix2 is subtracted from pix1
and the absolute value is taken.
(5) If type is L_COMPARE_SUBTRACT, pix2 is subtracted from pix1
and the result is clipped to 0.
(6) The plot output types are specified in gplot.h.
Use 0 if no difference plot is to be made.
(7) If the images are pixelwise identical, no difference
plot is made, even if requested.  The result (TRUE or FALSE)
is optionally returned in the parameter 'same'.
(8) The average difference (either subtracting or absolute value)
is optionally returned in the parameter 'diff'.
(9) The RMS difference is optionally returned in the
parameter 'rmsdiff'.  For RGB, we return the average of
the RMS differences for each of the components.
(10) Because pixel values are compared, pix1 and pix2 can be equal when:
they are both gray with different depth
one is colormapped and the other is not
they are both colormapped and have different size colormaps
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareGrayOrRGB(*args)
    
    

    try:
        leptonica.pixCompareGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareGray(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_int32', 'plottype')       
('l_int32', '*psame')       
('l_float32', '*pdiff')       
('l_float32', '*prmsdiff')       
('PIX', '**ppixdiff')       

:param[in]    pix1:       8 or 16 bpp, not cmapped
:param[in]    pix2:       8 or 16 bpp, not cmapped
:param[in]    comptype:   L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF
:param[in]    plottype:   gplot plot output type, or 0 for no plot
:param[out]   psame:      [optional] 1 if pixel values are identical
:param[out]   pdiff:      [optional] average difference
:param[out]   prmsdiff:   [optional] rms of difference
:param[out]   ppixdiff:   [optional] pix of difference
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) See pixCompareGrayOrRGB() for details.
(2) Use pixCompareGrayOrRGB() if the input pix are colormapped.
(3) Note: setting %plottype > 0 can result in writing named
output files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareGray(*args)
    
    

    try:
        leptonica.pixCompareRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCompareRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareRGB(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'comptype')       
('l_int32', 'plottype')       
('l_int32', '*psame')       
('l_float32', '*pdiff')       
('l_float32', '*prmsdiff')       
('PIX', '**ppixdiff')       

:param[in]    pix1:       32 bpp rgb
:param[in]    pix2:       32 bpp rgb
:param[in]    comptype:   L_COMPARE_SUBTRACT, L_COMPARE_ABS_DIFF
:param[in]    plottype:   gplot plot output type, or 0 for no plot
:param[out]   psame:      [optional] 1 if pixel values are identical
:param[out]   pdiff:      [optional] average difference
:param[out]   prmsdiff:   [optional] rms of difference
:param[out]   ppixdiff:   [optional] pix of difference
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) See pixCompareGrayOrRGB() for details.
(2) Note: setting %plottype > 0 can result in writing named
output files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareRGB(*args)
    
    

    try:
        leptonica.pixCompareTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCompareTiled.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareTiled(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'type')       
('PIX', '**ppixdiff')       

:param[in]    pix1:       8 bpp or 32 bpp rgb
:param[in]    pix2:       8 bpp 32 bpp rgb
:param[in]    sx,: sy     tile size; must be > 1 in each dimension
:param[in]    type:       L_MEAN_ABSVAL or L_ROOT_MEAN_SQUARE
:param[out]   ppixdiff:   pix of difference
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) With L_MEAN_ABSVAL, we compute for each tile the
average abs value of the pixel component difference between
the two (aligned) images.  With L_ROOT_MEAN_SQUARE, we
compute instead the rms difference over all components.
(2) The two input pix must be the same depth.  Comparison is made
using UL corner alignment.
(3) For 32 bpp, the distance between corresponding tiles
is found by averaging the measured difference over all three
components of each pixel in the tile.
(4) The result, pixdiff, contains one pixel for each source tile.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareTiled(*args)
    
    

    try:
        leptonica.pixCompareRankDifference.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCompareRankDifference.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareRankDifference not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareRankDifference(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       

:param[in]    pix1:      8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    pix2:      8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    factor:    subsampling factor; use 0 or 1 for no subsampling
:returns:  narank      numa of rank difference, or NULL on error

<pre>
Notes:
(1) This answers the question: if the pixel values in each
component are compared by absolute difference, for
any value of difference, what is the fraction of
pixel pairs that have a difference of this magnitude
or greater.  For a difference of 0, the fraction is 1.0.
In this sense, it is a mapping from pixel difference to
rank order of difference.
(2) The two images are aligned at the UL corner, and do not
need to be the same size.  If they are not the same size,
the comparison will be made over overlapping pixels.
(3) If there is a colormap, it is removed and the result
is either gray or RGB depending on the colormap.
(4) If RGB, pixel differences for each component are aggregated
into a single histogram.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareRankDifference(*args)
    
    

    try:
        leptonica.pixTestForSimilarity.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixTestForSimilarity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTestForSimilarity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTestForSimilarity(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('l_int32', 'mindiff')       
('l_float32', 'maxfract')       
('l_float32', 'maxave')       
('l_int32', '*psimilar')       
('l_int32', 'details')       

:param[in]    pix1:         8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    pix2:         8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    factor:       subsampling factor; use 0 or 1 for no subsampling
:param[in]    mindiff:      minimum pixel difference to be counted; > 0
:param[in]    maxfract:     maximum fraction of pixels allowed to have
diff greater than or equal to mindiff
:param[in]    maxave:       maximum average difference of pixels allowed for
pixels with diff greater than or equal to
mindiff, after subtracting mindiff
:param[out]   psimilar:     1 if similar, 0 otherwise
:param[in]    details:      use 1 to give normalized histogram and other data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This takes 2 pix that are the same size and determines using
3 input parameters if they are "similar".  The first parameter
%mindiff establishes a criterion of pixel-to-pixel similarity:
two pixels are not similar if their difference in value is
at least mindiff.  Then %maxfract and %maxave are thresholds
on the number and distribution of dissimilar pixels
allowed for the two pix to be similar.   If the pix are
to be similar, neither threshold can be exceeded.
(2) In setting the %maxfract and %maxave thresholds, you have
these options:
(a) Base the comparison only on %maxfract.  Then set
%maxave = 0.0 or 256.0.  (If 0, we always ignore it.)
(b) Base the comparison only on %maxave.  Then set
%maxfract = 1.0.
(c) Base the comparison on both thresholds.
(3) Example of values that can be expected at mindiff = 15 when
comparing lossless png encoding with jpeg encoding, q=75:
(smoothish bg)       fractdiff = 0.01, avediff = 2.5
(natural scene)      fractdiff = 0.13, avediff = 3.5
To identify these images as 'similar', select maxfract
and maxave to be upper bounds of what you expect.
(4) See pixGetDifferenceStats() for a discussion of why we subtract
mindiff from the computed average diff of the nonsimilar pixels
to get the 'avediff' returned by that function.
(5) If there is a colormap, it is removed and the result
is either gray or RGB depending on the colormap.
(6) If RGB, the maximum difference between pixel components is
saved in the histogram.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTestForSimilarity(*args)
    
    

    try:
        leptonica.pixGetDifferenceStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetDifferenceStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetDifferenceStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetDifferenceStats(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('l_int32', 'mindiff')       
('l_float32', '*pfractdiff')       
('l_float32', '*pavediff')       
('l_int32', 'details')       

:param[in]    pix1:        8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    pix2:        8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    factor:      subsampling factor; use 0 or 1 for no subsampling
:param[in]    mindiff:     minimum pixel difference to be counted; > 0
:param[out]   pfractdiff:  fraction of pixels with diff greater than or
equal to mindiff
:param[out]   pavediff:    average difference of pixels with diff greater
than or equal to mindiff, less mindiff
:param[in]    details:     use 1 to give normalized histogram and other data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This takes a threshold %mindiff and describes the difference
between two images in terms of two numbers:
(a) the fraction of pixels, %fractdiff, whose difference
equals or exceeds the threshold %mindiff, and
(b) the average value %avediff of the difference in pixel value
for the pixels in the set given by (a), after you subtract
%mindiff.  The reason for subtracting %mindiff is that
you then get a useful measure for the rate of falloff
of the distribution for larger differences.  For example,
if %mindiff = 10 and you find that %avediff = 2.5, it
says that of the pixels with diff > 10, the average of
their diffs is just mindiff + 2.5 = 12.5.  This is a
fast falloff in the histogram with increasing difference.
(2) The two images are aligned at the UL corner, and do not
need to be the same size.  If they are not the same size,
the comparison will be made over overlapping pixels.
(3) If there is a colormap, it is removed and the result
is either gray or RGB depending on the colormap.
(4) If RGB, the maximum difference between pixel components is
saved in the histogram.
(5) Set %details == 1 to see the difference histogram and get
an output that shows for each value of %mindiff, what are the
minimum values required for fractdiff and avediff in order
that the two pix will be considered similar.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetDifferenceStats(*args)
    
    

    try:
        leptonica.pixGetDifferenceHistogram.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetDifferenceHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetDifferenceHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetDifferenceHistogram(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       

:param[in]    pix1:      8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    pix2:      8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    factor:    subsampling factor; use 0 or 1 for no subsampling
:returns:  na     Numa of histogram of differences, or NULL on error

<pre>
Notes:
(1) The two images are aligned at the UL corner, and do not
need to be the same size.  If they are not the same size,
the comparison will be made over overlapping pixels.
(2) If there is a colormap, it is removed and the result
is either gray or RGB depending on the colormap.
(3) If RGB, the maximum difference between pixel components is
saved in the histogram.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetDifferenceHistogram(*args)
    
    

    try:
        leptonica.pixGetPerceptualDiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetPerceptualDiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetPerceptualDiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPerceptualDiff(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'sampling')       
('l_int32', 'dilation')       
('l_int32', 'mindiff')       
('l_float32', '*pfract')       
('PIX', '**ppixdiff1')       
('PIX', '**ppixdiff2')       

:param[in]    pixs1:       8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    pixs2:       8 bpp gray or 32 bpp rgb, or colormapped
:param[in]    sampling:    subsampling factor; use 0 or 1 for no subsampling
:param[in]    dilation:    size of grayscale or color Sel; odd
:param[in]    mindiff:     minimum pixel difference to be counted; > 0
:param[out]   pfract:      fraction of pixels with diff greater than mindiff
:param[out]   ppixdiff1:   [optional] showing difference (gray or color)
:param[out]   ppixdiff2:   [optional] showing pixels of sufficient diff
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This takes 2 pix and determines, using 2 input parameters:
%dilation specifies the amount of grayscale or color
dilation to apply to the images, to compensate for
a small amount of misregistration.  A typical number might
be 5, which uses a 5x5 Sel.  Grayscale dilation expands
lighter pixels into darker pixel regions.
%mindiff determines the threshold on the difference in
pixel values to be counted -- two pixels are not similar
if their difference in value is at least %mindiff.  For
color pixels, we use the maximum component difference.
(2) The pixelwise comparison is always done with the UL corners
aligned.  The sizes of pix1 and pix2 need not be the same,
although in practice it can be useful to scale to the same size.
(3) If there is a colormap, it is removed and the result
is either gray or RGB depending on the colormap.
(4) Two optional diff images can be retrieved (typ. for debugging):
pixdiff1: the gray or color difference
pixdiff2: thresholded to 1 bpp for pixels exceeding %mindiff
(5) The returned value of fract can be compared to some threshold,
which is application dependent.
(6) This method is in analogy to the two-sided hausdorff transform,
except here it is for d > 1.  For d == 1 (see pixRankHaustest()),
we verify that when one pix1 is dilated, it covers at least a
given fraction of the pixels in pix2, and v.v.; in that
case, the two pix are sufficiently similar.  Here, we
do an analogous thing: subtract the dilated pix1 from pix2 to
get a 1-sided hausdorff-like transform.  Then do it the
other way.  Take the component-wise max of the two results,
and threshold to get the fraction of pixels with a difference
below the threshold.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPerceptualDiff(*args)
    
    

    try:
        leptonica.pixGetPSNR.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetPSNR.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetPSNR not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPSNR(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('l_float32', '*ppsnr')       

:param[in]    pix1,: pix2     8 or 32 bpp; no colormap
:param[in]    factor:         sampling factor; >= 1
:param[out]   ppsnr:          power signal/noise ratio difference
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes the power S/N ratio, in dB, for the difference
between two images.  By convention, the power S/N
for a grayscale image is ('log' == log base 10,
and 'ln == log base e):
PSNR = 10 * log((255/MSE)^2)
= 4.3429 * ln((255/MSE)^2)
= -4.3429 * ln((MSE/255)^2)
where MSE is the mean squared error.
Here are some examples:
MSE             PSNR
---             ----
10              28.1
3               38.6
1               48.1
0.1             68.1
(2) If pix1 and pix2 have the same pixel values, the MSE = 0.0
and the PSNR is infinity.  For that case, this returns
PSNR = 1000, which corresponds to the very small MSE of
about 10^(-48).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPSNR(*args)
    
    

    try:
        leptonica.pixaComparePhotoRegionsByHisto.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaComparePhotoRegionsByHisto.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaComparePhotoRegionsByHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaComparePhotoRegionsByHisto(*args):
        """
        ('PIXA', '*pixa')       
('l_float32', 'minratio')       
('l_float32', 'textthresh')       
('l_int32', 'factor')       
('l_int32', 'n')       
('l_float32', 'simthresh')       
('NUMA', '**pnai')       
('l_float32', '**pscores')       
('PIX', '**ppixd')       
('l_int32', 'debug')       

:param[in]    pixa:        any depth; colormap OK
:param[in]    minratio:    requiring sizes be compatible; < 1.0
:param[in]    textthresh:  threshold for text/photo; use 0 for default
:param[in]    factor:      subsampling; >= 1
:param[in]    n:           in range {1, ... 7}. n^2 is the maximum number
of subregions for histograms; typ. n = 3.
:param[in]    simthresh:   threshold for similarity; use 0 for default
:param[out]   pnai: array  giving similarity class indices
:param[out]   pscores:     [optional] score matrix as 1-D array of size N^2
:param[out]   ppixd:       [optional] pix of similarity classes
:param[in]    debug:       1 to output histograms; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function takes a pixa of cropped photo images and
compares each one to the others for similarity.
Each image is first tested to see if it is a photo that can
be compared by tiled histograms.  If so, it is padded to put
the centroid in the center of the image, and the histograms
are generated.  The final step of comparing each histogram
with all the others is very fast.
(2) To make the histograms, each image is subdivided in a maximum
of n^2 subimages.  The parameter %n specifies the "side" of
an n x n grid of such subimages.  If the subimages have an
aspect ratio larger than 2, the grid will change, again using n^2
as a maximum for the number of subimages.  For example,
if n == 3, but the image is 600 x 200 pixels, a 3x3 grid
would have subimages of 200 x 67 pixels, which is more
than 2:1, so we change to a 4x2 grid where each subimage
has 150 x 100 pixels.
(3) An initial filter gives %score = 0 if the ratio of widths
and heights (smallest / largest) does not exceed a
threshold %minratio.  If set at 1.0, both images must be
exactly the same size.  A typical value for %minratio is 0.9.
(4) The comparison score between two images is a value in [0.0 .. 1.0].
If the comparison score >= %simthresh, the images are placed in
the same similarity class.  Default value for %simthresh is 0.25.
(5) An array %nai of similarity class indices for pix in the
input pixa is returned.
(6) There are two debugging options:
An optional 2D matrix of scores is returned as a 1D array.
A visualization of this is written to a temp file.
An optional pix showing the similarity classes can be
returned.  Text in each input pix is reproduced.
(7) See the notes in pixComparePhotoRegionsByHisto() for details
on the implementation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaComparePhotoRegionsByHisto(*args)
    
    

    try:
        leptonica.pixComparePhotoRegionsByHisto.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixComparePhotoRegionsByHisto.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixComparePhotoRegionsByHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixComparePhotoRegionsByHisto(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('BOX', '*box1')       
('BOX', '*box2')       
('l_float32', 'minratio')       
('l_int32', 'factor')       
('l_int32', 'n')       
('l_float32', '*pscore')       
('l_int32', 'debugflag')       

:param[in]    pix1,: pix2    any depth; colormap OK
:param[in]    box1,: box2    [optional] photo regions from each; can be null
:param[in]    minratio:      requiring sizes be compatible; < 1.0
:param[in]    factor:        subsampling factor; >= 1
:param[in]    n:             in range {1, ... 7}. n^2 is the maximum number
of subregions for histograms; typ. n = 3.
:param[out]   pscore:        similarity score of histograms
:param[in]    debugflag:     1 for debug output; 0 for no debugging
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function compares two grayscale photo regions.  If a
box is given, the region is clipped; otherwise assume
the entire images are photo regions.  This is done with a
set of not more than n^2 spatially aligned histograms, which are
aligned using the centroid of the inverse image.
(2) The parameter %n specifies the "side" of an n x n grid
of subimages.  If the subimages have an aspect ratio larger
than 2, the grid will change, using n^2 as a maximum for
the number of subimages.  For example, if n == 3, but the
image is 600 x 200 pixels, a 3x3 grid would have subimages
of 200 x 67 pixels, which is more than 2:1, so we change
to a 4x2 grid where each subimage has 150 x 100 pixels.
(3) An initial filter gives %score = 0 if the ratio of widths
and heights (smallest / largest) does not exceed a
threshold %minratio.  This must be between 0.5 and 1.0.
If set at 1.0, both images must be exactly the same size.
A typical value for %minratio is 0.9.
(4) Because this function should not be used on text or
line graphics, which can give false positive results
(i.e., high scores for different images), filter the images
using pixGenPhotoHistos(), which returns tiled histograms
only if an image is not text and comparison is expected
to work with histograms.  If either image fails the test,
the comparison returns a score of 0.0.
(5) The white value counts in the histograms are removed; they
are typically pixels that were padded to achieve alignment.
(6) For an efficient representation of the histogram, normalize
using a multiplicative factor so that the number in the
maximum bucket is 255.  It then takes 256 bytes to store.
(7) When comparing the histograms of two regions, use the
Earth Mover distance (EMD), with the histograms normalized
so that the sum over bins is the same.  Further normalize
by dividing by 255, so that the result is in [0.0 ... 1.0].
(8) Get a similarity score S = 1.0 - k * D, where
k is a constant, say in the range 5-10
D = normalized EMD
and for multiple tiles, take the Min(S) to be the final score.
Using aligned tiles gives protection against accidental
similarity of the overall grayscale histograms.
A small number of aligned tiles works well.
(9) With debug on, you get a pdf that shows, for each tile,
the images, histograms and score.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixComparePhotoRegionsByHisto(*args)
    
    

    try:
        leptonica.pixGenPhotoHistos.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGenPhotoHistos.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGenPhotoHistos not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenPhotoHistos(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'factor')       
('l_float32', 'thresh')       
('l_int32', 'n')       
('NUMAA', '**pnaa')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', 'debugindex')       

:param[in]    pixs:      depth > 1 bpp; colormap OK
:param[in]    box:       [optional] region to be selected; can be null
:param[in]    factor:    subsampling; >= 1
:param[in]    thresh:    threshold for photo/text; use 0 for default
:param[in]    n:         in range {1, ... 7}. n^2 is the maximum number
of subregions for histograms; typ. n = 3.
:param[out]   pnaa:      nx * ny 256-entry gray histograms
:param[out]   pw:        width of image used to make histograms
:param[out]   ph:        height of image used to make histograms
:param[in]    debugindex:  0 for no debugging; positive integer otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This crops and converts to 8 bpp if necessary.  It adds a
minimal white boundary such that the centroid of the
photo-inverted image is in the center. This allows
automatic alignment with histograms of other image regions.
(2) The parameter %n specifies the "side" of the n x n grid
of subimages.  If the subimages have an aspect ratio larger
than 2, the grid will change, using n^2 as a maximum for
the number of subimages.  For example, if n == 3, but the
image is 600 x 200 pixels, a 3x3 grid would have subimages
of 200 x 67 pixels, which is more than 2:1, so we change
to a 4x2 grid where each subimage has 150 x 100 pixels.
(3) The white value in the histogram is removed, because of
the padding.
(4) Use 0 for conservative default (1.3) for thresh.
(5) For an efficient representation of the histogram, normalize
using a multiplicative factor so that the number in the
maximum bucket is 255.  It then takes 256 bytes to store.
(6) With %debugindex > 0, this makes a pdf that shows, for each tile,
the images and histograms.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenPhotoHistos(*args)
    
    

    try:
        leptonica.pixPadToCenterCentroid.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixPadToCenterCentroid.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixPadToCenterCentroid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPadToCenterCentroid(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]    pixs:     any depth, colormap OK
:param[in]    factor:   subsampling for centroid; >= 1
:returns:  pixd padded with white pixels, or NULL on error.

<pre>
Notes:
(1) This add minimum white padding to an 8 bpp pix, such that
the centroid of the photometric inverse is in the center of
the resulting image.  Thus in computing the centroid,
black pixels have weight 255, and white pixels have weight 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPadToCenterCentroid(*args)
    
    

    try:
        leptonica.pixCentroid8.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCentroid8.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCentroid8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCentroid8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', '*pcx')       
('l_float32', '*pcy')       

:param[in]    pixs:    8 bpp
:param[in]    factor:  subsampling factor; >= 1
:param[out]   pcx:     x value of centroid
:param[out]   pcy:     y value of centroid
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This first does a photometric inversion (black = 255, white = 0).
It then finds the centroid of the result.  The inversion is
done because white is usually background, so the centroid
is computed based on the "foreground" gray pixels, and the
darker the pixel, the more weight it is given.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCentroid8(*args)
    
    

    try:
        leptonica.pixDecideIfPhotoImage.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDecideIfPhotoImage.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDecideIfPhotoImage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDecideIfPhotoImage(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'factor')       
('l_float32', 'thresh')       
('l_int32', 'n')       
('NUMAA', '**pnaa')       
('PIXA', '*pixadebug')       

:param[in]    pix:         8 bpp, centroid in center
:param[in]    factor:      subsampling for histograms; >= 1
:param[in]    thresh:      threshold for photo/text; use 0 for default
:param[in]    n:           in range {1, ... 7}. n^2 is the maximum number
of subregions for histograms; typ. n = 3.
:param[out]   pnaa:        array of normalized histograms
:param[in]    pixadebug:   [optional] use only for debug output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The input image must be 8 bpp (no colormap), and padded with
white pixels so the centroid of photo-inverted pixels is at
the center of the image.
(2) The parameter %n specifies the "side" of the n x n grid
of subimages.  If the subimages have an aspect ratio larger
than 2, the grid will change, using n^2 as a maximum for
the number of subimages.  For example, if n == 3, but the
image is 600 x 200 pixels, a 3x3 grid would have subimages
of 200 x 67 pixels, which is more than 2:1, so we change
to a 4x2 grid where each subimage has 150 x 100 pixels.
(3) If the pix is not almost certainly a photoimage, the returned
histograms (%naa) are null.
(4) If histograms are generated, the white (255) count is set
to 0.  This removes all pixels values above 230, including
white padding from the centroid matching operation, from
consideration.  The resulting histograms are then normalized
so the maximum count is 255.
(5) Default for %thresh is 1.3; this seems sufficiently conservative.
(6) Use %pixadebug == NULL unless debug output is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDecideIfPhotoImage(*args)
    
    

    try:
        leptonica.compareTilesByHisto.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.compareTilesByHisto.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function compareTilesByHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def compareTilesByHisto(*args):
        """
        ('NUMAA', '*naa1')       
('NUMAA', '*naa2')       
('l_float32', 'minratio')       
('l_int32', 'w1')       
('l_int32', 'h1')       
('l_int32', 'w2')       
('l_int32', 'h2')       
('l_float32', '*pscore')       
('PIXA', '*pixadebug')       

:param[in]    naa1,: naa2      each is a set of 256 entry histograms
:param[in]    minratio:        requiring image sizes be compatible; < 1.0
:param[in]    w1,: h1, w2, h2  image sizes from which histograms were made
:param[out]   pscore:          similarity score of histograms
:param[in]    pixadebug:       [optional] use only for debug output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) naa1 and naa2 must be generated using pixGenPhotoHistos(),
using the same tile sizes.
(2) The image dimensions must be similar.  The score is 0.0
if the ratio of widths and heights (smallest / largest)
exceeds a threshold %minratio, which must be between
0.5 and 1.0.  If set at 1.0, both images must be exactly
the same size.  A typical value for %minratio is 0.9.
(3) The input pixadebug is null unless debug output is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.compareTilesByHisto(*args)
    
    

    try:
        leptonica.pixCompareGrayByHisto.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCompareGrayByHisto.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareGrayByHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareGrayByHisto(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('BOX', '*box1')       
('BOX', '*box2')       
('l_float32', 'minratio')       
('l_int32', 'maxgray')       
('l_int32', 'factor')       
('l_int32', 'n')       
('l_float32', '*pscore')       
('l_int32', 'debugflag')       

:param[in]    pix1,: pix2  any depth; colormap OK
:param[in]    box1,: box2  [optional] region selected from each; can be null
:param[in]    minratio:    requiring sizes be compatible; < 1.0
:param[in]    maxgray:     max value to keep in histo; >= 200, 255 to keep all
:param[in]    factor:      subsampling factor; >= 1
:param[in]    n:           in range {1, ... 7}. n^2 is the maximum number
of subregions for histograms; typ. n = 3.
:param[out]   pscore:      similarity score of histograms
:param[in]    debugflag:   1 for debug output; 0 for no debugging
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function compares two grayscale photo regions.  It can
do it with a single histogram from each region, or with a
set of spatially aligned histograms.  For both cases,
align the regions using the centroid of the inverse image,
and crop to the smallest of the two.
(2) The parameter %n specifies the "side" of an n x n grid
of subimages.  If the subimages have an aspect ratio larger
than 2, the grid will change, using n^2 as a maximum for
the number of subimages.  For example, if n == 3, but the
image is 600 x 200 pixels, a 3x3 grid would have subimages
of 200 x 67 pixels, which is more than 2:1, so we change
to a 4x2 grid where each subimage has 150 x 100 pixels.
(3) An initial filter gives %score = 0 if the ratio of widths
and heights (smallest / largest) does not exceed a
threshold %minratio.  This must be between 0.5 and 1.0.
If set at 1.0, both images must be exactly the same size.
A typical value for %minratio is 0.9.
(4) The lightest values in the histogram can be disregarded.
Set %maxgray to the lightest value to be kept.  For example,
to eliminate white (255), set %maxgray = 254.  %maxgray must
be >= 200.
(5) For an efficient representation of the histogram, normalize
using a multiplicative factor so that the number in the
maximum bucket is 255.  It then takes 256 bytes to store.
(6) When comparing the histograms of two regions:
~ Use %maxgray = 254 to ignore the white pixels, the number
of which may be sensitive to the crop region if the pixels
outside that region are white.
~ Use the Earth Mover distance (EMD), with the histograms
normalized so that the sum over bins is the same.
Further normalize by dividing by 255, so that the result
is in [0.0 ... 1.0].
(7) Get a similarity score S = 1.0 - k * D, where
k is a constant, say in the range 5-10
D = normalized EMD
and for multiple tiles, take the Min(S) to be the final score.
Using aligned tiles gives protection against accidental
similarity of the overall grayscale histograms.
A small number of aligned tiles works well.
(8) With debug on, you get a pdf that shows, for each tile,
the images, histograms and score.
(9) When to use:
(a) Because this function should not be used on text or
line graphics, which can give false positive results
(i.e., high scores for different images), the input
images should be filtered.
(b) To filter, first use pixDecideIfText().  If that function
says the image is text, do not use it.  If the function
says it is not text, it still may be line graphics, and
in that case, use:
pixGetGrayHistogramTiled()
grayInterHistogramStats()
to determine whether it is photo or line graphics.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareGrayByHisto(*args)
    
    

    try:
        leptonica.pixCropAlignedToCentroid.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCropAlignedToCentroid.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCropAlignedToCentroid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCropAlignedToCentroid(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'factor')       
('BOX', '**pbox1')       
('BOX', '**pbox2')       

:param[in]    pix1,: pix2   any depth; colormap OK
:param[in]    factor:       subsampling; >= 1
:param[out]   pbox1:        crop box for pix1
:param[out]   pbox2:        crop box for pix2
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This finds the maximum crop boxes for two 8 bpp images when
their centroids of their photometric inverses are aligned.
Black pixels have weight 255; white pixels have weight 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCropAlignedToCentroid(*args)
    
    

    try:
        leptonica.l_compressGrayHistograms.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_compressGrayHistograms.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_compressGrayHistograms not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_compressGrayHistograms(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'w')       
('l_int32', 'h')       
('size_t', '*psize')       

:param[in]    naa:     set of 256-entry histograms
:param[in]    w,: h    size of image
:param[out]   psize:   size of byte array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This first writes w and h to the byte array as 4 byte ints.
(2) Then it normalizes each histogram to a max value of 255,
and saves each value as a byte.  If there are
N histograms, the output bytearray has 8 + 256 * N bytes.
(3) Further compression of the array with zlib yields only about
a 25% decrease in size, so we don't bother.  If size reduction
were important, a lossy transform using a 1-dimensional DCT
would be effective, because we don't care about the fine
details of these histograms.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_compressGrayHistograms(*args)
    
    

    try:
        leptonica.l_uncompressGrayHistograms.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_uncompressGrayHistograms.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_uncompressGrayHistograms not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_uncompressGrayHistograms(*args):
        """
        ('l_uint8', '*bytea')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    bytea:    byte array of size 8 + 256 * N, N an integer
:param[in]    size:     size of byte array
:param[out]   pw:       width of the image that generated the histograms
:param[out]   ph:       height of the image
:returns:  numaa     representing N histograms, each with 256 bins,
or NULL on error.

<pre>
Notes:
(1) The first 8 bytes are read as two 32-bit ints.
(2) Then this constructs a numaa representing some number of
gray histograms that are normalized such that the max value
in each histogram is 255.  The data is stored as a byte
array, with 256 bytes holding the data for each histogram.
Each gray histogram was computed from a tile of a grayscale image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_uncompressGrayHistograms(*args)
    
    

    try:
        leptonica.pixCompareWithTranslation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCompareWithTranslation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCompareWithTranslation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCompareWithTranslation(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'thresh')       
('l_int32', '*pdelx')       
('l_int32', '*pdely')       
('l_float32', '*pscore')       
('l_int32', 'debugflag')       

:param[in]    pix1,: pix2    any depth; colormap OK
:param[in]    thresh:        threshold for converting to 1 bpp
:param[out]   pdelx:         x translation on pix2 to align with pix1
:param[out]   pdely:         y translation on pix2 to align with pix1
:param[out]   pscore:        correlation score at best alignment
:param[in]    debugflag:     1 for debug output; 0 for no debugging
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a coarse-to-fine search for best translational
alignment of two images, measured by a scoring function
that is the correlation between the fg pixels.
(2) The threshold is used if the images aren't 1 bpp.
(3) With debug on, you get a pdf that shows, as a grayscale
image, the score as a function of shift from the initial
estimate, for each of the four levels.  The shift is 0 at
the center of the image.
(4) With debug on, you also get a pdf that shows the
difference at the best alignment between the two images,
at each of the four levels.  The red and green pixels
show locations where one image has a fg pixel and the
other doesn't.  The black pixels are where both images
have fg pixels, and white pixels are where neither image
has fg pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCompareWithTranslation(*args)
    
    

    try:
        leptonica.pixBestCorrelation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBestCorrelation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBestCorrelation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBestCorrelation(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_int32', 'etransx')       
('l_int32', 'etransy')       
('l_int32', 'maxshift')       
('l_int32', '*tab8')       
('l_int32', '*pdelx')       
('l_int32', '*pdely')       
('l_float32', '*pscore')       
('l_int32', 'debugflag')       

:param[in]    pix1:      1 bpp
:param[in]    pix2:      1 bpp
:param[in]    area1:     number of on pixels in pix1
:param[in]    area2:     number of on pixels in pix2
:param[in]    etransx:   estimated x translation of pix2 to align with pix1
:param[in]    etransy:   estimated y translation of pix2 to align with pix1
:param[in]    maxshift:  max x and y shift of pix2, around the estimated
alignment location, relative to pix1
:param[in]    tab8:      [optional] sum tab for ON pixels in byte; can be NULL
:param[out]   pdelx:     [optional] best x shift of pix2 relative to pix1
:param[out]   pdely:     [optional] best y shift of pix2 relative to pix1
:param[out]   pscore:    [optional] maximum score found; can be NULL
:param[in]    debugflag:   <= 0 to skip; positive to generate output.
The integer is used to label the debug image.
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This maximizes the correlation score between two 1 bpp images,
by starting with an estimate of the alignment
(%etransx, %etransy) and computing the correlation around this.
It optionally returns the shift (%delx, %dely) that maximizes
the correlation score when pix2 is shifted by this amount
relative to pix1.
(2) Get the centroids of pix1 and pix2, using pixCentroid(),
to compute (%etransx, %etransy).  Get the areas using
pixCountPixels().
(3) The centroid of pix2 is shifted with respect to the centroid
of pix1 by all values between -maxshiftx and maxshiftx,
and likewise for the y shifts.  Therefore, the number of
correlations computed is:
(2 * maxshiftx + 1) * (2 * maxshifty + 1)
Consequently, if pix1 and pix2 are large, you should do this
in a coarse-to-fine sequence.  See the use of this function
in pixCompareWithTranslation().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBestCorrelation(*args)
    




class gplot(object):
    """<pre>

Basic plotting functions
GPLOT      *gplotCreate()
void        gplotDestroy()
l_int32     gplotAddPlot()
l_int32     gplotSetScaling()
PIX        *gplotMakeOutputPix()
l_int32     gplotMakeOutput()
l_int32     gplotGenCommandFile()
l_int32     gplotGenDataFiles()

Quick, one-line plots
l_int32     gplotSimple1()
l_int32     gplotSimple2()
l_int32     gplotSimpleN()
PIX        *gplotSimplePix1()
PIX        *gplotSimplePix2()
PIX        *gplotSimplePixN()
GPLOT      *gplotSimpleXY1()
GPLOT      *gplotSimpleXY2()
GPLOT      *gplotSimpleXYN()
PIX        *gplotGeneralPix1()
PIX        *gplotGeneralPix2()
PIX        *gplotGeneralPixN()

Serialize for I/O
GPLOT      *gplotRead()
l_int32     gplotWrite()


Utility for programmatic plotting using gnuplot 4.6 or later
Enabled:
~ output to png (color), ps and eps (mono), latex (mono)
~ optional title for plot
~ optional x and y axis labels
~ multiple plots on one frame
~ optional label for each plot on the frame
~ optional log scaling on either or both axes
~ choice of 5 plot styles for each array of input data
~ choice of 2 plot modes, either using one input array
(Y vs index) or two input arrays (Y vs X).  For functions
that take two arrays, the first mode (Y vs index) is
employed if the first array is NULL.

General usage:
gplotCreate() initializes for plotting
gplotAddPlot() for each plot on the frame
gplotMakeOutput() to generate all output files and run gnuplot
gplotDestroy() to clean up

Example of use:
gplot = gplotCreate("tempskew", GPLOT_PNG, "Skew score vs angle",
"angle (deg)", "score");
gplotAddPlot(gplot, natheta, nascore1, GPLOT_LINES, "plot 1");
gplotAddPlot(gplot, natheta, nascore2, GPLOT_POINTS, "plot 2");
gplotSetScaling(gplot, GPLOT_LOG_SCALE_Y);
gplotMakeOutput(gplot);
gplotDestroy(&gplot);

Example usage of one-line plot generators:

-- Simple plots --
Specify the root of output files, the output format,
and the title (optional), but not the x and y coordinate labels
or the plot labels.  The plotstyle defaults to GPLOT_LINES.
gplotSimple2(na1, na2, GPLOT_PNG, "/tmp/lept/histo/gray",
"gray histogram");
Multiple plots can be generated using gplotSimpleN().

-- Simple plots with more options --
Specify the root of output files, the plotstyle, the output format,
and optionally the title, but not the x and y coordinate labels
or the plot labels.
gplotSimpleXY1(na1, na2, GPLOT_LINES, GPLOT_PNG,
"/tmp/lept/histo/gray", "gray histogram");
Multiple plots can be generated using gplotSimpleXYN().

-- Simple plots returning a pix --
Specify only the title (optional).  The plotstyle defaults
GPLOT_LINES and the output format is GPLOT_PNG..
You can't specify the x and y coordinate lables or the plot label.
The rootname of the generated files is determined internally.
Pix *pix = gplotSimplePix2(na1, na2, "gray histogram");
Multiple plots can be generated using gplotSimplePixN().

-- General plots returning a pix --
Specify the root of the output files, the plotstyle, and optionally
the title and axis labels.  This does not allow the individual
plots to have plot labels, or to use different plotstyles
for each plot.
Pix *pix = gplotGeneralPix2(na1, na2, "/tmp/lept/histo/gray",
GPLOT_LINES, "gray histogram",
"pix value", "num pixels");
Multiple plots can be generated using gplotGeneralPixN().

Note for output to GPLOT_LATEX:
This creates latex output of the plot, named <rootname>.tex.
It needs to be placed in a latex file <latexname>.tex
that precedes the plot output with, at a minimum:
\documentclass{article}
\begin{document}
and ends with
\end{document}
You can then generate a dvi file <latexname>.dvi using
latex <latexname>.tex
and a PostScript file <psname>.ps from that using
dvips -o <psname>.ps <latexname>.dvi

N.B. To generate plots, it is necessary to have gnuplot installed on
your Unix system, or wgnuplot on Windows.
</pre>




"""
    
    try:
        leptonica.gplotCreate.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotCreate.restype = lambda address: GPLOT(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotCreate(*args):
        """
        ('const char', '*rootname')       
('l_int32', 'outformat')       
('const char', '*title')       
('const char', '*xlabel')       
('const char', '*ylabel')       

:param[in]    rootname:    root for all output files
:param[in]    outformat:   GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    title:       [optional] overall title
:param[in]    xlabel:      [optional] x axis label
:param[in]    ylabel:      [optional] y axis label
:returns:  gplot, or NULL on error

<pre>
Notes:
(1) This initializes the plot.
(2) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
double quotes and backquotes, but not single quotes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotCreate(*args)
    
    

    try:
        leptonica.gplotDestroy.argtypes = [ctypes.c_void_p]
        leptonica.gplotDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function gplotDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotDestroy(*args):
        """
        ('GPLOT', '**pgplot')       

:param[in,out]   pgplot:    will be set to null before returning


        """
        args = _convert_params(*args)
        
        return leptonica.gplotDestroy(*args)
    
    

    try:
        leptonica.gplotAddPlot.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.gplotAddPlot.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotAddPlot not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotAddPlot(*args):
        """
        ('GPLOT', '*gplot')       
('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'plotstyle')       
('const char', '*plotlabel')       

:param[in]    gplot:
:param[in]    nax:         [optional] numa: set to null for Y_VS_I;
required for Y_VS_X
:param[in]    nay:         numa; required for both Y_VS_I and Y_VS_X
:param[in]    plotstyle:   GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    plotlabel:   [optional] label for individual plot
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) There are 2 options for (x,y) values:
o  To plot an array vs a linear function of the
index, set %nax = NULL.
o  To plot one array vs another, use both %nax and %nay.
(2) If %nax is NULL, the x value corresponding to the i-th
value of %nay is found from the startx and delx fields
in %nay:
x = startx + i * delx
These are set with numaSetParameters().  Their default
values are startx = 0.0, delx = 1.0.
(3) If %nax is defined, it must be the same size as %nay, and
must have at least one number.
(4) The 'plotlabel' string can have spaces, double
quotes and backquotes, but not single quotes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotAddPlot(*args)
    
    

    try:
        leptonica.gplotSetScaling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.gplotSetScaling.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotSetScaling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSetScaling(*args):
        """
        ('GPLOT', '*gplot')       
('l_int32', 'scaling')       

:param[in]    gplot:
:param[in]    scaling:   GPLOT_LINEAR_SCALE, GPLOT_LOG_SCALE_X,
GPLOT_LOG_SCALE_Y, GPLOT_LOG_SCALE_X_Y
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) By default, the x and y axis scaling is linear.
(2) Call this function to set semi-log or log-log scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSetScaling(*args)
    
    

    try:
        leptonica.gplotMakeOutputPix.argtypes = [ctypes.c_void_p]
        leptonica.gplotMakeOutputPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotMakeOutputPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotMakeOutputPix(*args):
        """
        ('GPLOT', '*gplot')       

:param[in]    gplot:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This wraps gplotMakeOutput(), and returns a pix.
See gplotMakeOutput() for details.
(2) The gplot output format must be an image (png or pnm).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotMakeOutputPix(*args)
    
    

    try:
        leptonica.gplotMakeOutput.argtypes = [ctypes.c_void_p]
        leptonica.gplotMakeOutput.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotMakeOutput not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotMakeOutput(*args):
        """
        ('GPLOT', '*gplot')       

:param[in]    gplot:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This uses gplot and the new arrays to add a plot
to the output, by writing a new data file and appending
the appropriate plot commands to the command file.
(2) Along with gplotMakeOutputPix(), these are the only functions
in this file that requires the gnuplot executable to
actually generate the plot.
(3) The command file name for unix is canonical (i.e., directory /tmp)
but the temp filename paths in the command file must be correct.
(4) The gnuplot program for windows is wgnuplot.exe.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotMakeOutput(*args)
    
    

    try:
        leptonica.gplotGenCommandFile.argtypes = [ctypes.c_void_p]
        leptonica.gplotGenCommandFile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotGenCommandFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGenCommandFile(*args):
        """
        ('GPLOT', '*gplot')       

:param[in]    gplot:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGenCommandFile(*args)
    
    

    try:
        leptonica.gplotGenDataFiles.argtypes = [ctypes.c_void_p]
        leptonica.gplotGenDataFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotGenDataFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGenDataFiles(*args):
        """
        ('GPLOT', '*gplot')       

:param[in]    gplot:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pathnames in the gplot command file are actual pathnames,
which can be in temp directories.  Consequently, they must not be
rewritten by calling fopenWriteStream(), and we use fopen().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGenDataFiles(*args)
    
    

    try:
        leptonica.gplotSimple1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotSimple1.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimple1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimple1(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       

:param[in]    na:          numa; plot Y_VS_I
:param[in]    outformat:   GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    outroot:     root of output files
:param[in]    title:       [optional], can be NULL
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a line plot of a numa, where the array value
is plotted vs the array index.  The plot is generated
in the specified output format; the title  is optional.
(2) When calling these simple plot functions more than once, use
different %outroot to avoid overwriting the output files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimple1(*args)
    
    

    try:
        leptonica.gplotSimple2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotSimple2.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimple2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimple2(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       

:param[in]    na1:         numa; plot with Y_VS_I
:param[in]    na2:         ditto
:param[in]    outformat:   GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    outroot:     root of output files
:param[in]    title:       [optional]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a line plot of two numa, where the array values
are each plotted vs the array index.  The plot is generated
in the specified output format; the title  is optional.
(2) When calling these simple plot functions more than once, use
different %outroot to avoid overwriting the output files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimple2(*args)
    
    

    try:
        leptonica.gplotSimpleN.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotSimpleN.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimpleN not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleN(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       

:param[in]    naa:         numaa; plot Y_VS_I for each numa
:param[in]    outformat:   GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    outroot:     root of output files
:param[in]    title:       [optional]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a line plot of all numas in a numaa (array of numa),
where the array values are each plotted vs the array index.
The plot is generated in the specified output format;
the title  is optional.
(2) When calling these simple plot functions more than once, use
different %outroot to avoid overwriting the output files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleN(*args)
    
    

    try:
        leptonica.gplotSimplePix1.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.gplotSimplePix1.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimplePix1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimplePix1(*args):
        """
        ('NUMA', '*na')       
('const char', '*title')       

:param[in]    na:          numa; plot Y_VS_I
:param[in]    title:       [optional], can be NULL
:returns:  pix   of plot, or null on error

<pre>
Notes:
(1) This generates a line plot of a numa as a pix, where the array
value is plotted vs the array index.  The title is optional.
(2) The temporary plot file is a png; its name is generated internally
and stored in gplot.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimplePix1(*args)
    
    

    try:
        leptonica.gplotSimplePix2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.gplotSimplePix2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimplePix2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimplePix2(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('const char', '*title')       

:param[in]    na1:         numa; plot with Y_VS_I
:param[in]    na2:         ditto
:param[in]    title:       [optional], can be NULL
:returns:  pix   of plot, or null on error

<pre>
Notes:
(1) This generates a pix with line plots of two numa, where each of
two arrays is plotted vs the array index.  the title is optional.
(2) The temporary plot file is a png; its name is generated internally
and stored in gplot.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimplePix2(*args)
    
    

    try:
        leptonica.gplotSimplePixN.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.gplotSimplePixN.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimplePixN not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimplePixN(*args):
        """
        ('NUMAA', '*naa')       
('const char', '*title')       

:param[in]    naa:         numaa; plot Y_VS_I for each numa
:param[in]    title:       [optional], can be NULL
:returns:  pix   of plot, or null on error

<pre>
Notes:
(1) This generates a pix with an arbitrary number of line plots,
each coming from a numa in %naa.  Each array value is plotted
vs the array index.  The title is optional.
(2) The temporary plot file is a png; its name is generated internally
and stored in gplot.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimplePixN(*args)
    
    

    try:
        leptonica.gplotSimpleXY1.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotSimpleXY1.restype = lambda address: GPLOT(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimpleXY1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleXY1(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay')       
('l_int32', 'plotstyle')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       

:param[in]    nax:         [optional]
:param[in]    nay:         [required]
:param[in]    plotstyle:   GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    outformat:   GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    outroot:     root of output files
:param[in]    title:       [optional], can be NULL
:returns:  gplot   or null on error

<pre>
Notes:
(1) This generates a plot of a %nay vs %nax, generated in
the specified output format.  The title is optional.
(2) Use 0 for default plotstyle (lines).
(3) %nax is optional.  If NULL, %nay is plotted against
the array index.
(4) When calling these simple plot functions more than once, use
different %outroot to avoid overwriting the output files.
(5) The returned gplot must be destroyed by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleXY1(*args)
    
    

    try:
        leptonica.gplotSimpleXY2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotSimpleXY2.restype = lambda address: GPLOT(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimpleXY2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleXY2(*args):
        """
        ('NUMA', '*nax')       
('NUMA', '*nay1')       
('NUMA', '*nay2')       
('l_int32', 'plotstyle')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       

:param[in]    nax:          [optional], can be NULL
:param[in]    nay1:
:param[in]    nay2:
:param[in]    plotstyle:    GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    outformat:    GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    outroot:      root of output files
:param[in]    title:        [optional]
:returns:  gplot   or null on error

<pre>
Notes:
(1) This generates plots of %nay1 and %nay2 against %nax, generated
in the specified output format.  The title is optional.
(2) Use 0 for default plotstyle (lines).
(3) %nax is optional.  If NULL, %nay1 and %nay2 are plotted
against the array index.
(4) When calling these simple plot functions more than once, use
different %outroot to avoid overwriting the output files.
(5) The returned gplot must be destroyed by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleXY2(*args)
    
    

    try:
        leptonica.gplotSimpleXYN.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotSimpleXYN.restype = lambda address: GPLOT(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotSimpleXYN not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotSimpleXYN(*args):
        """
        ('NUMA', '*nax')       
('NUMAA', '*naay')       
('l_int32', 'plotstyle')       
('l_int32', 'outformat')       
('const char', '*outroot')       
('const char', '*title')       

:param[in]    nax:          [optional]; can be NULL
:param[in]    naay:         numaa of arrays to plot against %nax
:param[in]    plotstyle:    GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    outformat:    GPLOT_PNG, GPLOT_PS, GPLOT_EPS,
GPLOT_LATEX, GPLOT_PNM
:param[in]    outroot:      root of output files
:param[in]    title:        [optional]
:returns:  gplot  or null on error

<pre>
Notes:
(1) This generates plots of each Numa in %naa against %nax,
generated in the specified output format.  The title is optional.
(2) Use 0 for default plotstyle (lines).
(3) %nax is optional.  If NULL, each Numa array is plotted against
the array index.
(4) When calling these simple plot functions more than once, use
different %outroot to avoid overwriting the output files.
(5) The returned gplot must be destroyed by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotSimpleXYN(*args)
    
    

    try:
        leptonica.gplotGeneralPix1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotGeneralPix1.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotGeneralPix1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGeneralPix1(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'plotstyle')       
('const char', '*rootname')       
('const char', '*title')       
('const char', '*xlabel')       
('const char', '*ylabel')       

:param[in]    na:          data array
:param[in]    plotstyle:   GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    rootname:    root for all output files
:param[in]    title:       [optional] overall title
:param[in]    xlabel:      [optional] x axis label
:param[in]    ylabel:      [optional] y axis label
:returns:  pix   of plot, or NULL on error

<pre>
Notes:
(1) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
double quotes and backquotes, but not single quotes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGeneralPix1(*args)
    
    

    try:
        leptonica.gplotGeneralPix2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotGeneralPix2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotGeneralPix2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGeneralPix2(*args):
        """
        ('NUMA', '*na1')       
('NUMA', '*na2')       
('l_int32', 'plotstyle')       
('const char', '*rootname')       
('const char', '*title')       
('const char', '*xlabel')       
('const char', '*ylabel')       

:param[in]    na1:         x-axis data array
:param[in]    na2:         y-axis data array
:param[in]    plotstyle:   GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    rootname:    root for all output files
:param[in]    title:       [optional] overall title
:param[in]    xlabel:      [optional] x axis label
:param[in]    ylabel:      [optional] y axis label
:returns:  pix   of plot, or NULL on error

<pre>
Notes:
(1) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
double quotes and backquotes, but not single quotes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGeneralPix2(*args)
    
    

    try:
        leptonica.gplotGeneralPixN.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.gplotGeneralPixN.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotGeneralPixN not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotGeneralPixN(*args):
        """
        ('NUMA', '*nax')       
('NUMAA', '*naay')       
('l_int32', 'plotstyle')       
('const char', '*rootname')       
('const char', '*title')       
('const char', '*xlabel')       
('const char', '*ylabel')       

:param[in]    nax:         x-axis data array
:param[in]    naay:        array of y-axis data arrays
:param[in]    plotstyle:   GPLOT_LINES, GPLOT_POINTS, GPLOT_IMPULSES,
GPLOT_LINESPOINTS, GPLOT_DOTS
:param[in]    rootname:    root for all output files
:param[in]    title:       [optional] overall title
:param[in]    xlabel:      [optional] x axis label
:param[in]    ylabel:      [optional] y axis label
:returns:  pix   of plot, or NULL on error

<pre>
Notes:
(1) The 'title', 'xlabel' and 'ylabel' strings can have spaces,
double quotes and backquotes, but not single quotes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gplotGeneralPixN(*args)
    
    

    try:
        leptonica.gplotRead.argtypes = [ctypes.c_char_p]
        leptonica.gplotRead.restype = lambda address: GPLOT(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function gplotRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  gplot, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotRead(*args)
    
    

    try:
        leptonica.gplotWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.gplotWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function gplotWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gplotWrite(*args):
        """
        ('const char', '*filename')       
('GPLOT', '*gplot')       

:param[in]    filename:
:param[in]    gplot:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.gplotWrite(*args)
    




class pix1(object):
    """<pre>

The pixN.c {N = 1,2,3,4,5} files are sorted by the type of operation.
The primary functions in these files are:

pix1.c: constructors, destructors and field accessors
pix2.c: pixel poking of image, pad and border pixels
pix3.c: masking and logical ops, counting, mirrored tiling
pix4.c: histograms, statistics, fg/bg estimation
pix5.c: property measurements, rectangle extraction


This file has the basic constructors, destructors and field accessors

Pix memory management (allows custom allocator and deallocator)
static void  *pix_malloc()
static void   pix_free()
void          setPixMemoryManager()

Pix creation
PIX          *pixCreate()
PIX          *pixCreateNoInit()
PIX          *pixCreateTemplate()
PIX          *pixCreateTemplateNoInit()
PIX          *pixCreateWithCmap()
PIX          *pixCreateHeader()
PIX          *pixClone()

Pix destruction
void          pixDestroy()
static void   pixFree()

Pix copy
PIX          *pixCopy()
l_int32       pixResizeImageData()
l_int32       pixCopyColormap()
l_int32       pixSizesEqual()
l_int32       pixTransferAllData()
l_int32       pixSwapAndDestroy()

Pix accessors
l_int32       pixGetWidth()
l_int32       pixSetWidth()
l_int32       pixGetHeight()
l_int32       pixSetHeight()
l_int32       pixGetDepth()
l_int32       pixSetDepth()
l_int32       pixGetDimensions()
l_int32       pixSetDimensions()
l_int32       pixCopyDimensions()
l_int32       pixGetSpp()
l_int32       pixSetSpp()
l_int32       pixCopySpp()
l_int32       pixGetWpl()
l_int32       pixSetWpl()
l_int32       pixGetRefcount()
l_int32       pixChangeRefcount()
l_uint32      pixGetXRes()
l_int32       pixSetXRes()
l_uint32      pixGetYRes()
l_int32       pixSetYRes()
l_int32       pixGetResolution()
l_int32       pixSetResolution()
l_int32       pixCopyResolution()
l_int32       pixScaleResolution()
l_int32       pixGetInputFormat()
l_int32       pixSetInputFormat()
l_int32       pixCopyInputFormat()
l_int32       pixSetSpecial()
char         *pixGetText()
l_int32       pixSetText()
l_int32       pixAddText()
l_int32       pixCopyText()
PIXCMAP      *pixGetColormap()
l_int32       pixSetColormap()
l_int32       pixDestroyColormap()
l_uint32     *pixGetData()
l_int32       pixSetData()
l_uint32     *pixExtractData()
l_int32       pixFreeData()

Pix line ptrs
void        **pixGetLinePtrs()

Pix debug
l_int32       pixPrintStreamInfo()


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Important notes on direct management of pix image data
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Custom allocator and deallocator
--------------------------------

At the lowest level, you can specify the function that does the
allocation and deallocation of the data field in the pix.
By default, this is malloc and free.  However, by calling
setPixMemoryManager(), custom functions can be substituted.
When using this, keep two things in mind:

(1) Call setPixMemoryManager() before any pix have been allocated
(2) Destroy all pix as usual, in order to prevent leaks.

In pixalloc.c, we provide an example custom allocator and deallocator.
To use it, you must call pmsCreate() before any pix have been allocated
and pmsDestroy() at the end after all pix have been destroyed.


Direct manipulation of the pix data field
-----------------------------------------

Memory management of the (image) data field in the pix is
handled differently from that in the colormap or text fields.
For colormap and text, the functions pixSetColormap() and
pixSetText() remove the existing heap data and insert the
new data.  For the image data, pixSetData() just reassigns the
data field; any existing data will be lost if there isn't
another handle for it.

Why is pixSetData() limited in this way?  Because the image
data can be very large, we need flexible ways to handle it,
particularly when you want to re-use the data in a different
context without making a copy.  Here are some different
things you might want to do:

(1) Use pixCopy(pixd, pixs) where pixd is not the same size
as pixs.  This will remove the data in pixd, allocate a
new data field in pixd, and copy the data from pixs, leaving
pixs unchanged.

(2) Use pixTransferAllData(pixd, &pixs, ...) to transfer the
data from pixs to pixd without making a copy of it.  If
pixs is not cloned, this will do the transfer and destroy pixs.
But if the refcount of pixs is greater than 1, it just copies
the data and decrements the ref count.

(3) Use pixSwapAndDestroy(pixd, &pixs) to replace pixs by an
existing pixd.  This is similar to pixTransferAllData(), but
simpler, in that it never makes any copies and if pixs is
cloned, the other references are not changed by this operation.

(4) Use pixExtractData() to extract the image data from the pix
without copying if possible.  This could be used, for example,
to convert from a pix to some other data structure with minimal
heap allocation.  After the data is extracated, the pixels can
be munged and used in another context.  However, the danger
here is that the pix might have a refcount > 1, in which case
a copy of the data must be made and the input pix left unchanged.
If there are no clones, the image data can be extracted without
a copy, and the data ptr in the pix must be nulled before
destroying it because the pix will no longer 'own' the data.

We have provided accessors and functions here that should be
sufficient so that you can do anything you want without
explicitly referencing any of the pix member fields.

However, to avoid memory smashes and leaks when doing special operations
on the pix data field, look carefully at the behavior of the image
data accessors and keep in mind that when you invoke pixDestroy(),
the pix considers itself the owner of all its heap data.
</pre>




"""
    
    try:
        leptonica.pixCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreate(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       

:param[in]    width,: height, depth
:returns:  pixd with data allocated and initialized to 0,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreate(*args)
    
    

    try:
        leptonica.pixCreateNoInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreateNoInit.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateNoInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateNoInit(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       

:param[in]    width,: height, depth
:returns:  pixd with data allocated but not initialized,
or NULL on error

<pre>
Notes:
(1) Must set pad bits to avoid reading uninitialized data, because
some optimized routines (e.g., pixConnComp()) read from pad bits.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateNoInit(*args)
    
    

    try:
        leptonica.pixCreateTemplate.argtypes = [ctypes.c_void_p]
        leptonica.pixCreateTemplate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateTemplate(*args):
        """
        ('const PIX', '*pixs')       

:param[in]    pixs:
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Makes a Pix of the same size as the input Pix, with the
data array allocated and initialized to 0.
(2) Copies the other fields, including colormap if it exists.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateTemplate(*args)
    
    

    try:
        leptonica.pixCreateTemplateNoInit.argtypes = [ctypes.c_void_p]
        leptonica.pixCreateTemplateNoInit.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateTemplateNoInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateTemplateNoInit(*args):
        """
        ('const PIX', '*pixs')       

:param[in]    pixs:
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Makes a Pix of the same size as the input Pix, with
the data array allocated but not initialized to 0.
(2) Copies the other fields, including colormap if it exists.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateTemplateNoInit(*args)
    
    

    try:
        leptonica.pixCreateWithCmap.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreateWithCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateWithCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateWithCmap(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       
('l_int32', 'initcolor')       

:param[in]    width:
:param[in]    height:
:param[in]    depth:        2, 4 or 8 bpp
:param[in]    initcolor:    L_SET_BLACK, L_SET_WHITE
:returns:  pixd   with the initialization color assigned to all pixels,
or NULL on error.

<pre>
Notes:
(1) Creates a pix with a cmap, initialized to value 0.
(2) Initializes the pix black or white by adding that color
to the cmap at index 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateWithCmap(*args)
    
    

    try:
        leptonica.pixCreateHeader.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCreateHeader.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateHeader not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateHeader(*args):
        """
        ('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'depth')       

:param[in]    width,: height, depth
:returns:  pixd with no data allocated, or NULL on error

<pre>
Notes:
(1) It is assumed that all 32 bit pix have 3 spp.  If there is
a valid alpha channel, this will be set to 4 spp later.
(2) All pixCreate*() functions call pixCreateHeader().
If the number of bytes to be allocated is larger than the
maximum value in an int32, we can get overflow, resulting
in a smaller amount of memory actually being allocated.
Later, an attempt to access memory that wasn't allocated will
cause a crash.  So to avoid crashing a program (or worse)
with bad (or malicious) input, we limit the requested
allocation of image data in a typesafe way.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateHeader(*args)
    
    

    try:
        leptonica.pixClone.argtypes = [ctypes.c_void_p]
        leptonica.pixClone.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClone(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:
:returns:  same pix ptr, or NULL on error

<pre>
Notes:
(1) A "clone" is simply a handle (ptr) to an existing pix.
It is implemented because (a) images can be large and
hence expensive to copy, and (b) extra handles to a data
structure need to be made with a simple policy to avoid
both double frees and memory leaks.  Pix are reference
counted.  The side effect of pixClone() is an increase
by 1 in the ref count.
(2) The protocol to be used is:
(a) Whenever you want a new handle to an existing image,
call pixClone(), which just bumps a ref count.
(b) Always call pixDestroy() on all handles.  This
decrements the ref count, nulls the handle, and
only destroys the pix when pixDestroy() has been
called on all handles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClone(*args)
    
    

    try:
        leptonica.pixDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDestroy(*args):
        """
        ('PIX', '**ppix')       

:param[in,out]   ppix:     will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the pix.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDestroy(*args)
    
    

    try:
        leptonica.pixCopy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopy.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopy(*args):
        """
        ('PIX', '*pixd')       
('const PIX', '*pixs')       

:param[in]    pixd:   [optional] can be null, equal to pixs,
different from pixs
:param[in]    pixs:
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) There are three cases:
(a) pixd == null  (makes a new pix; refcount = 1)
(b) pixd == pixs  (no-op)
(c) pixd != pixs  (data copy; no change in refcount)
If the refcount of pixd > 1, case (c) will side-effect
these handles.
(2) The general pattern of use is:
pixd = pixCopy(pixd, pixs);
This will work for all three cases.
For clarity when the case is known, you can use:
(a) pixd = pixCopy(NULL, pixs);
(c) pixCopy(pixd, pixs);
(3) For case (c), we check if pixs and pixd are the same
size (w,h,d).  If so, the data is copied directly.
Otherwise, the data is reallocated to the correct size
and the copy proceeds.  The refcount of pixd is unchanged.
(4) This operation, like all others that may involve a pre-existing
pixd, will side-effect any existing clones of pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopy(*args)
    
    

    try:
        leptonica.pixResizeImageData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixResizeImageData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixResizeImageData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixResizeImageData(*args):
        """
        ('PIX', '*pixd')       
('const PIX', '*pixs')       

:param[in]   pixd:   gets new uninitialized buffer for image data
:param[in]   pixs:   determines the size of the buffer; not changed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If the sizes of data in pixs and pixd are unequal, this
frees the existing image data in pixd and allocates
an uninitialized buffer that will hold the required amount
of image data in pixs.  The image data from pixs is not
copied into the new buffer.
(2) On failure to allocate, pixd is unchanged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixResizeImageData(*args)
    
    

    try:
        leptonica.pixCopyColormap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopyColormap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCopyColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyColormap(*args):
        """
        ('PIX', '*pixd')       
('const PIX', '*pixs')       

:param[in]   pixd:
:param[in]   pixs:   copies the colormap to %pixd
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys the colormap in pixd, unless the operation is a no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyColormap(*args)
    
    

    try:
        leptonica.pixSizesEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSizesEqual.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixSizesEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSizesEqual(*args):
        """
        ('const PIX', '*pix1')       
('const PIX', '*pix2')       

:param[in]    pix1,: pix2
:returns:  1 if the two pix have same {h, w, d}; 0 otherwise.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSizesEqual(*args)
    
    

    try:
        leptonica.pixTransferAllData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTransferAllData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTransferAllData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTransferAllData(*args):
        """
        ('PIX', '*pixd')       
('PIX', '**ppixs')       
('l_int32', 'copytext')       
('l_int32', 'copyformat')       

:param[in]      pixd:        must be different from pixs
:param[in,out]  ppixs:       will be nulled if refcount goes to 0
:param[in]      copytext:    1 to copy the text field; 0 to skip
:param[in]      copyformat:  1 to copy the informat field; 0 to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does a complete data transfer from pixs to pixd,
followed by the destruction of pixs (refcount permitting).
(2) If the refcount of pixs is 1, pixs is destroyed.  Otherwise,
the data in pixs is copied (rather than transferred) to pixd.
(3) This operation, like all others with a pre-existing pixd,
will side-effect any existing clones of pixd.  The pixd
refcount does not change.
(4) When might you use this?  Suppose you have an in-place Pix
function (returning void) with the typical signature:
void function-inplace(PIX *pix, ...)
where "..." are non-pointer input parameters, and suppose
further that you sometimes want to return an arbitrary Pix
in place of the input Pix.  There are two ways you can do this:
(a) The straightforward way is to change the function
signature to take the address of the Pix ptr:
\code
void function-inplace(PIX **ppix, ...) {
PIX *pixt = function-makenew(*ppix);
pixDestroy(ppix);
ppix = pixt;
return;
}
\endcode
Here, the input and returned pix are different, as viewed
by the calling function, and the inplace function is
expected to destroy the input pix to avoid a memory leak.
(b) Keep the signature the same and use pixTransferAllData()
to return the new Pix in the input Pix struct:
\code
void function-inplace(PIX *pix, ...) {
PIX *pixt = function-makenew(pix);
pixTransferAllData(pix, &pixt, 0, 0);
// pixDestroy() is called on pixt
return;
}
\endcode
Here, the input and returned pix are the same, as viewed
by the calling function, and the inplace function must
never destroy the input pix, because the calling function
maintains an unchanged handle to it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTransferAllData(*args)
    
    

    try:
        leptonica.pixSwapAndDestroy.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSwapAndDestroy.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSwapAndDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSwapAndDestroy(*args):
        """
        ('PIX', '**ppixd')       
('PIX', '**ppixs')       

:param[out]     ppixd:   [optional] input pixd can be null,
and it must be different from pixs
:param[in,out]  ppixs:   will be nulled after the swap
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Simple operation to change the handle name safely.
After this operation, the original image in pixd has
been destroyed, pixd points to what was pixs, and
the input pixs ptr has been nulled.
(2) This works safely whether or not pixs and pixd are cloned.
If pixs is cloned, the other handles still point to
the original image, with the ref count reduced by 1.
(3) Usage example:
\code
Pix *pix1 = pixRead("...");
Pix *pix2 = function(pix1, ...);
pixSwapAndDestroy(&pix1, &pix2);
pixDestroy(&pix1);  // holds what was in pix2
\endcode
Example with clones ([] shows ref count of image generated
by the function):
\code
Pix *pixs = pixRead("...");
Pix *pix1 = pixClone(pixs);
Pix *pix2 = function(pix1, ...);   [1]
Pix *pix3 = pixClone(pix2);   [1] --> [2]
pixSwapAndDestroy(&pix1, &pix2);
pixDestroy(&pixs);  // still holds read image
pixDestroy(&pix1);  // holds what was in pix2  [2] --> [1]
pixDestroy(&pix3);  // holds what was in pix2  [1] --> [0]
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSwapAndDestroy(*args)
    
    

    try:
        leptonica.pixGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetDimensions(*args):
        """
        ('const PIX', '*pix')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       

:param[in]    pix:
:param[out]   pw,: ph, pd    [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetDimensions(*args)
    
    

    try:
        leptonica.pixSetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetDimensions(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'd')       

:param[in]    pix:
:param[in]    w,: h, d   use 0 to skip the setting for any of these
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetDimensions(*args)
    
    

    try:
        leptonica.pixCopyDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopyDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCopyDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyDimensions(*args):
        """
        ('PIX', '*pixd')       
('const PIX', '*pixs')       

:param[in]   pixd:
:param[in]   pixs:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyDimensions(*args)
    
    

    try:
        leptonica.pixCopySpp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCopySpp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCopySpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopySpp(*args):
        """
        ('PIX', '*pixd')       
('const PIX', '*pixs')       

:param[in]   pixd:
:param[in]   pixs:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopySpp(*args)
    
    

    try:
        leptonica.pixGetResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetResolution(*args):
        """
        ('const PIX', '*pix')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       

:param[in]    pix:
:param[out]   pxres,: pyres   [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetResolution(*args)
    
    

    try:
        leptonica.pixSetResolution.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetResolution(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'xres')       
('l_int32', 'yres')       

:param[in]   pix:
:param[in]   xres,: yres   use 0 to skip setting a value for either of these
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetResolution(*args)
    
    

    try:
        leptonica.pixGetText.argtypes = [ctypes.c_void_p]
        leptonica.pixGetText.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function pixGetText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetText(*args):
        """
        ('PIX', '*pix')       

:param[in]   pix:
:returns:  ptr to existing text string

<pre>
Notes:
(1) The text string belongs to the pix:
the caller must NOT free it
it must not be used after the pix is destroyed
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetText(*args)
    
    

    try:
        leptonica.pixSetText.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixSetText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetText(*args):
        """
        ('PIX', '*pix')       
('const char', '*textstring')       

:param[in]   pix:
:param[in]   textstring:   can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes any existing textstring and puts a copy of
the input textstring there.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetText(*args)
    
    

    try:
        leptonica.pixAddText.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixAddText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAddText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddText(*args):
        """
        ('PIX', '*pix')       
('const char', '*textstring')       

:param[in]    pix:
:param[in]    textstring:   can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This adds the new textstring to any existing text.
(2) Either or both the existing text and the new text
string can be null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddText(*args)
    
    

    try:
        leptonica.pixSetColormap.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetColormap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetColormap(*args):
        """
        ('PIX', '*pix')       
('PIXCMAP', '*colormap')       

:param[in]   pix:
:param[in]   colormap:   to be assigned
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) Unlike with the pix data field, pixSetColormap() destroys
any existing colormap before assigning the new one.
Because colormaps are not ref counted, it is important that
the new colormap does not belong to any other pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetColormap(*args)
    
    

    try:
        leptonica.pixDestroyColormap.argtypes = [ctypes.c_void_p]
        leptonica.pixDestroyColormap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDestroyColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDestroyColormap(*args):
        """
        ('PIX', '*pix')       

:param[in]   pix:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixDestroyColormap(*args)
    
    

    try:
        leptonica.pixGetData.argtypes = [ctypes.c_void_p]
        leptonica.pixGetData.restype = ctypes.POINTER(ctypes.c_uint32)
    except AttributeError:
        sys.stderr.write("Warning - function pixGetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetData(*args):
        """
        ('PIX', '*pix')       

:param[in]    pix:
:returns:  ptr to image data

<pre>
Notes:
(1) This gives a new handle for the data.  The data is still
owned by the pix, so do not call LEPT_FREE() on it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetData(*args)
    
    

    try:
        leptonica.pixSetData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetData.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixSetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetData(*args):
        """
        ('PIX', '*pix')       
('l_uint32', '*data')       

:param[in]   pix:
:param[in]   data:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This does not free any existing data.  To free existing
data, use pixFreeData() before pixSetData().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetData(*args)
    
    

    try:
        leptonica.pixExtractData.argtypes = [ctypes.c_void_p]
        leptonica.pixExtractData.restype = ctypes.POINTER(ctypes.c_uint32)
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractData(*args):
        """
        ('PIX', '*pixs')       

:param[in]   pix:
:returns:  ptr to data, or null on error

<pre>
Notes:
(1) This extracts the pix image data for use in another context.
The caller still needs to use pixDestroy() on the input pix.
(2) If refcount == 1, the data is extracted and the
pix->data ptr is set to NULL.
(3) If refcount > 1, this simply returns a copy of the data,
using the pix allocator, and leaving the input pix unchanged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractData(*args)
    
    

    try:
        leptonica.pixFreeData.argtypes = [ctypes.c_void_p]
        leptonica.pixFreeData.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixFreeData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFreeData(*args):
        """
        ('PIX', '*pix')       

:param[in]   pix:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This frees the data and sets the pix data ptr to null.
It should be used before pixSetData() in the situation where
you want to free any existing data before doing
a subsequent assignment with pixSetData().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFreeData(*args)
    
    

    try:
        leptonica.pixGetLinePtrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetLinePtrs.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))
    except AttributeError:
        sys.stderr.write("Warning - function pixGetLinePtrs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetLinePtrs(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*psize')       

:param[in]    pix:
:param[out]   psize:   [optional] array size, which is the pix height
:returns:  array of line ptrs, or NULL on error

<pre>
Notes:
(1) This is intended to be used for fast random pixel access.
For example, for an 8 bpp image,
val = GET_DATA_BYTE(lines8[i], j);
is equivalent to, but much faster than,
pixGetPixel(pix, j, i, &val);
(2) How much faster?  For 1 bpp, it's from 6 to 10x faster.
For 8 bpp, it's an amazing 30x faster.  So if you are
doing random access over a substantial part of the image,
use this line ptr array.
(3) When random access is used in conjunction with a stack,
queue or heap, the overall computation time depends on
the operations performed on each struct that is popped
or pushed, and whether we are using a priority queue (O(logn))
or a queue or stack (O(1)).  For example, for maze search,
the overall ratio of time for line ptrs vs. pixGet/Set* is
Maze type     Type                   Time ratio
binary      queue                     0.4
gray        heap (priority queue)     0.6
(4) Because this returns a void** and the accessors take void*,
the compiler cannot check the pointer types.  It is
strongly recommended that you adopt a naming scheme for
the returned ptr arrays that indicates the pixel depth.
(This follows the original intent of Simonyi's "Hungarian"
application notation, where naming is used proactively
to make errors visibly obvious.)  By doing this, you can
tell by inspection if the correct accessor is used.
For example, for an 8 bpp pixg:
void **lineg8 = pixGetLinePtrs(pixg, NULL);
val = GET_DATA_BYTE(lineg8[i], j);  // fast access; BYTE, 8
...
LEPT_FREE(lineg8);  // don't forget this
(5) These are convenient for accessing bytes sequentially in an
8 bpp grayscale image.  People who write image processing code
on 8 bpp images are accustomed to grabbing pixels directly out
of the raster array.  Note that for little endians, you first
need to reverse the byte order in each 32-bit word.
Here's a typical usage pattern:
pixEndianByteSwap(pix);   // always safe; no-op on big-endians
l_uint8 **lineptrs = (l_uint8 **)pixGetLinePtrs(pix, NULL);
pixGetDimensions(pix, &w, &h, NULL);
for (i = 0; i < h; i++) {
l_uint8 *line = lineptrs[i];
for (j = 0; j < w; j++) {
val = line[j];
...
}
}
pixEndianByteSwap(pix);  // restore big-endian order
LEPT_FREE(lineptrs);
This can be done even more simply as follows:
l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);
for (i = 0; i < h; i++) {
l_uint8 *line = lineptrs[i];
for (j = 0; j < w; j++) {
val = line[j];
...
}
}
pixCleanupByteProcessing(pix, lineptrs);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetLinePtrs(*args)
    
    

    try:
        leptonica.pixPrintStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixPrintStreamInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixPrintStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPrintStreamInfo(*args):
        """
        ('FILE', '*fp')       
('const PIX', '*pix')       
('const char', '*text')       

:param[in]    fp:    file stream
:param[in]    pix:
:param[in]    text:  [optional] identifying string; can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixPrintStreamInfo(*args)
    




class queue(object):
    """<pre>

Create/Destroy L_Queue
L_QUEUE        *lqueueCreate()
void           *lqueueDestroy()

Operations to add/remove to/from a L_Queue
l_int32         lqueueAdd()
static l_int32  lqueueExtendArray()
void           *lqueueRemove()

Accessors
l_int32         lqueueGetCount()

Debug output
l_int32         lqueuePrint()

The lqueue is a fifo that implements a queue of void* pointers.
It can be used to hold a queue of any type of struct.
Internally, it maintains two counters:
nhead:  location of head (in ptrs) from the beginning
of the buffer
nelem:  number of ptr elements stored in the queue
As items are added to the queue, nelem increases.
As items are removed, nhead increases and nelem decreases.
Any time the tail reaches the end of the allocated buffer,
all the pointers are shifted to the left, so that the head
is at the beginning of the array.
If the buffer becomes more than 3/4 full, it doubles in size.

[A circular queue would allow us to skip the shifting and
to resize only when the buffer is full.  For most applications,
the extra work we do for a linear queue is not significant.]
</pre>




"""
    
    try:
        leptonica.lqueueCreate.argtypes = [ctypes.c_int32]
        leptonica.lqueueCreate.restype = lambda address: L_QUEUE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function lqueueCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueCreate(*args):
        """
        ('l_int32', 'nalloc')       

:param[in]    nalloc:     size of ptr array to be alloc'd; 0 for default
:returns:  lqueue, or NULL on error

<pre>
Notes:
(1) Allocates a ptr array of given size, and initializes counters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueCreate(*args)
    
    

    try:
        leptonica.lqueueDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lqueueDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function lqueueDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueDestroy(*args):
        """
        ('L_QUEUE', '**plq')       
('l_int32', 'freeflag')       

:param[in,out]   plq:       will be set to null before returning
:param[in]       freeflag:  TRUE to free each remaining struct in the array
:returns:  void

<pre>
Notes:
(1) If freeflag is TRUE, frees each struct in the array.
(2) If freeflag is FALSE but there are elements on the array,
gives a warning and destroys the array.  This will
cause a memory leak of all the items that were on the queue.
So if the items require their own destroy function, they
must be destroyed before the queue.  The same applies to the
auxiliary stack, if it is used.
(3) To destroy the L_Queue, we destroy the ptr array, then
the lqueue, and then null the contents of the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueDestroy(*args)
    
    

    try:
        leptonica.lqueueAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lqueueAdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lqueueAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueAdd(*args):
        """
        ('L_QUEUE', '*lq')       
('void', '*item')       

:param[in]    lq:     lqueue
:param[in]    item:   to be added to the tail of the queue
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The algorithm is as follows.  If the queue is populated
to the end of the allocated array, shift all ptrs toward
the beginning of the array, so that the head of the queue
is at the beginning of the array.  Then, if the array is
more than 0.75 full, realloc with double the array size.
Finally, add the item to the tail of the queue.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueAdd(*args)
    
    

    try:
        leptonica.lqueueRemove.argtypes = [ctypes.c_void_p]
        leptonica.lqueueRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function lqueueRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueRemove(*args):
        """
        ('L_QUEUE', '*lq')       

:param[in]    lq:   lqueue
:returns:  ptr to item popped from the head of the queue,
or NULL if the queue is empty or on error

<pre>
Notes:
(1) If this is the last item on the queue, so that the queue
becomes empty, nhead is reset to the beginning of the array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueRemove(*args)
    
    

    try:
        leptonica.lqueueGetCount.argtypes = [ctypes.c_void_p]
        leptonica.lqueueGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lqueueGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueueGetCount(*args):
        """
        ('L_QUEUE', '*lq')       

:param[in]    lq:   lqueue
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lqueueGetCount(*args)
    
    

    try:
        leptonica.lqueuePrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lqueuePrint.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lqueuePrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lqueuePrint(*args):
        """
        ('FILE', '*fp')       
('L_QUEUE', '*lq')       

:param[in]    fp:   file stream
:param[in]    lq:   lqueue
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lqueuePrint(*args)
    




class stack(object):
    """<pre>

Generic stack

The lstack is an array of void * ptrs, onto which
objects can be stored.  At any time, the number of
stored objects is lstack->n.  The object at the bottom
of the lstack is at array[0]; the object at the top of
the lstack is at array[n-1].  New objects are added
to the top of the lstack; i.e., the first available
location, which is at array[n].  The lstack is expanded
by doubling, when needed.  Objects are removed
from the top of the lstack.  When an attempt is made
to remove an object from an empty lstack, the result is null.

Create/Destroy
L_STACK        *lstackCreate()
void            lstackDestroy()

Accessors
l_int32         lstackAdd()
void           *lstackRemove()
static l_int32  lstackExtendArray()
l_int32         lstackGetCount()

Text description
l_int32         lstackPrint()
</pre>




"""
    
    try:
        leptonica.lstackCreate.argtypes = [ctypes.c_int32]
        leptonica.lstackCreate.restype = lambda address: L_STACK(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function lstackCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:   initial ptr array size; use 0 for default
:returns:  lstack, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackCreate(*args)
    
    

    try:
        leptonica.lstackDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lstackDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function lstackDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackDestroy(*args):
        """
        ('L_STACK', '**plstack')       
('l_int32', 'freeflag')       

:param[in,out]   plstack:    will be set to null before returning
:param[in]    freeflag: TRUE to free each remaining struct in the array
:returns:  void

<pre>
Notes:
(1) If %freeflag is TRUE, frees each struct in the array.
(2) If %freeflag is FALSE but there are elements on the array,
gives a warning and destroys the array.  This will
cause a memory leak of all the items that were on the lstack.
So if the items require their own destroy function, they
must be destroyed before the lstack.
(3) To destroy the lstack, we destroy the ptr array, then
the lstack, and then null the contents of the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lstackDestroy(*args)
    
    

    try:
        leptonica.lstackAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lstackAdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lstackAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackAdd(*args):
        """
        ('L_STACK', '*lstack')       
('void', '*item')       

:param[in]    lstack:
:param[in]    item:      to be added to the lstack
:returns:  0 if OK; 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.lstackAdd(*args)
    
    

    try:
        leptonica.lstackRemove.argtypes = [ctypes.c_void_p]
        leptonica.lstackRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function lstackRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackRemove(*args):
        """
        ('L_STACK', '*lstack')       

:param[in]    lstack:
:returns:  ptr to item popped from the top of the lstack,
or NULL if the lstack is empty or on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackRemove(*args)
    
    

    try:
        leptonica.lstackGetCount.argtypes = [ctypes.c_void_p]
        leptonica.lstackGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lstackGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackGetCount(*args):
        """
        ('L_STACK', '*lstack')       

:param[in]    lstack:
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackGetCount(*args)
    
    

    try:
        leptonica.lstackPrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lstackPrint.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lstackPrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lstackPrint(*args):
        """
        ('FILE', '*fp')       
('L_STACK', '*lstack')       

:param[in]    fp:       file stream
:param[in]    lstack:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lstackPrint(*args)
    




class baseline(object):
    """<pre>

Locate text baselines in an image
NUMA     *pixFindBaselines()

Projective transform to remove local skew
PIX      *pixDeskewLocal()

Determine local skew
l_int32   pixGetLocalSkewTransform()
NUMA     *pixGetLocalSkewAngles()

We have two apparently different functions here:
~ finding baselines
~ finding a projective transform to remove keystone warping
The function pixGetLocalSkewAngles() returns an array of angles,
one for each raster line, and the baselines of the text lines
should intersect the left edge of the image with that angle.
</pre>




"""
    
    try:
        leptonica.pixFindBaselines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindBaselines.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindBaselines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindBaselines(*args):
        """
        ('PIX', '*pixs')       
('PTA', '**ppta')       
('PIXA', '*pixadb')       

:param[in]    pixs:     1 bpp, 300 ppi
:param[out]   ppta:     [optional] pairs of pts corresponding to
approx. ends of each text line
:param[in]    pixadb:   for debug output; use NULL to skip
:returns:  na of baseline y values, or NULL on error

<pre>
Notes:
(1) Input binary image must have text lines already aligned
horizontally.  This can be done by either rotating the
image with pixDeskew(), or, if a projective transform
is required, by doing pixDeskewLocal() first.
(2) Input null for &pta if you don't want this returned.
The pta will come in pairs of points (left and right end
of each baseline).
(3) Caution: this will not work properly on text with multiple
columns, where the lines are not aligned between columns.
If there are multiple columns, they should be extracted
separately before finding the baselines.
(4) This function constructs different types of output
for baselines; namely, a set of raster line values and
a set of end points of each baseline.
(5) This function was designed to handle short and long text lines
without using dangerous thresholds on the peak heights.  It does
this by combining the differential signal with a morphological
analysis of the locations of the text lines.  One can also
combine this data to normalize the peak heights, by weighting
the differential signal in the region of each baseline
by the inverse of the width of the text line found there.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindBaselines(*args)
    
    

    try:
        leptonica.pixDeskewLocal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixDeskewLocal.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDeskewLocal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewLocal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nslices')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       

:param[in]    pixs:        1 bpp
:param[in]    nslices:     the number of horizontal overlapping slices;
must be larger than 1 and not exceed 20;
use 0 for default
:param[in]    redsweep:    sweep reduction factor: 1, 2, 4 or 8;
use 0 for default value
:param[in]    redsearch:   search reduction factor: 1, 2, 4 or 8, and
not larger than redsweep; use 0 for default value
:param[in]    sweeprange:  half the full range, assumed about 0; in degrees;
use 0.0 for default value
:param[in]    sweepdelta:  angle increment of sweep; in degrees;
use 0.0 for default value
:param[in]    minbsdelta:  min binary search increment angle; in degrees;
use 0.0 for default value
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function allows deskew of a page whose skew changes
approximately linearly with vertical position.  It uses
a projective transform that in effect does a differential
shear about the LHS of the page, and makes all text lines
horizontal.
(2) The origin of the keystoning can be either a cheap document
feeder that rotates the page as it is passed through, or a
camera image taken from either the left or right side
of the vertical.
(3) The image transformation is a projective warping,
not a rotation.  Apart from this function, the text lines
must be properly aligned vertically with respect to each
other.  This can be done by pre-processing the page; e.g.,
by rotating or horizontally shearing it.
Typically, this can be achieved by vertically aligning
the page edge.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewLocal(*args)
    
    

    try:
        leptonica.pixGetLocalSkewTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetLocalSkewTransform.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetLocalSkewTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetLocalSkewTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nslices')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
('PTA', '**pptas')       
('PTA', '**pptad')       

:param[in]    pixs:
:param[in]    nslices:      the number of horizontal overlapping slices;
must be larger than 1 and not exceed 20;
use 0 for default
:param[in]    redsweep:     sweep reduction factor: 1, 2, 4 or 8;
use 0 for default value
:param[in]    redsearch:    search reduction factor: 1, 2, 4 or 8, and not
larger than redsweep; use 0 for default value
:param[in]    sweeprange:   half the full range, assumed about 0;
in degrees; use 0.0 for default value
:param[in]    sweepdelta:   angle increment of sweep; in degrees;
use 0.0 for default value
:param[in]    minbsdelta:   min binary search increment angle; in degrees;
use 0.0 for default value
:param[out]   pptas:        4 points in the source
:param[out]   pptad:        the corresponding 4 pts in the dest
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates two pairs of points in the src, each pair
corresponding to a pair of points that would lie along
the same raster line in a transformed (dewarped) image.
(2) The sets of 4 src and 4 dest points returned by this function
can then be used, in a projective or bilinear transform,
to remove keystoning in the src.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetLocalSkewTransform(*args)
    
    

    try:
        leptonica.pixGetLocalSkewAngles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetLocalSkewAngles.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetLocalSkewAngles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetLocalSkewAngles(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nslices')       
('l_int32', 'redsweep')       
('l_int32', 'redsearch')       
('l_float32', 'sweeprange')       
('l_float32', 'sweepdelta')       
('l_float32', 'minbsdelta')       
('l_float32', '*pa')       
('l_float32', '*pb')       
('l_int32', 'debug')       

:param[in]    pixs:          1 bpp
:param[in]    nslices:       the number of horizontal overlapping slices;
must be larger than 1 and not exceed 20;
use 0 for default
:param[in]    redsweep:      sweep reduction factor: 1, 2, 4 or 8;
use 0 for default value
:param[in]    redsearch:     search reduction factor: 1, 2, 4 or 8, and not
larger than redsweep; use 0 for default value
:param[in]    sweeprange:    half the full range, assumed about 0;
in degrees; use 0.0 for default value
:param[in]    sweepdelta:    angle increment of sweep; in degrees;
use 0.0 for default value
:param[in]    minbsdelta:    min binary search increment angle; in degrees;
use 0.0 for default value
:param[out]   pa:            [optional] slope of skew as fctn of y
:param[out]   pb:            [optional] intercept at y = 0 of skew,
8                             as a function of y
:param[in]    debug:         1 for generating plot of skew angle vs. y;
0 otherwise
:returns:  naskew, or NULL on error

<pre>
Notes:
(1) The local skew is measured in a set of overlapping strips.
We then do a least square linear fit parameters to get
the slope and intercept parameters a and b in
skew-angle = a * y + b  (degrees)
for the local skew as a function of raster line y.
This is then used to make naskew, which can be interpreted
as the computed skew angle (in degrees) at the left edge
of each raster line.
(2) naskew can then be used to find the baselines of text, because
each text line has a baseline that should intersect
the left edge of the image with the angle given by this
array, evaluated at the raster line of intersection.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetLocalSkewAngles(*args)
    




class conncomp(object):
    """<pre>

Connected component counting and extraction, using Heckbert's
stack-based filling algorithm.

4- and 8-connected components: counts, bounding boxes and images

Top-level calls:
BOXA     *pixConnComp()
BOXA     *pixConnCompPixa()
BOXA     *pixConnCompBB()
l_int32   pixCountConnComp()

Identify the next c.c. to be erased:
l_int32   nextOnPixelInRaster()
static  l_int32   nextOnPixelInRasterLow()

Erase the c.c., saving the b.b.:
BOX      *pixSeedfillBB()
BOX      *pixSeedfill4BB()
BOX      *pixSeedfill8BB()

Just erase the c.c.:
l_int32   pixSeedfill()
l_int32   pixSeedfill4()
l_int32   pixSeedfill8()

Static stack helper functions for single raster line seedfill:
static void    pushFillsegBB()
static void    pushFillseg()
static void    popFillseg()

The basic method in pixConnCompBB() is very simple.  We scan the
image in raster order, looking for the next ON pixel.  When it
is found, we erase it and every pixel of the 4- or 8-connected
component to which it belongs, using Heckbert's seedfill
algorithm.  As pixels are erased, we keep track of the
minimum rectangle that encloses all erased pixels; after
the connected component has been erased, we save its
bounding box in an array of boxes.  When all pixels in the
image have been erased, we have an array that describes every
4- or 8-connected component in terms of its bounding box.

pixConnCompPixa() is a slight variation on pixConnCompBB(),
where we additionally save an array of images (in a Pixa)
of each of the 4- or 8-connected components.  This is done trivially
by maintaining two temporary images.  We erase a component from one,
and use the bounding box to extract the pixels within the b.b.
from each of the two images.  An XOR between these subimages
gives the erased component.  Then we erase the component from the
second image using the XOR again, with the extracted component
placed on the second image at the location of the bounding box.
Rasterop does all the work.  At the end, we have an array
of the 4- or 8-connected components, as well as an array of the
bounding boxes that describe where they came from in the original image.

If you just want the number of connected components, pixCountConnComp()
is a bit faster than pixConnCompBB(), because it doesn't have to
keep track of the bounding rectangles for each c.c.
</pre>




"""
    
    try:
        leptonica.pixConnComp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnComp.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnComp(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '**ppixa')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[out]   ppixa:          [optional] pixa of each c.c.
:param[in]    connectivity:   4 or 8
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) This is the top-level call for getting bounding boxes or
a pixa of the components, and it can be used instead
of either pixConnCompBB() or pixConnCompPixa(), rsp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnComp(*args)
    
    

    try:
        leptonica.pixConnCompPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnCompPixa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConnCompPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompPixa(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '**ppixa')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[out]   ppixa:          pixa of each c.c.
:param[in]    connectivity:   4 or 8
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) This finds bounding boxes of 4- or 8-connected components
in a binary image, and saves images of each c.c
in a pixa array.
(2) It sets up 2 temporary pix, and for each c.c. that is
located in raster order, it erases the c.c. from one pix,
then uses the b.b. to extract the c.c. from the two pix using
an XOR, and finally erases the c.c. from the second pix.
(3) A clone of the returned boxa (where all boxes in the array
are clones) is inserted into the pixa.
(4) If the input is valid, this always returns a boxa and a pixa.
If pixs is empty, the boxa and pixa will be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompPixa(*args)
    
    

    try:
        leptonica.pixConnCompBB.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnCompBB.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConnCompBB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompBB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   4 or 8
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) Finds bounding boxes of 4- or 8-connected components
in a binary image.
(2) This works on a copy of the input pix.  The c.c. are located
in raster order and erased one at a time.  In the process,
the b.b. is computed and saved.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompBB(*args)
    
    

    try:
        leptonica.pixCountConnComp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCountConnComp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountConnComp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('l_int32', '*pcount')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   4 or 8
:param[out]   pcount:
:returns:  0 if OK, 1 on error

Notes:
(1 This is the top-level call for getting the number of
4- or 8-connected components in a 1 bpp image.
2 It works on a copy of the input pix.  The c.c. are located
in raster order and erased one at a time.


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountConnComp(*args)
    
    

    try:
        leptonica.nextOnPixelInRaster.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.nextOnPixelInRaster.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function nextOnPixelInRaster not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def nextOnPixelInRaster(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xstart')       
('l_int32', 'ystart')       
('l_int32', '*px')       
('l_int32', '*py')       

:param[in]    pixs:             1 bpp
:param[in]    xstart,: ystart   starting point for search
:param[out]   px,: py           coord value of next ON pixel
:returns:  1 if a pixel is found; 0 otherwise or on error


        """
        args = _convert_params(*args)
        
        return leptonica.nextOnPixelInRaster(*args)
    
    

    try:
        leptonica.pixSeedfillBB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillBB.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillBB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillBB(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    stack:          for holding fillsegs
:param[in]    x,y:            location of seed pixel
:param[in]    connectivity:   4 or 8
:returns:  box or NULL on error

<pre>
Notes:
(1) This is the high-level interface to Paul Heckbert's
stack-based seedfill algorithm.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillBB(*args)
    
    

    try:
        leptonica.pixSeedfill4BB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill4BB.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfill4BB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill4BB(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pixs:     1 bpp
:param[in]    stack:    for holding fillsegs
:param[in]    x,y:      location of seed pixel
:returns:  box or NULL on error.

<pre>
Notes:
(1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
(2) This operates on the input 1 bpp pix to remove the fg seed
pixel, at (x,y), and all pixels that are 4-connected to it.
The seed pixel at (x,y) must initially be ON.
(3) Returns the bounding box of the erased 4-cc component.
(4) Reference: see Paul Heckbert's stack-based seed fill algorithm
in "Graphic Gems", ed. Andrew Glassner, Academic
Press, 1990.  The algorithm description is given
on pp. 275-277; working C code is on pp. 721-722.)
The code here follows Heckbert's exactly, except
we use function calls instead of macros for
pushing data on and popping data off the stack.
This makes sense to do because Heckbert's fixed-size
stack with macros is dangerous: images exist that
will overrun the stack and crash.   The stack utility
here grows dynamically as needed, and the fillseg
structures that are not in use are stored in another
stack for reuse.  It should be noted that the
overhead in the function calls (vs. macros) is negligible.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill4BB(*args)
    
    

    try:
        leptonica.pixSeedfill8BB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill8BB.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfill8BB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill8BB(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pixs:    1 bpp
:param[in]    stack:   for holding fillsegs
:param[in]    x,y:     location of seed pixel
:returns:  box or NULL on error.

<pre>
Notes:
(1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
(2) This operates on the input 1 bpp pix to remove the fg seed
pixel, at (x,y), and all pixels that are 8-connected to it.
The seed pixel at (x,y) must initially be ON.
(3) Returns the bounding box of the erased 8-cc component.
(4) Reference: see Paul Heckbert's stack-based seed fill algorithm
in "Graphic Gems", ed. Andrew Glassner, Academic
Press, 1990.  The algorithm description is given
on pp. 275-277; working C code is on pp. 721-722.)
The code here follows Heckbert's closely, except
the leak checks are changed for 8 connectivity.
See comments on pixSeedfill4BB() for more details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill8BB(*args)
    
    

    try:
        leptonica.pixSeedfill.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    stack:          for holding fillsegs
:param[in]    x,y:            location of seed pixel
:param[in]    connectivity:   4 or 8
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes the component from pixs with a fg pixel at (x,y).
(2) See pixSeedfill4() and pixSeedfill8() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill(*args)
    
    

    try:
        leptonica.pixSeedfill4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill4.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfill4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill4(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pixs:    1 bpp
:param[in]    stack:   for holding fillsegs
:param[in]    x,y:     location of seed pixel
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is Paul Heckbert's stack-based 4-cc seedfill algorithm.
(2) This operates on the input 1 bpp pix to remove the fg seed
pixel, at (x,y), and all pixels that are 4-connected to it.
The seed pixel at (x,y) must initially be ON.
(3) Reference: see pixSeedFill4BB()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill4(*args)
    
    

    try:
        leptonica.pixSeedfill8.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfill8.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfill8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfill8(*args):
        """
        ('PIX', '*pixs')       
('L_STACK', '*stack')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pixs:    1 bpp
:param[in]    stack:   for holding fillsegs
:param[in]    x,y:     location of seed pixel
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is Paul Heckbert's stack-based 8-cc seedfill algorithm.
(2) This operates on the input 1 bpp pix to remove the fg seed
pixel, at (x,y), and all pixels that are 8-connected to it.
The seed pixel at (x,y) must initially be ON.
(3) Reference: see pixSeedFill8BB()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfill8(*args)
    




class graphics(object):
    """<pre>

Pta generation for arbitrary shapes built with lines
PTA        *generatePtaLine()
PTA        *generatePtaWideLine()
PTA        *generatePtaBox()
PTA        *generatePtaBoxa()
PTA        *generatePtaHashBox()
PTA        *generatePtaHashBoxa()
PTAA       *generatePtaaBoxa()
PTAA       *generatePtaaHashBoxa()
PTA        *generatePtaPolyline()
PTA        *generatePtaGrid()
PTA        *convertPtaLineTo4cc()
PTA        *generatePtaFilledCircle()
PTA        *generatePtaFilledSquare()
PTA        *generatePtaLineFromPt()
l_int32     locatePtRadially()

Rendering function plots directly on images
l_int32     pixRenderPlotFromNuma()
l_int32     pixRenderPlotFromNumaGen()
PTA        *makePlotPtaFromNuma()
PTA        *makePlotPtaFromNumaGen()

Pta rendering
l_int32     pixRenderPta()
l_int32     pixRenderPtaArb()
l_int32     pixRenderPtaBlend()

Rendering of arbitrary shapes built with lines
l_int32     pixRenderLine()
l_int32     pixRenderLineArb()
l_int32     pixRenderLineBlend()

l_int32     pixRenderBox()
l_int32     pixRenderBoxArb()
l_int32     pixRenderBoxBlend()

l_int32     pixRenderBoxa()
l_int32     pixRenderBoxaArb()
l_int32     pixRenderBoxaBlend()

l_int32     pixRenderHashBox()
l_int32     pixRenderHashBoxArb()
l_int32     pixRenderHashBoxBlend()
l_int32     pixRenderHashMaskArb()

l_int32     pixRenderHashBoxa()
l_int32     pixRenderHashBoxaArb()
l_int32     pixRenderHashBoxaBlend()

l_int32     pixRenderPolyline()
l_int32     pixRenderPolylineArb()
l_int32     pixRenderPolylineBlend()

l_int32     pixRenderGrid()

l_int32     pixRenderRandomCmapPtaa()

Rendering and filling of polygons
PIX        *pixRenderPolygon()
PIX        *pixFillPolygon()

Contour rendering on grayscale images
PIX        *pixRenderContours()
PIX        *fpixAutoRenderContours()
PIX        *fpixRenderContours()

Boundary pt generation on 1 bpp images
PTA        *pixGeneratePtaBoundary()

The line rendering functions are relatively crude, but they
get the job done for most simple situations.  We use the pta
(array of points) as an intermediate data structure.  For example,
to render a line we first generate a pta.

Some rendering functions come in sets of three.  For example
pixRenderLine() -- render on 1 bpp pix
pixRenderLineArb() -- render on 32 bpp pix with arbitrary (r,g,b)
pixRenderLineBlend() -- render on 32 bpp pix, blending the
(r,g,b) graphic object with the underlying rgb pixels.

There are also procedures for plotting a function, computed
from the row or column pixels, directly on the image.
</pre>




"""
    
    try:
        leptonica.generatePtaLine.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaLine.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaLine(*args):
        """
        ('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       

:param[in]    x1,: y1    end point 1
:param[in]    x2,: y2    end point 2
:returns:  pta, or NULL on error

<pre>
Notes:
(1) Uses Bresenham line drawing, which results in an 8-connected line.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaLine(*args)
    
    

    try:
        leptonica.generatePtaWideLine.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaWideLine.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaWideLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaWideLine(*args):
        """
        ('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       

:param[in]    x1,: y1     end point 1
:param[in]    x2,: y2     end point 2
:param[in]    width:
:returns:  ptaj, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaWideLine(*args)
    
    

    try:
        leptonica.generatePtaBox.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.generatePtaBox.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaBox(*args):
        """
        ('BOX', '*box')       
('l_int32', 'width')       

:param[in]    box:
:param[in]    width:    of line
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) Because the box is constructed so that we don't have any
overlapping lines, there is no need to remove duplicates.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaBox(*args)
    
    

    try:
        leptonica.generatePtaBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaBoxa.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaBoxa(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'width')       
('l_int32', 'removedups')       

:param[in]    boxa:
:param[in]    width:
:param[in]    removedups:    1 to remove, 0 to leave
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) If %boxa has overlapping boxes, and if blending will
be used to give a transparent effect, transparency
artifacts at line intersections can be removed using
%removedups = 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaBoxa(*args)
    
    

    try:
        leptonica.generatePtaHashBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaHashBox.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaHashBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaHashBox(*args):
        """
        ('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       

:param[in]    box:
:param[in]    spacing:    spacing between lines; must be > 1
:param[in]    width:      of line
:param[in]    orient:     orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:    0 to skip drawing box outline
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) The orientation takes on one of 4 orientations (horiz, vertical,
slope +1, slope -1).
(2) The full outline is also drawn if %outline = 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaHashBox(*args)
    
    

    try:
        leptonica.generatePtaHashBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaHashBoxa.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaHashBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaHashBoxa(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'removedups')       

:param[in]    boxa:
:param[in]    spacing:     spacing between lines; must be > 1
:param[in]    width:       of line
:param[in]    orient:      orientation of lines: L_HORIZONTAL_LINE, ...
:param[in]    orient:      orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:     0 to skip drawing box outline
:param[in]    removedups:  1 to remove, 0 to leave
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) The orientation takes on one of 4 orientations (horiz, vertical,
slope +1, slope -1).
(2) The full outline is also drawn if %outline = 1.
(3) If the boxa has overlapping boxes, and if blending will
be used to give a transparent effect, transparency
artifacts at line intersections can be removed using
%removedups = 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaHashBoxa(*args)
    
    

    try:
        leptonica.generatePtaaBoxa.argtypes = [ctypes.c_void_p]
        leptonica.generatePtaaBoxa.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaaBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaaBoxa(*args):
        """
        ('BOXA', '*boxa')       

:param[in]    boxa:
:returns:  ptaa, or NULL on error

<pre>
Notes:
(1) This generates a pta of the four corners for each box in
the boxa.
(2) Each of these pta can be rendered onto a pix with random colors,
by using pixRenderRandomCmapPtaa() with closeflag = 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaaBoxa(*args)
    
    

    try:
        leptonica.generatePtaaHashBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaaHashBoxa.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaaHashBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaaHashBoxa(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       

:param[in]    boxa:
:param[in]    spacing:     spacing between hash lines; must be > 1
:param[in]    width:       hash line width
:param[in]    orient:      orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:     0 to skip drawing box outline
:returns:  ptaa, or NULL on error

<pre>
Notes:
(1) The orientation takes on one of 4 orientations (horiz, vertical,
slope +1, slope -1).
(2) The full outline is also drawn if %outline = 1.
(3) Each of these pta can be rendered onto a pix with random colors,
by using pixRenderRandomCmapPtaa() with closeflag = 1.

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaaHashBoxa(*args)
    
    

    try:
        leptonica.generatePtaPolyline.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaPolyline.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaPolyline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaPolyline(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'width')       
('l_int32', 'closeflag')       
('l_int32', 'removedups')       

:param[in]    ptas:         vertices of polyline
:param[in]    width:
:param[in]    closeflag:    1 to close the contour; 0 otherwise
:param[in]    removedups:   1 to remove, 0 to leave
:returns:  ptad, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaPolyline(*args)
    
    

    try:
        leptonica.generatePtaGrid.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.generatePtaGrid.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaGrid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaGrid(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'width')       

:param[in]    w,: h       of region where grid will be displayed
:param[in]    nx,: ny     number of rectangles in each direction in grid
:param[in]    width:      of rendered lines
:returns:  ptad, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaGrid(*args)
    
    

    try:
        leptonica.convertPtaLineTo4cc.argtypes = [ctypes.c_void_p]
        leptonica.convertPtaLineTo4cc.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function convertPtaLineTo4cc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertPtaLineTo4cc(*args):
        """
        ('PTA', '*ptas')       

:param[in]    ptas:    8-connected line of points
:returns:  ptad 4-connected line, or NULL on error

<pre>
Notes:
(1) When a polyline is generated with width = 1, the resulting
line is not 4-connected in general.  This function adds
points as necessary to convert the line to 4-cconnected.
It is useful when rendering 1 bpp on a pix.
(2) Do not use this for lines generated with width > 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertPtaLineTo4cc(*args)
    
    

    try:
        leptonica.generatePtaFilledCircle.argtypes = [ctypes.c_int32]
        leptonica.generatePtaFilledCircle.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaFilledCircle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaFilledCircle(*args):
        """
        ('l_int32', 'radius')       

:param[in]    radius:
:returns:  pta, or NULL on error

<pre>
Notes:
(1) The circle is has diameter = 2 * radius + 1.
(2) It is located with the center of the circle at the
point (%radius, %radius).
(3) Consequently, it typically must be translated if
it is to represent a set of pixels in an image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaFilledCircle(*args)
    
    

    try:
        leptonica.generatePtaFilledSquare.argtypes = [ctypes.c_int32]
        leptonica.generatePtaFilledSquare.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaFilledSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaFilledSquare(*args):
        """
        ('l_int32', 'side')       

:param[in]    side:
:returns:  pta, or NULL on error

<pre>
Notes:
(1) The center of the square can be chosen to be at
(side / 2, side / 2).  It must be translated by this amount
when used for replication.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaFilledSquare(*args)
    
    

    try:
        leptonica.generatePtaLineFromPt.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_double, ctypes.c_double]
        leptonica.generatePtaLineFromPt.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generatePtaLineFromPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generatePtaLineFromPt(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_float64', 'length')       
('l_float64', 'radang')       

:param[in]    x,: y      point of origination
:param[in]    length:    of line, including starting point
:param[in]    radang:    angle in radians, CW from horizontal
:returns:  pta, or NULL on error

<pre>
Notes:
(1) %length of the line is 1 greater than the distance
used in locatePtRadially().  Example: a distance of 1
gives rise to a length of 2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generatePtaLineFromPt(*args)
    
    

    try:
        leptonica.locatePtRadially.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_double, ctypes.c_double, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.locatePtRadially.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function locatePtRadially not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def locatePtRadially(*args):
        """
        ('l_int32', 'xr')       
('l_int32', 'yr')       
('l_float64', 'dist')       
('l_float64', 'radang')       
('l_float64', '*px')       
('l_float64', '*py')       

:param[in]    xr,: yr    reference point
:param[in]    radang:    angle in radians, CW from horizontal
:param[in]    dist:      distance of point from reference point along
line given by the specified angle
:param[out]   px,: py    location of point
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.locatePtRadially(*args)
    
    

    try:
        leptonica.pixRenderPlotFromNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixRenderPlotFromNuma.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPlotFromNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPlotFromNuma(*args):
        """
        ('PIX', '**ppix')       
('NUMA', '*na')       
('l_int32', 'plotloc')       
('l_int32', 'linewidth')       
('l_int32', 'max')       
('l_uint32', 'color')       

:param[in,out]  ppix:        any type; replaced if not 32 bpp rgb
:param[in]      na:          to be plotted
:param[in]      plotloc:     location of plot: L_PLOT_AT_TOP, etc
:param[in]      linewidth:   width of "line" that is drawn; between 1 and 7
:param[in]      max:         maximum excursion in pixels from baseline
:param[in]      color: plot color: 0xrrggbb00
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Simplified interface for plotting row or column aligned data
on a pix.
(2) This replaces %pix with a 32 bpp rgb version if it is not
already 32 bpp.  It then draws the plot on the pix.
(3) See makePlotPtaFromNumaGen() for more details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPlotFromNuma(*args)
    
    

    try:
        leptonica.makePlotPtaFromNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makePlotPtaFromNuma.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makePlotPtaFromNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePlotPtaFromNuma(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'size')       
('l_int32', 'plotloc')       
('l_int32', 'linewidth')       
('l_int32', 'max')       

:param[in]    na:
:param[in]    size:        pix height for horizontal plot; pix width
for vertical plot
:param[in]    plotloc:     location of plot: L_PLOT_AT_TOP, etc
:param[in]    linewidth:   width of "line" that is drawn; between 1 and 7
:param[in]    max:         maximum excursion in pixels from baseline
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) This generates points from %numa representing y(x) or x(y)
with respect to a pix.  A horizontal plot y(x) is drawn for
a function of column position, and a vertical plot is drawn
for a function x(y) of row position.  The baseline is located
so that all plot points will fit in the pix.
(2) See makePlotPtaFromNumaGen() for more details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makePlotPtaFromNuma(*args)
    
    

    try:
        leptonica.pixRenderPlotFromNumaGen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixRenderPlotFromNumaGen.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPlotFromNumaGen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPlotFromNumaGen(*args):
        """
        ('PIX', '**ppix')       
('NUMA', '*na')       
('l_int32', 'orient')       
('l_int32', 'linewidth')       
('l_int32', 'refpos')       
('l_int32', 'max')       
('l_int32', 'drawref')       
('l_uint32', 'color')       

:param[in,out]  ppix:         any type; replaced if not 32 bpp rgb
:param[in]      na:           to be plotted
:param[in]      orient:       L_HORIZONTAL_LINE, L_VERTICAL_LINE
:param[in]      linewidth:    width of "line" that is drawn; between 1 and 7
:param[in]      refpos:       reference position: y for horizontal;
x for vertical
:param[in]      max:          maximum excursion in pixels from baseline
:param[in]      drawref:      1 to draw the reference line and its normal
:param[in]      color:        plot color: 0xrrggbb00
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) General interface for plotting row or column aligned data
on a pix.
(2) This replaces %pix with a 32 bpp rgb version if it is not
already 32 bpp.  It then draws the plot on the pix.
(3) See makePlotPtaFromNumaGen() for other input parameters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPlotFromNumaGen(*args)
    
    

    try:
        leptonica.makePlotPtaFromNumaGen.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makePlotPtaFromNumaGen.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makePlotPtaFromNumaGen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePlotPtaFromNumaGen(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'orient')       
('l_int32', 'linewidth')       
('l_int32', 'refpos')       
('l_int32', 'max')       
('l_int32', 'drawref')       

:param[in]    na:
:param[in]    orient:       L_HORIZONTAL_LINE, L_VERTICAL_LINE
:param[in]    linewidth:    width of "line" that is drawn; between 1 and 7
:param[in]    refpos:       reference position: y for horizontal;
x for vertical
:param[in]    max:          maximum excursion in pixels from baseline
:param[in]    drawref:      1 to draw the reference line and its normal
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) This generates points from %numa representing y(x) or x(y)
with respect to a pix.  For y(x), we draw a horizontal line
at the reference position and a vertical line at the edge; then
we draw the values of %numa, scaled so that the maximum
excursion from the reference position is %max pixels.
(2) The start and delx parameters of %numa are used to refer
its values to the raster lines (L_VERTICAL_LINE) or columns
(L_HORIZONTAL_LINE).
(3) The linewidth is chosen in the interval [1 ... 7].
(4) %refpos should be chosen so the plot is entirely within the pix
that it will be painted onto.
(5) This would typically be used to plot, in place, a function
computed along pixel rows or columns.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makePlotPtaFromNumaGen(*args)
    
    

    try:
        leptonica.pixRenderPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRenderPta.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPta(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('l_int32', 'op')       

:param[in]    pix:   any depth, not cmapped
:param[in]    pta:   arbitrary set of points
:param[in]    op:    one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) L_SET_PIXELS puts all image bits in each pixel to 1
(black for 1 bpp; white for depth > 1)
(2) L_CLEAR_PIXELS puts all image bits in each pixel to 0
(white for 1 bpp; black for depth > 1)
(3) L_FLIP_PIXELS reverses all image bits in each pixel
(4) This function clips the rendering to the pix.  It performs
clipping for functions such as pixRenderLine(),
pixRenderBox() and pixRenderBoxa(), that call pixRenderPta().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPta(*args)
    
    

    try:
        leptonica.pixRenderPtaArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderPtaArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPtaArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPtaArb(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       

:param[in]    pix:      any depth, cmapped ok
:param[in]    pta:      arbitrary set of points
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %pix is colormapped, render this color (or the nearest
color if the cmap is full) on each pixel.
(2) The rgb components have the standard dynamic range [0 ... 255]
(3) If pix is not colormapped, do the best job you can using
the input colors:
~ d = 1: set the pixels
~ d = 2, 4, 8: average the input rgb value
~ d = 32: use the input rgb value
(4) This function clips the rendering to %pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPtaArb(*args)
    
    

    try:
        leptonica.pixRenderPtaBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float]
        leptonica.pixRenderPtaBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPtaBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPtaBlend(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       

:param[in]    pix:      32 bpp rgb
:param[in]    pta:      arbitrary set of points
:param[in]    rval,: gval, bval
:param[in]    fract:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function clips the rendering to %pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPtaBlend(*args)
    
    

    try:
        leptonica.pixRenderLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
('l_int32', 'op')       

:param[in]    pix:      any depth, not cmapped
:param[in]    x1,: y1
:param[in]    x2,: y2
:param[in]    width:    thickness of line
:param[in]    op:       one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderLine(*args)
    
    

    try:
        leptonica.pixRenderLineArb.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderLineArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderLineArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderLineArb(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       

:param[in]    pix:       any depth, cmapped ok
:param[in]    x1,: y1
:param[in]    x2,: y2
:param[in]    width:     thickness of line
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderLineArb(*args)
    
    

    try:
        leptonica.pixRenderLineBlend.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float]
        leptonica.pixRenderLineBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderLineBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderLineBlend(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       

:param[in]    pix:      32 bpp rgb
:param[in]    x1,: y1
:param[in]    x2,: y2
:param[in]    width:    thickness of line
:param[in]    rval,: gval, bval
:param[in]    fract:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderLineBlend(*args)
    
    

    try:
        leptonica.pixRenderBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBox(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'width')       
('l_int32', 'op')       

:param[in]    pix:     any depth, not cmapped
:param[in]    box:
:param[in]    width:   thickness of box lines
:param[in]    op:      one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBox(*args)
    
    

    try:
        leptonica.pixRenderBoxArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderBoxArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderBoxArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxArb(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       

:param[in]    pix:       any depth, cmapped ok
:param[in]    box:
:param[in]    width:     thickness of box lines
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxArb(*args)
    
    

    try:
        leptonica.pixRenderBoxBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float]
        leptonica.pixRenderBoxBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderBoxBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxBlend(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       

:param[in]    pix:       32 bpp rgb
:param[in]    box:
:param[in]    width:     thickness of box lines
:param[in]    rval,: gval, bval
:param[in]    fract:     in [0.0 - 1.0]: 1.0 is no transparency;
0.0 is complete transparency (no effect)
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxBlend(*args)
    
    

    try:
        leptonica.pixRenderBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxa(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_int32', 'op')       

:param[in]    pix:      any depth, not cmapped
:param[in]    boxa:
:param[in]    width:    thickness of line
:param[in]    op:       one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxa(*args)
    
    

    try:
        leptonica.pixRenderBoxaArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderBoxaArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderBoxaArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxaArb(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       

:param[in]    pix:       any depth; colormapped is ok
:param[in]    boxa:
:param[in]    width:     thickness of line
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxaArb(*args)
    
    

    try:
        leptonica.pixRenderBoxaBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRenderBoxaBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderBoxaBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderBoxaBlend(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
('l_int32', 'removedups')       

:param[in]    pix:          32 bpp rgb
:param[in]    boxa:
:param[in]    width:        thickness of line
:param[in]    rval,: gval, bval
:param[in]    fract:        in [0.0 - 1.0]: 1.0 is no transparency;
0.0 is complete transparency (no effect)
:param[in]    removedups:   1 to remove; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderBoxaBlend(*args)
    
    

    try:
        leptonica.pixRenderHashBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBox(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'op')       

:param[in]    pix:       any depth, not cmapped
:param[in]    box:
:param[in]    spacing:    spacing between lines; must be > 1
:param[in]    width:      thickness of box and hash lines
:param[in]    orient:     orientation of lines: L_HORIZONTAL_LINE, ...
:param[in]    outline:    0 to skip drawing box outline
:param[in]    op:         one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBox(*args)
    
    

    try:
        leptonica.pixRenderHashBoxArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashBoxArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashBoxArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxArb(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pix:         any depth; cmapped ok
:param[in]    box:
:param[in]    spacing:     spacing between lines; must be > 1
:param[in]    width:       thickness of box and hash lines
:param[in]    orient:      orientation of lines: L_HORIZONTAL_LINE, ...
:param[in]    outline:     0 to skip drawing box outline
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxArb(*args)
    
    

    try:
        leptonica.pixRenderHashBoxBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRenderHashBoxBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashBoxBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxBlend(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', 'fract')       

:param[in]    pix:        32 bpp
:param[in]    box:
:param[in]    spacing:    spacing between lines; must be > 1
:param[in]    width:      thickness of box and hash lines
:param[in]    orient:     orientation of lines: L_HORIZONTAL_LINE, ...
:param[in]    outline:    0 to skip drawing box outline
:param[in]    rval,: gval, bval
:param[in]    fract:      in [0.0 - 1.0]: 1.0 is no transparency;
0.0 is complete transparency (no effect)
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxBlend(*args)
    
    

    try:
        leptonica.pixRenderHashMaskArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashMaskArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashMaskArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashMaskArb(*args):
        """
        ('PIX', '*pix')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pix:       any depth; cmapped ok
:param[in]    pixm:      1 bpp clipping mask for hash marks
:param[in]    x,y:       UL corner of %pixm with respect to %pix
:param[in]    spacing:   spacing between lines; must be > 1
:param[in]    width:     thickness of box and hash lines
:param[in]    orient:    orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:   0 to skip drawing box outline
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error
<pre>
Notes:
(1) This is an in-place operation that renders hash lines
through a mask %pixm onto %pix.  The mask origin is
translated by (%x,%y) relative to the origin of %pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashMaskArb(*args)
    
    

    try:
        leptonica.pixRenderHashBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxa(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'op')       

:param[in]    pix:       any depth, not cmapped
:param[in]    boxa:
:param[in]    spacing:   spacing between lines; must be > 1
:param[in]    width:     thickness of box and hash lines
:param[in]    orient:    orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:   0 to skip drawing box outline
:param[in]    op:        one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxa(*args)
    
    

    try:
        leptonica.pixRenderHashBoxaArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderHashBoxaArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashBoxaArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxaArb(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pix:         any depth; cmapped ok
:param[in]    box:
:param[in]    spacing:     spacing between lines; must be > 1
:param[in]    width:       thickness of box and hash lines
:param[in]    orient:      orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:     0 to skip drawing box outline
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxaArb(*args)
    
    

    try:
        leptonica.pixRenderHashBoxaBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRenderHashBoxaBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderHashBoxaBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderHashBoxaBlend(*args):
        """
        ('PIX', '*pix')       
('BOXA', '*boxa')       
('l_int32', 'spacing')       
('l_int32', 'width')       
('l_int32', 'orient')       
('l_int32', 'outline')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_float32', 'fract')       

:param[in]    pix:         32 bpp rgb
:param[in]    boxa:
:param[in]    spacing:     spacing between lines; must be > 1
:param[in]    width:       thickness of box and hash lines
:param[in]    orient:      orientation of lines: L_HORIZONTAL_LINE,
L_POS_SLOPE_LINE, L_VERTICAL_LINE,
L_NEG_SLOPE_LINE
:param[in]    outline:     0 to skip drawing box outline
:param[in]    rval,: gval, bval
:param[in]    fract:       in [0.0 - 1.0]: 1.0 is no transparency;
0.0 is complete transparency (no effect)
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderHashBoxaBlend(*args)
    
    

    try:
        leptonica.pixRenderPolyline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderPolyline.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPolyline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolyline(*args):
        """
        ('PIX', '*pix')       
('PTA', '*ptas')       
('l_int32', 'width')       
('l_int32', 'op')       
('l_int32', 'closeflag')       

:param[in]    pix:         any depth, not cmapped
:param[in]    ptas:
:param[in]    width:       thickness of line
:param[in]    op:          one of L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:param[in]    closeflag:   1 to close the contour; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
This renders a closed contour.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolyline(*args)
    
    

    try:
        leptonica.pixRenderPolylineArb.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_int32]
        leptonica.pixRenderPolylineArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPolylineArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolylineArb(*args):
        """
        ('PIX', '*pix')       
('PTA', '*ptas')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_int32', 'closeflag')       

:param[in]    pix:         any depth; cmapped ok
:param[in]    ptas:
:param[in]    width:       thickness of line
:param[in]    rval,: gval, bval
:param[in]    closeflag:   1 to close the contour; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
This renders a closed contour.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolylineArb(*args)
    
    

    try:
        leptonica.pixRenderPolylineBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderPolylineBlend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPolylineBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolylineBlend(*args):
        """
        ('PIX', '*pix')       
('PTA', '*ptas')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       
('l_float32', 'fract')       
('l_int32', 'closeflag')       
('l_int32', 'removedups')       

:param[in]    pix:          32 bpp rgb
:param[in]    ptas:
:param[in]    width:        thickness of line
:param[in]    rval,: gval, bval
:param[in]    fract:        in [0.0 - 1.0]: 1.0 is no transparency;
0.0 is complete transparency (no effect)
:param[in]    closeflag:    1 to close the contour; 0 otherwise
:param[in]    removedups:   1 to remove; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolylineBlend(*args)
    
    

    try:
        leptonica.pixRenderGridArb.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixRenderGridArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderGridArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderGridArb(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'width')       
('l_uint8', 'rval')       
('l_uint8', 'gval')       
('l_uint8', 'bval')       

:param[in]    pix:        any depth, cmapped ok
:param[in]    nx,: ny     number of rectangles in each direction
:param[in]    width:      thickness of grid lines
:param[in]    rval,: gval, bval
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderGridArb(*args)
    
    

    try:
        leptonica.pixRenderRandomCmapPtaa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderRandomCmapPtaa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderRandomCmapPtaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderRandomCmapPtaa(*args):
        """
        ('PIX', '*pix')       
('PTAA', '*ptaa')       
('l_int32', 'polyflag')       
('l_int32', 'width')       
('l_int32', 'closeflag')       

:param[in]    pix:          1, 2, 4, 8, 16, 32 bpp
:param[in]    ptaa:
:param[in]    polyflag:     1 to interpret each Pta as a polyline;
0 to simply render the Pta as a set of pixels
:param[in]    width:        thickness of line; use only for polyline
:param[in]    closeflag:    1 to close the contour; 0 otherwise;
use only for polyline mode
:returns:  pixd cmapped, 8 bpp or NULL on error

<pre>
Notes:
(1) This is a debugging routine, that displays a set of
pixels, selected by the set of Ptas in a Ptaa,
in a random color in a pix.
(2) If %polyflag == 1, each Pta is considered to be a polyline,
and is rendered using %width and %closeflag.  Each polyline
is rendered in a random color.
(3) If %polyflag == 0, all points in each Pta are rendered in a
random color.  The %width and %closeflag parameters are ignored.
(4) The output pix is 8 bpp and colormapped.  Up to 254
different, randomly selected colors, can be used.
(5) The rendered pixels replace the input pixels.  They will
be clipped silently to the input pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderRandomCmapPtaa(*args)
    
    

    try:
        leptonica.pixRenderPolygon.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRenderPolygon.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderPolygon not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderPolygon(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'width')       
('l_int32', '*pxmin')       
('l_int32', '*pymin')       

:param[in]    ptas:     of vertices, none repeated
:param[in]    width:    of polygon outline
:param[out]   pxmin:    [optional] min x value of input pts
:param[out]   pymin:    [optional] min y value of input pts
:returns:  pix 1 bpp, with outline generated, or NULL on error

<pre>
Notes:
(1) The pix is the minimum size required to contain the origin
and the polygon.  For example, the max x value of the input
points is w - 1, where w is the pix width.
(2) The rendered line is 4-connected, so that an interior or
exterior 8-c.c. flood fill operation works properly.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderPolygon(*args)
    
    

    try:
        leptonica.pixFillPolygon.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFillPolygon.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFillPolygon not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillPolygon(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*pta')       
('l_int32', 'xmin')       
('l_int32', 'ymin')       

:param[in]    pixs:          1 bpp, with 4-connected polygon outline
:param[in]    pta:           vertices of the polygon
:param[in]    xmin,: ymin    min values of vertices of polygon
:returns:  pixd with outline filled, or NULL on error

<pre>
Notes:
(1) This fills the interior of the polygon, returning a
new pix.  It works for both convex and non-convex polygons.
(2) To generate a filled polygon from %pta:
PIX *pixt = pixRenderPolygon(pta, 1, &xmin, &ymin);
PIX *pixd = pixFillPolygon(pixt, pta, xmin, ymin);
pixDestroy(&pixt);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillPolygon(*args)
    
    

    try:
        leptonica.pixRenderContours.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRenderContours.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRenderContours not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRenderContours(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'startval')       
('l_int32', 'incr')       
('l_int32', 'outdepth')       

:param[in]    pixs:        8 or 16 bpp; no colormap
:param[in]    startval:    value of lowest contour; must be in [0 ... maxval]
:param[in]    incr:        increment to next contour; must be > 0
:param[in]    outdepth:    either 1 or depth of pixs
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The output can be either 1 bpp, showing just the contour
lines, or a copy of the input pixs with the contour lines
superposed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRenderContours(*args)
    
    

    try:
        leptonica.fpixAutoRenderContours.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixAutoRenderContours.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixAutoRenderContours not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixAutoRenderContours(*args):
        """
        ('FPIX', '*fpix')       
('l_int32', 'ncontours')       

:param[in]    fpix:
:param[in]    ncontours:   in [2 ... 500]; typically about 50
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) The increment is set to get approximately %ncontours.
(2) The proximity to the target value for contour display
is set to 0.15.
(3) Negative values are rendered in red; positive values as black.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixAutoRenderContours(*args)
    
    

    try:
        leptonica.fpixRenderContours.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.fpixRenderContours.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixRenderContours not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixRenderContours(*args):
        """
        ('FPIX', '*fpixs')       
('l_float32', 'incr')       
('l_float32', 'proxim')       

:param[in]    fpixs:
:param[in]    incr:      increment between contours; must be > 0.0
:param[in]    proxim:    required proximity to target value; default 0.15
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) Values are displayed when val/incr is within +-proxim
to an integer.  The default value is 0.15; smaller values
result in thinner contour lines.
(2) Negative values are rendered in red; positive values as black.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixRenderContours(*args)
    
    

    try:
        leptonica.pixGeneratePtaBoundary.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGeneratePtaBoundary.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGeneratePtaBoundary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGeneratePtaBoundary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'width')       

:param[in]    pixs:     1 bpp
:param[in]    width:    of boundary line
:returns:  pta, or NULL on error

<pre>
Notes:
(1) Similar to ptaGetBoundaryPixels(), except here:
we only get pixels in the foreground
we can have a "line" width greater than 1 pixel.
(2) Once generated, this can be applied to a random 1 bpp image
to add a color boundary as follows:
Pta *pta = pixGeneratePtaBoundary(pixs, width);
Pix *pix1 = pixConvert1To8Cmap(pixs);
pixRenderPtaArb(pix1, pta, rval, gval, bval);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGeneratePtaBoundary(*args)
    




class pix2(object):
    """<pre>

This file has these basic operations:

(1) Get and set: individual pixels, full image, rectangular region,
pad pixels, border pixels, and color components for RGB
(2) Add and remove border pixels
(3) Endian byte swaps
(4) Simple method for byte-processing images (instead of words)

Pixel poking
l_int32     pixGetPixel()
l_int32     pixSetPixel()
l_int32     pixGetRGBPixel()
l_int32     pixSetRGBPixel()
l_int32     pixSetCmapPixel()
l_int32     pixGetRandomPixel()
l_int32     pixClearPixel()
l_int32     pixFlipPixel()
void        setPixelLow()

Find black or white value
l_int32     pixGetBlackOrWhiteVal()

Full image clear/set/set-to-arbitrary-value
l_int32     pixClearAll()
l_int32     pixSetAll()
l_int32     pixSetAllGray()
l_int32     pixSetAllArbitrary()
l_int32     pixSetBlackOrWhite()
l_int32     pixSetComponentArbitrary()

Rectangular region clear/set/set-to-arbitrary-value/blend
l_int32     pixClearInRect()
l_int32     pixSetInRect()
l_int32     pixSetInRectArbitrary()
l_int32     pixBlendInRect()

Set pad bits
l_int32     pixSetPadBits()
l_int32     pixSetPadBitsBand()

Assign border pixels
l_int32     pixSetOrClearBorder()
l_int32     pixSetBorderVal()
l_int32     pixSetBorderRingVal()
l_int32     pixSetMirroredBorder()
PIX        *pixCopyBorder()

Add and remove border
PIX        *pixAddBorder()
PIX        *pixAddBlackOrWhiteBorder()
PIX        *pixAddBorderGeneral()
PIX        *pixRemoveBorder()
PIX        *pixRemoveBorderGeneral()
PIX        *pixRemoveBorderToSize()
PIX        *pixAddMirroredBorder()
PIX        *pixAddRepeatedBorder()
PIX        *pixAddMixedBorder()
PIX        *pixAddContinuedBorder()

Helper functions using alpha
l_int32     pixShiftAndTransferAlpha()
PIX        *pixDisplayLayersRGBA()

Color sample setting and extraction
PIX        *pixCreateRGBImage()
PIX        *pixGetRGBComponent()
l_int32     pixSetRGBComponent()
PIX        *pixGetRGBComponentCmap()
l_int32     pixCopyRGBComponent()
l_int32     composeRGBPixel()
l_int32     composeRGBAPixel()
void        extractRGBValues()
void        extractRGBAValues()
l_int32     extractMinMaxComponent()
l_int32     pixGetRGBLine()

Raster line pixel setter
l_int32     setLineDataVal()

Conversion between big and little endians
PIX        *pixEndianByteSwapNew()
l_int32     pixEndianByteSwap()
l_int32     lineEndianByteSwap()
PIX        *pixEndianTwoByteSwapNew()
l_int32     pixEndianTwoByteSwap()

Extract raster data as binary string
l_int32     pixGetRasterData()

Test alpha component opaqueness
l_int32     pixAlphaIsOpaque

Setup helpers for 8 bpp byte processing
l_uint8   **pixSetupByteProcessing()
l_int32     pixCleanupByteProcessing()

Setting parameters for antialias masking with alpha transforms
void        l_setAlphaMaskBorder()
</pre>




"""
    
    try:
        leptonica.pixGetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', '*pval')       

:param[in]    pix:
:param[in]    x,y:    pixel coords
:param[out]   pval:   pixel value
:returns:  0 if OK; 1 or 2 on error

<pre>
Notes:
(1) This returns the value in the data array.  If the pix is
colormapped, it returns the colormap index, not the rgb value.
(2) Because of the function overhead and the parameter checking,
this is much slower than using the GET_DATA_*() macros directly.
Speed on a 1 Mpixel RGB image, using a 3 GHz machine:
pixGet/pixSet: ~25 Mpix/sec
GET_DATA/SET_DATA: ~350 MPix/sec
If speed is important and you're doing random access into
the pix, use pixGetLinePtrs() and the array access macros.
(3) If the point is outside the image, this returns an error (2),
with 0 in %pval.  To avoid spamming output, it fails silently.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPixel(*args)
    
    

    try:
        leptonica.pixSetPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixSetPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', 'val')       

:param[in]    pix:
:param[in]    x,y:   pixel coords
:param[in]    val:   value to be inserted
:returns:  0 if OK; 1 or 2 on error

<pre>
Notes:
(1) Warning: the input value is not checked for overflow with respect
the the depth of %pix, and the sign bit (if any) is ignored.
For d == 1, %val > 0 sets the bit on.
For d == 2, 4, 8 and 16, %val is masked to the maximum allowable
pixel value, and any (invalid) higher order bits are discarded.
(2) See pixGetPixel() for information on performance.
(3) If the point is outside the image, this returns an error (2),
with 0 in %pval.  To avoid spamming output, it fails silently.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPixel(*args)
    
    

    try:
        leptonica.pixGetRGBPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRGBPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRGBPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    pix:    32 bpp rgb, not colormapped
:param[in]    x,y:    pixel coords
:param[out]   prval:  [optional] red component
:param[out]   pgval:  [optional] green component
:param[out]   pbval:  [optional] blue component
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBPixel(*args)
    
    

    try:
        leptonica.pixSetRGBPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetRGBPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetRGBPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetRGBPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pix:    32 bpp rgb
:param[in]    x,y:    pixel coords
:param[in]    rval:   red component
:param[in]    gval:   green component
:param[in]    bval:   blue component
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
and to avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetRGBPixel(*args)
    
    

    try:
        leptonica.pixSetCmapPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetCmapPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetCmapPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetCmapPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       

:param[in]    pix:    2, 4 or 8 bpp, colormapped
:param[in]    x,y:    pixel coords
:param[in]    rval:   red component
:param[in]    gval:   green component
:param[in]    bval:   blue component
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
and to avoid spamming output, it fails silently.
(2) - If the color already exists, use it.
- If the color does not exist in the colormap, it is added
if possible.
- If there is not room in the colormap for the new color:
if d < 8, return 2 with a warning.
if d == 8, find and use the nearest color.
(3) Note that this operation scales with the number of colors
in the colormap, and therefore can be very expensive if an
attempt is made to set many pixels.  (In that case, it should
be implemented with a map:rgb-->index for efficiency.)
This is best used with very small images.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetCmapPixel(*args)
    
    

    try:
        leptonica.pixGetRandomPixel.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRandomPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRandomPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRandomPixel(*args):
        """
        ('PIX', '*pix')       
('l_uint32', '*pval')       
('l_int32', '*px')       
('l_int32', '*py')       

:param[in]    pix:    any depth; can be colormapped
:param[out]   pval:   [optional] pixel value
:param[out]   px:     [optional] x coordinate chosen; can be null
:param[out]   py:     [optional] y coordinate chosen; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If the pix is colormapped, it returns the rgb value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRandomPixel(*args)
    
    

    try:
        leptonica.pixClearPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixClearPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixClearPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClearPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pix:   any depth; warning if colormapped
:param[in]    x,y:   pixel coords
:returns:  0 if OK; 1 or 2 on error.

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.pixClearPixel(*args)
    
    

    try:
        leptonica.pixFlipPixel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFlipPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFlipPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFlipPixel(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pix:   any depth, warning if colormapped
:param[in]    x,y:   pixel coords
:returns:  0 if OK; 1 or 2 on error

Notes:
(1) If the point is outside the image, this returns an error (2),
with 0 in %pval.  To avoid spamming output, it fails silently.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFlipPixel(*args)
    
    

    try:
        leptonica.setPixelLow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.setPixelLow.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function setPixelLow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def setPixelLow(*args):
        """
        ('l_uint32', '*line')       
('l_int32', 'x')       
('l_int32', 'depth')       
('l_uint32', 'val')       

:param[in]    line:    ptr to beginning of line,
:param[in]    x:       pixel location in line
:param[in]    depth:   bpp
:param[in]    val:     to be inserted
:returns:  void

<pre>
Notes:
(1) Caution: input variables are not checked!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.setPixelLow(*args)
    
    

    try:
        leptonica.pixGetBlackOrWhiteVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetBlackOrWhiteVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBlackOrWhiteVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBlackOrWhiteVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'op')       
('l_uint32', '*pval')       

:param[in]    pixs:    all depths; cmap ok
:param[in]    op:      L_GET_BLACK_VAL, L_GET_WHITE_VAL
:param[out]   pval:    pixel value
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Side effect.  For a colormapped image, if the requested
color is not present and there is room to add it in the cmap,
it is added and the new index is returned.  If there is no room,
the index of the closest color in intensity is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBlackOrWhiteVal(*args)
    
    

    try:
        leptonica.pixClearAll.argtypes = [ctypes.c_void_p]
        leptonica.pixClearAll.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixClearAll not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClearAll(*args):
        """
        ('PIX', '*pix')       

:param[in]    pix:    all depths; use cmapped with caution
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Clears all data to 0.  For 1 bpp, this is white; for grayscale
or color, this is black.
(2) Caution: for colormapped pix, this sets the color to the first
one in the colormap.  Be sure that this is the intended color!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClearAll(*args)
    
    

    try:
        leptonica.pixSetAll.argtypes = [ctypes.c_void_p]
        leptonica.pixSetAll.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetAll not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAll(*args):
        """
        ('PIX', '*pix')       

:param[in]    pix:     all depths; use cmapped with caution
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Sets all data to 1.  For 1 bpp, this is black; for grayscale
or color, this is white.
(2) Caution: for colormapped pix, this sets the pixel value to the
maximum value supported by the colormap: 2^d - 1.  However, this
color may not be defined, because the colormap may not be full.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAll(*args)
    
    

    try:
        leptonica.pixSetAllGray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetAllGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetAllGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAllGray(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'grayval')       

:param[in]    pix:       all depths, cmap ok
:param[in]    grayval:   in range 0 ... 255
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) N.B.  For all images, %grayval == 0 represents black and
%grayval == 255 represents white.
(2) For depth < 8, we do our best to approximate the gray level.
For 1 bpp images, any %grayval < 128 is black; >= 128 is white.
For 32 bpp images, each r,g,b component is set to %grayval,
and the alpha component is preserved.
(3) If pix is colormapped, it adds the gray value, replicated in
all components, to the colormap if it's not there and there
is room.  If the colormap is full, it finds the closest color in
L2 distance of components.  This index is written to all pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAllGray(*args)
    
    

    try:
        leptonica.pixSetAllArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixSetAllArbitrary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetAllArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAllArbitrary(*args):
        """
        ('PIX', '*pix')       
('l_uint32', 'val')       

:param[in]    pix:    all depths; use cmapped with caution
:param[in]    val:    value to set all pixels
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Caution 1!  For colormapped pix, %val is used as an index
into a colormap.  Be sure that index refers to the intended color.
If the color is not in the colormap, you should first add it
and then call this function.
(2) Caution 2!  For 32 bpp pix, the interpretation of the LSB
of %val depends on whether spp == 3 (RGB) or spp == 4 (RGBA).
For RGB, the LSB is ignored in image transformations.
For RGBA, the LSB is interpreted as the alpha (transparency)
component; full transparency has alpha == 0x0, whereas
full opacity has alpha = 0xff.  An RGBA image with full
opacity behaves like an RGB image.
(3) As an example of (2), suppose you want to initialize a 32 bpp
pix with partial opacity, say 0xee337788.  If the pix is 3 spp,
the 0x88 alpha component will be ignored and may be changed
in subsequent processing.  However, if the pix is 4 spp, the
alpha component will be retained and used. The function
pixCreate(w, h, 32) makes an RGB image by default, and
pixSetSpp(pix, 4) can be used to promote an RGB image to RGBA.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAllArbitrary(*args)
    
    

    try:
        leptonica.pixSetBlackOrWhite.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetBlackOrWhite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetBlackOrWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBlackOrWhite(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'op')       

:param[in]    pixs:    all depths; cmap ok
:param[in]    op:      L_SET_BLACK, L_SET_WHITE
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Function for setting all pixels in an image to either black
or white.
(2) If pixs is colormapped, it adds black or white to the
colormap if it's not there and there is room.  If the colormap
is full, it finds the closest color in intensity.
This index is written to all pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBlackOrWhite(*args)
    
    

    try:
        leptonica.pixSetComponentArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetComponentArbitrary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetComponentArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetComponentArbitrary(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'comp')       
('l_int32', 'val')       

:param[in]    pix:    32 bpp
:param[in]    comp:   COLOR_RED, COLOR_GREEN, COLOR_BLUE, L_ALPHA_CHANNEL
:param[in]    val:    value to set this component
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) For example, this can be used to set the alpha component to opaque:
pixSetComponentArbitrary(pix, L_ALPHA_CHANNEL, 255)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetComponentArbitrary(*args)
    
    

    try:
        leptonica.pixClearInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClearInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixClearInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClearInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]    pix:   all depths; can be cmapped
:param[in]    box:   in which all pixels will be cleared
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Clears all data in rect to 0.  For 1 bpp, this is white;
for grayscale or color, this is black.
(2) Caution: for colormapped pix, this sets the color to the first
one in the colormap.  Be sure that this is the intended color!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClearInRect(*args)
    
    

    try:
        leptonica.pixSetInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]    pix:   all depths, can be cmapped
:param[in]    box:   in which all pixels will be set
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Sets all data in rect to 1.  For 1 bpp, this is black;
for grayscale or color, this is white.
(2) Caution: for colormapped pix, this sets the pixel value to the
maximum value supported by the colormap: 2^d - 1.  However, this
color may not be defined, because the colormap may not be full.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetInRect(*args)
    
    

    try:
        leptonica.pixSetInRectArbitrary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixSetInRectArbitrary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetInRectArbitrary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetInRectArbitrary(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_uint32', 'val')       

:param[in]    pix:   all depths; can be cmapped
:param[in]    box:   in which all pixels will be set to val
:param[in]    val:   value to set all pixels
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) For colormapped pix, be sure the value is the intended
one in the colormap.
(2) Caution: for colormapped pix, this sets each pixel in the
rect to the color at the index equal to val.  Be sure that
this index exists in the colormap and that it is the intended one!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetInRectArbitrary(*args)
    
    

    try:
        leptonica.pixBlendInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_float]
        leptonica.pixBlendInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', 'val')       
('l_float32', 'fract')       

:param[in]    pixs:   32 bpp rgb
:param[in]    box:    [optional] in which all pixels will be blended
:param[in]    val:    blend value; 0xrrggbb00
:param[in]    fract:  fraction of color to be blended with each pixel in pixs
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place function.  It blends the input color %val
with the pixels in pixs in the specified rectangle.
If no rectangle is specified, it blends over the entire image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendInRect(*args)
    
    

    try:
        leptonica.pixSetPadBits.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetPadBits.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetPadBits not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPadBits(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'val')       

:param[in]    pix:   1, 2, 4, 8, 16, 32 bpp
:param[in]    val:   0 or 1
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The pad bits are the bits that expand each scanline to a
multiple of 32 bits.  They are usually not used in
image processing operations.  When boundary conditions
are important, as in seedfill, they must be set properly.
(2) This sets the value of the pad bits (if any) in the last
32-bit word in each scanline.
(3) For 32 bpp pix, there are no pad bits, so this is a no-op.
(4) When writing formatted output, such as tiff, png or jpeg,
the pad bits have no effect on the raster image that is
generated by reading back from the file.  However, in some
cases, the compressed file itself will depend on the pad
bits.  This is seen, for example, in Windows with 2 and 4 bpp
tiff-compressed images that have pad bits on each scanline.
It is sometimes convenient to use a golden file with a
byte-by-byte check to verify invariance.  Consequently,
and because setting the pad bits is cheap, the pad bits are
set to 0 before writing these compressed files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPadBits(*args)
    
    

    try:
        leptonica.pixSetPadBitsBand.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetPadBitsBand.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetPadBitsBand not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPadBitsBand(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'by')       
('l_int32', 'bh')       
('l_int32', 'val')       

:param[in]    pix:   1, 2, 4, 8, 16, 32 bpp
:param[in]    by:    starting y value of band
:param[in]    bh:    height of band
:param[in]    val:   0 or 1
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The pad bits are the bits that expand each scanline to a
multiple of 32 bits.  They are usually not used in
image processing operations.  When boundary conditions
are important, as in seedfill, they must be set properly.
(2) This sets the value of the pad bits (if any) in the last
32-bit word in each scanline, within the specified
band of raster lines.
(3) For 32 bpp pix, there are no pad bits, so this is a no-op.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPadBitsBand(*args)
    
    

    try:
        leptonica.pixSetOrClearBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetOrClearBorder.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetOrClearBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetOrClearBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_int32', 'op')       

:param[in]    pixs:   all depths
:param[in]    left,:  right, top, bot amount to set or clear
:param[in]    op:     operation PIX_SET or PIX_CLR
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The border region is defined to be the region in the
image within a specific distance of each edge.  Here, we
allow the pixels within a specified distance of each
edge to be set independently.  This either sets or
clears all pixels in the border region.
(2) For binary images, use PIX_SET for black and PIX_CLR for white.
(3) For grayscale or color images, use PIX_SET for white
and PIX_CLR for black.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetOrClearBorder(*args)
    
    

    try:
        leptonica.pixSetBorderVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixSetBorderVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetBorderVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBorderVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_uint32', 'val')       

:param[in]    pixs:                   8, 16 or 32 bpp
:param[in]    left,: right, top, bot  amount to set
:param[in]    val:                    value to set at each border pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The border region is defined to be the region in the
image within a specific distance of each edge.  Here, we
allow the pixels within a specified distance of each
edge to be set independently.  This sets the pixels
in the border region to the given input value.
(2) For efficiency, use pixSetOrClearBorder() if
you're setting the border to either black or white.
(3) If d != 32, the input value should be masked off
to the appropriate number of least significant bits.
(4) The code is easily generalized for 2 or 4 bpp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBorderVal(*args)
    
    

    try:
        leptonica.pixSetBorderRingVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixSetBorderRingVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetBorderRingVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBorderRingVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dist')       
('l_uint32', 'val')       

:param[in]    pixs:    any depth; cmap OK
:param[in]    dist:    distance from outside; must be > 0; first ring is 1
:param[in]    val:     value to set at each border pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The rings are single-pixel-wide rectangular sets of
pixels at a given distance from the edge of the pix.
This sets all pixels in a given ring to a value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBorderRingVal(*args)
    
    

    try:
        leptonica.pixSetMirroredBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetMirroredBorder.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetMirroredBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMirroredBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels to set
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This applies what is effectively mirror boundary conditions
to a border region in the image.  It is in-place.
(2) This is useful for setting pixels near the border to a
value representative of the near pixels to the interior.
(3) The general pixRasterop() is used for an in-place operation here
because there is no overlap between the src and dest rectangles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMirroredBorder(*args)
    
    

    try:
        leptonica.pixCopyBorder.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCopyBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCopyBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyBorder(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixd:                   all depths; colormap ok; can be NULL
:param[in]    pixs:                   same depth and size as pixd
:param[in]    left,: right, top, bot  number of pixels to copy
:returns:  pixd, or NULL on error if pixd is not defined

<pre>
Notes:
(1) pixd can be null, but otherwise it must be the same size
and depth as pixs.  Always returns pixd.
(2) This is useful in situations where by setting a few border
pixels we can avoid having to copy all pixels in pixs into
pixd as an initialization step for some operation.
Nevertheless, for safety, if making a new pixd, all the
non-border pixels are initialized to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyBorder(*args)
    
    

    try:
        leptonica.pixAddBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixAddBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'npix')       
('l_uint32', 'val')       

:param[in]    pixs:   all depths; colormap ok
:param[in]    npix:   number of pixels to be added to each side
:param[in]    val:    value of added border pixels
:returns:  pixd with the added exterior pixels, or NULL on error

<pre>
Notes:
(1) See pixGetBlackOrWhiteVal() for values of black and white pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddBorder(*args)
    
    

    try:
        leptonica.pixAddBlackOrWhiteBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddBlackOrWhiteBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddBlackOrWhiteBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddBlackOrWhiteBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_int32', 'op')       

:param[in]    pixs: all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels added
:param[in]    op: L_GET_BLACK_VAL, L_GET_WHITE_VAL
:returns:  pixd with the added exterior pixels, or NULL on error

<pre>
Notes:
(1) See pixGetBlackOrWhiteVal() for possible side effect (adding
a color to a colormap).
(2) The only complication is that pixs may have a colormap.
There are two ways to add the black or white border:
(a) As done here (simplest, most efficient)
(b) l_int32 ws, hs, d;
pixGetDimensions(pixs, &ws, &hs, &d);
Pix *pixd = pixCreate(ws + left + right, hs + top + bot, d);
PixColormap *cmap = pixGetColormap(pixs);
if (cmap != NULL)
pixSetColormap(pixd, pixcmapCopy(cmap));
pixSetBlackOrWhite(pixd, L_SET_WHITE);  // uses cmap
pixRasterop(pixd, left, top, ws, hs, PIX_SET, pixs, 0, 0);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddBlackOrWhiteBorder(*args)
    
    

    try:
        leptonica.pixAddBorderGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixAddBorderGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddBorderGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddBorderGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_uint32', 'val')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels added
:param[in]    val:                    value of added border pixels
:returns:  pixd with the added exterior pixels, or NULL on error

<pre>
Notes:
(1) For binary images:
white:  val = 0
black:  val = 1
For grayscale images:
white:  val = 2 ** d - 1
black:  val = 0
For rgb color images:
white:  val = 0xffffff00
black:  val = 0
For colormapped images, set val to the appropriate colormap index.
(2) If the added border is either black or white, you can use
pixAddBlackOrWhiteBorder()
The black and white values for all images can be found with
pixGetBlackOrWhiteVal()
which, if pixs is cmapped, may add an entry to the colormap.
Alternatively, if pixs has a colormap, you can find the index
of the pixel whose intensity is closest to white or black:
white: pixcmapGetRankIntensity(cmap, 1.0, &index);
black: pixcmapGetRankIntensity(cmap, 0.0, &index);
and use that for val.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddBorderGeneral(*args)
    
    

    try:
        leptonica.pixRemoveBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRemoveBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'npix')       

:param[in]    pixs:   all depths; colormap ok
:param[in]    npix:   number to be removed from each of the 4 sides
:returns:  pixd with pixels removed around border, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorder(*args)
    
    

    try:
        leptonica.pixRemoveBorderGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveBorderGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveBorderGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorderGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels removed
:returns:  pixd with pixels removed around border, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorderGeneral(*args)
    
    

    try:
        leptonica.pixRemoveBorderToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveBorderToSize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveBorderToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorderToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    pixs:   all depths; colormap ok
:param[in]    wd:     target width; use 0 if only removing from height
:param[in]    hd:     target height; use 0 if only removing from width
:returns:  pixd with pixels removed around border, or NULL on error

<pre>
Notes:
(1) Removes pixels as evenly as possible from the sides of the
image, leaving the central part.
(2) Returns clone if no pixels requested removed, or the target
sizes are larger than the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorderToSize(*args)
    
    

    try:
        leptonica.pixAddMirroredBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddMirroredBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddMirroredBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddMirroredBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels added
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This applies what is effectively mirror boundary conditions.
For the added border pixels in pixd, the pixels in pixs
near the border are mirror-copied into the border region.
(2) This is useful for avoiding special operations near
boundaries when doing image processing operations
such as rank filters and convolution.  In use, one first
adds mirrored pixels to each side of the image.  The number
of pixels added on each side is half the filter dimension.
Then the image processing operations proceed over a
region equal to the size of the original image, and
write directly into a dest pix of the same size as pixs.
(3) The general pixRasterop() is used for an in-place operation here
because there is no overlap between the src and dest rectangles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddMirroredBorder(*args)
    
    

    try:
        leptonica.pixAddRepeatedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddRepeatedBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddRepeatedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddRepeatedBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels added
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This applies a repeated border, as if the central part of
the image is tiled over the plane.  So, for example, the
pixels in the left border come from the right side of the image.
(2) The general pixRasterop() is used for an in-place operation here
because there is no overlap between the src and dest rectangles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddRepeatedBorder(*args)
    
    

    try:
        leptonica.pixAddMixedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddMixedBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddMixedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddMixedBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  number of pixels added
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This applies mirrored boundary conditions horizontally
and repeated b.c. vertically.
(2) It is specifically used for avoiding special operations
near boundaries when convolving a hue-saturation histogram
with a given window size.  The repeated b.c. are used
vertically for hue, and the mirrored b.c. are used
horizontally for saturation.  The number of pixels added
on each side is approximately (but not quite) half the
filter dimension.  The image processing operations can
then proceed over a region equal to the size of the original
image, and write directly into a dest pix of the same
size as pixs.
(3) The general pixRasterop() can be used for an in-place
operation here because there is no overlap between the
src and dest rectangles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddMixedBorder(*args)
    
    

    try:
        leptonica.pixAddContinuedBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAddContinuedBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddContinuedBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddContinuedBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       

:param[in]    pixs:                   all depths; colormap ok
:param[in]    left,: right, top, bot  pixels on each side to be added
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This adds pixels on each side whose values are equal to
the value on the closest boundary pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddContinuedBorder(*args)
    
    

    try:
        leptonica.pixShiftAndTransferAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixShiftAndTransferAlpha.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixShiftAndTransferAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixShiftAndTransferAlpha(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'shiftx')       
('l_float32', 'shifty')       

:param[in]    pixd:            32 bpp
:param[in]    pixs:            32 bpp
:param[in]    shiftx,: shifty
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixShiftAndTransferAlpha(*args)
    
    

    try:
        leptonica.pixDisplayLayersRGBA.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixDisplayLayersRGBA.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayLayersRGBA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayLayersRGBA(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'val')       
('l_int32', 'maxw')       

:param[in]    pixs:   cmap or 32 bpp rgba
:param[in]    val:    32 bit unsigned color to use as background
:param[in]    maxw:   max output image width; 0 for no scaling
:returns:  pixd showing various image views, or NULL on error

<pre>
Notes:
(1) Use %val == 0xffffff00 for white background.
(2) Three views are given:
~ the image with a fully opaque alpha
~ the alpha layer
~ the image as it would appear with a white background.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayLayersRGBA(*args)
    
    

    try:
        leptonica.pixCreateRGBImage.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCreateRGBImage.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateRGBImage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateRGBImage(*args):
        """
        ('PIX', '*pixr')       
('PIX', '*pixg')       
('PIX', '*pixb')       

:param[in]   pixr:   8 bpp red pix
:param[in]   pixg:   8 bpp green pix
:param[in]   pixb:   8 bpp blue pix
:returns:  32 bpp pix, interleaved with 4 samples/pixel,
or NULL on error

<pre>
Notes:
(1) the 4th byte, sometimes called the "alpha channel",
and which is often used for blending between different
images, is left with 0 value.
(2) see Note (4) in pix.h for details on storage of
8-bit samples within each 32-bit word.
(3) This implementation, setting the r, g and b components
sequentially, is much faster than setting them in parallel
by constructing an RGB dest pixel and writing it to dest.
The reason is there are many more cache misses when reading
from 3 input images simultaneously.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateRGBImage(*args)
    
    

    try:
        leptonica.pixGetRGBComponent.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetRGBComponent.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRGBComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBComponent(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'comp')       

:param[in]   pixs:   32 bpp, or colormapped
:param[in]   comp:   one of {COLOR_RED, COLOR_GREEN, COLOR_BLUE,
L_ALPHA_CHANNEL}
:returns:  pixd the selected 8 bpp component image of the
input 32 bpp image or NULL on error

<pre>
Notes:
(1) Three calls to this function generate the r, g and b 8 bpp
component images.  This is much faster than generating the
three images in parallel, by extracting a src pixel and setting
the pixels of each component image from it.  The reason is
there are many more cache misses when writing to three
output images simultaneously.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBComponent(*args)
    
    

    try:
        leptonica.pixSetRGBComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetRGBComponent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetRGBComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetRGBComponent(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'comp')       

:param[in]   pixd:   32 bpp
:param[in]   pixs:   8 bpp
:param[in]   comp:   one of the set: {COLOR_RED, COLOR_GREEN,
COLOR_BLUE, L_ALPHA_CHANNEL}
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This places the 8 bpp pixel in pixs into the
specified component (properly interleaved) in pixd,
(2) The two images are registered to the UL corner; the sizes
need not be the same, but a warning is issued if they differ.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetRGBComponent(*args)
    
    

    try:
        leptonica.pixGetRGBComponentCmap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetRGBComponentCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRGBComponentCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBComponentCmap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'comp')       

:param[in]   pixs:   colormapped
:param[in]   comp:   one of the set: {COLOR_RED, COLOR_GREEN, COLOR_BLUE}
:returns:  pixd  the selected 8 bpp component image of the
input cmapped image, or NULL on error

<pre>
Notes:
(1) In leptonica, we do not support alpha in colormaps.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBComponentCmap(*args)
    
    

    try:
        leptonica.pixCopyRGBComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCopyRGBComponent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCopyRGBComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyRGBComponent(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'comp')       

:param[in]   pixd:   32 bpp
:param[in]   pixs:   32 bpp
:param[in]   comp:   one of the set: {COLOR_RED, COLOR_GREEN,
COLOR_BLUE, L_ALPHA_CHANNEL}
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The two images are registered to the UL corner.  The sizes
are usually the same, and a warning is issued if they differ.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyRGBComponent(*args)
    
    

    try:
        leptonica.composeRGBPixel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.composeRGBPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function composeRGBPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def composeRGBPixel(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_uint32', '*ppixel')       

:param[in]    rval,: gval, bval
:param[out]   ppixel:             32-bit pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) All channels are 8 bits: the input values must be between
0 and 255.  For speed, this is not enforced by masking
with 0xff before shifting.
(2) A slower implementation uses macros:
SET_DATA_BYTE(ppixel, COLOR_RED, rval);
SET_DATA_BYTE(ppixel, COLOR_GREEN, gval);
SET_DATA_BYTE(ppixel, COLOR_BLUE, bval);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.composeRGBPixel(*args)
    
    

    try:
        leptonica.composeRGBAPixel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.composeRGBAPixel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function composeRGBAPixel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def composeRGBAPixel(*args):
        """
        ('l_int32', 'rval')       
('l_int32', 'gval')       
('l_int32', 'bval')       
('l_int32', 'aval')       
('l_uint32', '*ppixel')       

:param[in]    rval,: gval, bval, aval
:param[out]   ppixel:                  32-bit pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) All channels are 8 bits: the input values must be between
0 and 255.  For speed, this is not enforced by masking
with 0xff before shifting.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.composeRGBAPixel(*args)
    
    

    try:
        leptonica.extractRGBValues.argtypes = [ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.extractRGBValues.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function extractRGBValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractRGBValues(*args):
        """
        ('l_uint32', 'pixel')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       

:param[in]    pixel:   32 bit
:param[out]   prval:   [optional] red component
:param[out]   pgval:   [optional] green component
:param[out]   pbval:   [optional] blue component
:returns:  void

<pre>
Notes:
(1) A slower implementation uses macros:
prval = GET_DATA_BYTE(&pixel, COLOR_RED);
pgval = GET_DATA_BYTE(&pixel, COLOR_GREEN);
pbval = GET_DATA_BYTE(&pixel, COLOR_BLUE);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.extractRGBValues(*args)
    
    

    try:
        leptonica.extractRGBAValues.argtypes = [ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.extractRGBAValues.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function extractRGBAValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractRGBAValues(*args):
        """
        ('l_uint32', 'pixel')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
('l_int32', '*paval')       

:param[in]    pixel:   32 bit
:param[out]   prval:   [optional] red component
:param[out]   pgval:   [optional] green component
:param[out]   pbval:   [optional] blue component
:param[out]   paval:   [optional] alpha component
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.extractRGBAValues(*args)
    
    

    try:
        leptonica.extractMinMaxComponent.argtypes = [ctypes.c_uint32, ctypes.c_int32]
        leptonica.extractMinMaxComponent.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function extractMinMaxComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractMinMaxComponent(*args):
        """
        ('l_uint32', 'pixel')       
('l_int32', 'type')       

:param[in]   pixel:   32 bpp RGB
:param[in]   type:    L_CHOOSE_MIN or L_CHOOSE_MAX
:returns:  component in range [0 ... 255], or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.extractMinMaxComponent(*args)
    
    

    try:
        leptonica.pixGetRGBLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRGBLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRGBLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRGBLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'row')       
('l_uint8', '*bufr')       
('l_uint8', '*bufg')       
('l_uint8', '*bufb')       

:param[in]   pixs:   32 bpp
:param[in]   row:
:param[in]   bufr:   array of red samples; size w bytes
:param[in]   bufg:   array of green samples; size w bytes
:param[in]   bufb:   array of blue samples; size w bytes
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This puts rgb components from the input line in pixs
into the given buffers.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRGBLine(*args)
    
    

    try:
        leptonica.setLineDataVal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.setLineDataVal.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function setLineDataVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def setLineDataVal(*args):
        """
        ('l_uint32', '*line')       
('l_int32', 'j')       
('l_int32', 'd')       
('l_uint32', 'val')       

:param[in]    line:    ptr to first word in raster line data
:param[in]    j:       index of pixels into the raster line
:param[in]    d:       depth of the pixel
:param[in]    val:     pixel value to be set
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a convenience function to set a pixel value in a
raster line where the depth of the image can have different
values (1, 2, 4, 8, 16 or 32).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.setLineDataVal(*args)
    
    

    try:
        leptonica.pixEndianByteSwapNew.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianByteSwapNew.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixEndianByteSwapNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianByteSwapNew(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is used to convert the data in a pix to a
serialized byte buffer in raster order, and, for RGB,
in order RGBA.  This requires flipping bytes within
each 32-bit word for little-endian platforms, because the
words have a MSB-to-the-left rule, whereas byte raster-order
requires the left-most byte in each word to be byte 0.
For big-endians, no swap is necessary, so this returns a clone.
(2) Unlike pixEndianByteSwap(), which swaps the bytes in-place,
this returns a new pix (or a clone).  We provide this
because often when serialization is done, the source
pix needs to be restored to canonical little-endian order,
and this requires a second byte swap.  In such a situation,
it is twice as fast to make a new pix in big-endian order,
use it, and destroy it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianByteSwapNew(*args)
    
    

    try:
        leptonica.pixEndianByteSwap.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianByteSwap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianByteSwap(*args):
        """
        ('PIX', '*pixs')       

:param[in]   pixs:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is used on little-endian platforms to swap
the bytes within a word; bytes 0 and 3 are swapped,
and bytes 1 and 2 are swapped.
(2) This is required for little-endians in situations
where we convert from a serialized byte order that is
in raster order, as one typically has in file formats,
to one with MSB-to-the-left in each 32-bit word, or v.v.
See pix.h for a description of the canonical format
(MSB-to-the left) that is used for both little-endian
and big-endian platforms.   For big-endians, the
MSB-to-the-left word order has the bytes in raster
order when serialized, so no byte flipping is required.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianByteSwap(*args)
    
    

    try:
        leptonica.lineEndianByteSwap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.lineEndianByteSwap.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lineEndianByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lineEndianByteSwap(*args):
        """
        ('l_uint32', '*datad')       
('l_uint32', '*datas')       
('l_int32', 'wpl')       

:param[in]  datad:   dest byte array data, reordered on little-endians
:param[in]  datas:   a src line of pix data)
:param[in]  wpl:     number of 32 bit words in the line
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is used on little-endian platforms to swap
the bytes within each word in the line of image data.
Bytes 0 <==> 3 and 1 <==> 2 are swapped in the dest
byte array data8d, relative to the pix data in datas.
(2) The bytes represent 8 bit pixel values.  They are swapped
for little endians so that when the dest array datad
is addressed by bytes, the pixels are chosen sequentially
from left to right in the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lineEndianByteSwap(*args)
    
    

    try:
        leptonica.pixEndianTwoByteSwapNew.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianTwoByteSwapNew.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixEndianTwoByteSwapNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianTwoByteSwapNew(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is used on little-endian platforms to swap the
2-byte entities within a 32-bit word.
(2) This is equivalent to a full byte swap, as performed
by pixEndianByteSwap(), followed by byte swaps in
each of the 16-bit entities separately.
(3) Unlike pixEndianTwoByteSwap(), which swaps the shorts in-place,
this returns a new pix (or a clone).  We provide this
to avoid having to swap twice in situations where the input
pix must be restored to canonical little-endian order.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianTwoByteSwapNew(*args)
    
    

    try:
        leptonica.pixEndianTwoByteSwap.argtypes = [ctypes.c_void_p]
        leptonica.pixEndianTwoByteSwap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixEndianTwoByteSwap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEndianTwoByteSwap(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is used on little-endian platforms to swap the
2-byte entities within a 32-bit word.
(2) This is equivalent to a full byte swap, as performed
by pixEndianByteSwap(), followed by byte swaps in
each of the 16-bit entities separately.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEndianTwoByteSwap(*args)
    
    

    try:
        leptonica.pixGetRasterData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRasterData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRasterData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRasterData(*args):
        """
        ('PIX', '*pixs')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pixs:     1, 8, 32 bpp
:param[out]   pdata:    raster data in memory
:param[out]   pnbytes:  number of bytes in data string
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns the raster data as a byte string, padded to the
byte.  For 1 bpp, the first pixel is the MSbit in the first byte.
For rgb, the bytes are in (rgb) order.  This is the format
required for flate encoding of pixels in a PostScript file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRasterData(*args)
    
    

    try:
        leptonica.pixAlphaIsOpaque.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAlphaIsOpaque.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAlphaIsOpaque not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAlphaIsOpaque(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*popaque')       

:param[in]    pix:       32 bpp, spp == 4
:param[out]   popaque:   1 if spp == 4 and all alpha component
values are 255 (opaque); 0 otherwise
:returns:  0 if OK, 1 on error
Notes:
1) On error, opaque is returned as 0 (FALSE).


        """
        args = _convert_params(*args)
        
        return leptonica.pixAlphaIsOpaque(*args)
    
    

    try:
        leptonica.pixSetupByteProcessing.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetupByteProcessing.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_ubyte))
    except AttributeError:
        sys.stderr.write("Warning - function pixSetupByteProcessing not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetupByteProcessing(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    pix:   8 bpp, no colormap
:param[out]   pw:    [optional] width
:param[out]   ph:    [optional] height
:returns:  line ptr array, or NULL on error

<pre>
Notes:
(1) This is a simple helper for processing 8 bpp images with
direct byte access.  It can swap byte order within each word.
(2) After processing, you must call pixCleanupByteProcessing(),
which frees the lineptr array and restores byte order.
(3) Usage:
l_uint8 **lineptrs = pixSetupByteProcessing(pix, &w, &h);
for (i = 0; i < h; i++) {
l_uint8 *line = lineptrs[i];
for (j = 0; j < w; j++) {
val = line[j];
...
}
}
pixCleanupByteProcessing(pix, lineptrs);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetupByteProcessing(*args)
    
    

    try:
        leptonica.pixCleanupByteProcessing.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCleanupByteProcessing.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCleanupByteProcessing not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCleanupByteProcessing(*args):
        """
        ('PIX', '*pix')       
('l_uint8', '**lineptrs')       

:param[in]   pix:        8 bpp, no colormap
:param[in]   lineptrs:   ptrs to the beginning of each raster line of data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This must be called after processing that was initiated
by pixSetupByteProcessing() has finished.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCleanupByteProcessing(*args)
    
    

    try:
        leptonica.l_setAlphaMaskBorder.argtypes = [ctypes.c_float, ctypes.c_float]
        leptonica.l_setAlphaMaskBorder.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setAlphaMaskBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setAlphaMaskBorder(*args):
        """
        ('l_float32', 'val1')       
('l_float32', 'val2')       

:param[in]    val1,: val2     in [0.0 ... 1.0]
:returns:  void

<pre>
Notes:
(1) This sets the opacity values used to generate the two outer
boundary rings in the alpha mask associated with geometric
transforms such as pixRotateWithAlpha().
(2) The default values are val1 = 0.0 (completely transparent
in the outermost ring) and val2 = 0.5 (half transparent
in the second ring).  When the image is blended, this
completely removes the outer ring (shrinking the image by
2 in each direction), and alpha-blends with 0.5 the second ring.
Using val1 = 0.25 and val2 = 0.75 gives a slightly more
blurred border, with no perceptual difference at screen resolution.
(3) The actual mask values are found by multiplying these
normalized opacity values by 255.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_setAlphaMaskBorder(*args)
    




class rank(object):
    """<pre>

Rank filter (gray and rgb)
PIX      *pixRankFilter()
PIX      *pixRankFilterRGB()
PIX      *pixRankFilterGray()

Median filter
PIX      *pixMedianFilter()

Rank filter (accelerated with downscaling)
PIX      *pixRankFilterWithScaling()

What is a brick rank filter?

A brick rank order filter evaluates, for every pixel in the image,
a rectangular set of n = wf x hf pixels in its neighborhood (where the
pixel in question is at the "center" of the rectangle and is
included in the evaluation).  It determines the value of the
neighboring pixel that is the r-th smallest in the set,
where r is some integer between 1 and n.  The input rank parameter
is a fraction between 0.0 and 1.0, where 0.0 represents the
smallest value (r = 1) and 1.0 represents the largest value (r = n).
A median filter is a rank filter where rank = 0.5.

It is important to note that grayscale erosion is equivalent
to rank = 0.0, and grayscale dilation is equivalent to rank = 1.0.
These are much easier to calculate than the general rank value,
thanks to the van Herk/Gil-Werman algorithm:
http://www.leptonica.com/grayscale-morphology.html
so you should use pixErodeGray() and pixDilateGray() for
rank 0.0 and 1.0, rsp.  See notes below in the function header.

How is a rank filter implemented efficiently on an image?

Sorting will not work.

The best sort algorithms are O(n*logn), where n is the number
of values to be sorted (the area of the filter).  For large
filters this is an impractically large number.

Selection of the rank value is O(n).  (To understand why it's not
O(n*logn), see Numerical Recipes in C, 2nd edition, 1992,  p. 355ff).
This also still far too much computation for large filters.

Suppose we get clever.  We really only need to do an incremental
selection or sorting, because, for example, moving the filter
down by one pixel causes one filter width of pixels to be added
and another to be removed.  Can we do this incrementally in
an efficient way?  Unfortunately, no.  The sorted values will be
in an array.  Even if the filter width is 1, we can expect to
have to move O(n) pixels, because insertion and deletion can happen
anywhere in the array.  By comparison, heapsort is excellent for
incremental sorting, where the cost for insertion or deletion
is O(logn), because the array itself doesn't need to
be sorted into strictly increasing order.  However, heapsort
only gives the max (or min) value, not the general rank value.

This leaves histograms.

Represented as an array.  The problem with an array of 256
bins is that, in general, a significant fraction of the
entire histogram must be summed to find the rank value bin.
Suppose the filter size is 5x5.  You spend most of your time
adding zeroes.  Ouch!

Represented as a linked list.  This would overcome the
summing-over-empty-bin problem, but you lose random access
for insertions and deletions.  No way.

Two histogram solution.  Maintain two histograms with
bin sizes of 1 and 16.  Proceed from coarse to fine.
First locate the coarse bin for the given rank, of which
there are only 16.  Then, in the 256 entry (fine) histogram,
you need look at a maximum of 16 bins.  For each output
pixel, the average number of bins summed over, both in the
coarse and fine histograms, is thus 16.

If someone has a better method, please let me know!

The rank filtering operation is relatively expensive, compared to most
of the other imaging operations.  The speed is only weakly dependent
on the size of the rank filter.  On standard hardware, it runs at
about 10 Mpix/sec for a 50 x 50 filter, and 25 Mpix/sec for
a 5 x 5 filter.   For applications where the rank filter can be
performed on a downscaled image, significant speedup can be
achieved because the time goes as the square of the scaling factor.
We provide an interface that handles the details, and only
requires the amount of downscaling to be input.
</pre>




"""
    
    try:
        leptonica.pixRankFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRankFilter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       

:param[in]    pixs:     8 or 32 bpp; no colormap
:param[in]    wf,: hf   width and height of filter; each is >= 1
:param[in]    rank:     in [0.0 ... 1.0]
:returns:  pixd of rank values, or NULL on error

<pre>
Notes:
(1) This defines, for each pixel in pixs, a neighborhood of
pixels given by a rectangle "centered" on the pixel.
This set of wf*hf pixels has a distribution of values.
For each component, if the values are sorted in increasing
order, we choose the component such that rank*(wf*hf-1)
pixels have a lower or equal value and
(1-rank)*(wf*hf-1) pixels have an equal or greater value.
(2) See notes in pixRankFilterGray() for further details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilter(*args)
    
    

    try:
        leptonica.pixRankFilterRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRankFilterRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankFilterRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilterRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       

:param[in]    pixs:     32 bpp
:param[in]    wf,: hf   width and height of filter; each is >= 1
:param[in]    rank:     in [0.0 ... 1.0]
:returns:  pixd of rank values, or NULL on error

<pre>
Notes:
(1) This defines, for each pixel in pixs, a neighborhood of
pixels given by a rectangle "centered" on the pixel.
This set of wf*hf pixels has a distribution of values.
For each component, if the values are sorted in increasing
order, we choose the component such that rank*(wf*hf-1)
pixels have a lower or equal value and
(1-rank)*(wf*hf-1) pixels have an equal or greater value.
(2) Apply gray rank filtering to each component independently.
(3) See notes in pixRankFilterGray() for further details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilterRGB(*args)
    
    

    try:
        leptonica.pixRankFilterGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixRankFilterGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankFilterGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilterGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       

:param[in]    pixs:     8 bpp; no colormap
:param[in]    wf,: hf   width and height of filter; each is >= 1
:param[in]    rank:     in [0.0 ... 1.0]
:returns:  pixd of rank values, or NULL on error

<pre>
Notes:
(1) This defines, for each pixel in pixs, a neighborhood of
pixels given by a rectangle "centered" on the pixel.
This set of wf*hf pixels has a distribution of values,
and if they are sorted in increasing order, we choose
the pixel such that rank*(wf*hf-1) pixels have a lower
or equal value and (1-rank)*(wf*hf-1) pixels have an equal
or greater value.
(2) By this definition, the rank = 0.0 pixel has the lowest
value, and the rank = 1.0 pixel has the highest value.
(3) We add mirrored boundary pixels to avoid boundary effects,
and put the filter center at (0, 0).
(4) This dispatches to grayscale erosion or dilation if the
filter dimensions are odd and the rank is 0.0 or 1.0, rsp.
(5) Returns a copy if both wf and hf are 1.
(6) Uses row-major or column-major incremental updates to the
histograms depending on whether hf > wf or hv <= wf, rsp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilterGray(*args)
    
    

    try:
        leptonica.pixMedianFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMedianFilter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMedianFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMedianFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       

:param[in]    pixs:     8 or 32 bpp; no colormap
:param[in]    wf,: hf   width and height of filter; each is >= 1
:returns:  pixd of median values, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMedianFilter(*args)
    
    

    try:
        leptonica.pixRankFilterWithScaling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixRankFilterWithScaling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankFilterWithScaling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankFilterWithScaling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wf')       
('l_int32', 'hf')       
('l_float32', 'rank')       
('l_float32', 'scalefactor')       

:param[in]    pixs:          8 or 32 bpp; no colormap
:param[in]    wf,: hf        width and height of filter; each is >= 1
:param[in]    rank:          in [0.0 ... 1.0]
:param[in]    scalefactor:   scale factor; must be >= 0.2 and <= 0.7
:returns:  pixd of rank values, or NULL on error

<pre>
Notes:
(1) This is a convenience function that downscales, does
the rank filtering, and upscales.  Because the down-
and up-scaling functions are very fast compared to
rank filtering, the time it takes is reduced from that
for the simple rank filtering operation by approximately
the square of the scaling factor.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankFilterWithScaling(*args)
    




class sudoku(object):
    """<pre>

Solve a sudoku by brute force search

Read input data from file or string
l_int32         *sudokuReadFile()
l_int32         *sudokuReadString()

Create/destroy
L_SUDOKU        *sudokuCreate()
void             sudokuDestroy()

Solve the puzzle
l_int32          sudokuSolve()
static l_int32   sudokuValidState()
static l_int32   sudokuNewGuess()
static l_int32   sudokuTestState()

Test for uniqueness
l_int32          sudokuTestUniqueness()
static l_int32   sudokuCompareState()
static l_int32  *sudokuRotateArray()

Generation
L_SUDOKU        *sudokuGenerate()

Output
l_int32          sudokuOutput()

Solving sudokus is a somewhat addictive pastime.  The rules are
simple but it takes just enough concentration to make it rewarding
when you find a number.  And you get 50 to 60 such rewards each time
you complete one.  The downside is that you could have been doing
something more creative, like keying out a new plant, staining
the deck, or even writing a computer program to discourage your
wife from doing sudokus.

My original plan for the sudoku solver was somewhat grandiose.
The program would model the way a person solves the problem.
It would examine each empty position and determine how many possible
numbers could fit.  The empty positions would be entered in a priority
queue keyed on the number of possible numbers that could fit.
If there existed a position where only a single number would work,
it would greedily take it.  Otherwise it would consider a
positions that could accept two and make a guess, with backtracking
if an impossible state were reached.  And so on.

Then one of my colleagues announced she had solved the problem
by brute force and it was fast.  At that point the original plan was
dead in the water, because the two top requirements for a leptonica
algorithm are (1) as simple as possible and (2) fast.  The brute
force approach starts at the UL corner, and in succession at each
blank position it finds the first valid number (testing in
sequence from 1 to 9).  When no number will fit a blank position
it backtracks, choosing the next valid number in the previous
blank position.

This is an inefficient method for pruning the space of solutions
(imagine backtracking from the LR corner back to the UL corner
and starting over with a new guess), but it nevertheless gets
the job done quickly.  I have made no effort to optimize
it, because it is fast: a 5-star (highest difficulty) sudoku might
require a million guesses and take 0.05 sec.  (This BF implementation
does about 20M guesses/sec at 3 GHz.)

Proving uniqueness of a sudoku solution is tricker than finding
a solution (or showing that no solution exists).  A good indication
that a solution is unique is if we get the same result solving
by brute force when the puzzle is also rotated by 90, 180 and 270
degrees.  If there are multiple solutions, it seems unlikely
that you would get the same solution four times in a row, using a
brute force method that increments guesses and scans LR/TB.
The function sudokuTestUniqueness() does this.

And given a function that can determine uniqueness, it is
easy to generate valid sudokus.  We provide sudokuGenerate(),
which starts with some valid initial solution, and randomly
removes numbers, stopping either when a minimum number of non-zero
elements are left, or when it becomes difficult to remove another
element without destroying the uniqueness of the solution.

For further reading, see the Wikipedia articles:
(1) http://en.wikipedia.org/wiki/Algorithmics_of_sudoku
(2) http://en.wikipedia.org/wiki/Sudoku

How many 9x9 sudokus are there?  Here are the numbers.
~ From ref(1), there are about 6 x 10^27 "latin squares", where
each row and column has all 9 digits.
~ There are 7.2 x 10^21 actual solutions, having the added
constraint in each of the 9 3x3 squares.  (The constraint
reduced the number by the fraction 1.2 x 10^(-6).)
~ There are a mere 5.5 billion essentially different solutions (EDS),
when symmetries (rotation, reflection, permutation and relabelling)
are removed.
~ Thus there are 1.3 x 10^12 solutions that can be derived by
symmetry from each EDS.  Can we account for these?
~ Sort-of.  From an EDS, you can derive (3!)^8 = 1.7 million solutions
by simply permuting rows and columns.  (Do you see why it is
not (3!)^6 ?)
~ Also from an EDS, you can derive 9! solutions by relabelling,
and 4 solutions by rotation, for a total of 1.45 million solutions
by relabelling and rotation.  Then taking the product, by symmetry
we can derive 1.7M x 1.45M = 2.45 trillion solutions from each EDS.
(Something is off by about a factor of 2 -- close enough.)

Another interesting fact is that there are apparently 48K EDS sudokus
(with unique solutions) that have only 17 givens.  No sudokus are known
with less than 17, but there exists no proof that this is the minimum.
</pre>




"""
    
    try:
        leptonica.sudokuReadFile.argtypes = [ctypes.c_char_p]
        leptonica.sudokuReadFile.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function sudokuReadFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuReadFile(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:     formatted sudoku file
:returns:  array of 81 numbers, or NULL on error

<pre>
Notes:
(1) The file format has:
any number of comment lines beginning with '#'
a set of 9 lines, each having 9 digits (0-9) separated
by a space
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuReadFile(*args)
    
    

    try:
        leptonica.sudokuReadString.argtypes = [ctypes.c_char_p]
        leptonica.sudokuReadString.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function sudokuReadString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuReadString(*args):
        """
        ('const char', '*str')       

:param[in]    str:     formatted input data
:returns:  array of 81 numbers, or NULL on error

<pre>
Notes:
(1) The string is formatted as 81 single digits, each separated
by 81 spaces.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuReadString(*args)
    
    

    try:
        leptonica.sudokuCreate.argtypes = [ctypes.c_void_p]
        leptonica.sudokuCreate.restype = lambda address: L_SUDOKU(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sudokuCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuCreate(*args):
        """
        ('l_int32', '*array')       

:param[in]    array:   81 numbers, 9 rows of 9 numbers each
:returns:  l_sudoku, or NULL on error

<pre>
Notes:
(1) The input array has 0 for the unknown values, and 1-9
for the known initial values.  It is generated from
a file using sudokuReadInput(), which checks that the file
data has 81 numbers in 9 rows.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuCreate(*args)
    
    

    try:
        leptonica.sudokuDestroy.argtypes = [ctypes.c_void_p]
        leptonica.sudokuDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function sudokuDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuDestroy(*args):
        """
        ('L_SUDOKU', '**psud')       

:param[in,out]   psud:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuDestroy(*args)
    
    

    try:
        leptonica.sudokuSolve.argtypes = [ctypes.c_void_p]
        leptonica.sudokuSolve.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function sudokuSolve not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuSolve(*args):
        """
        ('L_SUDOKU', '*sud')       

:param[in]    sud:     l_sudoku starting in initial state
:returns:  1 on success, 0 on failure to solve note reversal of
typical unix returns


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuSolve(*args)
    
    

    try:
        leptonica.sudokuTestUniqueness.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sudokuTestUniqueness.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sudokuTestUniqueness not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuTestUniqueness(*args):
        """
        ('l_int32', '*array')       
('l_int32', '*punique')       

:param[in]    array:     of 81 numbers, 9 lines of 9 numbers each
:param[out]   punique:   1 if unique, 0 if not
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This applies the brute force method to all four 90 degree
rotations.  If there is more than one solution, it is highly
unlikely that all four results will be the same;
consequently, if they are the same, the solution is
most likely to be unique.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuTestUniqueness(*args)
    
    

    try:
        leptonica.sudokuGenerate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.sudokuGenerate.restype = lambda address: L_SUDOKU(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sudokuGenerate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuGenerate(*args):
        """
        ('l_int32', '*array')       
('l_int32', 'seed')       
('l_int32', 'minelems')       
('l_int32', 'maxtries')       

:param[in]    array:      81 numbers, 9 rows of 9 numbers each
:param[in]    seed:       random number
:param[in]    minelems:   min non-zero elements allowed; <= 80
:param[in]    maxtries:   max tries to remove a number and get a valid sudoku
:returns:  l_sudoku, or NULL on error

<pre>
Notes:
(1) This is a brute force generator.  It starts with a completed
sudoku solution and, by removing elements (setting them to 0),
generates a valid (unique) sudoku initial condition.
(2) The process stops when either %minelems, the minimum
number of non-zero elements, is reached, or when the
number of attempts to remove the next element exceeds %maxtries.
(3) No sudoku is known with less than 17 nonzero elements.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuGenerate(*args)
    
    

    try:
        leptonica.sudokuOutput.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sudokuOutput.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function sudokuOutput not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sudokuOutput(*args):
        """
        ('L_SUDOKU', '*sud')       
('l_int32', 'arraytype')       

:param[in]    sud:          l_sudoku at any stage
:param[in]    arraytype:    L_SUDOKU_INIT, L_SUDOKU_STATE
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Prints either the initial array or the current state
of the solution.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sudokuOutput(*args)
    




class bbuffer(object):
    """<pre>

Create/Destroy BBuffer
L_BBUFFER      *bbufferCreate()
void           *bbufferDestroy()
l_uint8        *bbufferDestroyAndSaveData()

Operations to read data TO a BBuffer
l_int32         bbufferRead()
l_int32         bbufferReadStream()
l_int32         bbufferExtendArray()

Operations to write data FROM a BBuffer
l_int32         bbufferWrite()
l_int32         bbufferWriteStream()

The bbuffer is an implementation of a byte queue.
The bbuffer holds a byte array from which bytes are
processed in a first-in/first-out fashion.  As with
any queue, bbuffer maintains two "pointers," one to the
tail of the queue (where you read new bytes onto it)
and one to the head of the queue (where you start from
when writing bytes out of it.

The queue can be visualized:

\code
byte 0                                           byte (nalloc - 1)
|                                                |
--------------------------------------------------
H                             T
[   aw   ][  bytes currently on queue  ][  anr   ]

---:  all allocated data in bbuffer
H:    queue head (ptr to next byte to be written out)
T:    queue tail (ptr to first byte to be written to)
aw:   already written from queue
anr:  allocated but not yet read to
\endcode
The purpose of bbuffer is to allow you to safely read
bytes in, and to sequentially write them out as well.
In the process of writing bytes out, you don't actually
remove the bytes in the array; you just move the pointer
(nwritten) which points to the head of the queue.  In
the process of reading bytes in, you sometimes need to
expand the array size.  If a read is performed after a
write, so that the head of the queue is not at the
beginning of the array, the bytes already written are
first removed by copying the others over them; then the
new bytes are read onto the tail of the queue.

Note that the meaning of "read into" and "write from"
the bbuffer is OPPOSITE to that for a stream, where
you read "from" a stream and write "into" a stream.
As a mnemonic for remembering the direction:
~ to read bytes from a stream into the bbuffer,
you call fread on the stream
~ to write bytes from the bbuffer into a stream,
you call fwrite on the stream

See zlibmem.c for an example use of bbuffer, where we
compress and decompress an array of bytes in memory.

We can also use the bbuffer trivially to read from stdin
into memory; e.g., to capture bytes piped from the stdout
of another program.  This is equivalent to repeatedly
calling bbufferReadStream() until the input queue is empty.
This is implemented in l_binaryReadStream().
</pre>




"""
    
    try:
        leptonica.bbufferCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferCreate.restype = lambda address: L_BBUFFER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function bbufferCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferCreate(*args):
        """
        ('const l_uint8', '*indata')       
('l_int32', 'nalloc')       

:param[in]    indata:   address in memory [optional]
:param[in]    nalloc:   size of byte array to be alloc'd 0 for default
:returns:  bbuffer, or NULL on error

<pre>
Notes:
(1) If a buffer address is given, you should read all the data in.
(2) Allocates a bbuffer with associated byte array of
the given size.  If a buffer address is given,
it then reads the number of bytes into the byte array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferCreate(*args)
    
    

    try:
        leptonica.bbufferDestroy.argtypes = [ctypes.c_void_p]
        leptonica.bbufferDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function bbufferDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferDestroy(*args):
        """
        ('L_BBUFFER', '**pbb')       

:param[in,out]   pbb:   will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Destroys the byte array in the bbuffer and then the bbuffer;
then nulls the contents of the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferDestroy(*args)
    
    

    try:
        leptonica.bbufferDestroyAndSaveData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bbufferDestroyAndSaveData.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function bbufferDestroyAndSaveData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferDestroyAndSaveData(*args):
        """
        ('L_BBUFFER', '**pbb')       
('size_t', '*pnbytes')       

:param[in,out]   pbb:       input data buffer; will be nulled
:param[out]      pnbytes:   number of bytes saved in array
:returns:  barray newly allocated array of data

<pre>
Notes:
(1) Copies data to newly allocated array; then destroys the bbuffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferDestroyAndSaveData(*args)
    
    

    try:
        leptonica.bbufferRead.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferRead.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bbufferRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferRead(*args):
        """
        ('L_BBUFFER', '*bb')       
('l_uint8', '*src')       
('l_int32', 'nbytes')       

:param[in]    bb:       bbuffer
:param[in]    src:      source memory buffer from which bytes are read
:param[in]    nbytes:   bytes to be read
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For a read after write, first remove the written
bytes by shifting the unwritten bytes in the array,
then check if there is enough room to add the new bytes.
If not, realloc with bbufferExpandArray(), resulting
in a second writing of the unwritten bytes.  While less
efficient, this is simpler than making a special case
of reallocNew().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferRead(*args)
    
    

    try:
        leptonica.bbufferReadStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferReadStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bbufferReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferReadStream(*args):
        """
        ('L_BBUFFER', '*bb')       
('FILE', '*fp')       
('l_int32', 'nbytes')       

:param[in]    bb:       bbuffer
:param[in]    fp:       source stream from which bytes are read
:param[in]    nbytes:   bytes to be read
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferReadStream(*args)
    
    

    try:
        leptonica.bbufferExtendArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.bbufferExtendArray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bbufferExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferExtendArray(*args):
        """
        ('L_BBUFFER', '*bb')       
('l_int32', 'nbytes')       

:param[in]    bb:       bbuffer
:param[in]    nbytes:   number of bytes to extend array size
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) reallocNew() copies all bb->nalloc bytes, even though
only bb->n are data.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferExtendArray(*args)
    
    

    try:
        leptonica.bbufferWrite.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.bbufferWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bbufferWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferWrite(*args):
        """
        ('L_BBUFFER', '*bb')       
('l_uint8', '*dest')       
('size_t', 'nbytes')       
('size_t', '*pnout')       

:param[in]    bb:       bbuffer
:param[in]    dest:     dest memory buffer to which bytes are written
:param[in]    nbytes:   bytes requested to be written
:param[out]   pnout:    bytes actually written
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferWrite(*args)
    
    

    try:
        leptonica.bbufferWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.bbufferWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bbufferWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bbufferWriteStream(*args):
        """
        ('L_BBUFFER', '*bb')       
('FILE', '*fp')       
('size_t', 'nbytes')       
('size_t', '*pnout')       

:param[in]    bb:       bbuffer
:param[in]    fp:       dest stream to which bytes are written
:param[in]    nbytes:   bytes requested to be written
:param[out]   pnout:    bytes actually written
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bbufferWriteStream(*args)
    




class convertfiles(object):
    """<pre>

Conversion to 1 bpp
l_int32    convertFilesTo1bpp()

These are utility functions that will perform depth conversion
on selected files, writing the results to a specified directory.
We start with conversion to 1 bpp.
</pre>




"""
    
    try:
        leptonica.convertFilesTo1bpp.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32]
        leptonica.convertFilesTo1bpp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertFilesTo1bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFilesTo1bpp(*args):
        """
        ('const char', '*dirin')       
('const char', '*substr')       
('l_int32', 'upscaling')       
('l_int32', 'thresh')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
('const char', '*dirout')       
('l_int32', 'outformat')       

:param[in]    dirin:
:param[in]    substr:       [optional] substring filter on filenames;
8                            can be NULL
:param[in]    upscaling:    1, 2 or 4; only for input color or grayscale
:param[in]    thresh:       global threshold for binarization; 0 for default
:param[in]    firstpage:
:param[in]    npages:       use 0 to do all from %firstpage to the end
:param[in]    dirout:
:param[in]    outformat:    IFF_PNG, IFF_TIFF_G4
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Images are sorted lexicographically, and the names in the
output directory are retained except for the extension.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertFilesTo1bpp(*args)
    




class graymorph(object):
    """<pre>

Top-level grayscale morphological operations (van Herk / Gil-Werman)
PIX           *pixErodeGray()
PIX           *pixDilateGray()
PIX           *pixOpenGray()
PIX           *pixCloseGray()

Special operations for 1x3, 3x1 and 3x3 Sels  (direct)
PIX           *pixErodeGray3()
static PIX    *pixErodeGray3h()
static PIX    *pixErodeGray3v()
PIX           *pixDilateGray3()
static PIX    *pixDilateGray3h()
static PIX    *pixDilateGray3v()
PIX           *pixOpenGray3()
PIX           *pixCloseGray3()

Low-level grayscale morphological operations
static void    dilateGrayLow()
static void    erodeGrayLow()


Method: Algorithm by van Herk and Gil and Werman, 1992

Measured speed of the vH/G-W implementation is about 1 output
pixel per 120 PIII clock cycles, for a horizontal or vertical
erosion or dilation.  The computation time doubles for opening
or closing, or for a square SE, as expected, and is independent
of the size of the SE.

A faster implementation can be made directly for brick Sels
of maximum size 3.  We unroll the computation for sets of 8 bytes.
It needs to be called explicitly; the general functions do not
default for the size 3 brick Sels.

We use the van Herk/Gil-Werman (vHGW) algorithm, [van Herk,
Patt. Recog. Let. 13, pp. 517-521, 1992; Gil and Werman,
IEEE Trans PAMI 15(5), pp. 504-507, 1993.]
This was the first grayscale morphology
algorithm to compute dilation and erosion with
complexity independent of the size of the structuring
element.  It is simple and elegant, and surprising that
it was discovered as recently as 1992.  It works for
SEs composed of horizontal and/or vertical lines.  The
general case requires finding the Min or Max over an
arbitrary set of pixels, and this requires a number of
pixel comparisons equal to the SE "size" at each pixel
in the image.  The vHGW algorithm requires not
more than 3 comparisons at each point.  The algorithm has been
recently refined by Gil and Kimmel ("Efficient Dilation
Erosion, Opening and Closing Algorithms", in "Mathematical
Morphology and its Applications to Image and Signal Processing",
the proceedings of the International Symposium on Mathematical
Morphology, Palo Alto, CA, June 2000, Kluwer Academic
Publishers, pp. 301-310).  They bring this number down below
1.5 comparisons per output pixel but at a cost of significantly
increased complexity, so I don't bother with that here.

In brief, the method is as follows.  We evaluate the dilation
in groups of "size" pixels, equal to the size of the SE.
For horizontal, we start at x = "size"/2 and go
(w - 2 * ("size"/2))/"size" steps.  This means that
we don't evaluate the first 0.5 * "size" pixels and, worst
case, the last 1.5 * "size" pixels.  Thus we embed the
image in a larger image with these augmented dimensions, where
the new border pixels are appropriately initialized (0 for
dilation; 255 for erosion), and remove the boundary at the end.
(For vertical, use h instead of w.)   Then for each group
of "size" pixels, we form an array of length 2 * "size" + 1,
consisting of backward and forward partial maxima (for
dilation) or minima (for erosion).  This represents a
jumping window computed from the source image, over which
the SE will slide.  The center of the array gets the source
pixel at the center of the SE.  Call this the center pixel
of the window.  Array values to left of center get
the maxima(minima) of the pixels from the center
one and going to the left an equal distance.  Array
values to the right of center get the maxima(minima) to
the pixels from the center one and going to the right
an equal distance.  These are computed sequentially starting
from the center one.  The SE (of length "size") can slide over this
window (of length 2 * "size + 1) at "size" different places.
At each place, the maxima(minima) of the values in the window
that correspond to the end points of the SE give the extremal
values over that interval, and these are stored at the dest
pixel corresponding to the SE center.  A picture is worth
at least this many words, so if this isn't clear, see the
leptonica documentation on grayscale morphology.
</pre>




"""
    
    try:
        leptonica.pixErodeGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:
:param[in]    hsize:  of Sel; must be odd; origin implicitly in center
:param[in]    vsize:  ditto
:returns:  pixd

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeGray(*args)
    
    

    try:
        leptonica.pixDilateGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:
:param[in]    hsize:  of Sel; must be odd; origin implicitly in center
:param[in]    vsize:  ditto
:returns:  pixd

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateGray(*args)
    
    

    try:
        leptonica.pixOpenGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:
:param[in]    hsize:  of Sel; must be odd; origin implicitly in center
:param[in]    vsize:  ditto
:returns:  pixd

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenGray(*args)
    
    

    try:
        leptonica.pixCloseGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:
:param[in]    hsize:  of Sel; must be odd; origin implicitly in center
:param[in]    vsize:  ditto
:returns:  pixd

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseGray(*args)
    
    

    try:
        leptonica.pixErodeGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeGray3.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    hsize:   1 or 3
:param[in]    vsize:   1 or 3
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
(2) If hsize = vsize = 1, just returns a copy.
(3) It would be nice not to add a border, but it is required
if we want the same results as from the general case.
We add 4 bytes on the left to speed up the copying, and
8 bytes at the right and bottom to allow unrolling of
the computation of 8 pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeGray3(*args)
    
    

    try:
        leptonica.pixDilateGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateGray3.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    hsize:   1 or 3
:param[in]    vsize:   1 or 3
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
(2) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateGray3(*args)
    
    

    try:
        leptonica.pixOpenGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenGray3.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    hsize:   1 or 3
:param[in]    vsize:   1 or 3
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
(2) If hsize = vsize = 1, just returns a copy.
(3) It would be nice not to add a border, but it is required
to get the same results as for the general case.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenGray3(*args)
    
    

    try:
        leptonica.pixCloseGray3.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseGray3.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseGray3(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    hsize:   1 or 3
:param[in]    vsize:   1 or 3
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Special case for 1x3, 3x1 or 3x3 brick sel (all hits)
(2) If hsize = vsize = 1, just returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseGray3(*args)
    




class pix3(object):
    """<pre>

This file has these operations:

(1) Mask-directed operations
(2) Full-image bit-logical operations
(3) Foreground pixel counting operations on 1 bpp images
(4) Average and variance of pixel values
(5) Mirrored tiling of a smaller image


Masked operations
l_int32     pixSetMasked()
l_int32     pixSetMaskedGeneral()
l_int32     pixCombineMasked()
l_int32     pixCombineMaskedGeneral()
l_int32     pixPaintThroughMask()
l_int32     pixCopyWithBoxa()  -- this is boxa-directed
PIX        *pixPaintSelfThroughMask()
PIX        *pixMakeMaskFromVal()
PIX        *pixMakeMaskFromLUT()
PIX        *pixMakeArbMaskFromRGB()
PIX        *pixSetUnderTransparency()
PIX        *pixMakeAlphaFromMask()
l_int32     pixGetColorNearMaskBoundary()
PIX        *pixDisplaySelectedPixels()  -- for debugging

One and two-image boolean operations on arbitrary depth images
PIX        *pixInvert()
PIX        *pixOr()
PIX        *pixAnd()
PIX        *pixXor()
PIX        *pixSubtract()

Foreground pixel counting in 1 bpp images
l_int32     pixZero()
l_int32     pixForegroundFraction()
NUMA       *pixaCountPixels()
l_int32     pixCountPixels()
l_int32     pixCountPixelsInRect()
NUMA       *pixCountByRow()
NUMA       *pixCountByColumn()
NUMA       *pixCountPixelsByRow()
NUMA       *pixCountPixelsByColumn()
l_int32     pixCountPixelsInRow()
NUMA       *pixGetMomentByColumn()
l_int32     pixThresholdPixelSum()
l_int32    *makePixelSumTab8()
l_int32    *makePixelCentroidTab8()

Average of pixel values in gray images
NUMA       *pixAverageByRow()
NUMA       *pixAverageByColumn()
l_int32     pixAverageInRect()

Average of pixel values in RGB images
l_int32     pixAverageInRectRGB()

Variance of pixel values in gray images
NUMA       *pixVarianceByRow()
NUMA       *pixVarianceByColumn()
l_int32     pixVarianceInRect()

Average of absolute value of pixel differences in gray images
NUMA       *pixAbsDiffByRow()
NUMA       *pixAbsDiffByColumn()
l_int32     pixAbsDiffInRect()
l_int32     pixAbsDiffOnLine()

Count of pixels with specific value
l_int32     pixCountArbInRect()

Mirrored tiling
PIX        *pixMirroredTiling()

Representative tile near but outside region
l_int32     pixFindRepCloseTile()

Static helper function
static BOXA    *findTileRegionsForSearch()
</pre>




"""
    
    try:
        leptonica.pixSetMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixSetMasked.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_uint32', 'val')       

:param[in]   pixd:   1, 2, 4, 8, 16 or 32 bpp; or colormapped
:param[in]   pixm:   [optional] 1 bpp mask; no operation if NULL
:param[in]   val:    value to set at each masked pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) In-place operation.
(2) NOTE: For cmapped images, this calls pixSetMaskedCmap().
%val must be the 32-bit color representation of the RGB pixel.
It is not the index into the colormap!
(2) If pixm == NULL, a warning is given.
(3) This is an implicitly aligned operation, where the UL
corners of pixd and pixm coincide.  A warning is
issued if the two image sizes differ significantly,
but the operation proceeds.
(4) Each pixel in pixd that co-locates with an ON pixel
in pixm is set to the specified input value.
Other pixels in pixd are not changed.
(5) You can visualize this as painting the color through
the mask, as a stencil.
(6) If you do not want to have the UL corners aligned,
use the function pixSetMaskedGeneral(), which requires
you to input the UL corner of pixm relative to pixd.
(7) Implementation details: see comments in pixPaintThroughMask()
for when we use rasterop to do the painting.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMasked(*args)
    
    

    try:
        leptonica.pixSetMaskedGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetMaskedGeneral.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetMaskedGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetMaskedGeneral(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_uint32', 'val')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]   pixd:    8, 16 or 32 bpp
:param[in]   pixm:    [optional] 1 bpp mask; no operation if null
:param[in]   val:     value to set at each masked pixel
:param[in]   x,: y    location of UL corner of pixm relative to pixd;
can be negative
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is an in-place operation.
(2) Alignment is explicit.  If you want the UL corners of
the two images to be aligned, use pixSetMasked().
(3) A typical use would be painting through the foreground
of a small binary mask pixm, located somewhere on a
larger pixd.  Other pixels in pixd are not changed.
(4) You can visualize this as painting the color through
the mask, as a stencil.
(5) This uses rasterop to handle clipping and different depths of pixd.
(6) If pixd has a colormap, you should call pixPaintThroughMask().
(7) Why is this function here, if pixPaintThroughMask() does the
same thing, and does it more generally?  I've retained it here
to show how one can paint through a mask using only full
image rasterops, rather than pixel peeking in pixm and poking
in pixd.  It's somewhat baroque, but I found it amusing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetMaskedGeneral(*args)
    
    

    try:
        leptonica.pixCombineMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCombineMasked.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCombineMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCombineMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       

:param[in]   pixd:   1 bpp, 8 bpp gray or 32 bpp rgb; no cmap
:param[in]   pixs:   1 bpp, 8 bpp gray or 32 bpp rgb; no cmap
:param[in]   pixm:   [optional] 1 bpp mask; no operation if NULL
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) In-place operation; pixd is changed.
(2) This sets each pixel in pixd that co-locates with an ON
pixel in pixm to the corresponding value of pixs.
(3) pixs and pixd must be the same depth and not colormapped.
(4) All three input pix are aligned at the UL corner, and the
operation is clipped to the intersection of all three images.
(5) If pixm == NULL, it's a no-op.
(6) Implementation: see notes in pixCombineMaskedGeneral().
For 8 bpp selective masking, you might guess that it
would be faster to generate an 8 bpp version of pixm,
using pixConvert1To8(pixm, 0, 255), and then use a
general combine operation
d = (d & ~m) | (s & m)
on a word-by-word basis.  Not always.  The word-by-word
combine takes a time that is independent of the mask data.
If the mask is relatively sparse, the byte-check method
is actually faster!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCombineMasked(*args)
    
    

    try:
        leptonica.pixCombineMaskedGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCombineMaskedGeneral.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCombineMaskedGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCombineMaskedGeneral(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]   pixd:   1 bpp, 8 bpp gray or 32 bpp rgb
:param[in]   pixs:   1 bpp, 8 bpp gray or 32 bpp rgb
:param[in]   pixm:   [optional] 1 bpp mask
:param[in]   x,: y   origin of pixs and pixm relative to pixd; can be negative
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) In-place operation; pixd is changed.
(2) This is a generalized version of pixCombinedMasked(), where
the source and mask can be placed at the same (arbitrary)
location relative to pixd.
(3) pixs and pixd must be the same depth and not colormapped.
(4) The UL corners of both pixs and pixm are aligned with
the point (x, y) of pixd, and the operation is clipped to
the intersection of all three images.
(5) If pixm == NULL, it's a no-op.
(6) Implementation.  There are two ways to do these.  In the first,
we use rasterop, ORing the part of pixs under the mask
with pixd (which has been appropriately cleared there first).
In the second, the mask is used one pixel at a time to
selectively replace pixels of pixd with those of pixs.
Here, we use rasterop for 1 bpp and pixel-wise replacement
for 8 and 32 bpp.  To use rasterop for 8 bpp, for example,
we must first generate an 8 bpp version of the mask.
The code is simple:

Pix *pixm8 = pixConvert1To8(NULL, pixm, 0, 255);
Pix *pixt = pixAnd(NULL, pixs, pixm8);
pixRasterop(pixd, x, y, wmin, hmin, PIX_DST & PIX_NOT(PIX_SRC),
pixm8, 0, 0);
pixRasterop(pixd, x, y, wmin, hmin, PIX_SRC | PIX_DST,
pixt, 0, 0);
pixDestroy(&pixt);
pixDestroy(&pixm8);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCombineMaskedGeneral(*args)
    
    

    try:
        leptonica.pixPaintThroughMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixPaintThroughMask.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixPaintThroughMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintThroughMask(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', 'val')       

:param[in]   pixd:   1, 2, 4, 8, 16 or 32 bpp; or colormapped
:param[in]   pixm:   [optional] 1 bpp mask
:param[in]   x,: y   origin of pixm relative to pixd; can be negative
:param[in]   val:    pixel value to set at each masked pixel
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) In-place operation.  Calls pixSetMaskedCmap() for colormapped
images.
(2) For 1, 2, 4, 8 and 16 bpp gray, we take the appropriate
number of least significant bits of val.
(3) If pixm == NULL, it's a no-op.
(4) The mask origin is placed at (x,y) on pixd, and the
operation is clipped to the intersection of rectangles.
(5) For rgb, the components in val are in the canonical locations,
with red in location COLOR_RED, etc.
(6) Implementation detail 1:
For painting with val == 0 or val == maxval, you can use rasterop.
If val == 0, invert the mask so that it's 0 over the region
into which you want to write, and use PIX_SRC & PIX_DST to
clear those pixels.  To write with val = maxval (all 1's),
use PIX_SRC | PIX_DST to set all bits under the mask.
(7) Implementation detail 2:
The rasterop trick can be used for depth > 1 as well.
For val == 0, generate the mask for depth d from the binary
mask using
pixmd = pixUnpackBinary(pixm, d, 1);
and use pixRasterop() with PIX_MASK.  For val == maxval,
pixmd = pixUnpackBinary(pixm, d, 0);
and use pixRasterop() with PIX_PAINT.
But note that if d == 32 bpp, it is about 3x faster to use
the general implementation (not pixRasterop()).
(8) Implementation detail 3:
It might be expected that the switch in the inner loop will
cause large branching delays and should be avoided.
This is not the case, because the entrance is always the
same and the compiler can correctly predict the jump.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintThroughMask(*args)
    
    

    try:
        leptonica.pixCopyWithBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixCopyWithBoxa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCopyWithBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCopyWithBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'background')       

:param[in]   pixs:         all depths; cmap ok
:param[in]   boxa:         e.g., from components of a photomask
:param[in]   background:   L_SET_WHITE or L_SET_BLACK
:returns:  pixd or NULL on error

<pre>
Notes:
(1) Pixels from pixs are copied ("blitted") through each box into pixd.
(2) Pixels not copied are preset to either white or black.
(3) This fast and simple implementation can use rasterop because
each region to be copied is rectangular.
(4) A much slower implemention that doesn't use rasterop would make
a 1 bpp mask from the boxa and then copy, pixel by pixel,
through the mask:
pixGetDimensions(pixs, &w, &h, NULL);
pixm = pixCreate(w, h, 1);
pixm = pixMaskBoxa(pixm, pixm, boxa);
pixd = pixCreateTemplate(pixs);
pixSetBlackOrWhite(pixd, background);
pixCombineMasked(pixd, pixs, pixm);
pixDestroy(&pixm);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCopyWithBoxa(*args)
    
    

    try:
        leptonica.pixPaintSelfThroughMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixPaintSelfThroughMask.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixPaintSelfThroughMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintSelfThroughMask(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'searchdir')       
('l_int32', 'mindist')       
('l_int32', 'tilesize')       
('l_int32', 'ntiles')       
('l_int32', 'distblend')       

:param[in]   pixd:       8 bpp gray or 32 bpp rgb; not colormapped
:param[in]   pixm:       1 bpp mask
:param[in]   x,: y       origin of pixm relative to pixd; must not be negative
:param[in]   searchdir:  L_HORIZ, L_VERT or L_BOTH_DIRECTIONS
:param[in]   mindist:    min distance of nearest tile edge to box; >= 0
:param[in]   tilesize:   requested size for tiling; may be reduced
:param[in]   ntiles:     number of tiles tested in each row/column
:param[in]   distblend:  distance outside the fg used for blending with pixs
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) In-place operation; pixd is changed.
(2) If pixm == NULL, it's a no-op.
(3) The mask origin is placed at (x,y) on pixd, and the
operation is clipped to the intersection of pixd and the
fg of the mask.
(4) %tsize is the the requested size for tiling.  The actual
actual size for each c.c. will be bounded by the minimum
dimension of the c.c.
(5) For %mindist, %searchdir and %ntiles, see pixFindRepCloseTile().
They determine the set of possible tiles that can be used
to build a larger mirrored tile to paint onto pixd through
the c.c. of pixm.
(6) %distblend is used for alpha blending.  It is only applied
if there is exactly one c.c. in the mask.  Use distblend == 0
to skip blending and just paint through the 1 bpp mask.
(7) To apply blending to more than 1 component, call this function
repeatedly with %pixm, %x and %y representing one component of
the mask each time.  This would be done as follows, for an
underlying image pixs and mask pixm of components to fill:
Boxa *boxa = pixConnComp(pixm, &pixa, 8);
n = boxaGetCount(boxa);
for (i = 0; i < n; i++) {
Pix *pix = pixaGetPix(pixa, i, L_CLONE);
Box *box = pixaGetBox(pixa, i, L_CLONE);
boxGetGeometry(box, &bx, &by, &bw, &bh);
pixPaintSelfThroughMask(pixs, pix, bx, by, searchdir,
mindist, tilesize, ntiles, distblend);
pixDestroy(&pix);
boxDestroy(&box);
}
pixaDestroy(&pixa);
boxaDestroy(&boxa);
(8) If no tiles can be found, this falls back to estimating the
color near the boundary of the region to be textured.
(9) This can be used to replace the pixels in some regions of
an image by selected neighboring pixels.  The mask represents
the pixels to be replaced.  For each connected component in
the mask, this function selects up to two tiles of neighboring
pixels to be used for replacement of pixels represented by
the component (i.e., under the FG of that component in the mask).
After selection, mirror replication is used to generate an
image that is large enough to cover the component.  Alpha
blending can also be used outside of the component, but near the
edge, to blur the transition between painted and original pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintSelfThroughMask(*args)
    
    

    try:
        leptonica.pixMakeMaskFromVal.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMakeMaskFromVal.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeMaskFromVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeMaskFromVal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'val')       

:param[in]   pixs:   2, 4 or 8 bpp; can be colormapped
:param[in]   val:    pixel value
:returns:  pixd 1 bpp mask, or NULL on error

<pre>
Notes:
(1) This generates a 1 bpp mask image, where a 1 is written in
the mask for each pixel in pixs that has a value %val.
(2) If no pixels have the value, an empty mask is generated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeMaskFromVal(*args)
    
    

    try:
        leptonica.pixMakeMaskFromLUT.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMakeMaskFromLUT.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeMaskFromLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeMaskFromLUT(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       

:param[in]   pixs:   2, 4 or 8 bpp; can be colormapped
:param[in]   tab:    256-entry LUT; 1 means to write to mask
:returns:  pixd 1 bpp mask, or NULL on error

<pre>
Notes:
(1) This generates a 1 bpp mask image, where a 1 is written in
the mask for each pixel in pixs that has a value corresponding
to a 1 in the LUT.
(2) The LUT should be of size 256.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeMaskFromLUT(*args)
    
    

    try:
        leptonica.pixMakeArbMaskFromRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixMakeArbMaskFromRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeArbMaskFromRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeArbMaskFromRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rc')       
('l_float32', 'gc')       
('l_float32', 'bc')       
('l_float32', 'thresh')       

:param[in]   pixs:         32 bpp RGB
:param[in]   rc,: gc, bc   arithmetic factors; can be negative
:param[in]   thresh:       lower threshold on weighted sum of components
:returns:  pixd 1 bpp mask, or NULL on error

<pre>
Notes:
(1) This generates a 1 bpp mask image, where a 1 is written in
the mask for each pixel in pixs that satisfies
rc * rval + gc * gval + bc * bval > thresh
where rval is the red component, etc.
(2) Unlike with pixConvertToGray(), there are no constraints
on the color coefficients, which can be negative.  For
example, a mask that discriminates against red and in favor
of blue will have rc < 0.0 and bc > 0.0.
(3) To make the result independent of intensity (the 'V' in HSV),
select coefficients so that %thresh = 0.  Then the result
is not changed when all components are multiplied by the
same constant (as long as nothing saturates).  This can be
useful if, for example, the illumination is not uniform.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeArbMaskFromRGB(*args)
    
    

    try:
        leptonica.pixSetUnderTransparency.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSetUnderTransparency.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSetUnderTransparency not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetUnderTransparency(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'val')       
('l_int32', 'debug')       

:param[in]   pixs:    32 bpp rgba
:param[in]   val:     32 bit unsigned color to use where alpha == 0
:param[in]   debug:   displays layers of pixs
:returns:  pixd 32 bpp rgba, or NULL on error

<pre>
Notes:
(1) This sets the r, g and b components under every fully
transparent alpha component to %val.  The alpha components
are unchanged.
(2) Full transparency is denoted by alpha == 0.  Setting
all pixels to a constant %val where alpha is transparent
can improve compressibility by reducing the entropy.
(3) The visual result depends on how the image is displayed.
(a) For display devices that respect the use of the alpha
layer, this will not affect the appearance.
(b) For typical leptonica operations, alpha is ignored,
so there will be a change in appearance because this
resets the rgb values in the fully transparent region.
(4) pixRead() and pixWrite() will, by default, read and write
4-component (rgba) pix in png format.  To ignore the alpha
component after reading, or omit it on writing, pixSetSpp(..., 3).
(5) Here are some examples:
To convert all fully transparent pixels in a 4 component
(rgba) png file to white:
pixs = pixRead(<infile>);
pixd = pixSetUnderTransparency(pixs, 0xffffff00, 0);
To write pixd with the alpha component:
pixWrite(<outfile>, pixd, IFF_PNG);
To write and rgba image without the alpha component, first do:
pixSetSpp(pixd, 3);
If you later want to use the alpha, spp must be reset to 4.
(fancier) To remove the alpha by blending the image over
a white background:
pixRemoveAlpha()
This changes all pixel values where the alpha component is
not opaque (255).
(6) Caution.  rgb images in leptonica typically have value 0 in
the alpha channel, which is fully transparent.  If spp for
such an image were changed from 3 to 4, the image becomes
fully transparent, and this function will set each pixel to %val.
If you really want to set every pixel to the same value,
use pixSetAllArbitrary().
(7) This is useful for compressing an RGBA image where the part
of the image that is fully transparent is random junk; compression
is typically improved by setting that region to a constant.
For rendering as a 3 component RGB image over a uniform
background of arbitrary color, use pixAlphaBlendUniform().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetUnderTransparency(*args)
    
    

    try:
        leptonica.pixMakeAlphaFromMask.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMakeAlphaFromMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeAlphaFromMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeAlphaFromMask(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dist')       
('BOX', '**pbox')       

:param[in]    pixs:   1 bpp
:param[in]    dist:   blending distance; typically 10 - 30
:param[out]   pbox:   [optional] use NULL to get the full size
:returns:  pixd (8 bpp gray, or NULL on error

<pre>
Notes:
(1) This generates a 8 bpp alpha layer that is opaque (256)
over the FG of pixs, and goes transparent linearly away
from the FG pixels, decaying to 0 (transparent) is an
8-connected distance given by %dist.  If %dist == 0,
this does a simple conversion from 1 to 8 bpp.
(2) If &box == NULL, this returns an alpha mask that is the
full size of pixs.  Otherwise, the returned mask pixd covers
just the FG pixels of pixs, expanded by %dist in each
direction (if possible), and the returned box gives the
location of the returned mask relative to pixs.
(3) This is useful for painting through a mask and allowing
blending of the painted image with an underlying image
in the mask background for pixels near foreground mask pixels.
For example, with an underlying rgb image pix1, an overlaying
image rgb pix2, binary mask pixm, and dist > 0, this
blending is achieved with:
pix3 = pixMakeAlphaFromMask(pixm, dist, &box);
boxGetGeometry(box, &x, &y, NULL, NULL);
pix4 = pixBlendWithGrayMask(pix1, pix2, pix3, x, y);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeAlphaFromMask(*args)
    
    

    try:
        leptonica.pixGetColorNearMaskBoundary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetColorNearMaskBoundary.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetColorNearMaskBoundary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColorNearMaskBoundary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('BOX', '*box')       
('l_int32', 'dist')       
('l_uint32', '*pval')       
('l_int32', 'debug')       

:param[in]    pixs:    32 bpp rgb
:param[in]    pixm:    1 bpp mask, full image
:param[in]    box:     region of mask; typically b.b. of a component
:param[in]    dist:    distance into BG from mask boundary to use
:param[out]   pval:    average pixel value
:param[in]    debug:   1 to output mask images
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This finds the average color in a set of pixels that are
roughly a distance %dist from the c.c. boundary and in the
background of the mask image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColorNearMaskBoundary(*args)
    
    

    try:
        leptonica.pixDisplaySelectedPixels.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixDisplaySelectedPixels.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplaySelectedPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplaySelectedPixels(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('SEL', '*sel')       
('l_uint32', 'val')       

:param[in]    pixs:    [optional] any depth
:param[in]    pixm:    1 bpp mask, aligned UL corner with %pixs
:param[in]    sel:     [optional] pattern to paint at each pixel in pixm
:param[in]    val:     rgb rendering of pattern
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) For every fg pixel in %pixm, this paints the pattern in %sel
in color %val on a copy of %pixs.
(2) The implementation is to dilate %pixm by %sel, and then
paint through the dilated mask onto %pixs.
(3) If %pixs == NULL, it paints on a white image.
(4) If %sel == NULL, it paints only the pixels in the input %pixm.
(5) This visualization would typically be used in debugging.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplaySelectedPixels(*args)
    
    

    try:
        leptonica.pixInvert.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixInvert.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixInvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixInvert(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]   pixd:  [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]   pixs:
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This inverts pixs, for all pixel depths.
(2) There are 3 cases:
(a) pixd == null,   ~src --> new pixd
(b) pixd == pixs,   ~src --> src  (in-place)
(c) pixd != pixs,   ~src --> input pixd
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixInvert(NULL, pixs);
(b) pixInvert(pixs, pixs);
(c) pixInvert(pixd, pixs);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixInvert(*args)
    
    

    try:
        leptonica.pixOr.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOr.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOr(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]   pixd:    [optional]; this can be null, equal to pixs1,
different from pixs1
:param[in]   pixs1:   can be == pixd
:param[in]   pixs2:   must be != pixd
:returns:  pixd always

<pre>
Notes:
(1) This gives the union of two images with equal depth,
aligning them to the the UL corner.  pixs1 and pixs2
need not have the same width and height.
(2) There are 3 cases:
(a) pixd == null,   (src1 | src2) --> new pixd
(b) pixd == pixs1,  (src1 | src2) --> src1  (in-place)
(c) pixd != pixs1,  (src1 | src2) --> input pixd
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixOr(NULL, pixs1, pixs2);
(b) pixOr(pixs1, pixs1, pixs2);
(c) pixOr(pixd, pixs1, pixs2);
(4) The size of the result is determined by pixs1.
(5) The depths of pixs1 and pixs2 must be equal.
(6) Note carefully that the order of pixs1 and pixs2 only matters
for the in-place case.  For in-place, you must have
pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
result: the copy puts pixs1 image data in pixs2, and
the rasterop is then between pixs2 and pixs2 (a no-op).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOr(*args)
    
    

    try:
        leptonica.pixAnd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAnd.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAnd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAnd(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]   pixd:    [optional]; this can be null, equal to pixs1,
different from pixs1
:param[in]   pixs1:   can be == pixd
:param[in]   pixs2:   must be != pixd
:returns:  pixd always

<pre>
Notes:
(1) This gives the intersection of two images with equal depth,
aligning them to the the UL corner.  pixs1 and pixs2
need not have the same width and height.
(2) There are 3 cases:
(a) pixd == null,   (src1 & src2) --> new pixd
(b) pixd == pixs1,  (src1 & src2) --> src1  (in-place)
(c) pixd != pixs1,  (src1 & src2) --> input pixd
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixAnd(NULL, pixs1, pixs2);
(b) pixAnd(pixs1, pixs1, pixs2);
(c) pixAnd(pixd, pixs1, pixs2);
(4) The size of the result is determined by pixs1.
(5) The depths of pixs1 and pixs2 must be equal.
(6) Note carefully that the order of pixs1 and pixs2 only matters
for the in-place case.  For in-place, you must have
pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
result: the copy puts pixs1 image data in pixs2, and
the rasterop is then between pixs2 and pixs2 (a no-op).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAnd(*args)
    
    

    try:
        leptonica.pixXor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixXor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixXor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixXor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]   pixd:    [optional]; this can be null, equal to pixs1,
different from pixs1
:param[in]   pixs1:   can be == pixd
:param[in]   pixs2:   must be != pixd
:returns:  pixd always

<pre>
Notes:
(1) This gives the XOR of two images with equal depth,
aligning them to the the UL corner.  pixs1 and pixs2
need not have the same width and height.
(2) There are 3 cases:
(a) pixd == null,   (src1 ^ src2) --> new pixd
(b) pixd == pixs1,  (src1 ^ src2) --> src1  (in-place)
(c) pixd != pixs1,  (src1 ^ src2) --> input pixd
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixXor(NULL, pixs1, pixs2);
(b) pixXor(pixs1, pixs1, pixs2);
(c) pixXor(pixd, pixs1, pixs2);
(4) The size of the result is determined by pixs1.
(5) The depths of pixs1 and pixs2 must be equal.
(6) Note carefully that the order of pixs1 and pixs2 only matters
for the in-place case.  For in-place, you must have
pixd == pixs1.  Setting pixd == pixs2 gives an incorrect
result: the copy puts pixs1 image data in pixs2, and
the rasterop is then between pixs2 and pixs2 (a no-op).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixXor(*args)
    
    

    try:
        leptonica.pixSubtract.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSubtract.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSubtract not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSubtract(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]   pixd:    [optional]; this can be null, equal to pixs1,
equal to pixs2, or different from both pixs1 and pixs2
:param[in]   pixs1:   can be == pixd
:param[in]   pixs2:   can be == pixd
:returns:  pixd always

<pre>
Notes:
(1) This gives the set subtraction of two images with equal depth,
aligning them to the the UL corner.  pixs1 and pixs2
need not have the same width and height.
(2) Source pixs2 is always subtracted from source pixs1.
The result is
pixs1 \ pixs2 = pixs1 & (~pixs2)
(3) There are 4 cases:
(a) pixd == null,   (src1 - src2) --> new pixd
(b) pixd == pixs1,  (src1 - src2) --> src1  (in-place)
(c) pixd == pixs2,  (src1 - src2) --> src2  (in-place)
(d) pixd != pixs1 && pixd != pixs2),
(src1 - src2) --> input pixd
(4) For clarity, if the case is known, use these patterns:
(a) pixd = pixSubtract(NULL, pixs1, pixs2);
(b) pixSubtract(pixs1, pixs1, pixs2);
(c) pixSubtract(pixs2, pixs1, pixs2);
(d) pixSubtract(pixd, pixs1, pixs2);
(5) The size of the result is determined by pixs1.
(6) The depths of pixs1 and pixs2 must be equal.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSubtract(*args)
    
    

    try:
        leptonica.pixZero.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixZero.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixZero not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixZero(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pempty')       

:param[in]    pix:     all depths; colormap OK
:param[out]   pempty:  1 if all bits in image data field are 0; 0 otherwise
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) For a binary image, if there are no fg (black) pixels, empty = 1.
(2) For a grayscale image, if all pixels are black (0), empty = 1.
(3) For an RGB image, if all 4 components in every pixel is 0,
empty = 1.
(4) For a colormapped image, pixel values are 0.  The colormap
is ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixZero(*args)
    
    

    try:
        leptonica.pixForegroundFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixForegroundFraction.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixForegroundFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixForegroundFraction(*args):
        """
        ('PIX', '*pix')       
('l_float32', '*pfract')       

:param[in]    pix:      1 bpp
:param[out]   pfract:   fraction of ON pixels
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixForegroundFraction(*args)
    
    

    try:
        leptonica.pixaCountPixels.argtypes = [ctypes.c_void_p]
        leptonica.pixaCountPixels.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCountPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCountPixels(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:    array of 1 bpp pix
:returns:  na of ON pixels in each pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCountPixels(*args)
    
    

    try:
        leptonica.pixCountPixels.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixels.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountPixels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixels(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pcount')       
('l_int32', '*tab8')       

:param[in]    pixs:     1 bpp
:param[out]   pcount:   count of ON pixels
:param[in]    tab8:     [optional] 8-bit pixel lookup table
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixels(*args)
    
    

    try:
        leptonica.pixCountPixelsInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixelsInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountPixelsInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', '*pcount')       
('l_int32', '*tab8')       

:param[in]    pixs:     1 bpp
:param[in]    box:      (can be null)
:param[out]   pcount:   count of ON pixels
:param[in]    tab8:     [optional] 8-bit pixel lookup table
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsInRect(*args)
    
    

    try:
        leptonica.pixCountByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountByRow.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCountByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]   pix:   1 bpp
:param[in]   box:   [optional] clipping box for count; can be null
:returns:  na of number of ON pixels by row, or NULL on error

<pre>
Notes:
(1) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountByRow(*args)
    
    

    try:
        leptonica.pixCountByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountByColumn.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCountByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]   pix:   1 bpp
:param[in]   box:   [optional] clipping box for count; can be null
:returns:  na of number of ON pixels by column, or NULL on error

<pre>
Notes:
(1) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountByColumn(*args)
    
    

    try:
        leptonica.pixCountPixelsByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixelsByRow.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCountPixelsByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsByRow(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*tab8')       

:param[in]   pix:   1 bpp
:param[in]   tab8:  [optional] 8-bit pixel lookup table
:returns:  na of counts, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsByRow(*args)
    
    

    try:
        leptonica.pixCountPixelsByColumn.argtypes = [ctypes.c_void_p]
        leptonica.pixCountPixelsByColumn.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCountPixelsByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsByColumn(*args):
        """
        ('PIX', '*pix')       

:param[in]   pix:   1 bpp
:returns:  na of counts in each column, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsByColumn(*args)
    
    

    try:
        leptonica.pixCountPixelsInRow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountPixelsInRow.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountPixelsInRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountPixelsInRow(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'row')       
('l_int32', '*pcount')       
('l_int32', '*tab8')       

:param[in]    pix:     1 bpp
:param[in]    row:     number
:param[out]   pcount:  sum of ON pixels in raster line
:param[in]    tab8:    [optional] 8-bit pixel lookup table
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountPixelsInRow(*args)
    
    

    try:
        leptonica.pixGetMomentByColumn.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetMomentByColumn.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetMomentByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetMomentByColumn(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'order')       

:param[in]   pix:     1 bpp
:param[in]   order:   of moment, either 1 or 2
:returns:  na of first moment of fg pixels, by column, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetMomentByColumn(*args)
    
    

    try:
        leptonica.pixThresholdPixelSum.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdPixelSum.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdPixelSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdPixelSum(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'thresh')       
('l_int32', '*pabove')       
('l_int32', '*tab8')       

:param[in]    pix:      1 bpp
:param[in]    thresh:   threshold
:param[out]   pabove:   1 if above threshold;
0 if equal to or less than threshold
:param[in]    tab8:     [optional] 8-bit pixel lookup table
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This sums the ON pixels and returns immediately if the count
goes above threshold.  It is therefore more efficient
for matching images (by running this function on the xor of
the 2 images) than using pixCountPixels(), which counts all
pixels before returning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdPixelSum(*args)
    
    

    try:
        leptonica.makePixelSumTab8.argtypes = []
        leptonica.makePixelSumTab8.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function makePixelSumTab8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePixelSumTab8(*args):
        """
               

:returns:  table of 256 l_int32.

<pre>
Notes:
(1) This table of integers gives the number of 1 bits
in the 8 bit index.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makePixelSumTab8(*args)
    
    

    try:
        leptonica.makePixelCentroidTab8.argtypes = []
        leptonica.makePixelCentroidTab8.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function makePixelCentroidTab8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makePixelCentroidTab8(*args):
        """
               

:returns:  table of 256 l_int32.

<pre>
Notes:
(1) This table of integers gives the centroid weight of the 1 bits
in the 8 bit index.  In other words, if sumtab is obtained by
makePixelSumTab8, and centroidtab is obtained by
makePixelCentroidTab8, then, for 1 <= i <= 255,
centroidtab[i] / (float)sumtab[i]
is the centroid of the 1 bits in the 8-bit index i, where the
MSB is considered to have position 0 and the LSB is considered
to have position 7.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makePixelCentroidTab8(*args)
    
    

    try:
        leptonica.pixAverageByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAverageByRow.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAverageByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'type')       

:param[in]   pix:    8 or 16 bpp; no colormap
:param[in]   box:    [optional] clipping box for sum; can be null
:param[in]   type:   L_WHITE_IS_MAX, L_BLACK_IS_MAX
:returns:  na of pixel averages by row, or NULL on error

<pre>
Notes:
(1) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
(2) If type == L_BLACK_IS_MAX, black pixels get the maximum
value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageByRow(*args)
    
    

    try:
        leptonica.pixAverageByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAverageByColumn.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAverageByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'type')       

:param[in]   pix:   8 or 16 bpp; no colormap
:param[in]   box:   [optional] clipping box for sum; can be null
:param[in]   type:  L_WHITE_IS_MAX, L_BLACK_IS_MAX
:returns:  na of pixel averages by column, or NULL on error

<pre>
Notes:
(1) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
(2) If type == L_BLACK_IS_MAX, black pixels get the maximum
value (0xff for 8 bpp, 0xffff for 16 bpp) and white get 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageByColumn(*args)
    
    

    try:
        leptonica.pixAverageInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAverageInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAverageInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageInRect(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('BOX', '*box')       
('l_int32', 'minval')       
('l_int32', 'maxval')       
('l_int32', 'subsamp')       
('l_float32', '*pave')       

:param[in]    pixs:     1, 2, 4, 8 bpp; not cmapped
:param[in]    pixm:     [optional] 1 bpp mask; if null, use all pixels
:param[in]    box:      [optional] if null, use entire image
:param[in]    minval:   ignore values less than this
:param[in]    maxval:   ignore values greater than this
:param[in]    subsamp:  subsample factor: integer; use 1 for all pixels
:param[out]   pave:     average of pixel values under consideration
:returns:  0 if OK; 1 on error; 2 if all pixels are filtered out

<pre>
Notes:
(1) The average is computed with 4 optional filters: a rectangle,
a mask, a contiguous set of range values, and subsampling.
In practice you might use only one or two of these.
(2) The mask %pixm is a blocking mask: only count pixels in the bg.
If it exists, alignment is assumed at UL corner and computation
is over the minimum intersection of %pixs and %pixm.
If you want the average of pixels under the mask fg, invert it.
(3) Set the range limits %minval = 0 and %maxval = 255 to use
all non-masked pixels (regardless of value) in the average.
(4) If no pixels are used in the averaging, the returned average
value is 0 and the function returns 2.  This is not an error,
but it says to disregard the returned average value.
(5) For example, to average all pixels in a given clipping rect %box,
pixAverageInRect(pixs, NULL, box, 0, 255, 1, &aveval);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageInRect(*args)
    
    

    try:
        leptonica.pixAverageInRectRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAverageInRectRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAverageInRectRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageInRectRGB(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('BOX', '*box')       
('l_int32', 'subsamp')       
('l_uint32', '*pave')       

:param[in]    pixs:     rgb; not cmapped
:param[in]    pixm:     [optional] 1 bpp mask; if null, use all pixels
:param[in]    box:      [optional] if null, use entire image
:param[in]    subsamp:  subsample factor: integer; use 1 for all pixels
:param[out]   pave:     average color of pixel values under consideration,
in format 0xrrggbb00.
:returns:  0 if OK; 1 on error; 2 if all pixels are filtered out

<pre>
Notes:
(1) The average is computed with 3 optional filters: a rectangle,
a mask, and subsampling.
In practice you might use only one or two of these.
(2) The mask %pixm is a blocking mask: only count pixels in the bg.
If it exists, alignment is assumed at UL corner and computation
is over the minimum intersection of %pixs and %pixm.
If you want the average of pixels under the mask fg, invert it.
(3) If no pixels are used in the averaging, the returned average
value is 0 and the function returns 2.  This is not an error,
but it says to disregard the returned average value.
(4) For example, to average all pixels in a given clipping rect %box,
pixAverageInRectRGB(pixs, NULL, box, 1, &aveval);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageInRectRGB(*args)
    
    

    try:
        leptonica.pixVarianceByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceByRow.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVarianceByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]   pix:   8 or 16 bpp; no colormap
:param[in]   box:   [optional] clipping box for variance; can be null
:returns:  na of rmsdev by row, or NULL on error

<pre>
Notes:
(1) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
(2) We are actually computing the RMS deviation in each row.
This is the square root of the variance.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceByRow(*args)
    
    

    try:
        leptonica.pixVarianceByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceByColumn.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVarianceByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]   pix:   8 or 16 bpp; no colormap
:param[in]   box:   [optional] clipping box for variance; can be null
:returns:  na of rmsdev by column, or NULL on error

<pre>
Notes:
(1) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
(2) We are actually computing the RMS deviation in each row.
This is the square root of the variance.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceByColumn(*args)
    
    

    try:
        leptonica.pixVarianceInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixVarianceInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_float32', '*prootvar')       

:param[in]    pix:       1, 2, 4, 8 bpp; not cmapped
:param[in]    box:       [optional] if null, use entire image
:param[out]   prootvar:  sqrt variance of pixel values in region
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceInRect(*args)
    
    

    try:
        leptonica.pixAbsDiffByRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAbsDiffByRow.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAbsDiffByRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffByRow(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]   pix:   8 bpp; no colormap
:param[in]   box:   [optional] clipping box for region; can be null
:returns:  na of abs val pixel difference averages by row, or NULL on error

<pre>
Notes:
(1) This is an average over differences of adjacent pixels along
each row.
(2) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffByRow(*args)
    
    

    try:
        leptonica.pixAbsDiffByColumn.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAbsDiffByColumn.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAbsDiffByColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffByColumn(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       

:param[in]   pix:   8 bpp; no colormap
:param[in]   box:   [optional] clipping box for region; can be null
:returns:  na of abs val pixel difference averages by column,
or NULL on error

<pre>
Notes:
(1) This is an average over differences of adjacent pixels along
each column.
(2) To resample for a bin size different from 1, use
numaUniformSampling() on the result of this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffByColumn(*args)
    
    

    try:
        leptonica.pixAbsDiffInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAbsDiffInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAbsDiffInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffInRect(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'dir')       
('l_float32', '*pabsdiff')       

:param[in]   pix:       8 bpp; not cmapped
:param[in]   box:       [optional] if null, use entire image
:param[in]   dir:       differences along L_HORIZONTAL_LINE or L_VERTICAL_LINE
:param[out]  pabsdiff:  average of abs diff pixel values in region
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This gives the average over the abs val of differences of
adjacent pixels values, along either each
row:     dir == L_HORIZONTAL_LINE
column:  dir == L_VERTICAL_LINE
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffInRect(*args)
    
    

    try:
        leptonica.pixAbsDiffOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAbsDiffOnLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAbsDiffOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDiffOnLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_float32', '*pabsdiff')       

:param[in]    pix:        8 bpp; not cmapped
:param[in]    x1,: y1     first point; x1 <= x2, y1 <= y2
:param[in]    x2,: y2     first point
:param[out]   pabsdiff:   average of abs diff pixel values on line
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This gives the average over the abs val of differences of
adjacent pixels values, along a line that is either horizontal
or vertical.
(2) If horizontal, require x1 < x2; if vertical, require y1 < y2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDiffOnLine(*args)
    
    

    try:
        leptonica.pixCountArbInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCountArbInRect.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixCountArbInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountArbInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'val')       
('l_int32', 'factor')       
('l_int32', '*pcount')       

:param[in]    pixs:     8 bpp, or colormapped
:param[in]    box:      [optional] over which count is made;
use entire image if NULL
:param[in]    val:      pixel value to count
:param[in]    factor:   subsampling factor; integer >= 1
:param[out]   pcount:   count; estimate it if factor > 1
:returns:  na histogram, or NULL on error

<pre>
Notes:
(1) If pixs is cmapped, %val is compared to the colormap index;
otherwise, %val is compared to the grayscale value.
(2) Set the subsampling %factor > 1 to reduce the amount of computation.
If %factor > 1, multiply the count by %factor * %factor.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountArbInRect(*args)
    
    

    try:
        leptonica.pixMirroredTiling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMirroredTiling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMirroredTiling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMirroredTiling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]   pixs:   8 or 32 bpp, small tile; to be replicated
:param[in]   w,: h   dimensions of output pix
:returns:  pixd usually larger pix, mirror-tiled with pixs,
or NULL on error

<pre>
Notes:
(1) This uses mirrored tiling, where each row alternates
with LR flips and every column alternates with TB
flips, such that the result is a tiling with identical
2 x 2 tiles, each of which is composed of these transforms:
-----------------
| 1    |  LR    |
-----------------
| TB   |  LR/TB |
-----------------
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMirroredTiling(*args)
    
    

    try:
        leptonica.pixFindRepCloseTile.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFindRepCloseTile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindRepCloseTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindRepCloseTile(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'searchdir')       
('l_int32', 'mindist')       
('l_int32', 'tsize')       
('l_int32', 'ntiles')       
('BOX', '**pboxtile')       
('l_int32', 'debug')       

:param[in]    pixs:       32 bpp rgb
:param[in]    box:        region of pixs to search around
:param[in]    searchdir:  L_HORIZ or L_VERT; direction to search
:param[in]    mindist:    min distance of selected tile edge from box; >= 0
:param[in]    tsize:      tile size; > 1; even; typically ~50
:param[in]    ntiles:     number of tiles tested in each row/column
:param[out]   pboxtile:   region of best tile
:param[in]    debug: 1    for debug output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This looks for one or two square tiles with conforming median
intensity and low variance, that is outside but near the input box.
(2) %mindist specifies the gap between the box and the
potential tiles.  The tiles are given an overlap of 50%.
%ntiles specifies the number of tiles that are tested
beyond %mindist for each row or column.
(3) For example, if %mindist = 20, %tilesize = 50 and %ntiles = 3,
a horizontal search to the right will have 3 tiles in each row,
with left edges at 20, 45 and 70 from the right edge of the
input %box.  The number of rows of tiles is determined by
the height of %box and %tsize, with the 50% overlap..
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindRepCloseTile(*args)
    




class readbarcode(object):
    """<pre>

Basic operations to locate and identify the line widths
in 1D barcodes.

Top level
SARRAY          *pixProcessBarcodes()

Next levels
PIXA            *pixExtractBarcodes()
SARRAY          *pixReadBarcodes()
l_int32          pixReadBarcodeWidths()

Location
BOXA            *pixLocateBarcodes()
static PIX      *pixGenerateBarcodeMask()

Extraction and deskew
PIXA            *pixDeskewBarcodes()

Process to get line widths
NUMA            *pixExtractBarcodeWidths1()
NUMA            *pixExtractBarcodeWidths2()
NUMA            *pixExtractBarcodeCrossings()

Average adjacent rasters
static NUMA     *pixAverageRasterScans()

Signal processing for barcode widths
NUMA            *numaQuantizeCrossingsByWidth()
static l_int32   numaGetCrossingDistances()
static NUMA     *numaLocatePeakRanges()
static NUMA     *numaGetPeakCentroids()
static NUMA     *numaGetPeakWidthLUT()
NUMA            *numaQuantizeCrossingsByWindow()
static l_int32   numaEvalBestWidthAndShift()
static l_int32   numaEvalSyncError()


NOTE CAREFULLY: This is "early beta" code.  It has not been tuned
to work robustly on a large database of barcode images.  I'm putting
it out so that people can play with it, find out how it breaks, and
contribute decoders for other barcode formats.  Both the functional
interfaces and ABI will almost certainly change in the coming
few months.  The actual decoder, in bardecode.c, at present only
works on the following codes: Code I2of5, Code 2of5, Code 39, Code 93
Codabar and UPCA.  To add another barcode format, it is necessary
to make changes in readbarcode.h and bardecode.c.
The program prog/barcodetest shows how to run from the top level
(image --> decoded data).
</pre>




"""
    
    try:
        leptonica.pixProcessBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProcessBarcodes.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProcessBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProcessBarcodes(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'format')       
('l_int32', 'method')       
('SARRAY', '**psaw')       
('l_int32', 'debugflag')       

:param[in]    pixs:        any depth
:param[in]    format:      L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...
:param[in]    method:      L_USE_WIDTHS, L_USE_WINDOWS
:param[out]   psaw:        [optional] sarray of bar widths
:param[in]    debugflag:   use 1 to generate debug output
:returns:  sarray text of barcodes, or NULL if none found or on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProcessBarcodes(*args)
    
    

    try:
        leptonica.pixExtractBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBarcodes.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodes(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'debugflag')       

:param[in]    pixs:        8 bpp, no colormap
:param[in]    debugflag:   use 1 to generate debug output
:returns:  pixa  deskewed and cropped barcodes, or NULL if none found
or on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodes(*args)
    
    

    try:
        leptonica.pixReadBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadBarcodes.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadBarcodes(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'format')       
('l_int32', 'method')       
('SARRAY', '**psaw')       
('l_int32', 'debugflag')       

:param[in]    pixa:        of 8 bpp deskewed and cropped barcodes
:param[in]    format:      L_BF_ANY, L_BF_CODEI2OF5, L_BF_CODE93, ...
:param[in]    method:      L_USE_WIDTHS, L_USE_WINDOWS;
:param[out]   psaw:        [optional] sarray of bar widths
:param[in]    debugflag:   use 1 to generate debug output
:returns:  sa   sarray of widths, one string for each barcode found,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadBarcodes(*args)
    
    

    try:
        leptonica.pixReadBarcodeWidths.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReadBarcodeWidths.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadBarcodeWidths not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadBarcodeWidths(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'method')       
('l_int32', 'debugflag')       

:param[in]    pixs:        of 8 bpp deskewed and cropped barcode
:param[in]    method:      L_USE_WIDTHS, L_USE_WINDOWS;
:param[in]    debugflag:   use 1 to generate debug output
:returns:  na   numa of widths (each in set {1,2,3,4}, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadBarcodeWidths(*args)
    
    

    try:
        leptonica.pixLocateBarcodes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixLocateBarcodes.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixLocateBarcodes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLocateBarcodes(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('PIX', '**ppixb')       
('PIX', '**ppixm')       

:param[in]    pixs:     any depth
:param[in]    thresh:   for binarization of edge filter output; typ. 20
:param[out]   ppixb:    [optional] binarized edge filtered input image
:param[out]   ppixm:    [optional] mask over barcodes
:returns:  boxa   location of barcodes, or NULL if none found or on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixLocateBarcodes(*args)
    
    

    try:
        leptonica.pixDeskewBarcode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDeskewBarcode.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDeskewBarcode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDeskewBarcode(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('BOX', '*box')       
('l_int32', 'margin')       
('l_int32', 'threshold')       
('l_float32', '*pangle')       
('l_float32', '*pconf')       

:param[in]    pixs:        input image; 8 bpp
:param[in]    pixb:        binarized edge-filtered input image
:param[in]    box:         identified region containing barcode
:param[in]    margin:      of extra pixels around box to extract
:param[in]    threshold:   for binarization; ~20
:param[out]   pangle:      [optional] in degrees, clockwise is positive
:param[out]   pconf:       [optional] confidence
:returns:  pixd   deskewed barcode, or NULL on error

<pre>
Notes:
(1) The (optional) angle returned is the angle in degrees (cw positive)
necessary to rotate the image so that it is deskewed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDeskewBarcode(*args)
    
    

    try:
        leptonica.pixExtractBarcodeWidths1.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBarcodeWidths1.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractBarcodeWidths1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodeWidths1(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_float32', 'binfract')       
('NUMA', '**pnaehist')       
('NUMA', '**pnaohist')       
('l_int32', 'debugflag')       

:param[in]    pixs:        input image; 8 bpp
:param[in]    thresh:      estimated pixel threshold for crossing
white <--> black; typ. ~120
:param[in]    binfract:    histo binsize as a fraction of minsize; e.g., 0.25
:param[out]   pnaehist:    [optional] histogram of black widths; NULL ok
:param[out]   pnaohist:    [optional] histogram of white widths; NULL ok
:param[in]    debugflag:   use 1 to generate debug output
:returns:  nad   numa of barcode widths in encoded integer units,
or NULL on error

<pre>
Notes:
(1) The widths are alternating black/white, starting with black
and ending with black.
(2) This method uses the widths of the bars directly, in terms
of the (float) number of pixels between transitions.
The histograms of these widths for black and white bars is
generated and interpreted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodeWidths1(*args)
    
    

    try:
        leptonica.pixExtractBarcodeWidths2.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBarcodeWidths2.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractBarcodeWidths2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodeWidths2(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_float32', '*pwidth')       
('NUMA', '**pnac')       
('l_int32', 'debugflag')       

:param[in]    pixs:        input image; 8 bpp
:param[in]    thresh:      estimated pixel threshold for crossing
white <--> black; typ. ~120
:param[out]   pwidth:      [optional] best decoding window width, in pixels
:param[out]   pnac:        [optional] number of transitions in each window
:param[in]    debugflag:   use 1 to generate debug output
:returns:  nad   numa of barcode widths in encoded integer units,
or NULL on error

<pre>
Notes:
(1) The widths are alternating black/white, starting with black
and ending with black.
(2) The optional best decoding window width is the width of the window
that is used to make a decision about whether a transition occurs.
It is approximately the average width in pixels of the narrowest
white and black bars (i.e., those corresponding to unit width).
(3) The optional return signal %nac is a sequence of 0s, 1s,
and perhaps a few 2s, giving the number of crossings in each window.
On the occasion where there is a '2', it is interpreted as
as ending two runs: the previous one and another one that has length 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodeWidths2(*args)
    
    

    try:
        leptonica.pixExtractBarcodeCrossings.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixExtractBarcodeCrossings.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractBarcodeCrossings not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBarcodeCrossings(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'debugflag')       

:param[in]    pixs:        input image; 8 bpp
:param[in]    thresh:      estimated pixel threshold for crossing
white <--> black; typ. ~120
:param[in]    debugflag:   use 1 to generate debug output
:returns:  numa   of crossings, in pixel units, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBarcodeCrossings(*args)
    
    

    try:
        leptonica.numaQuantizeCrossingsByWidth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaQuantizeCrossingsByWidth.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaQuantizeCrossingsByWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaQuantizeCrossingsByWidth(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'binfract')       
('NUMA', '**pnaehist')       
('NUMA', '**pnaohist')       
('l_int32', 'debugflag')       

:param[in]    nas:         numa of crossing locations, in pixel units
:param[in]    binfract:    histo binsize as a fraction of minsize; e.g., 0.25
:param[out]   pnaehist:    [optional] histo of even (black) bar widths
:param[out]   pnaohist:    [optional] histo of odd (white) bar widths
:param[in]    debugflag:   1 to generate plots of histograms of bar widths
:returns:  nad   sequence of widths, in unit sizes, or NULL on error

<pre>
Notes:
(1) This first computes the histogram of black and white bar widths,
binned in appropriate units.  There should be well-defined
peaks, each corresponding to a specific width.  The sequence
of barcode widths (namely, the integers from the set {1,2,3,4})
is returned.
(2) The optional returned histograms are binned in width units
that are inversely proportional to %binfract.  For example,
if %binfract = 0.25, there are 4.0 bins in the distance of
the width of the narrowest bar.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaQuantizeCrossingsByWidth(*args)
    
    

    try:
        leptonica.numaQuantizeCrossingsByWindow.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaQuantizeCrossingsByWindow.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaQuantizeCrossingsByWindow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaQuantizeCrossingsByWindow(*args):
        """
        ('NUMA', '*nas')       
('l_float32', 'ratio')       
('l_float32', '*pwidth')       
('l_float32', '*pfirstloc')       
('NUMA', '**pnac')       
('l_int32', 'debugflag')       

:param[in]    nas:         numa of crossing locations
:param[in]    ratio:       of max window size over min window size in search;
typ. 2.0
:param[out]   pwidth:      [optional] best window width
:param[out]   pfirstloc:   [optional] center of window for first xing
:param[out]   pnac:        [optional] array of window crossings (0, 1, 2)
:param[in]    debugflag:   1 to generate various plots of intermediate results
:returns:  nad   sequence of widths, in unit sizes, or NULL on error

<pre>
Notes:
(1) The minimum size of the window is set by the minimum
distance between zero crossings.
(2) The optional return signal %nac is a sequence of 0s, 1s,
and perhaps a few 2s, giving the number of crossings in each window.
On the occasion where there is a '2', it is interpreted as
ending two runs: the previous one and another one that has length 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaQuantizeCrossingsByWindow(*args)
    




class textops(object):
    """<pre>

Font layout
PIX             *pixAddSingleTextblock()
PIX             *pixAddTextlines()
l_int32          pixSetTextblock()
l_int32          pixSetTextline()
PIXA            *pixaAddTextNumber()
PIXA            *pixaAddTextlines()
l_int32          pixaAddPixWithText()

Text size estimation and partitioning
SARRAY          *bmfGetLineStrings()
NUMA            *bmfGetWordWidths()
l_int32          bmfGetStringWidth()

Text splitting
SARRAY          *splitStringToParagraphs()
static l_int32   stringAllWhitespace()
static l_int32   stringLeadingWhitespace()

This is a simple utility to put text on images.  One font and style
is provided, with a variety of pt sizes.  For example, to put a
line of green 10 pt text on an image, with the beginning baseline
at (50, 50):
L_Bmf  *bmf = bmfCreate(NULL, 10);
const char *textstr = "This is a funny cat";
pixSetTextline(pixs, bmf, textstr, 0x00ff0000, 50, 50, NULL, NULL);

The simplest interfaces for adding text to an image are
pixAddTextlines() and pixAddSingleTextblock().
For example, to add the same text in red, centered, below the image:
Pix *pixd = pixAddTextlines(pixs, bmf, textstr, 0xff000000,
L_ADD_BELOW);  // red text

To add text to all pix in a pixa, generating a new pixa, use
either an sarray to hold the strings for each pix, or use the
strings in the text field of each pix; e.g.,
Pixa *pixa2 = pixaAddTextlines(pixa1, bmf, sa, 0x0000ff00,
L_ADD_LEFT);  // blue text
Pixa *pixa2 = pixaAddTextlines(pixa1, bmf, NULL, 0x00ff0000,
L_ADD_RIGHT);  // green text
</pre>




"""
    
    try:
        leptonica.pixAddSingleTextblock.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixAddSingleTextblock.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddSingleTextblock not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddSingleTextblock(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       
('l_int32', '*poverflow')       

:param[in]    pixs:        input pix; colormap ok
:param[in]    bmf:         bitmap font data
:param[in]    textstr:     [optional] text string to be added
:param[in]    val:         color to set the text
:param[in]    location:    L_ADD_ABOVE, L_ADD_AT_TOP,
L_ADD_AT_BOT, L_ADD_BELOW
:param[out]   poverflow:   [optional] 1 if text overflows allocated
region and is clipped; 0 otherwise
:returns:  pixd   new pix with rendered text, or either a copy,
or NULL on error

<pre>
Notes:
(1) This function paints a set of lines of text over an image.
If %location is L_ADD_ABOVE or L_ADD_BELOW, the pix size
is expanded with a border and rendered over the border.
(2) %val is the pixel value to be painted through the font mask.
It should be chosen to agree with the depth of pixs.
If it is out of bounds, an intermediate value is chosen.
For RGB, use hex notation: 0xRRGGBB00, where RR is the
hex representation of the red intensity, etc.
(3) If textstr == NULL, use the text field in the pix.
(4) If there is a colormap, this does the best it can to use
the requested color, or something similar to it.
(5) Typical usage is for labelling a pix with some text data.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddSingleTextblock(*args)
    
    

    try:
        leptonica.pixAddTextlines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixAddTextlines.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddTextlines(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       

:param[in]    pixs:        input pix; colormap ok
:param[in]    bmf:         bitmap font data
:param[in]    textstr:     [optional] text string to be added
:param[in]    val:         color to set the text
:param[in]    location:    L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT
:returns:  pixd   new pix with rendered text, or either a copy,
or NULL on error

<pre>
Notes:
(1) This function expands an image as required to paint one or
more lines of text adjacent to the image.  If %bmf == NULL,
this returns a copy.  If above or below, the lines are
centered with respect to the image; if left or right, they
are left justified.
(2) %val is the pixel value to be painted through the font mask.
It should be chosen to agree with the depth of pixs.
If it is out of bounds, an intermediate value is chosen.
For RGB, use hex notation: 0xRRGGBB00, where RR is the
hex representation of the red intensity, etc.
(3) If textstr == NULL, use the text field in the pix.  The
text field contains one or most "lines" of text, where newlines
are used as line separators.
(4) If there is a colormap, this does the best it can to use
the requested color, or something similar to it.
(5) Typical usage is for labelling a pix with some text data.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddTextlines(*args)
    
    

    try:
        leptonica.pixSetTextblock.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSetTextblock.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetTextblock not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetTextblock(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_int32', 'wtext')       
('l_int32', 'firstindent')       
('l_int32', '*poverflow')       

:param[in]    pixs:          input image
:param[in]    bmf:           bitmap font data
:param[in]    textstr:       block text string to be set
:param[in]    val:           color to set the text
:param[in]    x0:            left edge for each line of text
:param[in]    y0:            baseline location for the first text line
:param[in]    wtext:         max width of each line of generated text
:param[in]    firstindent:   indentation of first line, in x-widths
:param[out]   poverflow:     [optional] 0 if text is contained in input pix;
1 if it is clipped
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function paints a set of lines of text over an image.
(2) %val is the pixel value to be painted through the font mask.
It should be chosen to agree with the depth of pixs.
If it is out of bounds, an intermediate value is chosen.
For RGB, use hex notation: 0xRRGGBB00, where RR is the
hex representation of the red intensity, etc.
The last two hex digits are 00 (byte value 0), assigned to
the A component.  Note that, as usual, RGBA proceeds from
left to right in the order from MSB to LSB (see pix.h
for details).
(3) If there is a colormap, this does the best it can to use
the requested color, or something similar to it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetTextblock(*args)
    
    

    try:
        leptonica.pixSetTextline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSetTextline.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetTextline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetTextline(*args):
        """
        ('PIX', '*pixs')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_int32', '*pwidth')       
('l_int32', '*poverflow')       

:param[in]    pixs:        input image
:param[in]    bmf:         bitmap font data
:param[in]    textstr:     text string to be set on the line
:param[in]    val:         color to set the text
:param[in]    x0:          left edge for first char
:param[in]    y0:          baseline location for all text on line
:param[out]   pwidth:      [optional] width of generated text
:param[out]   poverflow:   [optional] 0 if text is contained in input pix;
1 if it is clipped
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function paints a line of text over an image.
(2) %val is the pixel value to be painted through the font mask.
It should be chosen to agree with the depth of pixs.
If it is out of bounds, an intermediate value is chosen.
For RGB, use hex notation: 0xRRGGBB00, where RR is the
hex representation of the red intensity, etc.
The last two hex digits are 00 (byte value 0), assigned to
the A component.  Note that, as usual, RGBA proceeds from
left to right in the order from MSB to LSB (see pix.h
for details).
(3) If there is a colormap, this does the best it can to use
the requested color, or something similar to it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetTextline(*args)
    
    

    try:
        leptonica.pixaAddTextNumber.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixaAddTextNumber.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaAddTextNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddTextNumber(*args):
        """
        ('PIXA', '*pixas')       
('L_BMF', '*bmf')       
('NUMA', '*na')       
('l_uint32', 'val')       
('l_int32', 'location')       

:param[in]    pixas:      input pixa; colormap ok
:param[in]    bmf:        bitmap font data
:param[in]    na:         [optional] number array; use 1 ... n if null
:param[in]    val:        color to set the text
:param[in]    location:   L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT
:returns:  pixad   new pixa with rendered numbers, or NULL on error

<pre>
Notes:
(1) Typical usage is for labelling each pix in a pixa with a number.
(2) This function paints numbers external to each pix, in a position
given by %location.  In all cases, the pix is expanded on
on side and the number is painted over white in the added region.
(3) %val is the pixel value to be painted through the font mask.
It should be chosen to agree with the depth of pixs.
If it is out of bounds, an intermediate value is chosen.
For RGB, use hex notation: 0xRRGGBB00, where RR is the
hex representation of the red intensity, etc.
(4) If na == NULL, number each pix sequentially, starting with 1.
(5) If there is a colormap, this does the best it can to use
the requested color, or something similar to it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddTextNumber(*args)
    
    

    try:
        leptonica.pixaAddTextlines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixaAddTextlines.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaAddTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddTextlines(*args):
        """
        ('PIXA', '*pixas')       
('L_BMF', '*bmf')       
('SARRAY', '*sa')       
('l_uint32', 'val')       
('l_int32', 'location')       

:param[in]    pixas:      input pixa; colormap ok
:param[in]    bmf:        bitmap font data
:param[in]    sa:         [optional] sarray; use text embedded in
each pix if null
:param[in]    val:        color to set the text
:param[in]    location:   L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT
:returns:  pixad   new pixa with rendered text, or NULL on error

<pre>
Notes:
(1) This function adds one or more lines of text externally to
each pix, in a position given by %location.  In all cases,
the pix is expanded as necessary to accommodate the text.
(2) %val is the pixel value to be painted through the font mask.
It should be chosen to agree with the depth of pixs.
If it is out of bounds, an intermediate value is chosen.
For RGB, use hex notation: 0xRRGGBB00, where RR is the
hex representation of the red intensity, etc.
(3) If sa == NULL, use the text embedded in each pix.  In all
cases, newlines in the text string are used to separate the
lines of text that are added to the pix.
(4) If sa has a smaller count than pixa, issue a warning
and do not use any embedded text.
(5) If there is a colormap, this does the best it can to use
the requested color, or something similar to it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddTextlines(*args)
    
    

    try:
        leptonica.pixaAddPixWithText.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixaAddPixWithText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaAddPixWithText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddPixWithText(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pixs')       
('l_int32', 'reduction')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       

:param[in]    pixa:
:param[in]    pixs:       any depth, colormap ok
:param[in]    reduction:  integer subsampling factor
:param[in]    bmf:        [optional] bitmap font data
:param[in]    textstr:    [optional] text string to be added
:param[in]    val:        color to set the text
:param[in]    location:   L_ADD_ABOVE, L_ADD_BELOW, L_ADD_LEFT, L_ADD_RIGHT
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This function generates a new pix with added text, and adds
it by insertion into the pixa.
(2) If the input pixs is not cmapped and not 32 bpp, it is
converted to 32 bpp rgb.  %val is a standard 32 bpp pixel,
expressed as 0xrrggbb00.  If there is a colormap, this does
the best it can to use the requested color, or something close.
(3) if %bmf == NULL, generate an 8 pt font; this takes about 5 msec.
(4) If %textstr == NULL, use the text field in the pix.
(5) In general, the text string can be written in multiple lines;
use newlines as the separators.
(6) Typical usage is for debugging, where the pixa of labeled images
is used to generate a pdf.  Suggest using 1.0 for scalefactor.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddPixWithText(*args)
    
    

    try:
        leptonica.bmfGetLineStrings.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.bmfGetLineStrings.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function bmfGetLineStrings not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetLineStrings(*args):
        """
        ('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_int32', 'maxw')       
('l_int32', 'firstindent')       
('l_int32', '*ph')       

:param[in]    bmf:
:param[in]    textstr:
:param[in]    maxw:          max width of a text line in pixels
:param[in]    firstindent:   indentation of first line, in x-widths
:param[out]   ph:            height required to hold text bitmap
:returns:  sarray of text strings for each line, or NULL on error

<pre>
Notes:
(1) Divides the input text string into an array of text strings,
each of which will fit within maxw bits of width.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetLineStrings(*args)
    
    

    try:
        leptonica.bmfGetWordWidths.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.bmfGetWordWidths.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function bmfGetWordWidths not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetWordWidths(*args):
        """
        ('L_BMF', '*bmf')       
('const char', '*textstr')       
('SARRAY', '*sa')       

:param[in]    bmf:
:param[in]    textstr:
:param[in]    sa:        of individual words
:returns:  numa  of word lengths in pixels for the font represented
by the bmf, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetWordWidths(*args)
    
    

    try:
        leptonica.bmfGetStringWidth.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.bmfGetStringWidth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bmfGetStringWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetStringWidth(*args):
        """
        ('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_int32', '*pw')       

:param[in]    bmf:
:param[in]    textstr:
:param[out]   pw:        width of text string, in pixels for the
font represented by the bmf
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetStringWidth(*args)
    
    

    try:
        leptonica.splitStringToParagraphs.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.splitStringToParagraphs.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function splitStringToParagraphs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def splitStringToParagraphs(*args):
        """
        ('char', '*textstr')       
('l_int32', 'splitflag')       

:param[in]    textstr:     text string
:param[in]    splitflag:   see enum in bmf.h; valid values in {1,2,3}
:returns:  sarray  where each string is a paragraph of the input,
or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.splitStringToParagraphs(*args)
    




class bilinear(object):
    """<pre>

Bilinear (4 pt) image transformation using a sampled
(to nearest integer) transform on each dest point
PIX      *pixBilinearSampledPta()
PIX      *pixBilinearSampled()

Bilinear (4 pt) image transformation using interpolation
(or area mapping) for anti-aliasing images that are
2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
PIX      *pixBilinearPta()
PIX      *pixBilinear()
PIX      *pixBilinearPtaColor()
PIX      *pixBilinearColor()
PIX      *pixBilinearPtaGray()
PIX      *pixBilinearGray()

Bilinear transform including alpha (blend) component
PIX      *pixBilinearPtaWithAlpha()

Bilinear coordinate transformation
l_int32   getBilinearXformCoeffs()
l_int32   bilinearXformSampledPt()
l_int32   bilinearXformPt()

A bilinear transform can be specified as a specific functional
mapping between 4 points in the source and 4 points in the dest.
It can be used as an approximation to a (nonlinear) projective
transform, because for small warps it is very similar and
it is more stable.  (Projective transforms have a division
by a quantity that can get arbitrarily small.)

We give both a bilinear coordinate transformation and
a bilinear image transformation.

For the former, we ask for the coordinate value (x',y')
in the transformed space for any point (x,y) in the original
space.  The coefficients of the transformation are found by
solving 8 simultaneous equations for the 8 coordinates of
the 4 points in src and dest.  The transformation can then
be used to compute the associated image transform, by
computing, for each dest pixel, the relevant pixel(s) in
the source.  This can be done either by taking the closest
src pixel to each transformed dest pixel ("sampling") or
by doing an interpolation and averaging over 4 source
pixels with appropriate weightings ("interpolated").

A typical application would be to remove some of the
keystoning due to a projective transform in the imaging system.

The bilinear transform is given by specifying two equations:

x' = ax + by + cxy + d
y' = ex + fy + gxy + h

where the eight coefficients have been computed from four
sets of these equations, each for two corresponding data pts.
In practice, once the coefficients are known, we use the
equations "backwards": for each point (x,y) in the dest image,
these two equations are used to compute the corresponding point
(x',y') in the src.  That computed point in the src is then used
to determine the corresponding dest pixel value in one of two ways:

~ sampling: simply take the value of the src pixel in which this
point falls
~ interpolation: take appropriate linear combinations of the
four src pixels that this dest pixel would
overlap, with the coefficients proportional
to the amount of overlap

For small warp, like rotation, area mapping in the
interpolation is equivalent to linear interpolation.

Typical relative timing of transforms (sampled = 1.0):
8 bpp:   sampled        1.0
interpolated   1.6
32 bpp:  sampled        1.0
interpolated   1.8
Additionally, the computation time/pixel is nearly the same
for 8 bpp and 32 bpp, for both sampled and interpolated.
</pre>




"""
    
    try:
        leptonica.pixBilinearSampledPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinearSampledPta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearSampledPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearSampledPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary.
(2) Retains colormap, which you can do for a sampled transform..
(3) No 3 of the 4 points may be collinear.
(4) For 8 and 32 bpp pix, better quality is obtained by the
somewhat slower pixBilinearPta().  See that
function for relative timings between sampled and interpolated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearSampledPta(*args)
    
    

    try:
        leptonica.pixBilinearSampled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinearSampled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearSampled(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths
:param[in]    vc:        vector of 8 coefficients for bilinear transformation
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary.
(2) Retains colormap, which you can do for a sampled transform..
(3) For 8 or 32 bpp, much better quality is obtained by the
somewhat slower pixBilinear().  See that function
for relative timings between sampled and interpolated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearSampled(*args)
    
    

    try:
        leptonica.pixBilinearPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinearPta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths; colormap ok
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary
(2) Removes any existing colormap, if necessary, before transforming
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPta(*args)
    
    

    try:
        leptonica.pixBilinear.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixBilinear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinear(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       

:param[in]    pixs:       all depths; colormap ok
:param[in]    vc:         vector of 8 coefficients for bilinear transformation
:param[in]    incolor:    L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary
(2) Removes any existing colormap, if necessary, before transforming
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinear(*args)
    
    

    try:
        leptonica.pixBilinearPtaColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixBilinearPtaColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearPtaColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPtaColor(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint32', 'colorval')       

:param[in]    pixs:        32 bpp
:param[in]    ptad:        4 pts of final coordinate space
:param[in]    ptas:        4 pts of initial coordinate space
:param[in]    colorval:    e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPtaColor(*args)
    
    

    try:
        leptonica.pixBilinearColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixBilinearColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint32', 'colorval')       

:param[in]    pixs:       32 bpp
:param[in]    vc:         vector of 8 coefficients for bilinear transformation
:param[in]    colorval:   e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearColor(*args)
    
    

    try:
        leptonica.pixBilinearPtaGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixBilinearPtaGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearPtaGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPtaGray(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint8', 'grayval')       

:param[in]    pixs:       8 bpp
:param[in]    ptad:       4 pts of final coordinate space
:param[in]    ptas:       4 pts of initial coordinate space
:param[in]    grayval:    e.g., 0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPtaGray(*args)
    
    

    try:
        leptonica.pixBilinearGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixBilinearGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint8', 'grayval')       

:param[in]    pixs:      8 bpp
:param[in]    vc:        vector of 8 coefficients for bilinear transformation
:param[in]    grayval:   e.g., 0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearGray(*args)
    
    

    try:
        leptonica.pixBilinearPtaWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixBilinearPtaWithAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilinearPtaWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilinearPtaWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('PIX', '*pixg')       
('l_float32', 'fract')       
('l_int32', 'border')       

:param[in]    pixs:     32 bpp rgb
:param[in]    ptad:     4 pts of final coordinate space
:param[in]    ptas:     4 pts of initial coordinate space
:param[in]    pixg:     [optional] 8 bpp, can be null
:param[in]    fract:    between 0.0 and 1.0, with 0.0 fully transparent
and 1.0 fully opaque
:param[in]    border:   of pixels added to capture transformed source pixels
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The alpha channel is transformed separately from pixs,
and aligns with it, being fully transparent outside the
boundary of the transformed pixs.  For pixels that are fully
transparent, a blending function like pixBlendWithGrayMask()
will give zero weight to corresponding pixels in pixs.
(2) If %pixg is NULL, it is generated as an alpha layer that is
partially opaque, using %fract.  Otherwise, it is cropped
to %pixs if required and %fract is ignored.  The alpha channel
in %pixs is never used.
(3) Colormaps are removed.
(4) When pixs is transformed, it doesn't matter what color is brought
in because the alpha channel will be transparent (0) there.
(5) To avoid losing source pixels in the destination, it may be
necessary to add a border to the source pix before doing
the bilinear transformation.  This can be any non-negative number.
(6) The input %ptad and %ptas are in a coordinate space before
the border is added.  Internally, we compensate for this
before doing the bilinear transform on the image after
the border is added.
(7) The default setting for the border values in the alpha channel
is 0 (transparent) for the outermost ring of pixels and
(0.5 * fract * 255) for the second ring.  When blended over
a second image, this
(a) shrinks the visible image to make a clean overlap edge
with an image below, and
(b) softens the edges by weakening the aliasing there.
Use l_setAlphaMaskBorder() to change these values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilinearPtaWithAlpha(*args)
    
    

    try:
        leptonica.getBilinearXformCoeffs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getBilinearXformCoeffs.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getBilinearXformCoeffs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getBilinearXformCoeffs(*args):
        """
        ('PTA', '*ptas')       
('PTA', '*ptad')       
('l_float32', '**pvc')       

:param[in]    ptas:    source 4 points; unprimed
:param[in]    ptad:    transformed 4 points; primed
:param[out]   pvc:     vector of coefficients of transform
:returns:  0 if OK; 1 on error

<pre>
We have a set of 8 equations, describing the bilinear
transformation that takes 4 points ptas into 4 other
points ptad.  These equations are:

x1' = c[0]*x1 + c[1]*y1 + c[2]*x1*y1 + c[3]
y1' = c[4]*x1 + c[5]*y1 + c[6]*x1*y1 + c[7]
x2' = c[0]*x2 + c[1]*y2 + c[2]*x2*y2 + c[3]
y2' = c[4]*x2 + c[5]*y2 + c[6]*x2*y2 + c[7]
x3' = c[0]*x3 + c[1]*y3 + c[2]*x3*y3 + c[3]
y3' = c[4]*x3 + c[5]*y3 + c[6]*x3*y3 + c[7]
x4' = c[0]*x4 + c[1]*y4 + c[2]*x4*y4 + c[3]
y4' = c[4]*x4 + c[5]*y4 + c[6]*x4*y4 + c[7]

This can be represented as

AC = B

where B and C are column vectors

B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]

and A is the 8x8 matrix

x1   y1   x1*y1   1   0    0      0     0
0    0     0     0   x1   y1   x1*y1   1
x2   y2   x2*y2   1   0    0      0     0
0    0     0     0   x2   y2   x2*y2   1
x3   y3   x3*y3   1   0    0      0     0
0    0     0     0   x3   y3   x3*y3   1
x4   y4   x4*y4   1   0    0      0     0
0    0     0     0   x4   y4   x4*y4   1

These eight equations are solved here for the coefficients C.

These eight coefficients can then be used to find the mapping
x,y) --> (x',y':

x' = c[0]x + c[1]y + c[2]xy + c[3]
y' = c[4]x + c[5]y + c[6]xy + c[7]

that are implemented in bilinearXformSampledPt and
bilinearXFormPt.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getBilinearXformCoeffs(*args)
    
    

    try:
        leptonica.bilinearXformSampledPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bilinearXformSampledPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bilinearXformSampledPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bilinearXformSampledPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       

:param[in]    vc:         vector of 8 coefficients
:param[in]    x,: y       initial point
:param[out]   pxp,: pyp   transformed point
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds the nearest pixel coordinates of the transformed point.
(2) It does not check ptrs for returned data!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bilinearXformSampledPt(*args)
    
    

    try:
        leptonica.bilinearXformPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.bilinearXformPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bilinearXformPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bilinearXformPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pxp')       
('l_float32', '*pyp')       

:param[in]    vc:           vector of 8 coefficients
:param[in]    x,: y         initial point
:param[out]   pxp,: pyp     transformed point
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This computes the floating point location of the transformed point.
(2) It does not check ptrs for returned data!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bilinearXformPt(*args)
    




class convolve(object):
    """<pre>

Top level grayscale or color block convolution
PIX          *pixBlockconv()

Grayscale block convolution
PIX          *pixBlockconvGray()
static void   blockconvLow()

Accumulator for 1, 8 and 32 bpp convolution
PIX          *pixBlockconvAccum()
static void   blockconvAccumLow()

Un-normalized grayscale block convolution
PIX          *pixBlockconvGrayUnnormalized()

Tiled grayscale or color block convolution
PIX          *pixBlockconvTiled()
PIX          *pixBlockconvGrayTile()

Convolution for mean, mean square, variance and rms deviation
in specified window
l_int32       pixWindowedStats()
PIX          *pixWindowedMean()
PIX          *pixWindowedMeanSquare()
l_int32       pixWindowedVariance()
DPIX         *pixMeanSquareAccum()

Binary block sum and rank filter
PIX          *pixBlockrank()
PIX          *pixBlocksum()
static void   blocksumLow()

Census transform
PIX          *pixCensusTransform()

Generic convolution (with Pix)
PIX          *pixConvolve()
PIX          *pixConvolveSep()
PIX          *pixConvolveRGB()
PIX          *pixConvolveRGBSep()

Generic convolution (with float arrays)
FPIX         *fpixConvolve()
FPIX         *fpixConvolveSep()

Convolution with bias (for non-negative output)
PIX          *pixConvolveWithBias()

Set parameter for convolution subsampling
void          l_setConvolveSampling()

Additive gaussian noise
PIX          *pixAddGaussNoise()
l_float32     gaussDistribSampling()
</pre>




"""
    
    try:
        leptonica.pixBlockconv.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconv.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockconv not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconv(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'wc')       
('l_int32', 'hc')       

:param[in]    pix: 8    or 32 bpp; or 2, 4 or 8 bpp with colormap
:param[in]    wc,: hc   half width/height of convolution kernel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1)
(2) Returns a copy if both wc and hc are 0
(3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
where (w,h) are the dimensions of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconv(*args)
    
    

    try:
        leptonica.pixBlockconvGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockconvGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       

:param[in]    pixs:     8 bpp
:param[in]    pixacc:   pix 32 bpp; can be null
:param[in]    wc,: hc   half width/height of convolution kernel
:returns:  pix 8 bpp, or NULL on error

<pre>
Notes:
(1) If accum pix is null, make one and destroy it before
returning; otherwise, just use the input accum pix.
(2) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1).
(3) Returns a copy if both wc and hc are 0.
(4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
where (w,h) are the dimensions of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvGray(*args)
    
    

    try:
        leptonica.pixBlockconvAccum.argtypes = [ctypes.c_void_p]
        leptonica.pixBlockconvAccum.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockconvAccum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvAccum(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1, 8 or 32 bpp
:returns:  accum pix 32 bpp, or NULL on error.

<pre>
Notes:
(1) The general recursion relation is
a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
For the first line, this reduces to the special case
a(i,j) = v(i,j) + a(i, j-1)
For the first column, the special case is
a(i,j) = v(i,j) + a(i-1, j)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvAccum(*args)
    
    

    try:
        leptonica.pixBlockconvGrayUnnormalized.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvGrayUnnormalized.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockconvGrayUnnormalized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvGrayUnnormalized(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       

:param[in]    pixs:     8 bpp
:param[in]    wc,: hc   half width/height of convolution kernel
:returns:  pix 32 bpp; containing the convolution without normalizing
for the window size, or NULL on error

<pre>
Notes:
(1) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1).
(2) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
where (w,h) are the dimensions of pixs.
(3) Returns a copy if both wc and hc are 0.
(3) Adds mirrored border to avoid treating the boundary pixels
specially.  Note that we add wc + 1 pixels to the left
and wc to the right.  The added width is 2 * wc + 1 pixels,
and the particular choice simplifies the indexing in the loop.
Likewise, add hc + 1 pixels to the top and hc to the bottom.
(4) To get the normalized result, divide by the area of the
convolution kernel: (2 * wc + 1) * (2 * hc + 1)
Specifically, do this:
pixc = pixBlockconvGrayUnnormalized(pixs, wc, hc);
fract = 1. / ((2 * wc + 1) * (2 * hc + 1));
pixMultConstantGray(pixc, fract);
pixd = pixGetRGBComponent(pixc, L_ALPHA_CHANNEL);
(5) Unlike pixBlockconvGray(), this always computes the accumulation
pix because its size is tied to wc and hc.
(6) Compare this implementation with pixBlockconvGray(), where
most of the code in blockconvLow() is special casing for
efficiently handling the boundary.  Here, the use of
mirrored borders and destination indexing makes the
implementation very simple.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvGrayUnnormalized(*args)
    
    

    try:
        leptonica.pixBlockconvTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvTiled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockconvTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvTiled(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'nx')       
('l_int32', 'ny')       

:param[in]    pix:      8 or 32 bpp; or 2, 4 or 8 bpp with colormap
:param[in]    wc,: hc   half width/height of convolution kernel
:param[in]    nx,: ny   subdivision into tiles
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1)
(2) Returns a copy if both wc and hc are 0
(3) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
where (w,h) are the dimensions of pixs.
(4) For nx == ny == 1, this defaults to pixBlockconv(), which
is typically about twice as fast, and gives nearly
identical results as pixBlockconvGrayTile().
(5) If the tiles are too small, nx and/or ny are reduced
a minimum amount so that the tiles are expanded to the
smallest workable size in the problematic direction(s).
(6) Why a tiled version?  Three reasons:
(a) Because the accumulator is a uint32, overflow can occur
for an image with more than 16M pixels.
(b) The accumulator array for 16M pixels is 64 MB; using
tiles reduces the size of this array.
(c) Each tile can be processed independently, in parallel,
on a multicore processor.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvTiled(*args)
    
    

    try:
        leptonica.pixBlockconvGrayTile.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlockconvGrayTile.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockconvGrayTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockconvGrayTile(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       

:param[in]    pixs:     8 bpp gray
:param[in]    pixacc:   32 bpp accum pix
:param[in]    wc,: hc   half width/height of convolution kernel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1)
(2) Assumes that the input pixs is padded with (wc + 1) pixels on
left and right, and with (hc + 1) pixels on top and bottom.
The returned pix has these stripped off; they are only used
for computation.
(3) Returns a copy if both wc and hc are 0
(4) Require that w > 2 * wc + 1 and h > 2 * hc + 1,
where (w,h) are the dimensions of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockconvGrayTile(*args)
    
    

    try:
        leptonica.pixWindowedStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWindowedStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWindowedStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'hasborder')       
('PIX', '**ppixm')       
('PIX', '**ppixms')       
('FPIX', '**pfpixv')       
('FPIX', '**pfpixrv')       

:param[in]    pixs:        8 bpp grayscale
:param[in]    wc,: hc      half width/height of convolution kernel
:param[in]    hasborder:   use 1 if it already has (wc + 1 border pixels
on left and right, and hc + 1 on top and bottom;
use 0 to add kernel-dependent border)
:param[out]   ppixm:       [optional] 8 bpp mean value in window
:param[out]   ppixms:      [optional] 32 bpp mean square value in window
:param[out]   pfpixv:      [optional] float variance in window
:param[out]   pfpixrv:     [optional] float rms deviation from the mean
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a high-level convenience function for calculating
any or all of these derived images.
(2) If %hasborder = 0, a border is added and the result is
computed over all pixels in pixs.  Otherwise, no border is
added and the border pixels are removed from the output images.
(3) These statistical measures over the pixels in the
rectangular window are:
~ average value: <p>  (pixm)
~ average squared value: <p*p> (pixms)
~ variance: <(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>  (pixv)
~ square-root of variance: (pixrv)
where the brackets < .. > indicate that the average value is
to be taken over the window.
(4) Note that the variance is just the mean square difference from
the mean value; and the square root of the variance is the
root mean square difference from the mean, sometimes also
called the 'standard deviation'.
(5) The added border, along with the use of an accumulator array,
allows computation without special treatment of pixels near
the image boundary, and runs in a time that is independent
of the size of the convolution kernel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedStats(*args)
    
    

    try:
        leptonica.pixWindowedMean.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWindowedMean.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixWindowedMean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedMean(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'hasborder')       
('l_int32', 'normflag')       

:param[in]    pixs:        8 or 32 bpp grayscale
:param[in]    wc,: hc      half width/height of convolution kernel
:param[in]    hasborder:   use 1 if it already has (wc + 1 border pixels
on left and right, and hc + 1 on top and bottom;
use 0 to add kernel-dependent border)
:param[in]    normflag:    1 for normalization to get average in window;
0 for the sum in the window (un-normalized)
:returns:  pixd 8 or 32 bpp, average over kernel window

<pre>
Notes:
(1) The input and output depths are the same.
(2) A set of border pixels of width (wc + 1) on left and right,
and of height (hc + 1) on top and bottom, must be on the
pix before the accumulator is found.  The output pixd
(after convolution) has this border removed.
If %hasborder = 0, the required border is added.
(3) Typically, %normflag == 1.  However, if you want the sum
within the window, rather than a normalized convolution,
use %normflag == 0.
(4) This builds a block accumulator pix, uses it here, and
destroys it.
(5) The added border, along with the use of an accumulator array,
allows computation without special treatment of pixels near
the image boundary, and runs in a time that is independent
of the size of the convolution kernel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedMean(*args)
    
    

    try:
        leptonica.pixWindowedMeanSquare.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWindowedMeanSquare.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixWindowedMeanSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedMeanSquare(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'hasborder')       

:param[in]    pixs:        8 bpp grayscale
:param[in]    wc,: hc      half width/height of convolution kernel
:param[in]    hasborder:   use 1 if it already has (wc + 1 border pixels
on left and right, and hc + 1 on top and bottom;
use 0 to add kernel-dependent border)
:returns:  pixd    32 bpp, average over rectangular window of
width = 2 * wc + 1 and height = 2 * hc + 1

<pre>
Notes:
(1) A set of border pixels of width (wc + 1) on left and right,
and of height (hc + 1) on top and bottom, must be on the
pix before the accumulator is found.  The output pixd
(after convolution) has this border removed.
If %hasborder = 0, the required border is added.
(2) The advantage is that we are unaffected by the boundary, and
it is not necessary to treat pixels within %wc and %hc of the
border differently.  This is because processing for pixd
only takes place for pixels in pixs for which the
kernel is entirely contained in pixs.
(3) Why do we have an added border of width (%wc + 1) and
height (%hc + 1), when we only need %wc and %hc pixels
to satisfy this condition?  Answer: the accumulators
are asymmetric, requiring an extra row and column of
pixels at top and left to work accurately.
(4) The added border, along with the use of an accumulator array,
allows computation without special treatment of pixels near
the image boundary, and runs in a time that is independent
of the size of the convolution kernel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedMeanSquare(*args)
    
    

    try:
        leptonica.pixWindowedVariance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWindowedVariance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWindowedVariance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedVariance(*args):
        """
        ('PIX', '*pixm')       
('PIX', '*pixms')       
('FPIX', '**pfpixv')       
('FPIX', '**pfpixrv')       

:param[in]    pixm:      mean over window; 8 or 32 bpp grayscale
:param[in]    pixms:     mean square over window; 32 bpp
:param[out]   pfpixv:    [optional] float variance -- the ms deviation
from the mean
:param[out]   pfpixrv:   [optional] float rms deviation from the mean
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The mean and mean square values are precomputed, using
pixWindowedMean() and pixWindowedMeanSquare().
(2) Either or both of the variance and square-root of variance
are returned as an fpix, where the variance is the
average over the window of the mean square difference of
the pixel value from the mean:
<(p - <p>)*(p - <p>)> = <p*p> - <p>*<p>
(3) To visualize the results:
~ for both, use fpixDisplayMaxDynamicRange().
~ for rms deviation, simply convert the output fpix to pix,
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedVariance(*args)
    
    

    try:
        leptonica.pixMeanSquareAccum.argtypes = [ctypes.c_void_p]
        leptonica.pixMeanSquareAccum.restype = lambda address: DPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMeanSquareAccum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeanSquareAccum(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    8 bpp grayscale
:returns:  dpix   64 bit array, or NULL on error

<pre>
Notes:
(1) Similar to pixBlockconvAccum(), this computes the
sum of the squares of the pixel values in such a way
that the value at (i,j) is the sum of all squares in
the rectangle from the origin to (i,j).
(2) The general recursion relation (v are squared pixel values) is
a(i,j) = v(i,j) + a(i-1, j) + a(i, j-1) - a(i-1, j-1)
For the first line, this reduces to the special case
a(i,j) = v(i,j) + a(i, j-1)
For the first column, the special case is
a(i,j) = v(i,j) + a(i-1, j)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeanSquareAccum(*args)
    
    

    try:
        leptonica.pixBlockrank.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixBlockrank.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockrank not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockrank(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_float32', 'rank')       

:param[in]    pixs:     1 bpp
:param[in]    pixacc:   pix [optional] 32 bpp
:param[in]    wc,: hc   half width/height of block sum/rank kernel
:param[in]    rank:     between 0.0 and 1.0; 0.5 is median filter
:returns:  pixd 1 bpp

<pre>
Notes:
(1) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1)
(2) This returns a pixd where each pixel is a 1 if the
neighborhood (2 * wc + 1) x (2 * hc + 1)) pixels
contains the rank fraction of 1 pixels.  Otherwise,
the returned pixel is 0.  Note that the special case
of rank = 0.0 is always satisfied, so the returned
pixd has all pixels with value 1.
(3) If accum pix is null, make one, use it, and destroy it
before returning; otherwise, just use the input accum pix
(4) If both wc and hc are 0, returns a copy unless rank == 0.0,
in which case this returns an all-ones image.
(5) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
where (w,h) are the dimensions of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockrank(*args)
    
    

    try:
        leptonica.pixBlocksum.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlocksum.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlocksum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlocksum(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixacc')       
('l_int32', 'wc')       
('l_int32', 'hc')       

:param[in]    pixs:     1 bpp
:param[in]    pixacc:   pix [optional] 32 bpp
:param[in]    wc,: hc   half width/height of block sum/rank kernel
:returns:  pixd 8 bpp

<pre>
Notes:
(1) If accum pix is null, make one and destroy it before
returning; otherwise, just use the input accum pix
(2) The full width and height of the convolution kernel
are (2 * wc + 1) and (2 * hc + 1)
(3) Use of wc = hc = 1, followed by pixInvert() on the
8 bpp result, gives a nice anti-aliased, and somewhat
darkened, result on text.
(4) Require that w >= 2 * wc + 1 and h >= 2 * hc + 1,
where (w,h) are the dimensions of pixs.
(5) Returns in each dest pixel the sum of all src pixels
that are within a block of size of the kernel, centered
on the dest pixel.  This sum is the number of src ON
pixels in the block at each location, normalized to 255
for a block containing all ON pixels.  For pixels near
the boundary, where the block is not entirely contained
within the image, we then multiply by a second normalization
factor that is greater than one, so that all results
are normalized by the number of participating pixels
within the block.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlocksum(*args)
    
    

    try:
        leptonica.pixCensusTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCensusTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCensusTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCensusTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfsize')       
('PIX', '*pixacc')       

:param[in]    pixs:       8 bpp
:param[in]    halfsize:   of square over which neighbors are averaged
:param[in]    pixacc:     [optional] 32 bpp pix
:returns:  pixd 1 bpp

<pre>
Notes:
(1) The Census transform was invented by Ramin Zabih and John Woodfill
("Non-parametric local transforms for computing visual
correspondence", Third European Conference on Computer Vision,
Stockholm, Sweden, May 1994); see publications at
http://www.cs.cornell.edu/~rdz/index.htm
This compares each pixel against the average of its neighbors,
in a square of odd dimension centered on the pixel.
If the pixel is greater than the average of its neighbors,
the output pixel value is 1; otherwise it is 0.
(2) This can be used as an encoding for an image that is
fairly robust against slow illumination changes, with
applications in image comparison and mosaicing.
(3) The size of the convolution kernel is (2 * halfsize + 1)
on a side.  The halfsize parameter must be >= 1.
(4) If accum pix is null, make one, use it, and destroy it
before returning; otherwise, just use the input accum pix
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCensusTransform(*args)
    
    

    try:
        leptonica.pixConvolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvolve.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvolve not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolve(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel')       
('l_int32', 'outdepth')       
('l_int32', 'normflag')       

:param[in]    pixs:       8, 16, 32 bpp; no colormap
:param[in]    kel:        kernel
:param[in]    outdepth:   of pixd: 8, 16 or 32
:param[in]    normflag:   1 to normalize kernel to unit sum; 0 otherwise
:returns:  pixd 8, 16 or 32 bpp

<pre>
Notes:
(1) This gives a convolution with an arbitrary kernel.
(2) The input pixs must have only one sample/pixel.
To do a convolution on an RGB image, use pixConvolveRGB().
(3) The parameter %outdepth determines the depth of the result.
If the kernel is normalized to unit sum, the output values
can never exceed 255, so an output depth of 8 bpp is sufficient.
If the kernel is not normalized, it may be necessary to use
16 or 32 bpp output to avoid overflow.
(4) If normflag == 1, the result is normalized by scaling all
kernel values for a unit sum.  If the sum of kernel values
is very close to zero, the kernel can not be normalized and
the convolution will not be performed.  A warning is issued.
(5) The kernel values can be positive or negative, but the
result for the convolution can only be stored as a positive
number.  Consequently, if it goes negative, the choices are
to clip to 0 or take the absolute value.  We're choosing
to take the absolute value.  (Another possibility would be
to output a second unsigned image for the negative values.)
If you want to get a clipped result, or to keep the negative
values in the result, use fpixConvolve(), with the
converters in fpix2.c between pix and fpix.
(6) This uses a mirrored border to avoid special casing on
the boundaries.
(7) To get a subsampled output, call l_setConvolveSampling().
The time to make a subsampled output is reduced by the
product of the sampling factors.
(8) The function is slow, running at about 12 machine cycles for
each pixel-op in the convolution.  For example, with a 3 GHz
cpu, a 1 Mpixel grayscale image, and a kernel with
(sx * sy) = 25 elements, the convolution takes about 100 msec.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolve(*args)
    
    

    try:
        leptonica.pixConvolveSep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvolveSep.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvolveSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveSep(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kelx')       
('L_KERNEL', '*kely')       
('l_int32', 'outdepth')       
('l_int32', 'normflag')       

:param[in]    pixs:       8, 16, 32 bpp; no colormap
:param[in]    kelx:       x-dependent kernel
:param[in]    kely:       y-dependent kernel
:param[in]    outdepth:   of pixd: 8, 16 or 32
:param[in]    normflag:   1 to normalize kernel to unit sum; 0 otherwise
:returns:  pixd    8, 16 or 32 bpp

<pre>
Notes:
(1) This does a convolution with a separable kernel that is
is a sequence of convolutions in x and y.  The two
one-dimensional kernel components must be input separately;
the full kernel is the product of these components.
The support for the full kernel is thus a rectangular region.
(2) The input pixs must have only one sample/pixel.
To do a convolution on an RGB image, use pixConvolveSepRGB().
(3) The parameter %outdepth determines the depth of the result.
If the kernel is normalized to unit sum, the output values
can never exceed 255, so an output depth of 8 bpp is sufficient.
If the kernel is not normalized, it may be necessary to use
16 or 32 bpp output to avoid overflow.
(2) The %normflag parameter is used as in pixConvolve().
(4) The kernel values can be positive or negative, but the
result for the convolution can only be stored as a positive
number.  Consequently, if it goes negative, the choices are
to clip to 0 or take the absolute value.  We're choosing
the former for now.  Another possibility would be to output
a second unsigned image for the negative values.
(5) Warning: if you use l_setConvolveSampling() to get a
subsampled output, and the sampling factor is larger than
the kernel half-width, it is faster to use the non-separable
version pixConvolve().  This is because the first convolution
here must be done on every raster line, regardless of the
vertical sampling factor.  If the sampling factor is smaller
than kernel half-width, it's faster to use the separable
convolution.
(6) This uses mirrored borders to avoid special casing on
the boundaries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveSep(*args)
    
    

    try:
        leptonica.pixConvolveRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvolveRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvolveRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveRGB(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel')       

:param[in]    pixs:   32 bpp rgb
:param[in]    kel:    kernel
:returns:  pixd   32 bpp rgb

<pre>
Notes:
(1) This gives a convolution on an RGB image using an
arbitrary kernel (which we normalize to keep each
component within the range [0 ... 255].
(2) The input pixs must be RGB.
(3) The kernel values can be positive or negative, but the
result for the convolution can only be stored as a positive
number.  Consequently, if it goes negative, we clip the
result to 0.
(4) To get a subsampled output, call l_setConvolveSampling().
The time to make a subsampled output is reduced by the
product of the sampling factors.
(5) This uses a mirrored border to avoid special casing on
the boundaries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveRGB(*args)
    
    

    try:
        leptonica.pixConvolveRGBSep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvolveRGBSep.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvolveRGBSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveRGBSep(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kelx')       
('L_KERNEL', '*kely')       

:param[in]    pixs:   32 bpp rgb
:param[in]    kelx:   x-dependent kernel
:param[in]    kely:   y-dependent kernel
:returns:  pixd 32 bpp rgb

<pre>
Notes:
(1) This does a convolution on an RGB image using a separable
kernel that is a sequence of convolutions in x and y.  The two
one-dimensional kernel components must be input separately;
the full kernel is the product of these components.
The support for the full kernel is thus a rectangular region.
(2) The kernel values can be positive or negative, but the
result for the convolution can only be stored as a positive
number.  Consequently, if it goes negative, we clip the
result to 0.
(3) To get a subsampled output, call l_setConvolveSampling().
The time to make a subsampled output is reduced by the
product of the sampling factors.
(4) This uses a mirrored border to avoid special casing on
the boundaries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveRGBSep(*args)
    
    

    try:
        leptonica.fpixConvolve.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixConvolve.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixConvolve not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvolve(*args):
        """
        ('FPIX', '*fpixs')       
('L_KERNEL', '*kel')       
('l_int32', 'normflag')       

:param[in]    fpixs:      32 bit float array
:param[in]    kel:        kernel
:param[in]    normflag:   1 to normalize kernel to unit sum; 0 otherwise
:returns:  fpixd 32 bit float array

<pre>
Notes:
(1) This gives a float convolution with an arbitrary kernel.
(2) If normflag == 1, the result is normalized by scaling all
kernel values for a unit sum.  If the sum of kernel values
is very close to zero, the kernel can not be normalized and
the convolution will not be performed.  A warning is issued.
(3) With the FPix, there are no issues about negative
array or kernel values.  The convolution is performed
with single precision arithmetic.
(4) To get a subsampled output, call l_setConvolveSampling().
The time to make a subsampled output is reduced by the
product of the sampling factors.
(5) This uses a mirrored border to avoid special casing on
the boundaries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvolve(*args)
    
    

    try:
        leptonica.fpixConvolveSep.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.fpixConvolveSep.restype = lambda address: FPIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixConvolveSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixConvolveSep(*args):
        """
        ('FPIX', '*fpixs')       
('L_KERNEL', '*kelx')       
('L_KERNEL', '*kely')       
('l_int32', 'normflag')       

:param[in]    fpixs:      32 bit float array
:param[in]    kelx:       x-dependent kernel
:param[in]    kely:       y-dependent kernel
:param[in]    normflag:   1 to normalize kernel to unit sum; 0 otherwise
:returns:  fpixd    32 bit float array

<pre>
Notes:
(1) This does a convolution with a separable kernel that is
is a sequence of convolutions in x and y.  The two
one-dimensional kernel components must be input separately;
the full kernel is the product of these components.
The support for the full kernel is thus a rectangular region.
(2) The normflag parameter is used as in fpixConvolve().
(3) Warning: if you use l_setConvolveSampling() to get a
subsampled output, and the sampling factor is larger than
the kernel half-width, it is faster to use the non-separable
version pixConvolve().  This is because the first convolution
here must be done on every raster line, regardless of the
vertical sampling factor.  If the sampling factor is smaller
than kernel half-width, it's faster to use the separable
convolution.
(4) This uses mirrored borders to avoid special casing on
the boundaries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixConvolveSep(*args)
    
    

    try:
        leptonica.pixConvolveWithBias.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixConvolveWithBias.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvolveWithBias not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvolveWithBias(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel1')       
('L_KERNEL', '*kel2')       
('l_int32', 'force8')       
('l_int32', '*pbias')       

:param[in]    pixs:     8 bpp; no colormap
:param[in]    kel1:
:param[in]    kel2:     can be null; use if separable
:param[in]    force8:   if 1, force output to 8 bpp; otherwise, determine
output depth by the dynamic range of pixel values
:param[out]   pbias:    applied bias
:returns:  pixd 8 or 16 bpp

<pre>
Notes:
(1) This does a convolution with either a single kernel or
a pair of separable kernels, and automatically applies whatever
bias (shift) is required so that the resulting pixel values
are non-negative.
(2) The kernel is always normalized.  If there are no negative
values in the kernel, a standard normalized convolution is
performed, with 8 bpp output.  If the sum of kernel values is
very close to zero, the kernel can not be normalized and
the convolution will not be performed.  An error message results.
(3) If there are negative values in the kernel, the pix is
converted to an fpix, the convolution is done on the fpix, and
a bias (shift) may need to be applied.
(4) If force8 == TRUE and the range of values after the convolution
is > 255, the output values will be scaled to fit in [0 ... 255].
If force8 == FALSE, the output will be either 8 or 16 bpp,
to accommodate the dynamic range of output values without scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvolveWithBias(*args)
    
    

    try:
        leptonica.l_setConvolveSampling.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.l_setConvolveSampling.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setConvolveSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setConvolveSampling(*args):
        """
        ('l_int32', 'xfact')       
('l_int32', 'yfact')       


:param[in]    xfact,: yfact     integer >= 1
:returns:  void

<pre>
Notes:
(1) This sets the x and y output subsampling factors for generic pix
and fpix convolution.  The default values are 1 (no subsampling).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_setConvolveSampling(*args)
    
    

    try:
        leptonica.pixAddGaussianNoise.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixAddGaussianNoise.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddGaussianNoise not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddGaussianNoise(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'stdev')       

:param[in]    pixs:     8 bpp gray or 32 bpp rgb; no colormap
:param[in]    stdev:    of noise
:returns:  pixd    8 or 32 bpp, or NULL on error

<pre>
Notes:
(1) This adds noise to each pixel, taken from a normal
distribution with zero mean and specified standard deviation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddGaussianNoise(*args)
    
    

    try:
        leptonica.gaussDistribSampling.argtypes = []
        leptonica.gaussDistribSampling.restype = ctypes.c_float
    except AttributeError:
        sys.stderr.write("Warning - function gaussDistribSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def gaussDistribSampling(*args):
        """
               

:returns:   gaussian distributed variable with zero mean and unit stdev

<pre>
Notes:
(1) For an explanation of the Box-Muller method for generating
a normally distributed random variable with zero mean and
unit standard deviation, see Numerical Recipes in C,
2nd edition, p. 288ff.
(2) This can be called sequentially to get samples that can be
used for adding noise to each pixel of an image, for example.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.gaussDistribSampling(*args)
    




class pix4(object):
    """<pre>

This file has these operations:

(1) Pixel histograms
(2) Pixel row/column statistics
(3) Foreground/background estimation

Pixel histogram, rank val, averaging and min/max
NUMA       *pixGetGrayHistogram()
NUMA       *pixGetGrayHistogramMasked()
NUMA       *pixGetGrayHistogramInRect()
NUMAA      *pixGetGrayHistogramTiled()
l_int32     pixGetColorHistogram()
l_int32     pixGetColorHistogramMasked()
NUMA       *pixGetCmapHistogram()
NUMA       *pixGetCmapHistogramMasked()
NUMA       *pixGetCmapHistogramInRect()
l_int32     pixCountRGBColorsByHash()
l_int32     pixCountRGBColors()
L_AMAP     *pixGetColorAmapHistogram()
l_int32     amapGetCountForColor()
l_int32     pixGetRankValue()
l_int32     pixGetRankValueMaskedRGB()
l_int32     pixGetRankValueMasked()
l_int32     pixGetPixelAverage()
l_int32     pixGetPixelStats()
l_int32     pixGetAverageMaskedRGB()
l_int32     pixGetAverageMasked()
l_int32     pixGetAverageTiledRGB()
PIX        *pixGetAverageTiled()
NUMA       *pixRowStats()
NUMA       *pixColumnStats()
l_int32     pixGetRangeValues()
l_int32     pixGetExtremeValue()
l_int32     pixGetMaxValueInRect()
l_int32     pixGetBinnedComponentRange()
l_int32     pixGetRankColorArray()
l_int32     pixGetBinnedColor()
PIX        *pixDisplayColorArray()
PIX        *pixRankBinByStrip()

Pixelwise aligned statistics
PIX        *pixaGetAlignedStats()
l_int32     pixaExtractColumnFromEachPix()
l_int32     pixGetRowStats()
l_int32     pixGetColumnStats()
l_int32     pixSetPixelColumn()

Foreground/background estimation
l_int32     pixThresholdForFgBg()
l_int32     pixSplitDistributionFgBg()
</pre>




"""
    
    try:
        leptonica.pixGetGrayHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetGrayHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetGrayHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]   pixs:     1, 2, 4, 8, 16 bpp; can be colormapped
:param[in]   factor:   subsampling factor; integer >= 1
:returns:  na histogram, or NULL on error

<pre>
Notes:
(1) If pixs has a colormap, it is converted to 8 bpp gray.
If you want a histogram of the colormap indices, use
pixGetCmapHistogram().
(2) If pixs does not have a colormap, the output histogram is
of size 2^d, where d is the depth of pixs.
(3) Set the subsampling factor > 1 to reduce the amount of computation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogram(*args)
    
    

    try:
        leptonica.pixGetGrayHistogramMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetGrayHistogramMasked.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetGrayHistogramMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogramMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       

:param[in]   pixs:     8 bpp, or colormapped
:param[in]   pixm:     [optional] 1 bpp mask over which histogram is
to be computed; use all pixels if null
:param[in]   x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0; these values are ignored if pixm is null
:param[in]   factor:   subsampling factor; integer >= 1
:returns:  na histogram, or NULL on error

<pre>
Notes:
(1) If pixs is cmapped, it is converted to 8 bpp gray.
If you want a histogram of the colormap indices, use
pixGetCmapHistogramMasked().
(2) This always returns a 256-value histogram of pixel values.
(3) Set the subsampling factor > 1 to reduce the amount of computation.
(4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
(5) Input x,y are ignored unless pixm exists.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogramMasked(*args)
    
    

    try:
        leptonica.pixGetGrayHistogramInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetGrayHistogramInRect.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetGrayHistogramInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogramInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'factor')       

:param[in]   pixs:    8 bpp, or colormapped
:param[in]   box:     [optional] over which histogram is to be computed;
use full image if NULL
:param[in]   factor:  subsampling factor; integer >= 1
:returns:  na histogram, or NULL on error

<pre>
Notes:
(1) If pixs is cmapped, it is converted to 8 bpp gray.
If you want a histogram of the colormap indices, use
pixGetCmapHistogramInRect().
(2) This always returns a 256-value histogram of pixel values.
(3) Set the subsampling %factor > 1 to reduce the amount of computation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogramInRect(*args)
    
    

    try:
        leptonica.pixGetGrayHistogramTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetGrayHistogramTiled.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetGrayHistogramTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetGrayHistogramTiled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'nx')       
('l_int32', 'ny')       

:param[in]   pixs:     any depth, colormap OK
:param[in]   factor:   subsampling factor; integer >= 1
:param[in]   nx,: ny   tiling; >= 1; typically small
:returns:  naa set of histograms, or NULL on error

<pre>
Notes:
(1) If pixs is cmapped, it is converted to 8 bpp gray.
(2) This returns a set of 256-value histograms of pixel values.
(3) Set the subsampling factor > 1 to reduce the amount of computation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetGrayHistogramTiled(*args)
    
    

    try:
        leptonica.pixGetColorHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetColorHistogram.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetColorHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColorHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('NUMA', '**pnar')       
('NUMA', '**pnag')       
('NUMA', '**pnab')       

:param[in]    pixs:     rgb or colormapped
:param[in]    factor:   subsampling factor; integer >= 1
:param[out]   pnar:     red histogram
:param[out]   pnag:     green histogram
:param[out]   pnab:     blue histogram
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a set of three 256 entry histograms,
one for each color component (r,g,b).
(2) Set the subsampling %factor > 1 to reduce the amount of computation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColorHistogram(*args)
    
    

    try:
        leptonica.pixGetColorHistogramMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetColorHistogramMasked.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetColorHistogramMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColorHistogramMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('NUMA', '**pnar')       
('NUMA', '**pnag')       
('NUMA', '**pnab')       

:param[in]    pixs:     32 bpp rgb, or colormapped
:param[in]    pixm:     [optional] 1 bpp mask over which histogram is
to be computed; use all pixels if null
:param[in]    x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0; these values are ignored if pixm is null
:param[in]    factor:   subsampling factor; integer >= 1
:param[out]   pnar:     red histogram
:param[out]   pnag:     green histogram
:param[out]   pnab:     blue histogram
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a set of three 256 entry histograms,
(2) Set the subsampling %factor > 1 to reduce the amount of computation.
(3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
(4) Input x,y are ignored unless pixm exists.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColorHistogramMasked(*args)
    
    

    try:
        leptonica.pixGetCmapHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetCmapHistogram.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetCmapHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCmapHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]   pixs:    colormapped: d = 2, 4 or 8
:param[in]   factor:  subsampling factor; integer >= 1
:returns:  na histogram of cmap indices, or NULL on error

<pre>
Notes:
(1) This generates a histogram of colormap pixel indices,
and is of size 2^d.
(2) Set the subsampling %factor > 1 to reduce the amount of computation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCmapHistogram(*args)
    
    

    try:
        leptonica.pixGetCmapHistogramMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetCmapHistogramMasked.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetCmapHistogramMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCmapHistogramMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       

:param[in]   pixs:     colormapped: d = 2, 4 or 8
:param[in]   pixm:     [optional] 1 bpp mask over which histogram is
to be computed; use all pixels if null
:param[in]   x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0; these values are ignored if pixm is null
:param[in]   factor:   subsampling factor; integer >= 1
:returns:  na histogram, or NULL on error

<pre>
Notes:
(1) This generates a histogram of colormap pixel indices,
and is of size 2^d.
(2) Set the subsampling %factor > 1 to reduce the amount of computation.
(3) Clipping of pixm to pixs is done in the inner loop.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCmapHistogramMasked(*args)
    
    

    try:
        leptonica.pixGetCmapHistogramInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetCmapHistogramInRect.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetCmapHistogramInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetCmapHistogramInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'factor')       

:param[in]   pixs:     colormapped: d = 2, 4 or 8
:param[in]   box:      [optional] over which histogram is to be computed;
use full image if NULL
:param[in]   factor:   subsampling factor; integer >= 1
:returns:  na histogram, or NULL on error

<pre>
Notes:
(1) This generates a histogram of colormap pixel indices,
and is of size 2^d.
(2) Set the subsampling %factor > 1 to reduce the amount of computation.
(3) Clipping to the box is done in the inner loop.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetCmapHistogramInRect(*args)
    
    

    try:
        leptonica.pixCountRGBColorsByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCountRGBColorsByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountRGBColorsByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountRGBColorsByHash(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pncolors')       

:param[in]    pixs:       rgb or rgba
:param[out]   pncolors:   number of colors found
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is about 3x faster than pixCountRGBColors(),
which uses an ordered map.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountRGBColorsByHash(*args)
    
    

    try:
        leptonica.pixCountRGBColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixCountRGBColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCountRGBColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCountRGBColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', '*pncolors')       

:param[in]    pixs:       rgb or rgba
:param[in]    factor:     subsampling factor; integer >= 1
:param[out]   pncolors:   number of colors found
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %factor == 1, this gives the exact number of colors.
(2) This is about 3x slower than pixCountRGBColorsByHash().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCountRGBColors(*args)
    
    

    try:
        leptonica.pixGetColorAmapHistogram.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetColorAmapHistogram.restype = lambda address: L_AMAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetColorAmapHistogram not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColorAmapHistogram(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]   pixs:    rgb or rgba
:param[in]   factor:  subsampling factor; integer >= 1
:returns:  amap, or NULL on error

<pre>
Notes:
(1) This generates an ordered map from pixel value to histogram count.
(2) Use amapGetCountForColor() to use the map to look up a count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColorAmapHistogram(*args)
    
    

    try:
        leptonica.amapGetCountForColor.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.amapGetCountForColor.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function amapGetCountForColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def amapGetCountForColor(*args):
        """
        ('L_AMAP', '*amap')       
('l_uint32', 'val')       

:param[in]   amap:   map from pixel value to count
:param[in]   val:    rgb or rgba pixel value
:returns:  count, or -1 on error

<pre>
Notes:
(1) The ordered map is made by pixGetColorAmapHistogram().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.amapGetCountForColor(*args)
    
    

    try:
        leptonica.pixGetRankValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixGetRankValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRankValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', 'rank')       
('l_uint32', '*pvalue')       

:param[in]    pixs:     8 bpp, 32 bpp or colormapped
:param[in]    factor:   subsampling factor; integer >= 1
:param[in]    rank:     between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest
:param[out]   pvalue:   pixel value corresponding to input rank
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Simple function to get rank values of an image.
For a color image, the median value (rank = 0.5) can be
used to linearly remap the colors based on the median
of a target image, using pixLinearMapToTargetColor().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankValue(*args)
    
    

    try:
        leptonica.pixGetRankValueMaskedRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRankValueMaskedRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRankValueMaskedRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankValueMaskedRGB(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_float32', 'rank')       
('l_float32', '*prval')       
('l_float32', '*pgval')       
('l_float32', '*pbval')       

:param[in]    pixs:     32 bpp
:param[in]    pixm:     [optional] 1 bpp mask over which rank val is to be taken;
use all pixels if null
:param[in]    x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0; these values are ignored if pixm is null
:param[in]    factor:   subsampling factor; integer >= 1
:param[in]    rank:     between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest
:param[out]   prval:    [optional] red component val for input rank
:param[out]   pgval:    [optional] green component val for input rank
:param[out]   pbval:    [optional] blue component val for input rank
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Computes the rank component values of pixels in pixs that
are under the fg of the optional mask.  If the mask is null, it
computes the average of the pixels in pixs.
(2) Set the subsampling %factor > 1 to reduce the amount of
computation.
(4) Input x,y are ignored unless pixm exists.
(5) The rank must be in [0.0 ... 1.0], where the brightest pixel
has rank 1.0.  For the median pixel value, use 0.5.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankValueMaskedRGB(*args)
    
    

    try:
        leptonica.pixGetRankValueMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRankValueMasked.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRankValueMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankValueMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_float32', 'rank')       
('l_float32', '*pval')       
('NUMA', '**pna')       

:param[in]    pixs:     8 bpp, or colormapped
:param[in]    pixm:     [optional] 1 bpp mask, over which the rank val
is to be taken; use all pixels if null
:param[in]    x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0; these values are ignored if pixm is null
:param[in]    factor:   subsampling factor; integer >= 1
:param[in]    rank:     between 0.0 and 1.0; 1.0 is brightest, 0.0 is darkest
:param[out]   pval:     pixel value corresponding to input rank
:param[out]   pna:     [optional] of histogram
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Computes the rank value of pixels in pixs that are under
the fg of the optional mask.  If the mask is null, it
computes the average of the pixels in pixs.
(2) Set the subsampling %factor > 1 to reduce the amount of
computation.
(3) Clipping of pixm (if it exists) to pixs is done in the inner loop.
(4) Input x,y are ignored unless pixm exists.
(5) The rank must be in [0.0 ... 1.0], where the brightest pixel
has rank 1.0.  For the median pixel value, use 0.5.
(6) The histogram can optionally be returned, so that other rank
values can be extracted without recomputing the histogram.
In that case, just use
numaHistogramGetValFromRank(na, rank, &val);
on the returned Numa for additional rank values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankValueMasked(*args)
    
    

    try:
        leptonica.pixGetPixelAverage.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetPixelAverage.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetPixelAverage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPixelAverage(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_uint32', '*pval')       

:param[in]    pixs:     8 or 32 bpp, or colormapped
:param[in]    pixm:     [optional] 1 bpp mask over which average is
to be taken; use all pixels if null
:param[in]    x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0
:param[in]    factor:   subsampling factor; >= 1
:param[out]   pval:     average pixel value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For rgb pix, this is a more direct computation of the
average value of the pixels in %pixs that are under the
mask %pixm. It is faster than pixGetPixelStats(), which
calls pixGetAverageMaskedRGB() and has the overhead of
generating a temporary pix of each of the three components;
this can take most of the time if %factor > 1.
(2) If %pixm is null, this gives the average value of all
pixels in %pixs.  The returned value is an integer.
(3) For color %pixs, the returned pixel value is in the standard
uint32 RGBA packing.
(4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
(5) Input x,y are ignored if %pixm does not exist.
(6) For general averaging of 1, 2, 4 or 8 bpp grayscale, use
pixAverageInRect().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPixelAverage(*args)
    
    

    try:
        leptonica.pixGetPixelStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetPixelStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetPixelStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetPixelStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_uint32', '*pvalue')       

:param[in]    pixs:     8 bpp, 32 bpp or colormapped
:param[in]    factor:   subsampling factor; integer >= 1
:param[in]    type:     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,
L_STANDARD_DEVIATION, L_VARIANCE
:param[out]   pvalue:   pixel value corresponding to input type
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Simple function to get one of four statistical values of an image.
(2) It does not take a mask: it uses the entire image.
(3) To get the average pixel value of an RGB image, suggest using
pixGetPixelAverage(), which is considerably faster.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetPixelStats(*args)
    
    

    try:
        leptonica.pixGetAverageMaskedRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetAverageMaskedRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetAverageMaskedRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageMaskedRGB(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_float32', '*prval')       
('l_float32', '*pgval')       
('l_float32', '*pbval')       

:param[in]    pixs:     32 bpp, or colormapped
:param[in]    pixm:     [optional] 1 bpp mask over which average is
to be taken; use all pixels if null
:param[in]    x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0
:param[in]    factor:   subsampling factor; >= 1
:param[in]    type:     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,
L_STANDARD_DEVIATION, L_VARIANCE
:param[out]   prval:    [optional] measured red value of given 'type'
:param[out]   pgval:    [optional] measured green value of given 'type'
:param[out]   pbval:    [optional] measured blue value of given 'type'
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For usage, see pixGetAverageMasked().
(2) If there is a colormap, it is removed before the 8 bpp
component images are extracted.
(3) A better name for this would be: pixGetPixelStatsRGB()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageMaskedRGB(*args)
    
    

    try:
        leptonica.pixGetAverageMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetAverageMasked.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetAverageMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_float32', '*pval')       

:param[in]   pixs:     8 or 16 bpp, or colormapped
:param[in]   pixm:     [optional] 1 bpp mask over which average is
to be taken; use all pixels if null
:param[in]   x,: y     UL corner of pixm relative to the UL corner of pixs;
can be < 0
:param[in]   factor:   subsampling factor; >= 1
:param[in]   type:     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE,
L_STANDARD_DEVIATION, L_VARIANCE
:param[out]  pval:     measured value of given 'type'
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Use L_MEAN_ABSVAL to get the average value of pixels in pixs
that are under the fg of the optional mask.  If the mask
is null, it finds the average of the pixels in pixs.
(2) Likewise, use L_ROOT_MEAN_SQUARE to get the rms value of
pixels in pixs, either masked or not; L_STANDARD_DEVIATION
to get the standard deviation from the mean of the pixels;
L_VARIANCE to get the average squared difference from the
expected value.  The variance is the square of the stdev.
For the standard deviation, we use
sqrt([([x] - x)]^2) = sqrt([x^2] - [x]^2)
(3) Set the subsampling %factor > 1 to reduce the amount of
computation.
(4) Clipping of pixm (if it exists) to pixs is done in the inner loop.
(5) Input x,y are ignored unless pixm exists.
(6) A better name for this would be: pixGetPixelStatsGray()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageMasked(*args)
    
    

    try:
        leptonica.pixGetAverageTiledRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetAverageTiledRGB.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetAverageTiledRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageTiledRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'type')       
('PIX', '**ppixr')       
('PIX', '**ppixg')       
('PIX', '**ppixb')       

:param[in]   pixs:     32 bpp, or colormapped
:param[in]   sx,: sy   tile size; must be at least 2 x 2
:param[in]   type:     L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION
:param[out]  ppixr:    [optional] tiled 'average' of red component
:param[out]  ppixg:    [optional] tiled 'average' of green component
:param[out]  ppixb:    [optional] tiled 'average' of blue component
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For usage, see pixGetAverageTiled().
(2) If there is a colormap, it is removed before the 8 bpp
component images are extracted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageTiledRGB(*args)
    
    

    try:
        leptonica.pixGetAverageTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGetAverageTiled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetAverageTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAverageTiled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'type')       

:param[in]   pixs:    8 bpp, or colormapped
:param[in]   sx,: sy  tile size; must be at least 2 x 2
:param[in]   type:    L_MEAN_ABSVAL, L_ROOT_MEAN_SQUARE, L_STANDARD_DEVIATION
:returns:  pixd average values in each tile, or NULL on error

<pre>
Notes:
(1) Only computes for tiles that are entirely contained in pixs.
(2) Use L_MEAN_ABSVAL to get the average abs value within the tile;
L_ROOT_MEAN_SQUARE to get the rms value within each tile;
L_STANDARD_DEVIATION to get the standard dev. from the average
within each tile.
(3) If colormapped, converts to 8 bpp gray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAverageTiled(*args)
    
    

    try:
        leptonica.pixRowStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRowStats.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixRowStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRowStats(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('NUMA', '**pnamean')       
('NUMA', '**pnamedian')       
('NUMA', '**pnamode')       
('NUMA', '**pnamodecount')       
('NUMA', '**pnavar')       
('NUMA', '**pnarootvar')       

:param[in]    pixs:          8 bpp; not cmapped
:param[in]    box:           [optional] clipping box; can be null
:param[out]   pnamean:       [optional] numa of mean values
:param[out]   pnamedian:     [optional] numa of median values
:param[out]   pnamode:       [optional] numa of mode intensity values
:param[out]   pnamodecount:  [optional] numa of mode counts
:param[out]   pnavar:        [optional] numa of variance
:param[out]   pnarootvar:    [optional] numa of square root of variance
:returns:  na numa of requested statistic for each row, or NULL on error

<pre>
Notes:
(1) This computes numas that represent column vectors of statistics,
with each of its values derived from the corresponding row of a Pix.
(2) Use NULL on input to prevent computation of any of the 5 numas.
(3) Other functions that compute pixel row statistics are:
pixCountPixelsByRow()
pixAverageByRow()
pixVarianceByRow()
pixGetRowStats()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRowStats(*args)
    
    

    try:
        leptonica.pixColumnStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixColumnStats.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixColumnStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColumnStats(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('NUMA', '**pnamean')       
('NUMA', '**pnamedian')       
('NUMA', '**pnamode')       
('NUMA', '**pnamodecount')       
('NUMA', '**pnavar')       
('NUMA', '**pnarootvar')       

:param[in]    pixs:          8 bpp; not cmapped
:param[in]    box:           [optional] clipping box; can be null
:param[out]   pnamean:       [optional] numa of mean values
:param[out]   pnamedian:     [optional] numa of median values
:param[out]   pnamode:       [optional] numa of mode intensity values
:param[out]   pnamodecount:  [optional] numa of mode counts
:param[out]   pnavar:        [optional] numa of variance
:param[out]   pnarootvar:    [optional] numa of square root of variance
:returns:  na numa of requested statistic for each column,
or NULL on error

<pre>
Notes:
(1) This computes numas that represent row vectors of statistics,
with each of its values derived from the corresponding col of a Pix.
(2) Use NULL on input to prevent computation of any of the 5 numas.
(3) Other functions that compute pixel column statistics are:
pixCountPixelsByColumn()
pixAverageByColumn()
pixVarianceByColumn()
pixGetColumnStats()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColumnStats(*args)
    
    

    try:
        leptonica.pixGetRangeValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetRangeValues.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRangeValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRangeValues(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'color')       
('l_int32', '*pminval')       
('l_int32', '*pmaxval')       

:param[in]    pixs:     8 bpp grayscale, 32 bpp rgb, or colormapped
:param[in]    factor:   subsampling factor; >= 1; ignored if colormapped
:param[in]    color:    L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE
:param[out]   pminval:  [optional] minimum value of component
:param[out]   pmaxval:  [optional] maximum value of component
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If pixs is 8 bpp grayscale, the color selection type is ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRangeValues(*args)
    
    

    try:
        leptonica.pixGetExtremeValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetExtremeValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetExtremeValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetExtremeValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'type')       
('l_int32', '*prval')       
('l_int32', '*pgval')       
('l_int32', '*pbval')       
('l_int32', '*pgrayval')       

:param[in]    pixs:      8 bpp grayscale, 32 bpp rgb, or colormapped
:param[in]    factor:    subsampling factor; >= 1; ignored if colormapped
:param[in]    type:      L_SELECT_MIN or L_SELECT_MAX
:param[out]   prval:     [optional] red component
:param[out]   pgval:     [optional] green component
:param[out]   pbval:     [optional] blue component
:param[out]   pgrayval:  [optional] min or max gray value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If pixs is grayscale, the result is returned in &grayval.
Otherwise, if there is a colormap or d == 32,
each requested color component is returned.  At least
one color component (address) must be input.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetExtremeValue(*args)
    
    

    try:
        leptonica.pixGetMaxValueInRect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetMaxValueInRect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetMaxValueInRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetMaxValueInRect(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', '*pmaxval')       
('l_int32', '*pxmax')       
('l_int32', '*pymax')       

:param[in]    pixs:     8, 16 or 32 bpp grayscale; no color space components
:param[in]    box:      [optional] region; set box = NULL to use entire pixs
:param[out]   pmaxval:  [optional] max value in region
:param[out]   pxmax:    [optional] x location of max value
:param[out]   pymax:    [optional] y location of max value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This can be used to find the maximum and its location
in a 2-dimensional histogram, where the x and y directions
represent two color components (e.g., saturation and hue).
(2) Note that here a 32 bpp pixs has pixel values that are simply
numbers.  They are not 8 bpp components in a colorspace.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetMaxValueInRect(*args)
    
    

    try:
        leptonica.pixGetBinnedComponentRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetBinnedComponentRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBinnedComponentRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBinnedComponentRange(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nbins')       
('l_int32', 'factor')       
('l_int32', 'color')       
('l_int32', '*pminval')       
('l_int32', '*pmaxval')       
('l_uint32', '**pcarray')       
('l_int32', 'fontsize')       

:param[in]    pixs:      32 bpp rgb
:param[in]    nbins:     number of equal population bins; must be > 1
:param[in]    factor:    subsampling factor; >= 1
:param[in]    color:     L_SELECT_RED, L_SELECT_GREEN or L_SELECT_BLUE
:param[out]   pminval:   [optional] minimum value of component
:param[out]   pmaxval:   [optional] maximum value of component
:param[out]   pcarray:   [optional] color array of bins
:param[in]    fontsize:  [optional] 0 for no debug; for debug, valid set
is {4,6,8,10,12,14,16,18,20}.
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns the min and max average values of the
selected color component in the set of rank bins,
where the ranking is done using the specified component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBinnedComponentRange(*args)
    
    

    try:
        leptonica.pixGetRankColorArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGetRankColorArray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRankColorArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRankColorArray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nbins')       
('l_int32', 'type')       
('l_int32', 'factor')       
('l_uint32', '**pcarray')       
('PIXA', '*pixadb')       
('l_int32', 'fontsize')       

:param[in]    pixs:       32 bpp or cmapped
:param[in]    nbins:      number of equal population bins; must be > 1
:param[in]    type:       color selection flag
:param[in]    factor:     subsampling factor; integer >= 1
:param[out]   pcarray:    array of colors, ranked by intensity
:param[in]    pixadb:     [optional] debug: caller passes this in.
Use to display color squares and to
capture plots of color components
:param[in]    fontsize:   [optional] debug: only used if pixadb exists.
Valid set is {4,6,8,10,12,14,16,18,20}.
fontsize == 6 is typical.
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE,
L_SELECT_HUE, L_SELECT_SATURATION.
(2) Then it finds the histogram of the selected color type in each
RGB pixel.  For each of the %nbins sets of pixels,
ordered by this color type value, find the average RGB color,
and return this as a "rank color" array.  The output array
has %nbins colors.
(3) Set the subsampling factor > 1 to reduce the amount of
computation.  Typically you want at least 10,000 pixels
for reasonable statistics.
(4) The rank color as a function of rank can then be found from
rankint = (l_int32)(rank * (nbins - 1) + 0.5);
extractRGBValues(array[rankint], &rval, &gval, &bval);
where the rank is in [0.0 ... 1.0].
This function is meant to be simple and approximate.
(5) Compare this with pixGetBinnedColor(), which generates equal
width intensity bins and finds the average color in each bin.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRankColorArray(*args)
    
    

    try:
        leptonica.pixGetBinnedColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetBinnedColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetBinnedColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetBinnedColor(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       
('l_int32', 'factor')       
('l_int32', 'nbins')       
('NUMA', '*nalut')       
('l_uint32', '**pcarray')       
('PIXA', '*pixadb')       

:param[in]    pixs:       32 bpp
:param[in]    pixg:       8 bpp grayscale version of pixs
:param[in]    factor:     sampling factor along pixel counting direction
:param[in]    nbins:      number of intensity bins
:param[in]    nalut:      LUT for mapping from intensity to bin number
:param[out]   pcarray:    array of average color values in each bin
:param[in]    pixadb:     [optional] debug: caller passes this in.
Use to display color squares and to
capture plots of color components
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This takes a color image, a grayscale (intensity) version,
a LUT from intensity to bin number, and the number of bins.
It computes the average color for pixels whose intensity
is in each bin.  This is returned as an array of l_uint32
colors in our standard RGBA ordering.
(2) This function generates equal width intensity bins and
finds the average color in each bin.  Compare this with
pixGetRankColorArray(), which rank orders the pixels
by the value of the selected component in each pixel,
sets up bins with equal population (not intensity width!),
and gets the average color in each bin.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetBinnedColor(*args)
    
    

    try:
        leptonica.pixDisplayColorArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDisplayColorArray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayColorArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayColorArray(*args):
        """
        ('l_uint32', '*carray')       
('l_int32', 'ncolors')       
('l_int32', 'side')       
('l_int32', 'ncols')       
('l_int32', 'fontsize')       

:param[in]   carray:    array of colors: 0xrrggbb00
:param[in]   ncolors:   size of array
:param[in]   side:      size of each color square; suggest 200
:param[in]   ncols:     number of columns in output color matrix
:param[in]   fontsize:  to label each square with text.
Valid set is {4,6,8,10,12,14,16,18,20}.
Suggest 6 for 200x200 square. Use 0 to disable.
:returns:  pixd color array, or NULL on error

<pre>
Notes:
(1) This generates an array of labeled color squares from an
array of color values.
(2) To make a single color square, use pixMakeColorSquare().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayColorArray(*args)
    
    

    try:
        leptonica.pixRankBinByStrip.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRankBinByStrip.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankBinByStrip not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankBinByStrip(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'direction')       
('l_int32', 'size')       
('l_int32', 'nbins')       
('l_int32', 'type')       

:param[in]   pixs:       32 bpp or cmapped
:param[in]   direction:  L_SCAN_HORIZONTAL or L_SCAN_VERTICAL
:param[in]   size:       of strips in scan direction
:param[in]   nbins:      number of equal population bins; must be > 1
:param[in]   type:       color selection flag
:returns:  pixd result, or NULL on error

<pre>
Notes:
(1) This generates a pix where each column represents a strip of
the input image.  If %direction == L_SCAN_HORIZONTAL, the
input impage is tiled into vertical strips of width %size,
where %size is a compromise between getting better spatial
columnwise resolution (small %size) and getting better
columnwise statistical information (larger %size).  Likewise
with rows of the image if %direction == L_SCAN_VERTICAL.
(2) For L_HORIZONTAL_SCAN, the output pix contains rank binned
median colors in each column that correspond to a vertical
strip of width %size in the input image.
(3) The color selection flag is one of: L_SELECT_RED, L_SELECT_GREEN,
L_SELECT_BLUE, L_SELECT_MIN, L_SELECT_MAX, L_SELECT_AVERAGE.
It determines how the rank ordering is done.
(4) Typical input values might be %size = 5, %nbins = 10.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankBinByStrip(*args)
    
    

    try:
        leptonica.pixaGetAlignedStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaGetAlignedStats.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetAlignedStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetAlignedStats(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'type')       
('l_int32', 'nbins')       
('l_int32', 'thresh')       

:param[in]   pixa:    of identically sized, 8 bpp pix; not cmapped
:param[in]   type:    L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT
:param[in]   nbins:   of histogram for median and mode; ignored for mean
:param[in]   thresh:  on histogram for mode val; ignored for all other types
:returns:  pix with pixelwise aligned stats, or NULL on error.

<pre>
Notes:
(1) Each pixel in the returned pix represents an average
(or median, or mode) over the corresponding pixels in each
pix in the pixa.
(2) The %thresh parameter works with L_MODE_VAL only, and
sets a minimum occupancy of the mode bin.
If the occupancy of the mode bin is less than %thresh, the
mode value is returned as 0.  To always return the actual
mode value, set %thresh = 0.  See pixGetRowStats().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetAlignedStats(*args)
    
    

    try:
        leptonica.pixaExtractColumnFromEachPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaExtractColumnFromEachPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaExtractColumnFromEachPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaExtractColumnFromEachPix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'col')       
('PIX', '*pixd')       

:param[in]   pixa:   of identically sized, 8 bpp; not cmapped
:param[in]   col:    column index
:param[in]   pixd:   pix into which each column is inserted
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaExtractColumnFromEachPix(*args)
    
    

    try:
        leptonica.pixGetRowStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetRowStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetRowStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetRowStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'nbins')       
('l_int32', 'thresh')       
('l_float32', '*colvect')       

:param[in]   pixs:     8 bpp; not cmapped
:param[in]   type:     L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT
:param[in]   nbins:    of histogram for median and mode; ignored for mean
:param[in]   thresh:   on histogram for mode; ignored for mean and median
:param[in]   colvect:  vector of results gathered across the rows of pixs
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes a column vector of statistics using each
row of a Pix.  The result is put in %colvect.
(2) The %thresh parameter works with L_MODE_VAL only, and
sets a minimum occupancy of the mode bin.
If the occupancy of the mode bin is less than %thresh, the
mode value is returned as 0.  To always return the actual
mode value, set %thresh = 0.
(3) What is the meaning of this %thresh parameter?
For each row, the total count in the histogram is w, the
image width.  So %thresh, relative to w, gives a measure
of the ratio of the bin width to the width of the distribution.
The larger %thresh, the narrower the distribution must be
for the mode value to be returned (instead of returning 0).
(4) If the Pix consists of a set of corresponding columns,
one for each Pix in a Pixa, the width of the Pix is the
number of Pix in the Pixa and the column vector can
be stored as a column in a Pix of the same size as
each Pix in the Pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetRowStats(*args)
    
    

    try:
        leptonica.pixGetColumnStats.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGetColumnStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetColumnStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetColumnStats(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'nbins')       
('l_int32', 'thresh')       
('l_float32', '*rowvect')       

:param[in]   pixs:     8 bpp; not cmapped
:param[in]   type:     L_MEAN_ABSVAL, L_MEDIAN_VAL, L_MODE_VAL, L_MODE_COUNT
:param[in]   nbins:    of histogram for median and mode; ignored for mean
:param[in]   thresh:   on histogram for mode val; ignored for all other types
:param[in]   rowvect:  vector of results gathered down the columns of pixs
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes a row vector of statistics using each
column of a Pix.  The result is put in %rowvect.
(2) The %thresh parameter works with L_MODE_VAL only, and
sets a minimum occupancy of the mode bin.
If the occupancy of the mode bin is less than %thresh, the
mode value is returned as 0.  To always return the actual
mode value, set %thresh = 0.
(3) What is the meaning of this %thresh parameter?
For each column, the total count in the histogram is h, the
image height.  So %thresh, relative to h, gives a measure
of the ratio of the bin width to the width of the distribution.
The larger %thresh, the narrower the distribution must be
for the mode value to be returned (instead of returning 0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetColumnStats(*args)
    
    

    try:
        leptonica.pixSetPixelColumn.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSetPixelColumn.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetPixelColumn not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetPixelColumn(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'col')       
('l_float32', '*colvect')       

:param[in]   pix:      8 bpp; not cmapped
:param[in]   col:      column index
:param[in]   colvect:  vector of floats
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetPixelColumn(*args)
    
    

    try:
        leptonica.pixThresholdForFgBg.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdForFgBg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdForFgBg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdForFgBg(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'thresh')       
('l_int32', '*pfgval')       
('l_int32', '*pbgval')       

:param[in]    pixs:    any depth; cmapped ok
:param[in]    factor:  subsampling factor; integer >= 1
:param[in]    thresh:  threshold for generating foreground mask
:param[out]   pfgval:  [optional] average foreground value
:param[out]   pbgval:  [optional] average background value
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdForFgBg(*args)
    
    

    try:
        leptonica.pixSplitDistributionFgBg.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSplitDistributionFgBg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSplitDistributionFgBg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitDistributionFgBg(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scorefract')       
('l_int32', 'factor')       
('l_int32', '*pthresh')       
('l_int32', '*pfgval')       
('l_int32', '*pbgval')       
('PIX', '**ppixdb')       

:param[in]    pixs:        any depth; cmapped ok
:param[in]    scorefract:  fraction of the max score, used to determine
the range over which the histogram min is searched
:param[in]    factor:      subsampling factor; integer >= 1
:param[out]   pthresh:     [optional] best threshold for separating
:param[out]   pfgval:      [optional] average foreground value
:param[out]   pbgval:      [optional] average background value
:param[out]   ppixdb:      [optional] plot of distribution and split point
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See numaSplitDistribution() for details on the underlying
method of choosing a threshold.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitDistributionFgBg(*args)
    




class readfile(object):
    """<pre>

Top-level functions for reading images from file
PIXA      *pixaReadFiles()
PIXA      *pixaReadFilesSA()
PIX       *pixRead()
PIX       *pixReadWithHint()
PIX       *pixReadIndexed()
PIX       *pixReadStream()

Read header information from file
l_int32    pixReadHeader()

Format finders
l_int32    findFileFormat()
l_int32    findFileFormatStream()
l_int32    findFileFormatBuffer()
l_int32    fileFormatIsTiff()

Read from memory
PIX       *pixReadMem()
l_int32    pixReadHeaderMem()

Output image file information
void       writeImageFileInfo()

Test function for I/O with different formats
l_int32    ioFormatTest()

Supported file formats:
(1) Reading is supported without any external libraries:
bmp
pnm   (including pbm, pgm, etc)
spix  (raw serialized)
(2) Reading is supported with installation of external libraries:
png
jpg   (standard jfif version)
tiff  (including most varieties of compression)
gif
webp
jp2 (jpeg 2000)
(3) Other file types will get an "unknown format" error.
</pre>




"""
    
    try:
        leptonica.pixaReadFiles.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.pixaReadFiles.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       

:param[in]    dirname:
:param[in]    substr:   [optional] substring filter on filenames; can be null
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) %dirname is the full path for the directory.
(2) %substr is the part of the file name (excluding
the directory) that is to be matched.  All matching
filenames are read into the Pixa.  If substr is NULL,
all filenames are read into the Pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadFiles(*args)
    
    

    try:
        leptonica.pixaReadFilesSA.argtypes = [ctypes.c_void_p]
        leptonica.pixaReadFilesSA.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadFilesSA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadFilesSA(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:     full pathnames for all files
:returns:  pixa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadFilesSA(*args)
    
    

    try:
        leptonica.pixRead.argtypes = [ctypes.c_char_p]
        leptonica.pixRead.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:    with full pathname or in local directory
:returns:  pix if OK; NULL on error

<pre>
Notes:
(1) See at top of file for supported formats.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRead(*args)
    
    

    try:
        leptonica.pixReadWithHint.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixReadWithHint.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadWithHint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadWithHint(*args):
        """
        ('const char', '*filename')       
('l_int32', 'hint')       

:param[in]    filename:    with full pathname or in local directory
:param[in]    hint:        bitwise OR of L_HINT_* values for jpeg;
use 0 for no hint
:returns:  pix if OK; NULL on error

<pre>
Notes:
(1) The hint is not binding, but may be used to optimize jpeg decoding.
Use 0 for no hinting.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadWithHint(*args)
    
    

    try:
        leptonica.pixReadIndexed.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadIndexed.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadIndexed not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadIndexed(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       

:param[in]    sa:      string array of full pathnames
:param[in]    index:   into pathname array
:returns:  pix if OK; null if not found

<pre>
Notes:
(1) This function is useful for selecting image files from a
directory, where the integer %index is embedded into
the file name.
(2) This is typically done by generating the sarray using
getNumberedPathnamesInDirectory(), so that the %index
pathname would have the number %index in it.  The size
of the sarray should be the largest number (plus 1) appearing
in the file names, respecting the constraints in the
call to getNumberedPathnamesInDirectory().
(3) Consequently, for some indices into the sarray, there may
be no pathnames in the directory containing that number.
By convention, we place empty C strings ("") in those
locations in the sarray, and it is not an error if such
a string is encountered and no pix is returned.
Therefore, the caller must verify that a pix is returned.
(4) See convertSegmentedPagesToPS() in src/psio1.c for an
example of usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadIndexed(*args)
    
    

    try:
        leptonica.pixReadStream.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadStream.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStream(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'hint')       

:param[in]    fp:      file stream
:param[in]    hint:    bitwise OR of L_HINT_* values for jpeg; 0 for no hint
:returns:  pix if OK; NULL on error

<pre>
Notes:
(1) The hint only applies to jpeg.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStream(*args)
    
    

    try:
        leptonica.pixReadHeader.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixReadHeader.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixReadHeader not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadHeader(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pformat')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    filename:    with full pathname or in local directory
:param[out]   pformat:     [optional] file format
:param[out]   pw,: ph      [optional] width and height
:param[out]   pbps:        [optional] bits/sample
:param[out]   pspp:        [optional] samples/pixel 1, 3 or 4
:param[out]   piscmap:     [optional] 1 if cmap exists; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This reads the actual headers for jpeg, png, tiff and pnm.
For bmp and gif, we cheat and read the entire file into a pix,
from which we extract the "header" information.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadHeader(*args)
    
    

    try:
        leptonica.findFileFormat.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.findFileFormat.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function findFileFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findFileFormat(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pformat')       

:param[in]    filename:
:param[out]   pformat:    found format
:returns:  0 if OK, 1 on error or if format is not recognized


        """
        args = _convert_params(*args)
        
        return leptonica.findFileFormat(*args)
    
    

    try:
        leptonica.findFileFormatStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findFileFormatStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function findFileFormatStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findFileFormatStream(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pformat')       

:param[in]    fp:        file stream
:param[out]   pformat:   found format
:returns:  0 if OK, 1 on error or if format is not recognized

<pre>
Notes:
(1) Important: Side effect -- this resets fp to BOF.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.findFileFormatStream(*args)
    
    

    try:
        leptonica.findFileFormatBuffer.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findFileFormatBuffer.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function findFileFormatBuffer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findFileFormatBuffer(*args):
        """
        ('const l_uint8', '*buf')       
('l_int32', '*pformat')       

:param[in]    buf:       byte buffer at least 12 bytes in size; we can't check
:param[out]   pformat:   found format
:returns:  0 if OK, 1 on error or if format is not recognized

<pre>
Notes:
(1) This determines the file format from the first 12 bytes in
the compressed data stream, which are stored in memory.
(2) For tiff files, this returns IFF_TIFF.  The specific tiff
compression is then determined using findTiffCompression().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.findFileFormatBuffer(*args)
    
    

    try:
        leptonica.fileFormatIsTiff.argtypes = [ctypes.c_void_p]
        leptonica.fileFormatIsTiff.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function fileFormatIsTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileFormatIsTiff(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  1 if file is tiff; 0 otherwise or on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileFormatIsTiff(*args)
    
    

    try:
        leptonica.pixReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMem.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    const; encoded
:param[in]    size:    size of data
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This is a variation of pixReadStream(), where the data is read
from a memory buffer rather than a file.
(2) On windows, this only reads tiff formatted files directly from
memory.  For other formats, it writes to a temp file and
decompresses from file.
(3) findFileFormatBuffer() requires up to 12 bytes to decide on
the format.  That determines the constraint here.  But in
fact the data must contain the entire compressed string for
the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMem(*args)
    
    

    try:
        leptonica.pixReadHeaderMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixReadHeaderMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixReadHeaderMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadHeaderMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pformat')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    data:       const; encoded
:param[in]    size:       size of data
:param[out]   pformat:    [optional] image format
:param[out]   pw,: ph     [optional] width and height
:param[out]   pbps:       [optional] bits/sample
:param[out]   pspp:       [optional] samples/pixel 1, 3 or 4
:param[out]   piscmap:    [optional] 1 if cmap exists; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This reads the actual headers for jpeg, png, tiff, jp2k and pnm.
For bmp and gif, we cheat and read all the data into a pix,
from which we extract the "header" information.
(2) The amount of data required depends on the format.  For
png, it requires less than 30 bytes, but for jpeg it can
require most of the compressed file.  In practice, the data
is typically the entire compressed file in memory.
(3) findFileFormatBuffer() requires up to 12 bytes to decide on
the format, which we require.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadHeaderMem(*args)
    
    

    try:
        leptonica.writeImageFileInfo.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.writeImageFileInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function writeImageFileInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def writeImageFileInfo(*args):
        """
        ('const char', '*filename')       
('FILE', '*fpout')       
('l_int32', 'headeronly')       

:param[in]    filename:    input file
:param[in]    fpout:       output file stream
:param[in]    headeronly:  1 to read only the header; 0 to read both
the header and the input file
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If headeronly == 0 and the image has spp == 4,this will
also call pixDisplayLayersRGBA() to display the image
in three views.
(2) This is a debug function that changes the value of
var_PNG_STRIP_16_TO_8 to 1 (the default).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.writeImageFileInfo(*args)
    
    

    try:
        leptonica.ioFormatTest.argtypes = [ctypes.c_char_p]
        leptonica.ioFormatTest.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ioFormatTest not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ioFormatTest(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:    input image file
:returns:  0 if OK; 1 on error or if the test fails

<pre>
Notes:
(1) This writes and reads a set of output files losslessly
in different formats to /tmp/format/, and tests that the
result before and after is unchanged.
(2) This should work properly on input images of any depth,
with and without colormaps.
(3) All supported formats are tested for bmp, png, tiff and
non-ascii pnm.  Ascii pnm also works (but who'd ever want
to use it?)   We allow 2 bpp bmp, although it's not
supported elsewhere.  And we don't support reading
16 bpp png, although this can be turned on in pngio.c.
(4) This silently skips png or tiff testing if HAVE_LIBPNG
or HAVE_LIBTIFF are 0, respectively.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ioFormatTest(*args)
    




class tiffio(object):
    """<pre>

TIFFClientOpen() wrappers for FILE*:
static tsize_t    lept_read_proc()
static tsize_t    lept_write_proc()
static toff_t     lept_seek_proc()
static int        lept_close_proc()
static toff_t     lept_size_proc()

Reading tiff:
PIX       *pixReadTiff()             [ special top level ]
PIX       *pixReadStreamTiff()
static PIX       *pixReadFromTiffStream()

Writing tiff:
l_int32    pixWriteTiff()            [ special top level ]
l_int32    pixWriteTiffCustom()      [ special top level ]
l_int32    pixWriteStreamTiff()
l_int32    pixWriteStreamTiffWA()
static l_int32    pixWriteToTiffStream()
static l_int32    writeCustomTiffTags()

Reading and writing multipage tiff
PIX       *pixReadFromMultipageTiff()
PIXA      *pixaReadMultipageTiff()   [ special top level ]
l_int32    pixaWriteMultipageTiff()  [ special top level ]
l_int32    writeMultipageTiff()      [ special top level ]
l_int32    writeMultipageTiffSA()

Information about tiff file
l_int32    fprintTiffInfo()
l_int32    tiffGetCount()
l_int32    getTiffResolution()
static l_int32    getTiffStreamResolution()
l_int32    readHeaderTiff()
l_int32    freadHeaderTiff()
l_int32    readHeaderMemTiff()
static l_int32    tiffReadHeaderTiff()
l_int32    findTiffCompression()
static l_int32    getTiffCompressedFormat()

Extraction of tiff g4 data:
l_int32    extractG4DataFromFile()

Open tiff stream from file stream
static TIFF      *fopenTiff()

Wrapper for TIFFOpen:
static TIFF      *openTiff()

Memory I/O: reading memory --> pix and writing pix --> memory
[10 static helper functions]
PIX       *pixReadMemTiff();
PIX       *pixReadMemFromMultipageTiff();
PIXA      *pixaReadMemMultipageTiff()    [ special top level ]
l_int32    pixaWriteMemMultipageTiff()   [ special top level ]
l_int32    pixWriteMemTiff();
l_int32    pixWriteMemTiffCustom();

Note:  To include all necessary functions, use libtiff version 3.7.4
(or later)
Note:  On Windows with 2 bpp or 4 bpp images, the bytes in the
tiff-compressed file depend on the pad bits (but not the
decoded raster image when read).  Because it is sometimes
convenient to use a golden file with a byte-by-byte check
to verify invariance, we set the pad bits to 0 before writing,
in pixWriteToTiffStream().
</pre>




"""
    
    try:
        leptonica.pixReadTiff.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixReadTiff.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadTiff(*args):
        """
        ('const char', '*filename')       
('l_int32', 'n')       

:param[in]    filename:
:param[in]    n:           page number 0 based
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This is a version of pixRead(), specialized for tiff
files, that allows specification of the page to be returned
(2) No warning messages on failure, because of how multi-page
TIFF reading works. You are supposed to keep trying until
it stops working.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadTiff(*args)
    
    

    try:
        leptonica.pixReadStreamTiff.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadStreamTiff.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamTiff(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'n')       

:param[in]    fp:    file stream
:param[in]    n:     page number: 0 based
:returns:  pix, or NULL on error or if there are no more images in the file

<pre>
Notes:
(1) No warning messages on failure, because of how multi-page
TIFF reading works. You are supposed to keep trying until
it stops working.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamTiff(*args)
    
    

    try:
        leptonica.pixWriteTiff.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixWriteTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteTiff(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('const char', '*modestr')       

:param[in]    filename:   to write to
:param[in]    pix:        any depth, colormap will be removed
:param[in]    comptype:   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
IFF_TIFF_G3, IFF_TIFF_G4,
IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG
:param[in]    modestr:    "a" or "w"
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For multipage tiff, write the first pix with mode "w" and
all subsequent pix with mode "a".
(2) For multipage tiff, there is considerable overhead in the
machinery to append an image and add the directory entry,
and the time required for each image increases linearly
with the number of images in the file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteTiff(*args)
    
    

    try:
        leptonica.pixWriteTiffCustom.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteTiffCustom.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteTiffCustom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteTiffCustom(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('const char', '*modestr')       
('NUMA', '*natags')       
('SARRAY', '*savals')       
('SARRAY', '*satypes')       
('NUMA', '*nasizes')       

:param[in]    filename:   to write to
:param[in]    pix:
:param[in]    comptype:   IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
IFF_TIFF_G3, IFF_TIFF_G4,
IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG
:param[in]    modestr:    "a" or "w"
:param[in]    natags: [optional] NUMA of custom tiff tags
:param[in]    savals: [optional] SARRAY of values
:param[in]    satypes: [optional] SARRAY of types
:param[in]    nasizes: [optional] NUMA of sizes
:returns:  0 if OK, 1 on error

Usage:
1 This writes a page image to a tiff file, with optional
extra tags defined in tiff.h
2 For multipage tiff, write the first pix with mode "w" and
all subsequent pix with mode "a".
3 For the custom tiff tags:
a The three arrays {natags, savals, satypes} must all be
either NULL or defined and of equal size.
b If they are defined, the tags are an array of integers,
the vals are an array of values in string format, and
the types are an array of types in string format.
c All valid tags are definined in tiff.h.
d The types allowed are the set of strings:
"char*"
"l_uint8*"
"l_uint16"
"l_uint32"
"l_int32"
"l_float64"
"l_uint16-l_uint16" note the dash; use it between the
two l_uint16 vals in the val string
Of these, "char*" and "l_uint16" are the most commonly used.
e The last array, nasizes, is also optional.  It is for
tags that take an array of bytes for a value, a number of
elements in the array, and a type that is either "char*"
or "l_uint8*" probably either will work.
Use NULL if there are no such tags.
f VERY IMPORTANT: if there are any tags that require the
extra size value, stored in nasizes, they must be
written first!


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteTiffCustom(*args)
    
    

    try:
        leptonica.pixWriteStreamTiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteStreamTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamTiff(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'comptype')       

:param[in]    fp:       file stream
:param[in]    pix:
:param[in]    comptype: IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
IFF_TIFF_G3, IFF_TIFF_G4,
IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This writes a single image to a file stream opened for writing.
(2) If the pix has a colormap, it is preserved in the output file.
(3) For images with bpp > 1, this resets the comptype, if
necessary, to write uncompressed data.
(4) G3 and G4 are only defined for 1 bpp.
(5) We only allow PACKBITS for bpp = 1, because for bpp > 1
it typically expands images that are not synthetically generated.
(6) G4 compression is typically about twice as good as G3.
G4 is excellent for binary compression of text/line-art,
but terrible for halftones and dithered patterns.  (In
fact, G4 on halftones can give a file that is larger
than uncompressed!)  If a binary image has dithered
regions, it is usually better to compress with png.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamTiff(*args)
    
    

    try:
        leptonica.pixWriteStreamTiffWA.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixWriteStreamTiffWA.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamTiffWA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamTiffWA(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('const char', '*modestr')       

:param[in]    fp:       file stream opened for append or write
:param[in]    pix:
:param[in]    comptype: IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
IFF_TIFF_G3, IFF_TIFF_G4,
IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG
:param[in]    modestr:  "w" or "a"
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteStreamTiff()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamTiffWA(*args)
    
    

    try:
        leptonica.pixReadFromMultipageTiff.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixReadFromMultipageTiff.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadFromMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadFromMultipageTiff(*args):
        """
        ('const char', '*fname')       
('size_t', '*poffset')       

:param[in]      fname:     filename
:param[in,out]  poffset:   set offset to 0 for first image
:returns:  pix, or NULL on error or if previous call returned the last image

<pre>
Notes:
(1) This allows overhead for traversal of a multipage tiff file
to be linear in the number of images.  This will also work
with a singlepage tiff file.
(2) No TIFF internal data structures are exposed to the caller
(thanks to Jeff Breidenbach).
(3) offset is the byte offset of a particular image in a multipage
tiff file. To get the first image in the file, input the
special offset value of 0.
(4) The offset is updated to point to the next image, for a
subsequent call.
(5) On the last image, the offset returned is 0.  Exit the loop
when the returned offset is 0.
(6) For reading a multipage tiff from a memory buffer, see
pixReadMemFromMultipageTiff()
(7) Example usage for reading all the images in the tif file:
size_t offset = 0;
do {
Pix *pix = pixReadFromMultipageTiff(filename, &offset);
// do something with pix
} while (offset != 0);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadFromMultipageTiff(*args)
    
    

    try:
        leptonica.pixaReadMultipageTiff.argtypes = [ctypes.c_char_p]
        leptonica.pixaReadMultipageTiff.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadMultipageTiff(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:    input tiff file
:returns:  pixa of page images, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadMultipageTiff(*args)
    
    

    try:
        leptonica.pixaWriteMultipageTiff.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixaWriteMultipageTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteMultipageTiff(*args):
        """
        ('const char', '*fname')       
('PIXA', '*pixa')       

:param[in]    fname:      input tiff file
:param[in]    pixa:       any depth; colormap will be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The tiff directory overhead is O(n^2).  I have not been
able to reduce it to O(n).  The overhead for n = 2000 is
about 1 second.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteMultipageTiff(*args)
    
    

    try:
        leptonica.writeMultipageTiff.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.writeMultipageTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function writeMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def writeMultipageTiff(*args):
        """
        ('const char', '*dirin')       
('const char', '*substr')       
('const char', '*fileout')       

:param[in]    dirin:   input directory
:param[in]    substr:  [optional] substring filter on filenames; can be NULL
:param[in]    fileout: output multipage tiff file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This writes a set of image files in a directory out
as a multipage tiff file.  The images can be in any
initial file format.
(2) Images with a colormap have the colormap removed before
re-encoding as tiff.
(3) All images are encoded losslessly.  Those with 1 bpp are
encoded 'g4'.  The rest are encoded as 'zip' (flate encoding).
Because it is lossless, this is an expensive method for
saving most rgb images.
(4) The tiff directory overhead is quadratic in the number of
images.  To avoid this for very large numbers of images to be
written, apply the method used in pixaWriteMultipageTiff().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.writeMultipageTiff(*args)
    
    

    try:
        leptonica.writeMultipageTiffSA.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.writeMultipageTiffSA.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function writeMultipageTiffSA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def writeMultipageTiffSA(*args):
        """
        ('SARRAY', '*sa')       
('const char', '*fileout')       

:param[in]    sa:       string array of full path names
:param[in]    fileout:  output ps file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See writeMultipageTiff()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.writeMultipageTiffSA(*args)
    
    

    try:
        leptonica.fprintTiffInfo.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.fprintTiffInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fprintTiffInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fprintTiffInfo(*args):
        """
        ('FILE', '*fpout')       
('const char', '*tiffile')       

:param[in]    fpout:    stream for output of tag data
:param[in]    tiffile:  input
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fprintTiffInfo(*args)
    
    

    try:
        leptonica.tiffGetCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.tiffGetCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function tiffGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def tiffGetCount(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pn')       

:param[in]    fp:   file stream opened for read
:param[out]   pn:   number of images
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.tiffGetCount(*args)
    
    

    try:
        leptonica.getTiffResolution.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getTiffResolution.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getTiffResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getTiffResolution(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       

:param[in]    fp:            file stream opened for read
:param[out]   pxres,: pyres  resolution in ppi
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If neither resolution field is set, this is not an error;
the returned resolution values are 0 (designating 'unknown').
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getTiffResolution(*args)
    
    

    try:
        leptonica.readHeaderTiff.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderTiff(*args):
        """
        ('const char', '*filename')       
('l_int32', 'n')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*pres')       
('l_int32', '*pcmap')       
('l_int32', '*pformat')       

:param[in]    filename:
:param[in]    n:          page image number: 0-based
:param[out]   pw:         [optional] width
:param[out]   ph:         [optional] height
:param[out]   pbps:       [optional] bits per sample -- 1, 2, 4 or 8
:param[out]   pspp:       [optional] samples per pixel -- 1 or 3
:param[out]   pres:       [optional] resolution in x dir; NULL to ignore
:param[out]   pcmap:      [optional] colormap exists; input NULL to ignore
:param[out]   pformat:    [optional] tiff format; input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there is a colormap, cmap is returned as 1; else 0.
(2) If %n is equal to or greater than the number of images, returns 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderTiff(*args)
    
    

    try:
        leptonica.freadHeaderTiff.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function freadHeaderTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderTiff(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'n')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*pres')       
('l_int32', '*pcmap')       
('l_int32', '*pformat')       

:param[in]    fp:       file stream
:param[in]    n:        page image number: 0-based
:param[out]   pw:       [optional] width
:param[out]   ph:       [optional] height
:param[out]   pbps:     [optional] bits per sample -- 1, 2, 4 or 8
:param[out]   pspp:     [optional] samples per pixel -- 1 or 3
:param[out]   pres:     [optional] resolution in x dir; NULL to ignore
:param[out]   pcmap:    [optional] colormap exists; input NULL to ignore
:param[out]   pformat:  [optional] tiff format; input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there is a colormap, cmap is returned as 1; else 0.
(2) If %n is equal to or greater than the number of images, returns 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderTiff(*args)
    
    

    try:
        leptonica.readHeaderMemTiff.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderMemTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemTiff(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
('l_int32', 'n')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*pres')       
('l_int32', '*pcmap')       
('l_int32', '*pformat')       

:param[in]    cdata:     const; tiff-encoded
:param[in]    size:      size of data
:param[in]    n:         page image number: 0-based
:param[out]   pw:        [optional] width
:param[out]   ph:        [optional] height
:param[out]   pbps:      [optional] bits per sample -- 1, 2, 4 or 8
:param[out]   pspp:      [optional] samples per pixel -- 1 or 3
:param[out]   pres:      [optional] resolution in x dir; NULL to ignore
:param[out]   pcmap:     [optional] colormap exists; input NULL to ignore
:param[out]   pformat:   [optional] tiff format; input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemTiff(*args)
    
    

    try:
        leptonica.findTiffCompression.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.findTiffCompression.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function findTiffCompression not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findTiffCompression(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pcomptype')       

:param[in]    fp:         file stream; must be rewound to BOF
:param[out]   pcomptype:  compression type
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The returned compression type is that defined in
the enum in imageio.h.  It is not the tiff flag value.
(2) The compression type is initialized to IFF_UNKNOWN.
If it is not one of the specified types, the returned
type is IFF_TIFF, which indicates no compression.
(3) When this function is called, the stream must be at BOF.
If the opened stream is to be used again to read the
file, it must be rewound to BOF after calling this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.findTiffCompression(*args)
    
    

    try:
        leptonica.extractG4DataFromFile.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.extractG4DataFromFile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function extractG4DataFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractG4DataFromFile(*args):
        """
        ('const char', '*filein')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pminisblack')       

:param[in]    filein:
:param[out]   pdata:         binary data of ccitt g4 encoded stream
:param[out]   pnbytes:       size of binary data
:param[out]   pw:            [optional] image width
:param[out]   ph:            [optional] image height
:param[out]   pminisblack:   [optional] boolean
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.extractG4DataFromFile(*args)
    
    

    try:
        leptonica.pixReadMemTiff.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.pixReadMemTiff.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemTiff(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
('l_int32', 'n')       

:param[in]    cdata:    const; tiff-encoded
:param[in]    size:     size of cdata
:param[in]    n:        page image number: 0-based
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This is a version of pixReadTiff(), where the data is read
from a memory buffer and uncompressed.
(2) Use TIFFClose(); TIFFCleanup() doesn't free internal memstream.
(3) No warning messages on failure, because of how multi-page
TIFF reading works. You are supposed to keep trying until
it stops working.
(4) Tiff directory overhead is linear in the input page number.
If reading many images, use pixReadMemFromMultipageTiff().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemTiff(*args)
    
    

    try:
        leptonica.pixReadMemFromMultipageTiff.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.pixReadMemFromMultipageTiff.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemFromMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemFromMultipageTiff(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       
('size_t', '*poffset')       

:param[in]    cdata:      const; tiff-encoded
:param[in]    size:       size of cdata
:param[in,out]  poffset:  set offset to 0 for first image
:returns:  pix, or NULL on error or if previous call returned the last image

<pre>
Notes:
(1) This is a read-from-memory version of pixReadFromMultipageTiff().
See that function for usage.
(2) If reading sequentially from the tiff data, this is more
efficient than pixReadMemTiff(), which has an overhead
proportional to the image index n.
(3) Example usage for reading all the images:
size_t offset = 0;
do {
Pix *pix = pixReadMemFromMultipageTiff(data, size, &offset);
// do something with pix
} while (offset != 0);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemFromMultipageTiff(*args)
    
    

    try:
        leptonica.pixaReadMemMultipageTiff.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixaReadMemMultipageTiff.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadMemMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadMemMultipageTiff(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    const; multiple pages; tiff-encoded
:param[in]    size:    size of cdata
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) This is an O(n) read-from-memory version of pixaReadMultipageTiff().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadMemMultipageTiff(*args)
    
    

    try:
        leptonica.pixaWriteMemMultipageTiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaWriteMemMultipageTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteMemMultipageTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteMemMultipageTiff(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIXA', '*pixa')       

:param[out]    pdata:   const; tiff-encoded
:param[out]    psize:   size of data
:param[in]     pixa:    any depth; colormap will be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) fopenTiffMemstream() does not work in append mode, so we
must work-around with a temporary file.
(2) Getting a file stream from
open_memstream((char **)pdata, psize)
does not work with the tiff directory.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteMemMultipageTiff(*args)
    
    

    try:
        leptonica.pixWriteMemTiff.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteMemTiff.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemTiff not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemTiff(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'comptype')       

:param[out]   pdata:     data of tiff compressed image
:param[out]   psize:     size of returned data
:param[in]    pix:
:param[in]    comptype:  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
IFF_TIFF_G3, IFF_TIFF_G4,
IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG
:returns:  0 if OK, 1 on error

Usage:
1) See pixWriteTiff(.  This version writes to
memory instead of to a file.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemTiff(*args)
    
    

    try:
        leptonica.pixWriteMemTiffCustom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemTiffCustom.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemTiffCustom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemTiffCustom(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'comptype')       
('NUMA', '*natags')       
('SARRAY', '*savals')       
('SARRAY', '*satypes')       
('NUMA', '*nasizes')       

:param[out]   pdata:     data of tiff compressed image
:param[out]   psize:     size of returned data
:param[in]    pix:
:param[in]    comptype:  IFF_TIFF, IFF_TIFF_RLE, IFF_TIFF_PACKBITS,
IFF_TIFF_G3, IFF_TIFF_G4,
IFF_TIFF_LZW, IFF_TIFF_ZIP, IFF_TIFF_JPEG
:param[in]    natags:    [optional] NUMA of custom tiff tags
:param[in]    savals:    [optional] SARRAY of values
:param[in]    satypes:   [optional] SARRAY of types
:param[in]    nasizes:   [optional] NUMA of sizes
:returns:  0 if OK, 1 on error

Usage:
1) See pixWriteTiffCustom(.  This version writes to
memory instead of to a file.
2) Use TIFFClose(); TIFFCleanup( doesn't free internal memstream.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemTiffCustom(*args)
    




class binarize(object):
    """<pre>

===================================================================
Image binarization algorithms are found in:
grayquant.c:   standard, simple, general grayscale quantization
adaptmap.c:    local adaptive; mostly gray-to-gray in preparation
for binarization
binarize.c:    special binarization methods, locally adaptive and
global.
===================================================================

Adaptive Otsu-based thresholding
l_int32       pixOtsuAdaptiveThreshold()       8 bpp

Otsu thresholding on adaptive background normalization
PIX          *pixOtsuThreshOnBackgroundNorm()  8 bpp

Masking and Otsu estimate on adaptive background normalization
PIX          *pixMaskedThreshOnBackgroundNorm()  8 bpp

Sauvola local thresholding
l_int32       pixSauvolaBinarizeTiled()
l_int32       pixSauvolaBinarize()
static PIX   *pixSauvolaGetThreshold()
static PIX   *pixApplyLocalThreshold();

Global thresholding using connected components
PIX          *pixThresholdByConnComp()

Global thresholding by histogram
PIX          *pixThresholdByHisto()

Notes:
(1) pixOtsuAdaptiveThreshold() computes a global threshold over each
tile and performs the threshold operation, resulting in a
binary image for each tile.  These are stitched into the
final result.
(2) pixOtsuThreshOnBackgroundNorm() and
pixMaskedThreshOnBackgroundNorm() are binarization functions
that use background normalization with other techniques.
(3) Sauvola binarization computes a local threshold based on
the local average and square average.  It takes two constants:
the window size for the measurement at each pixel and a
parameter that determines the amount of normalized local
standard deviation to subtract from the local average value.
(4) pixThresholdByConnComp() uses the numbers of 4 and 8 connected
components at different thresholding to determine if a
global threshold can be used (for text or line-art) and the
value it should have.
</pre>




"""
    
    try:
        leptonica.pixOtsuAdaptiveThreshold.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOtsuAdaptiveThreshold.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixOtsuAdaptiveThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOtsuAdaptiveThreshold(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'scorefract')       
('PIX', '**ppixth')       
('PIX', '**ppixd')       

:param[in]    pixs:              8 bpp
:param[in]    sx,: sy            desired tile dimensions; actual size may vary
:param[in]    smoothx,: smoothy  half-width of convolution kernel applied to
threshold array: use 0 for no smoothing
:param[in]    scorefract:        fraction of the max Otsu score; typ. 0.1;
use 0.0 for standard Otsu
:param[out]   ppixth:            [optional] array of threshold values
found for each tile
:param[out]   ppixd:             [optional] thresholded input pixs,
based on the threshold array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The Otsu method finds a single global threshold for an image.
This function allows a locally adapted threshold to be
found for each tile into which the image is broken up.
(2) The array of threshold values, one for each tile, constitutes
a highly downscaled image.  This array is optionally
smoothed using a convolution.  The full width and height of the
convolution kernel are (2 * %smoothx + 1) and (2 * %smoothy + 1).
(3) The minimum tile dimension allowed is 16.  If such small
tiles are used, it is recommended to use smoothing, because
without smoothing, each small tile determines the splitting
threshold independently.  A tile that is entirely in the
image bg will then hallucinate fg, resulting in a very noisy
binarization.  The smoothing should be large enough that no
tile is only influenced by one type (fg or bg) of pixels,
because it will force a split of its pixels.
(4) To get a single global threshold for the entire image, use
input values of %sx and %sy that are larger than the image.
For this situation, the smoothing parameters are ignored.
(5) The threshold values partition the image pixels into two classes:
one whose values are less than the threshold and another
whose values are greater than or equal to the threshold.
This is the same use of 'threshold' as in pixThresholdToBinary().
(6) The scorefract is the fraction of the maximum Otsu score, which
is used to determine the range over which the histogram minimum
is searched.  See numaSplitDistribution() for details on the
underlying method of choosing a threshold.
(7) This uses enables a modified version of the Otsu criterion for
splitting the distribution of pixels in each tile into a
fg and bg part.  The modification consists of searching for
a minimum in the histogram over a range of pixel values where
the Otsu score is within a defined fraction, %scorefract,
of the max score.  To get the original Otsu algorithm, set
%scorefract == 0.
(8) N.B. This method is NOT recommended for images with weak text
and significant background noise, such as bleedthrough, because
of the problem noted in (3) above for tiling.  Use Sauvola.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOtsuAdaptiveThreshold(*args)
    
    

    try:
        leptonica.pixOtsuThreshOnBackgroundNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixOtsuThreshOnBackgroundNorm.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOtsuThreshOnBackgroundNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOtsuThreshOnBackgroundNorm(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'bgval')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'scorefract')       
('l_int32', '*pthresh')       

:param[in]    pixs:         8 bpp grayscale; not colormapped
:param[in]    pixim:        [optional] 1 bpp 'image' mask; can be null
:param[in]    sx,: sy       tile size in pixels
:param[in]    thresh:       threshold for determining foreground
:param[in]    mincount:     min threshold on counts in a tile
:param[in]    bgval:        target bg val; typ. > 128
:param[in]    smoothx:      half-width of block convolution kernel width
:param[in]    smoothy:      half-width of block convolution kernel height
:param[in]    scorefract:   fraction of the max Otsu score; typ. 0.1
:param[out]   pthresh:      [optional] threshold value that was
used on the normalized image
:returns:  pixd 1 bpp thresholded image, or NULL on error

<pre>
Notes:
(1) This does background normalization followed by Otsu
thresholding.  Otsu binarization attempts to split the
image into two roughly equal sets of pixels, and it does
a very poor job when there are large amounts of dark
background.  By doing a background normalization first,
to get the background near 255, we remove this problem.
Then we use a modified Otsu to estimate the best global
threshold on the normalized image.
(2) See pixBackgroundNorm() for meaning and typical values
of input parameters.  For a start, you can try:
sx, sy = 10, 15
thresh = 100
mincount = 50
bgval = 255
smoothx, smoothy = 2
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOtsuThreshOnBackgroundNorm(*args)
    
    

    try:
        leptonica.pixMaskedThreshOnBackgroundNorm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixMaskedThreshOnBackgroundNorm.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaskedThreshOnBackgroundNorm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskedThreshOnBackgroundNorm(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixim')       
('l_int32', 'sx')       
('l_int32', 'sy')       
('l_int32', 'thresh')       
('l_int32', 'mincount')       
('l_int32', 'smoothx')       
('l_int32', 'smoothy')       
('l_float32', 'scorefract')       
('l_int32', '*pthresh')       

:param[in]    pixs:         8 bpp grayscale; not colormapped
:param[in]    pixim:        [optional] 1 bpp 'image' mask; can be null
:param[in]    sx,: sy       tile size in pixels
:param[in]    thresh:       threshold for determining foreground
:param[in]    mincount:     min threshold on counts in a tile
:param[in]    smoothx:      half-width of block convolution kernel width
:param[in]    smoothy:      half-width of block convolution kernel height
:param[in]    scorefract:   fraction of the max Otsu score; typ. ~ 0.1
:param[out]   pthresh:      [optional] threshold value that was
used on the normalized image
:returns:  pixd 1 bpp thresholded image, or NULL on error

<pre>
Notes:
(1) This begins with a standard background normalization.
Additionally, there is a flexible background norm, that
will adapt to a rapidly varying background, and this
puts white pixels in the background near regions with
significant foreground.  The white pixels are turned into
a 1 bpp selection mask by binarization followed by dilation.
Otsu thresholding is performed on the input image to get an
estimate of the threshold in the non-mask regions.
The background normalized image is thresholded with two
different values, and the result is combined using
the selection mask.
(2) Note that the numbers 255 (for bgval target) and 190 (for
thresholding on pixn) are tied together, and explicitly
defined in this function.
(3) See pixBackgroundNorm() for meaning and typical values
of input parameters.  For a start, you can try:
sx, sy = 10, 15
thresh = 100
mincount = 50
smoothx, smoothy = 2
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskedThreshOnBackgroundNorm(*args)
    
    

    try:
        leptonica.pixSauvolaBinarizeTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSauvolaBinarizeTiled.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSauvolaBinarizeTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSauvolaBinarizeTiled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'whsize')       
('l_float32', 'factor')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('PIX', '**ppixth')       
('PIX', '**ppixd')       

:param[in]    pixs:      8 bpp grayscale, not colormapped
:param[in]    whsize:    window half-width for measuring local statistics
:param[in]    factor:    factor for reducing threshold due to variance; >= 0
:param[in]    nx,: ny    subdivision into tiles; >= 1
:param[out]   ppixth:    [optional] Sauvola threshold values
:param[out]   ppixd:     [optional] thresholded image
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The window width and height are 2 * %whsize + 1.  The minimum
value for %whsize is 2; typically it is >= 7..
(2) For nx == ny == 1, this defaults to pixSauvolaBinarize().
(3) Why a tiled version?
(a) Because the mean value accumulator is a uint32, overflow
can occur for an image with more than 16M pixels.
(b) The mean value accumulator array for 16M pixels is 64 MB.
The mean square accumulator array for 16M pixels is 128 MB.
Using tiles reduces the size of these arrays.
(c) Each tile can be processed independently, in parallel,
on a multicore processor.
(4) The Sauvola threshold is determined from the formula:
t = m * (1 - k * (1 - s / 128))
See pixSauvolaBinarize() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSauvolaBinarizeTiled(*args)
    
    

    try:
        leptonica.pixSauvolaBinarize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSauvolaBinarize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSauvolaBinarize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSauvolaBinarize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'whsize')       
('l_float32', 'factor')       
('l_int32', 'addborder')       
('PIX', '**ppixm')       
('PIX', '**ppixsd')       
('PIX', '**ppixth')       
('PIX', '**ppixd')       

:param[in]    pixs:       8 bpp grayscale; not colormapped
:param[in]    whsize:     window half-width for measuring local statistics
:param[in]    factor:     factor for reducing threshold due to variance; >= 0
:param[in]    addborder:  1 to add border of width (%whsize + 1) on all sides
:param[out]   ppixm:      [optional] local mean values
:param[out]   ppixsd:     [optional] local standard deviation values
:param[out]   ppixth:     [optional] threshold values
:param[out]   ppixd:      [optional] thresholded image
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The window width and height are 2 * %whsize + 1.  The minimum
value for %whsize is 2; typically it is >= 7..
(2) The local statistics, measured over the window, are the
average and standard deviation.
(3) The measurements of the mean and standard deviation are
performed inside a border of (%whsize + 1) pixels.  If pixs does
not have these added border pixels, use %addborder = 1 to add
it here; otherwise use %addborder = 0.
(4) The Sauvola threshold is determined from the formula:
t = m * (1 - k * (1 - s / 128))
where:
t = local threshold
m = local mean
k = %factor (>= 0)   [ typ. 0.35 ]
s = local standard deviation, which is maximized at
127.5 when half the samples are 0 and half are 255.
(5) The basic idea of Niblack and Sauvola binarization is that
the local threshold should be less than the median value,
and the larger the variance, the closer to the median
it should be chosen.  Typical values for k are between
0.2 and 0.5.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSauvolaBinarize(*args)
    
    

    try:
        leptonica.pixThresholdByConnComp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixThresholdByConnComp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdByConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdByConnComp(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'start')       
('l_int32', 'end')       
('l_int32', 'incr')       
('l_float32', 'thresh48')       
('l_float32', 'threshdiff')       
('l_int32', '*pglobthresh')       
('PIX', '**ppixd')       
('l_int32', 'debugflag')       

:param[in]    pixs:          depth > 1, colormap OK
:param[in]    pixm:          [optional] 1 bpp mask giving region to ignore
by setting pixels to white; use NULL if no mask
:param[in]    start,: end, incr   binarization threshold levels to test
:param[in]    thresh48:      threshold on normalized difference between the
numbers of 4 and 8 connected components
:param[in]    threshdiff:    threshold on normalized difference between the
number of 4 cc at successive iterations
:param[out]   pglobthresh:   [optional] best global threshold; 0
if no threshold is found
:param[out]   ppixd:         [optional] image thresholded to binary, or
null if no threshold is found
:param[in]    debugflag:     1 for plotted results
:returns:  0 if OK, 1 on error or if no threshold is found

<pre>
Notes:
(1) This finds a global threshold based on connected components.
Although slow, it is reasonable to use it in a situation where
(a) the background in the image is relatively uniform, and
(b) the result will be fed to an OCR program that accepts 1 bpp
images and works best with easily segmented characters.
The reason for (b) is that this selects a threshold with a
minimum number of both broken characters and merged characters.
(2) If the pix has color, it is converted to gray using the
max component.
(3) Input 0 to use default values for any of these inputs:
%start, %end, %incr, %thresh48, %threshdiff.
(4) This approach can be understood as follows.  When the
binarization threshold is varied, the numbers of c.c. identify
four regimes:
(a) For low thresholds, text is broken into small pieces, and
the number of c.c. is large, with the 4 c.c. significantly
exceeding the 8 c.c.
(b) As the threshold rises toward the optimum value, the text
characters coalesce and there is very little difference
between the numbers of 4 and 8 c.c, which both go
through a minimum.
(c) Above this, the image background gets noisy because some
pixels are(thresholded to foreground, and the numbers
of c.c. quickly increase, with the 4 c.c. significantly
larger than the 8 c.c.
(d) At even higher thresholds, the image background noise
coalesces as it becomes mostly foreground, and the
number of c.c. drops quickly.
(5) If there is no global threshold that distinguishes foreground
text from background (e.g., weak text over a background that
has significant variation and/or bleedthrough), this returns 1,
which the caller should check.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdByConnComp(*args)
    
    

    try:
        leptonica.pixThresholdByHisto.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixThresholdByHisto.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdByHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdByHisto(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'halfw')       
('l_float32', 'delta')       
('l_int32', '*pthresh')       
('PIX', '**ppixd')       
('PIX', '**ppixhisto')       

:param[in]    pixs:          gray 8 bpp, no colormap
:param[in]    factor:        subsampling factor >= 1
:param[in]    halfw:         half of window width for smoothing;
use 0 for default
:param[in]    delta:         relative amount to resolve peaks and valleys;
in (0 ... 1], use 0 for default
:param[out]   pthresh:       best global threshold; 0 if no threshold is found
:param[out]   ppixd:         [optional] thresholded 1 bpp pix
:param[out]   ppixhisto:     [optional] rescaled histogram of gray values
:returns:  0 if OK, 1 on error or if no threshold is found

<pre>
Notes:
(1) This finds a global threshold.  It is best for an image that
has a fairly well-defined fg and bg.
(2) If it finds a good threshold and %ppixd is defined, the binarized
image is returned in &pixd; otherwise it return null.
(3) Suggest using default values for %half and %delta.
(4) Returns 0 in %pthresh if it can't find a good threshold.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdByHisto(*args)
    




class grayquant(object):
    """<pre>

Thresholding from 8 bpp to 1 bpp

Floyd-Steinberg dithering to binary
PIX         *pixDitherToBinary()
PIX         *pixDitherToBinarySpec()
static void  ditherToBinaryLow()
void         ditherToBinaryLineLow()

Simple (pixelwise) binarization with fixed threshold
PIX         *pixThresholdToBinary()
static void  thresholdToBinaryLow()
void         thresholdToBinaryLineLow()

Binarization with variable threshold
PIX         *pixVarThresholdToBinary()

Binarization by adaptive mapping
PIX         *pixAdaptThresholdToBinary()
PIX         *pixAdaptThresholdToBinaryGen()

Generate a binary mask from pixels of particular values
PIX         *pixGenerateMaskByValue()
PIX         *pixGenerateMaskByBand()

Thresholding from 8 bpp to 2 bpp

Floyd-Steinberg-like dithering to 2 bpp
PIX         *pixDitherTo2bpp()
PIX         *pixDitherTo2bppSpec()
static void  ditherTo2bppLow()
static void  ditherTo2bppLineLow()
static l_int32  make8To2DitherTables()

Simple (pixelwise) thresholding to 2 bpp with optional cmap
PIX         *pixThresholdTo2bpp()
static void  thresholdTo2bppLow()

Simple (pixelwise) thresholding from 8 bpp to 4 bpp
PIX         *pixThresholdTo4bpp()
static void  thresholdTo4bppLow()

Simple (pixelwise) quantization on 8 bpp grayscale
PIX         *pixThresholdOn8bpp()

Arbitrary (pixelwise) thresholding from 8 bpp to 2, 4 or 8 bpp
PIX         *pixThresholdGrayArb()

Quantization tables for linear thresholds of grayscale images
l_int32     *makeGrayQuantIndexTable()
static l_int32  *makeGrayQuantTargetTable()

Quantization table for arbitrary thresholding of grayscale images
l_int32      makeGrayQuantTableArb()
static l_int32   makeGrayQuantColormapArb()

Thresholding from 32 bpp rgb to 1 bpp
(really color quantization, but it's better placed in this file)
PIX         *pixGenerateMaskByBand32()
PIX         *pixGenerateMaskByDiscr32()

Histogram-based grayscale quantization
PIX         *pixGrayQuantFromHisto()
static l_int32  numaFillCmapFromHisto()

Color quantize grayscale image using existing colormap
PIX         *pixGrayQuantFromCmap()
</pre>




"""
    
    try:
        leptonica.pixDitherToBinary.argtypes = [ctypes.c_void_p]
        leptonica.pixDitherToBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDitherToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherToBinary(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:
:returns:  pixd dithered binary, or NULL on error

The Floyd-Steinberg error diffusion dithering algorithm
binarizes an 8 bpp grayscale image to a threshold of 128.
If a pixel has a value above 127, it is binarized to white
and the excess below 255 is subtracted from three
neighboring pixels in the fractions 3/8 to i, j+1,
3/8 to i+1, j) and 1/4 to (i+1,j+1, truncating to 0
if necessary.  Likewise, if it the pixel has a value
below 128, it is binarized to black and the excess above 0
is added to the neighboring pixels, truncating to 255 if necessary.

This function differs from straight dithering in that it allows
clipping of grayscale to 0 or 255 if the values are
sufficiently close, without distribution of the excess.
This uses default values to specify the range of lower
and upper values near 0 and 255, rsp that are clipped
to black and white without propagating the excess.
Not propagating the excess has the effect of reducing the
snake patterns in parts of the image that are nearly black or white;
however, it also prevents the attempt to reproduce gray for those values.

The implementation is straightforward.  It uses a pair of
line buffers to avoid changing pixs.  It is about the same speed
as pixDitherToBinaryLUT(), which uses three LUTs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherToBinary(*args)
    
    

    try:
        leptonica.pixDitherToBinarySpec.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDitherToBinarySpec.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDitherToBinarySpec not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherToBinarySpec(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       

:param[in]    pixs:
:param[in]    lowerclip:   lower clip distance to black; use 0 for default
:param[in]    upperclip:   upper clip distance to white; use 0 for default
:returns:  pixd dithered binary, or NULL on error

<pre>
Notes:
(1) See comments above in pixDitherToBinary() for details.
(2) The input parameters lowerclip and upperclip specify the range
of lower and upper values (near 0 and 255, rsp) that are
clipped to black and white without propagating the excess.
For that reason, lowerclip and upperclip should be small numbers.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherToBinarySpec(*args)
    
    

    try:
        leptonica.ditherToBinaryLineLow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.ditherToBinaryLineLow.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ditherToBinaryLineLow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ditherToBinaryLineLow(*args):
        """
        ('l_uint32', '*lined')       
('l_int32', 'w')       
('l_uint32', '*bufs1')       
('l_uint32', '*bufs2')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       
('l_int32', 'lastlineflag')       

:param[in]    lined:         ptr to beginning of dest line
:param[in]    w:             width of image in pixels
:param[in]    bufs1:         buffer of current source line
:param[in]    bufs2:         buffer of next source line
:param[in]    lowerclip:     lower clip distance to black
:param[in]    upperclip:     upper clip distance to white
:param[in]    lastlineflag:  0 if not last dest line, 1 if last dest line
:returns:  void

Dispatches FS error diffusion dithering for
a single line of the image.  If lastlineflag == 0,
both source buffers are used; otherwise, only bufs1
is used.  We use source buffers because the error
is propagated into them, and we don't want to change
the input src image.

We break dithering out line by line to make it
easier to combine functions like interpolative
scaling and error diffusion dithering, as such a
combination of operations obviates the need to
generate a 2x grayscale image as an intermediary.


        """
        args = _convert_params(*args)
        
        return leptonica.ditherToBinaryLineLow(*args)
    
    

    try:
        leptonica.pixThresholdToBinary.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixThresholdToBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdToBinary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       

:param[in]    pixs:     4 or 8 bpp
:param[in]    thresh:   threshold value
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) If the source pixel is less than the threshold value,
the dest will be 1; otherwise, it will be 0.
(2) For example, for 8 bpp src pix, if %thresh == 256, the dest
1 bpp pix is all ones (fg), and if %thresh == 0, the dest
pix is all zeros (bg).

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdToBinary(*args)
    
    

    try:
        leptonica.pixVarThresholdToBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarThresholdToBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixVarThresholdToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarThresholdToBinary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       

:param[in]    pixs:    8 bpp
:param[in]    pixg:    8 bpp; contains threshold values for each pixel
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) If the pixel in pixs is less than the corresponding pixel
in pixg, the dest will be 1; otherwise it will be 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarThresholdToBinary(*args)
    
    

    try:
        leptonica.pixAdaptThresholdToBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixAdaptThresholdToBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAdaptThresholdToBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAdaptThresholdToBinary(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'gamma')       

:param[in]    pixs:    8 bpp
:param[in]    pixm:    [optional] 1 bpp image mask; can be null
:param[in]    gamma:   gamma correction; must be > 0.0; typically ~1.0
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This is a simple convenience function for doing adaptive
thresholding on a grayscale image with variable background.
It uses default parameters appropriate for typical text images.
(2) %pixm is a 1 bpp mask over "image" regions, which are not
expected to have a white background.  The mask inhibits
background finding under the fg pixels of the mask.  For
images with both text and image, the image regions would
be binarized (or quantized) by a different set of operations.
(3) As %gamma is increased, the foreground pixels are reduced.
(4) Under the covers:  The default background value for normalization
is 200, so we choose 170 for 'maxval' in pixGammaTRC.  Likewise,
the default foreground threshold for normalization is 60,
so we choose 50 for 'minval' in pixGammaTRC.  Because
170 was mapped to 255, choosing 200 for the threshold is
quite safe for avoiding speckle noise from the background.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAdaptThresholdToBinary(*args)
    
    

    try:
        leptonica.pixAdaptThresholdToBinaryGen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAdaptThresholdToBinaryGen.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAdaptThresholdToBinaryGen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAdaptThresholdToBinaryGen(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'gamma')       
('l_int32', 'blackval')       
('l_int32', 'whiteval')       
('l_int32', 'thresh')       

:param[in]    pixs:       8 bpp
:param[in]    pixm:       [optional] 1 bpp image mask; can be null
:param[in]    gamma:      gamma correction; must be > 0.0; typically ~1.0
:param[in]    blackval:   dark value to set to black (0)
:param[in]    whiteval:   light value to set to white (255)
:param[in]    thresh:     final threshold for binarization
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This is a convenience function for doing adaptive thresholding
on a grayscale image with variable background.  Also see notes
in pixAdaptThresholdToBinary().
(2) Reducing %gamma increases the foreground (text) pixels.
Use a low value (e.g., 0.5) for images with light text.
(3) For normal images, see default args in pixAdaptThresholdToBinary().
For images with very light text, these values are appropriate:
gamma     ~0.5
blackval  ~70
whiteval  ~190
thresh    ~200
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAdaptThresholdToBinaryGen(*args)
    
    

    try:
        leptonica.pixGenerateMaskByValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGenerateMaskByValue.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateMaskByValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByValue(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'val')       
('l_int32', 'usecmap')       

:param[in]    pixs:      2, 4 or 8 bpp, or colormapped
:param[in]    val:       of pixels for which we set 1 in dest
:param[in]    usecmap:   1 to retain cmap values; 0 to convert to gray
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) %val is the pixel value that we are selecting.  It can be
either a gray value or a colormap index.
(2) If pixs is colormapped, %usecmap determines if the colormap
index values are used, or if the colormap is removed to gray and
the gray values are used.  For the latter, it generates
an approximate grayscale value for each pixel, and then looks
for gray pixels with the value %val.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByValue(*args)
    
    

    try:
        leptonica.pixGenerateMaskByBand.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGenerateMaskByBand.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateMaskByBand not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByBand(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lower')       
('l_int32', 'upper')       
('l_int32', 'inband')       
('l_int32', 'usecmap')       

:param[in]    pixs:           2, 4 or 8 bpp, or colormapped
:param[in]    lower,: upper   two pixel values from which a range, either
between (inband) or outside of (!inband),
determines which pixels in pixs cause us to
set a 1 in the dest mask
:param[in]    inband:         1 for finding pixels in [lower, upper];
0 for finding pixels in
[0, lower) union (upper, 255]
:param[in]    usecmap:        1 to retain cmap values; 0 to convert to gray
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) Generates a 1 bpp mask pixd, the same size as pixs, where
the fg pixels in the mask are those either within the specified
band (for inband == 1) or outside the specified band
(for inband == 0).
(2) If pixs is colormapped, %usecmap determines if the colormap
values are used, or if the colormap is removed to gray and
the gray values are used.  For the latter, it generates
an approximate grayscale value for each pixel, and then looks
for gray pixels with the value %val.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByBand(*args)
    
    

    try:
        leptonica.pixDitherTo2bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDitherTo2bpp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDitherTo2bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherTo2bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'cmapflag')       

:param[in]    pixs:       8 bpp
:param[in]    cmapflag:   1 to generate a colormap
:returns:  pixd dithered   2 bpp, or NULL on error

An analog of the Floyd-Steinberg error diffusion dithering
algorithm is used to "dibitize" an 8 bpp grayscale image
to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255,
which are served by thresholds of 43, 128 and 213.
If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255.
If a pixel has a value between 0 and 42, it is dibitized
to 0, and the excess above 0 is added to the
three neighboring pixels, in the fractions 3/8 to i, j+1,
3/8 to i+1, j) and 1/4 to (i+1, j+1, truncating to 255 if
necessary.  If a pixel has a value between 43 and 127, it is
dibitized to 1, and the excess above 85 is added to the three
neighboring pixels as before.  If the value is below 85, the
excess is subtracted.  With a value between 128
and 212, it is dibitized to 2, with the excess on either side
of 170 distributed as before.  Finally, with a value between
213 and 255, it is dibitized to 3, with the excess below 255
subtracted from the neighbors.  We always truncate to 0 or 255.
The details can be seen in the lookup table generation.

This function differs from straight dithering in that it allows
clipping of grayscale to 0 or 255 if the values are
sufficiently close, without distribution of the excess.
This uses default values from pix.h to specify the range of lower
and upper values near 0 and 255, rsp that are clipped to black
and white without propagating the excess.
Not propagating the excess has the effect of reducing the snake
patterns in parts of the image that are nearly black or white;
however, it also prevents any attempt to reproduce gray for those values.

The implementation uses 3 lookup tables for simplicity, and
a pair of line buffers to avoid modifying pixs.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherTo2bpp(*args)
    
    

    try:
        leptonica.pixDitherTo2bppSpec.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDitherTo2bppSpec.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDitherTo2bppSpec not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherTo2bppSpec(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       
('l_int32', 'cmapflag')       

:param[in]    pixs:        8 bpp
:param[in]    lowerclip:   lower clip distance to black; use 0 for default
:param[in]    upperclip:   upper clip distance to white; use 0 for default
:param[in]    cmapflag:    1 to generate a colormap
:returns:  pixd dithered    2 bpp, or NULL on error

<pre>
Notes:
(1) See comments above in pixDitherTo2bpp() for details.
(2) The input parameters lowerclip and upperclip specify the range
of lower and upper values (near 0 and 255, rsp) that are
clipped to black and white without propagating the excess.
For that reason, lowerclip and upperclip should be small numbers.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherTo2bppSpec(*args)
    
    

    try:
        leptonica.pixThresholdTo2bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdTo2bpp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdTo2bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdTo2bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       

:param[in]    pixs:       8 bpp
:param[in]    nlevels:    equally spaced; must be between 2 and 4
:param[in]    cmapflag:   1 to build colormap; 0 otherwise
:returns:  pixd 2 bpp, optionally with colormap, or NULL on error

<pre>
Notes:
(1) Valid values for nlevels is the set {2, 3, 4}.
(2) Any colormap on the input pixs is removed to 8 bpp grayscale.
(3) This function is typically invoked with cmapflag == 1.
In the situation where no colormap is desired, nlevels is
ignored and pixs is thresholded to 4 levels.
(4) The target output colors are equally spaced, with the
darkest at 0 and the lightest at 255.  The thresholds are
chosen halfway between adjacent output values.  A table
is built that specifies the mapping from src to dest.
(5) If cmapflag == 1, a colormap of size 'nlevels' is made,
and the pixel values in pixs are replaced by their
appropriate color indices.  The number of holdouts,
4 - nlevels, will be between 0 and 2.
(6) If you don't want the thresholding to be equally spaced,
either first transform the 8 bpp src using pixGammaTRC().
or, if cmapflag == 1, after calling this function you can use
pixcmapResetColor() to change any individual colors.
(7) If a colormap is generated, it will specify (to display
programs) exactly how each level is to be represented in RGB
space.  When representing text, 3 levels is far better than
2 because of the antialiasing of the single gray level,
and 4 levels (black, white and 2 gray levels) is getting
close to the perceptual quality of a (nearly continuous)
grayscale image.  With 2 bpp, you can set up a colormap
and allocate from 2 to 4 levels to represent antialiased text.
Any left over colormap entries can be used for coloring regions.
For the same number of levels, the file size of a 2 bpp image
is about 10% smaller than that of a 4 bpp result for the same
number of levels.  For both 2 bpp and 4 bpp, using 4 levels you
get compression far better than that of jpeg, because the
quantization to 4 levels will remove the jpeg ringing in the
background near character edges.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdTo2bpp(*args)
    
    

    try:
        leptonica.pixThresholdTo4bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdTo4bpp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdTo4bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdTo4bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      8 bpp, can have colormap
:param[in]    nlevels:   equally spaced; must be between 2 and 16
:param[in]    cmapflag:  1 to build colormap; 0 otherwise
:returns:  pixd 4 bpp, optionally with colormap, or NULL on error

<pre>
Notes:
(1) Valid values for nlevels is the set {2, ... 16}.
(2) Any colormap on the input pixs is removed to 8 bpp grayscale.
(3) This function is typically invoked with cmapflag == 1.
In the situation where no colormap is desired, nlevels is
ignored and pixs is thresholded to 16 levels.
(4) The target output colors are equally spaced, with the
darkest at 0 and the lightest at 255.  The thresholds are
chosen halfway between adjacent output values.  A table
is built that specifies the mapping from src to dest.
(5) If cmapflag == 1, a colormap of size 'nlevels' is made,
and the pixel values in pixs are replaced by their
appropriate color indices.  The number of holdouts,
16 - nlevels, will be between 0 and 14.
(6) If you don't want the thresholding to be equally spaced,
either first transform the 8 bpp src using pixGammaTRC().
or, if cmapflag == 1, after calling this function you can use
pixcmapResetColor() to change any individual colors.
(7) If a colormap is generated, it will specify, to display
programs, exactly how each level is to be represented in RGB
space.  When representing text, 3 levels is far better than
2 because of the antialiasing of the single gray level,
and 4 levels (black, white and 2 gray levels) is getting
close to the perceptual quality of a (nearly continuous)
grayscale image.  Therefore, with 4 bpp, you can set up a
colormap, allocate a relatively small fraction of the 16
possible values to represent antialiased text, and use the
other colormap entries for other things, such as coloring
text or background.  Two other reasons for using a small number
of gray values for antialiased text are (1) PNG compression
gets worse as the number of levels that are used is increased,
and (2) using a small number of levels will filter out most of
the jpeg ringing that is typically introduced near sharp edges
of text.  This filtering is partly responsible for the improved
compression.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdTo4bpp(*args)
    
    

    try:
        leptonica.pixThresholdOn8bpp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdOn8bpp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdOn8bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdOn8bpp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       

:param[in]    pixs:       8 bpp, can have colormap
:param[in]    nlevels:    equally spaced; must be between 2 and 256
:param[in]    cmapflag:   1 to build colormap; 0 otherwise
:returns:  pixd 8 bpp, optionally with colormap, or NULL on error

<pre>
Notes:
(1) Valid values for nlevels is the set {2,...,256}.
(2) Any colormap on the input pixs is removed to 8 bpp grayscale.
(3) If cmapflag == 1, a colormap of size 'nlevels' is made,
and the pixel values in pixs are replaced by their
appropriate color indices.  Otherwise, the pixel values
are the actual thresholded (i.e., quantized) grayscale values.
(4) If you don't want the thresholding to be equally spaced,
first transform the input 8 bpp src using pixGammaTRC().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdOn8bpp(*args)
    
    

    try:
        leptonica.pixThresholdGrayArb.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdGrayArb.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdGrayArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdGrayArb(*args):
        """
        ('PIX', '*pixs')       
('const char', '*edgevals')       
('l_int32', 'outdepth')       
('l_int32', 'use_average')       
('l_int32', 'setblack')       
('l_int32', 'setwhite')       

:param[in]    pixs:          8 bpp grayscale; can have colormap
:param[in]    edgevals:      string giving edge value of each bin
:param[in]    outdepth:      0, 2, 4 or 8 bpp; 0 is default for min depth
:param[in]    use_average:   1 if use the average pixel value in colormap
:param[in]    setblack:      1 if darkest color is set to black
:param[in]    setwhite:      1 if lightest color is set to white
:returns:  pixd 2, 4 or 8 bpp quantized image with colormap,
or NULL on error

<pre>
Notes:
(1) This function allows exact specification of the quantization bins.
The string %edgevals is a space-separated set of values
specifying the dividing points between output quantization bins.
These threshold values are assigned to the bin with higher
values, so that each of them is the smallest value in their bin.
(2) The output image (pixd) depth is specified by %outdepth.  The
number of bins is the number of edgevals + 1.  The
relation between outdepth and the number of bins is:
outdepth = 2       nbins <= 4
outdepth = 4       nbins <= 16
outdepth = 8       nbins <= 256
With %outdepth == 0, the minimum required depth for the
given number of bins is used.
The output pixd has a colormap.
(3) The last 3 args determine the specific values that go into
the colormap.
(4) For %use_average:
~ if TRUE, the average value of pixels falling in the bin is
chosen as the representative gray value.  Otherwise,
~ if FALSE, the central value of each bin is chosen as
the representative value.
The colormap holds the representative value.
(5) For %setblack, if TRUE the darkest color is set to (0,0,0).
(6) For %setwhite, if TRUE the lightest color is set to (255,255,255).
(7) An alternative to using this function to quantize to
unequally-spaced bins is to first transform the 8 bpp pixs
using pixGammaTRC(), and follow this with pixThresholdTo4bpp().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdGrayArb(*args)
    
    

    try:
        leptonica.makeGrayQuantIndexTable.argtypes = [ctypes.c_int32]
        leptonica.makeGrayQuantIndexTable.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function makeGrayQuantIndexTable not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGrayQuantIndexTable(*args):
        """
        ('l_int32', 'nlevels')       

:param[in]    nlevels:    number of output levels
:returns:  table maps input gray level to colormap index,
or NULL on error
<pre>
Notes:
(1) 'nlevels' is some number between 2 and 256 (typically 8 or less).
(2) The table is typically used for quantizing 2, 4 and 8 bpp
grayscale src pix, and generating a colormapped dest pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeGrayQuantIndexTable(*args)
    
    

    try:
        leptonica.makeGrayQuantTableArb.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.makeGrayQuantTableArb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function makeGrayQuantTableArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGrayQuantTableArb(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'outdepth')       
('l_int32', '**ptab')       
('PIXCMAP', '**pcmap')       

:param[in]    na:         numa of bin boundaries
:param[in]    outdepth:   of colormap: 1, 2, 4 or 8
:param[out]   ptab:       table mapping input gray level to cmap index
:param[out]   pcmap:      colormap
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The number of bins is the count of %na + 1.
(2) The bin boundaries in na must be sorted in increasing order.
(3) The table is an inverse colormap: it maps input gray level
to colormap index (the bin number).
(4) The colormap generated here has quantized values at the
center of each bin.  If you want to use the average gray
value of pixels within the bin, discard the colormap and
compute it using makeGrayQuantColormapArb().
(5) Returns an error if there are not enough levels in the
output colormap for the number of bins.  The number
of bins must not exceed 2^outdepth.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeGrayQuantTableArb(*args)
    
    

    try:
        leptonica.pixGenerateMaskByBand32.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixGenerateMaskByBand32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateMaskByBand32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByBand32(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'refval')       
('l_int32', 'delm')       
('l_int32', 'delp')       
('l_float32', 'fractm')       
('l_float32', 'fractp')       

:param[in]    pixs:     32 bpp
:param[in]    refval:   reference rgb value
:param[in]    delm:     max amount below the ref value for any component
:param[in]    delp:     max amount above the ref value for any component
:param[in]    fractm:   fractional amount below ref value for all components
:param[in]    fractp:   fractional amount above ref value for all components
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) Generates a 1 bpp mask pixd, the same size as pixs, where
the fg pixels in the mask within a band of rgb values
surrounding %refval.  The band can be chosen in two ways
for each component:
(a) Use (%delm, %delp) to specify how many levels down and up
(b) Use (%fractm, %fractp) to specify the fractional
distance toward 0 and 255, respectively.
Note that %delm and %delp must be in [0 ... 255], whereas
%fractm and %fractp must be in [0.0 - 1.0].
(2) Either (%delm, %delp) or (%fractm, %fractp) can be used.
Set each value in the other pair to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByBand32(*args)
    
    

    try:
        leptonica.pixGenerateMaskByDiscr32.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixGenerateMaskByDiscr32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateMaskByDiscr32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateMaskByDiscr32(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'refval1')       
('l_uint32', 'refval2')       
('l_int32', 'distflag')       

:param[in]    pixs:       32 bpp
:param[in]    refval1:    reference rgb value
:param[in]    refval2:    reference rgb value
:param[in]    distflag:   L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) Generates a 1 bpp mask pixd, the same size as pixs, where
the fg pixels in the mask are those where the pixel in pixs
is "closer" to refval1 than to refval2.
(2) "Closer" can be defined in several ways, such as:
~ manhattan distance (L1)
~ euclidean distance (L2)
~ majority vote of the individual components
Here, we have a choice of L1 or L2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateMaskByDiscr32(*args)
    
    

    try:
        leptonica.pixGrayQuantFromHisto.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixGrayQuantFromHisto.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGrayQuantFromHisto not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGrayQuantFromHisto(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'minfract')       
('l_int32', 'maxsize')       

:param[in]    pixd:       [optional] quantized pix with cmap; can be null
:param[in]    pixs:       8 bpp gray input pix; not cmapped
:param[in]    pixm:       [optional] mask over pixels in pixs to quantize
:param[in]    minfract:   minimum fraction of pixels in a set of adjacent
histo bins that causes the set to be automatically
set aside as a color in the colormap; must be
at least 0.01
:param[in]    maxsize:    maximum number of adjacent bins allowed to represent
a color, regardless of the population of pixels
in the bins; must be at least 2
:returns:  pixd 8 bpp, cmapped, or NULL on error

<pre>
Notes:
(1) This is useful for quantizing images with relatively few
colors, but which may have both color and gray pixels.
If there are color pixels, it is assumed that an input
rgb image has been color quantized first so that:
~ pixd has a colormap describing the color pixels
~ pixm is a mask over the non-color pixels in pixd
~ the colormap in pixd, and the color pixels in pixd,
have been repacked to go from 0 to n-1 (n colors)
If there are no color pixels, pixd and pixm are both null,
and all pixels in pixs are quantized to gray.
(2) A 256-entry histogram is built of the gray values in pixs.
If pixm exists, the pixels contributing to the histogram are
restricted to the fg of pixm.  A colormap and LUT are generated
from this histogram.  We break up the array into a set
of intervals, each one constituting a color in the colormap:
An interval is identified by summing histogram bins until
either the sum equals or exceeds the %minfract of the total
number of pixels, or the span itself equals or exceeds %maxsize.
The color of each bin is always an average of the pixels
that constitute it.
(3) Note that we do not specify the number of gray colors in
the colormap.  Instead, we specify two parameters that
describe the accuracy of the color assignments; this and
the actual image determine the number of resulting colors.
(4) If a mask exists and it is not the same size as pixs, make
a new mask the same size as pixs, with the original mask
aligned at the UL corners.  Set all additional pixels
in the (larger) new mask set to 1, causing those pixels
in pixd to be set as gray.
(5) We estimate the total number of colors (color plus gray);
if it exceeds 255, return null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGrayQuantFromHisto(*args)
    
    

    try:
        leptonica.pixGrayQuantFromCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixGrayQuantFromCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGrayQuantFromCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGrayQuantFromCmap(*args):
        """
        ('PIX', '*pixs')       
('PIXCMAP', '*cmap')       
('l_int32', 'mindepth')       

:param[in]    pixs:       8 bpp grayscale without cmap
:param[in]    cmap:       to quantize to; of dest pix
:param[in]    mindepth:   minimum depth of pixd: can be 2, 4 or 8 bpp
:returns:  pixd 2, 4 or 8 bpp, colormapped, or NULL on error

<pre>
Notes:
(1) In use, pixs is an 8 bpp grayscale image without a colormap.
If there is an existing colormap, a warning is issued and
a copy of the input pixs is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGrayQuantFromCmap(*args)
    
    

    try:
        leptonica.pixDitherToBinaryLUT.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDitherToBinaryLUT.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDitherToBinaryLUT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDitherToBinaryLUT(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       

:param[in]    pixs:
:param[in]    lowerclip:  lower clip distance to black; use -1 for default
:param[in]    upperclip:  upper clip distance to white; use -1 for default
:returns:  pixd dithered binary, or NULL on error

We don't need two implementations of Floyd-Steinberg dithering,
and this one with LUTs is a little more complicated than
pixDitherToBinary().  It uses three lookup tables to generate the
output pixel value and the excess or deficit carried over to the
neighboring pixels.  It's here for pedagogical reasons only.


        """
        args = _convert_params(*args)
        
        return leptonica.pixDitherToBinaryLUT(*args)
    
    

    try:
        leptonica.ditherToBinaryLUTLow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ditherToBinaryLUTLow.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ditherToBinaryLUTLow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ditherToBinaryLUTLow(*args):
        """
        ('l_uint32', '*datad')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'wpld')       
('l_uint32', '*datas')       
('l_int32', 'wpls')       
('l_uint32', '*bufs1')       
('l_uint32', '*bufs2')       
('l_int32', '*tabval')       
('l_int32', '*tab38')       
('l_int32', '*tab14')       

Low-level function for doing Floyd-Steinberg error diffusion
dithering from 8 bpp (datas) to 1 bpp (datad).  Two source
line buffers, bufs1 and bufs2, are provided, along with three
256-entry lookup tables: tabval gives the output pixel value,
tab38 gives the extra (plus or minus) transferred to the pixels
directly to the left and below, and tab14 gives the extra
transferred to the diagonal below.  The choice of 3/8 and 1/4
is traditional but arbitrary when you use a lookup table; the
only constraint is that the sum is 1.  See other comments below.


        """
        args = _convert_params(*args)
        
        return leptonica.ditherToBinaryLUTLow(*args)
    
    

    try:
        leptonica.ditherToBinaryLineLUTLow.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.ditherToBinaryLineLUTLow.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ditherToBinaryLineLUTLow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ditherToBinaryLineLUTLow(*args):
        """
        ('l_uint32', '*lined')       
('l_int32', 'w')       
('l_uint32', '*bufs1')       
('l_uint32', '*bufs2')       
('l_int32', '*tabval')       
('l_int32', '*tab38')       
('l_int32', '*tab14')       
('l_int32', 'lastlineflag')       

:param[in]    lined:          ptr to beginning of dest line
:param[in]    w:              width of image in pixels
:param[in]    bufs1:          buffer of current source line
:param[in]    bufs2:          buffer of next source line
:param[in]    tabval:         value to assign for current pixel
:param[in]    tab38:          excess value to give to neighboring 3/8 pixels
:param[in]    tab14:          excess value to give to neighboring 1/4 pixel
:param[in]    lastlineflag:   0 if not last dest line, 1 if last dest line
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.ditherToBinaryLineLUTLow(*args)
    
    

    try:
        leptonica.make8To1DitherTables.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.make8To1DitherTables.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function make8To1DitherTables not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def make8To1DitherTables(*args):
        """
        ('l_int32', '**ptabval')       
('l_int32', '**ptab38')       
('l_int32', '**ptab14')       
('l_int32', 'lowerclip')       
('l_int32', 'upperclip')       

:param[out]  ptabval:     value assigned to output pixel; 0 or 1
:param[out]  ptab38:      amount propagated to pixels left and below
:param[out]  ptab14:      amount propagated to pixel to left and down
:param[in]   lowerclip:   values near 0 where the excess is not propagated
:param[in]   upperclip:   values near 255 where the deficit is not propagated

:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.make8To1DitherTables(*args)
    




class pix5(object):
    """<pre>

This file has these operations:

(1) Measurement of 1 bpp image properties
(2) Extract rectangular regions
(3) Clip to foreground
(4) Extract pixel averages, reversals and variance along lines
(5) Rank row and column transforms

Measurement of properties
l_int32     pixaFindDimensions()
l_int32     pixFindAreaPerimRatio()
NUMA       *pixaFindPerimToAreaRatio()
l_int32     pixFindPerimToAreaRatio()
NUMA       *pixaFindPerimSizeRatio()
l_int32     pixFindPerimSizeRatio()
NUMA       *pixaFindAreaFraction()
l_int32     pixFindAreaFraction()
NUMA       *pixaFindAreaFractionMasked()
l_int32     pixFindAreaFractionMasked()
NUMA       *pixaFindWidthHeightRatio()
NUMA       *pixaFindWidthHeightProduct()
l_int32     pixFindOverlapFraction()
BOXA       *pixFindRectangleComps()
l_int32     pixConformsToRectangle()

Extract rectangular region
PIXA       *pixClipRectangles()
PIX        *pixClipRectangle()
PIX        *pixClipRectangleWithBorder()
PIX        *pixClipMasked()
l_int32     pixCropToMatch()
PIX        *pixCropToSize()
PIX        *pixResizeToMatch()

Select a connected component by size
PIX        *pixSelectComponentBySize()
PIX        *pixFilterComponentBySize()

Make special masks
PIX        *pixMakeSymmetricMask()
PIX        *pixMakeFrameMask()

Generate a covering of rectangles over connected components
PIX        * pixMakeCoveringOfRectangles()

Fraction of Fg pixels under a mask
l_int32     pixFractionFgInMask()

Clip to foreground
PIX        *pixClipToForeground()
l_int32     pixTestClipToForeground()
l_int32     pixClipBoxToForeground()
l_int32     pixScanForForeground()
l_int32     pixClipBoxToEdges()
l_int32     pixScanForEdge()

Extract pixel averages and reversals along lines
NUMA       *pixExtractOnLine()
l_float32   pixAverageOnLine()
NUMA       *pixAverageIntensityProfile()
NUMA       *pixReversalProfile()

Extract windowed variance along a line
NUMA       *pixWindowedVarianceOnLine()

Extract min/max of pixel values near lines
l_int32     pixMinMaxNearLine()

Rank row and column transforms
PIX        *pixRankRowTransform()
PIX        *pixRankColumnTransform()
</pre>




"""
    
    try:
        leptonica.pixaFindDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaFindDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindDimensions(*args):
        """
        ('PIXA', '*pixa')       
('NUMA', '**pnaw')       
('NUMA', '**pnah')       

:param[in]    pixa:
:param[out]   pnaw: [optional] numa of pix widths
:param[out]   pnah: [optional] numa of pix heights
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindDimensions(*args)
    
    

    try:
        leptonica.pixFindAreaPerimRatio.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindAreaPerimRatio.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindAreaPerimRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindAreaPerimRatio(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pfract')       

:param[in]    pixs:    1 bpp
:param[in]    tab:     [optional] pixel sum table, can be NULL
:param[out]   pfract:  area/perimeter ratio
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The area is the number of fg pixels that are not on the
boundary (i.e., are not 8-connected to a bg pixel), and the
perimeter is the number of fg boundary pixels.  Returns
0.0 if there are no fg pixels.
(2) This function is retained because clients are using it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindAreaPerimRatio(*args)
    
    

    try:
        leptonica.pixaFindPerimToAreaRatio.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindPerimToAreaRatio.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindPerimToAreaRatio(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:   of 1 bpp pix
:returns:  na   of perimeter/arear ratio for each pix, or NULL on error

<pre>
Notes:
(1) This is typically used for a pixa consisting of
1 bpp connected components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixFindPerimToAreaRatio.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindPerimToAreaRatio.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindPerimToAreaRatio(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pfract')       

:param[in]    pixs:    1 bpp
:param[in]    tab:     [optional] pixel sum table, can be NULL
:param[out]   pfract:  perimeter/area ratio
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The perimeter is the number of fg boundary pixels, and the
area is the number of fg pixels.  This returns 0.0 if
there are no fg pixels.
(2) Unlike pixFindAreaPerimRatio(), this uses the full set of
fg pixels for the area, and the ratio is taken in the opposite
order.
(3) This is typically used for a single connected component.
This always has a value <= 1.0, and if the average distance
of a fg pixel from the nearest bg pixel is d, this has
a value ~1/d.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixaFindPerimSizeRatio.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindPerimSizeRatio.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindPerimSizeRatio(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:   of 1 bpp pix
:returns:  na   of fg perimeter/(2*(w+h)) ratio for each pix,
or NULL on error

<pre>
Notes:
(1) This is typically used for a pixa consisting of
1 bpp connected components.
(2) This has a minimum value for a circle of pi/4; a value for
a rectangle component of approx. 1.0; and a value much larger
than 1.0 for a component with a highly irregular boundary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixFindPerimSizeRatio.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindPerimSizeRatio.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindPerimSizeRatio(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pratio')       

:param[in]    pixs:    1 bpp
:param[in]    tab:     [optional] pixel sum table, can be NULL
:param[out]   pratio:  perimeter/size ratio
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) We take the 'size' as twice the sum of the width and
height of pixs, and the perimeter is the number of fg
boundary pixels.  We use the fg pixels of the boundary
because the pix may be clipped to the boundary, so an
erosion is required to count all boundary pixels.
(2) This has a large value for dendritic, fractal-like components
with highly irregular boundaries.
(3) This is typically used for a single connected component.
It has a value of about 1.0 for rectangular components with
relatively smooth boundaries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixaFindAreaFraction.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindAreaFraction.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindAreaFraction(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:   of 1 bpp pix
:returns:  na  of area fractions for each pix, or NULL on error

<pre>
Notes:
(1) This is typically used for a pixa consisting of
1 bpp connected components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindAreaFraction(*args)
    
    

    try:
        leptonica.pixFindAreaFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindAreaFraction.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindAreaFraction(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab')       
('l_float32', '*pfract')       

:param[in]    pixs:    1 bpp
:param[in]    tab:     [optional] pixel sum table, can be NULL
:param[out]   pfract:  fg area/size ratio
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This finds the ratio of the number of fg pixels to the
size of the pix (w * h).  It is typically used for a
single connected component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindAreaFraction(*args)
    
    

    try:
        leptonica.pixaFindAreaFractionMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaFindAreaFractionMasked.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindAreaFractionMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindAreaFractionMasked(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pixm')       
('l_int32', 'debug')       

:param[in]    pixa:    of 1 bpp pix
:param[in]    pixm:    mask image
:param[in]    debug:   1 for output, 0 to suppress
:returns:  na of ratio masked/total fractions for each pix,
or NULL on error

<pre>
Notes:
(1) This is typically used for a pixa consisting of
1 bpp connected components, which has an associated
boxa giving the location of the components relative
to the mask origin.
(2) The debug flag displays in green and red the masked and
unmasked parts of the image from which pixa was derived.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindAreaFractionMasked(*args)
    
    

    try:
        leptonica.pixFindAreaFractionMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindAreaFractionMasked.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindAreaFractionMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindAreaFractionMasked(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('PIX', '*pixm')       
('l_int32', '*tab')       
('l_float32', '*pfract')       

:param[in]    pixs:    1 bpp, typically a single component
:param[in]    box:     [optional] for pixs relative to pixm
:param[in]    pixm:    1 bpp mask, typically over the entire image from
which the component pixs was extracted
:param[in]    tab:     [optional] pixel sum table, can be NULL
:param[out]   pfract:  fg area/size ratio
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This finds the ratio of the number of masked fg pixels
in pixs to the total number of fg pixels in pixs.
It is typically used for a single connected component.
If there are no fg pixels, this returns a ratio of 0.0.
(2) The box gives the location of the pix relative to that
of the UL corner of the mask.  Therefore, the rasterop
is performed with the pix translated to its location
(x, y) in the mask before ANDing.
If box == NULL, the UL corners of pixs and pixm are aligned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindAreaFractionMasked(*args)
    
    

    try:
        leptonica.pixaFindWidthHeightRatio.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindWidthHeightRatio.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindWidthHeightRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindWidthHeightRatio(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:   of 1 bpp pix
:returns:  na of width/height ratios for each pix, or NULL on error

<pre>
Notes:
(1) This is typically used for a pixa consisting of
1 bpp connected components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindWidthHeightRatio(*args)
    
    

    try:
        leptonica.pixaFindWidthHeightProduct.argtypes = [ctypes.c_void_p]
        leptonica.pixaFindWidthHeightProduct.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindWidthHeightProduct not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindWidthHeightProduct(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:   of 1 bpp pix
:returns:  na of width*height products for each pix, or NULL on error

<pre>
Notes:
(1) This is typically used for a pixa consisting of
1 bpp connected components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindWidthHeightProduct(*args)
    
    

    try:
        leptonica.pixFindOverlapFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindOverlapFraction.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindOverlapFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindOverlapFraction(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', '*tab')       
('l_float32', '*pratio')       
('l_int32', '*pnoverlap')       

:param[in]    pixs1,: pixs2   1 bpp
:param[in]    x2,: y2         location in pixs1 of UL corner of pixs2
:param[in]    tab:            [optional] pixel sum table, can be null
:param[out]   pratio:         ratio fg intersection to fg union
:param[out]   pnoverlap:      [optional] number of overlapping pixels
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The UL corner of pixs2 is placed at (x2, y2) in pixs1.
(2) This measure is similar to the correlation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindOverlapFraction(*args)
    
    

    try:
        leptonica.pixFindRectangleComps.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFindRectangleComps.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindRectangleComps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindRectangleComps(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dist')       
('l_int32', 'minw')       
('l_int32', 'minh')       

:param[in]    pixs:        1 bpp
:param[in]    dist:        max distance allowed between bounding box
and nearest foreground pixel within it
:param[in]    minw,: minh  minimum size in each direction as a requirement
for a conforming rectangle
:returns:  boxa of components that conform, or NULL on error

<pre>
Notes:
(1) This applies the function pixConformsToRectangle() to
each 8-c.c. in pixs, and returns a boxa containing the
regions of all components that are conforming.
(2) Conforming components must satisfy both the size constraint
given by %minsize and the slop in conforming to a rectangle
determined by %dist.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindRectangleComps(*args)
    
    

    try:
        leptonica.pixConformsToRectangle.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixConformsToRectangle.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixConformsToRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConformsToRectangle(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'dist')       
('l_int32', '*pconforms')       

:param[in]    pixs:       1 bpp
:param[in]    box:        [optional] if null, use the entire pixs
:param[in]    dist:       max distance allowed between bounding box and
nearest foreground pixel within it
:param[out]   pconforms:  0 (false) if not conforming;
1 (true) if conforming
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) There are several ways to test if a connected component has
an essentially rectangular boundary, such as:
a. Fraction of fill into the bounding box
b. Max-min distance of fg pixel from periphery of bounding box
c. Max depth of bg intrusions into component within bounding box
The weakness of (a) is that it is highly sensitive to holes
within the c.c.  The weakness of (b) is that it can have
arbitrarily large intrusions into the c.c.  Method (c) tests
the integrity of the outer boundary of the c.c., with respect
to the enclosing bounding box, so we use it.
(2) This tests if the connected component within the box conforms
to the box at all points on the periphery within %dist.
Inside, at a distance from the box boundary that is greater
than %dist, we don't care about the pixels in the c.c.
(3) We can think of the conforming condition as follows:
No pixel inside a distance %dist from the boundary
can connect to the boundary through a path through the bg.
To implement this, we need to do a flood fill.  We can go
either from inside toward the boundary, or the other direction.
It's easiest to fill from the boundary, and then verify that
there are no filled pixels farther than %dist from the boundary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConformsToRectangle(*args)
    
    

    try:
        leptonica.pixClipRectangles.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipRectangles.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixClipRectangles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipRectangles(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       

:param[in]    pixs:
:param[in]    boxa:  requested clipping regions
:returns:  pixa consisting of requested regions, or NULL on error

<pre>
Notes:
(1) The returned pixa includes the actual regions clipped out from
the input pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipRectangles(*args)
    
    

    try:
        leptonica.pixClipRectangle.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipRectangle.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixClipRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipRectangle(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('BOX', '**pboxc')       

:param[in]    pixs:
:param[in]    box:    requested clipping region; const
:param[out]   pboxc:  [optional] actual box of clipped region
:returns:  clipped pix, or NULL on error or if rectangle
doesn't intersect pixs

<pre>
Notes:

This should be simple, but there are choices to be made.
The box is defined relative to the pix coordinates.  However,
if the box is not contained within the pix, we have two choices:

(1) clip the box to the pix
(2) make a new pix equal to the full box dimensions,
but let rasterop do the clipping and positioning
of the src with respect to the dest

Choice (2) immediately brings up the problem of what pixel values
to use that were not taken from the src.  For example, on a grayscale
image, do you want the pixels not taken from the src to be black
or white or something else?  To implement choice 2, one needs to
specify the color of these extra pixels.

So we adopt (1), and clip the box first, if necessary,
before making the dest pix and doing the rasterop.  But there
is another issue to consider.  If you want to paste the
clipped pix back into pixs, it must be properly aligned, and
it is necessary to use the clipped box for alignment.
Accordingly, this function has a third (optional) argument, which is
the input box clipped to the src pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipRectangle(*args)
    
    

    try:
        leptonica.pixClipRectangleWithBorder.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixClipRectangleWithBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixClipRectangleWithBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipRectangleWithBorder(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'maxbord')       
('BOX', '**pboxn')       

:param[in]    pixs:
:param[in]    box:       requested clipping region; const
:param[in]    maxbord:   maximum amount of border to include
:param[out]   pboxn:     box in coordinates of returned pix
:returns:  under-clipped pix, or NULL on error or if rectangle
doesn't intersect pixs

<pre>
Notes:
(1) This underclips by an amount determined by the minimum of
%maxbord and the amount of border that can be included
equally on all 4 sides.
(2) If part of the rectangle lies outside the pix, no border
is included on any side.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipRectangleWithBorder(*args)
    
    

    try:
        leptonica.pixClipMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixClipMasked.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixClipMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_uint32', 'outval')       

:param[in]    pixs:    1, 2, 4, 8, 16, 32 bpp; colormap ok
:param[in]    pixm:    clipping mask, 1 bpp
:param[in]    x,: y    origin of clipping mask relative to pixs
:param[in]    outval:  val to use for pixels that are outside the mask
:returns:  pixd, clipped pix or NULL on error or if pixm doesn't
intersect pixs

<pre>
Notes:
(1) If pixs has a colormap, it is preserved in pixd.
(2) The depth of pixd is the same as that of pixs.
(3) If the depth of pixs is 1, use %outval = 0 for white background
and 1 for black; otherwise, use the max value for white
and 0 for black.  If pixs has a colormap, the max value for
%outval is 0xffffffff; otherwise, it is 2^d - 1.
(4) When using 1 bpp pixs, this is a simple clip and
blend operation.  For example, if both pix1 and pix2 are
black text on white background, and you want to OR the
fg on the two images, let pixm be the inverse of pix2.
Then the operation takes all of pix1 that's in the bg of
pix2, and for the remainder (which are the pixels
corresponding to the fg of the pix2), paint them black
(1) in pix1.  The function call looks like
pixClipMasked(pix2, pixInvert(pix1, pix1), x, y, 1);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipMasked(*args)
    
    

    try:
        leptonica.pixCropToMatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCropToMatch.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCropToMatch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCropToMatch(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('PIX', '**ppixd1')       
('PIX', '**ppixd2')       

:param[in]    pixs1:   any depth, colormap OK
:param[in]    pixs2:   any depth, colormap OK
:param[out]   ppixd1:  may be a clone
:param[out]   ppixd2:  may be a clone
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This resizes pixs1 and/or pixs2 by cropping at the right
and bottom, so that they're the same size.
(2) If a pix doesn't need to be cropped, a clone is returned.
(3) Note: the images are implicitly aligned to the UL corner.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCropToMatch(*args)
    
    

    try:
        leptonica.pixCropToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCropToSize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCropToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCropToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    pixs:   any depth, colormap OK
:param[in]    w,: h   max dimensions of cropped image
:returns:  pixd cropped if necessary or NULL on error.

<pre>
Notes:
(1) If either w or h is smaller than the corresponding dimension
of pixs, this returns a cropped image; otherwise it returns
a clone of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCropToSize(*args)
    
    

    try:
        leptonica.pixResizeToMatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixResizeToMatch.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixResizeToMatch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixResizeToMatch(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixt')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    pixs:   1, 2, 4, 8, 16, 32 bpp; colormap ok
:param[in]    pixt:   can be null; we use only the size
:param[in]    w,: h   ignored if pixt is defined
:returns:  pixd resized to match or NULL on error

<pre>
Notes:
(1) This resizes pixs to make pixd, without scaling, by either
cropping or extending separately in both width and height.
Extension is done by replicating the last row or column.
This is useful in a situation where, due to scaling
operations, two images that are expected to be the
same size can differ slightly in each dimension.
(2) You can use either an existing pixt or specify
both %w and %h.  If pixt is defined, the values
in %w and %h are ignored.
(3) If pixt is larger than pixs (or if w and/or d is larger
than the dimension of pixs, replicate the outer row and
column of pixels in pixs into pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixResizeToMatch(*args)
    
    

    try:
        leptonica.pixSelectComponentBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectComponentBySize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectComponentBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectComponentBySize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rankorder')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('BOX', '**pbox')       

:param[in]    pixs:          1 bpp
:param[in]    rankorder:     in decreasing size: 0 for largest.
:param[in]    type:          L_SELECT_BY_WIDTH, L_SELECT_BY_HEIGHT,
L_SELECT_BY_MAX_DIMENSION,
L_SELECT_BY_AREA, L_SELECT_BY_PERIMETER
:param[in]    connectivity:  4 or 8
:param[out]   pbox:          [optional] location of returned component
:returns:  pix of rank order connected component, or NULL on error.

<pre>
Notes:
(1) This selects the Nth largest connected component, based on
the selection type and connectivity.
(2) Note that %rankorder is an integer.  Use %rankorder = 0 for
the largest component and %rankorder = -1 for the smallest.
If %rankorder >= number of components, select the smallest.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectComponentBySize(*args)
    
    

    try:
        leptonica.pixFilterComponentBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFilterComponentBySize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFilterComponentBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFilterComponentBySize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rankorder')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('BOX', '**pbox')       

:param[in]    pixs:          1 bpp
:param[in]    rankorder:     in decreasing size: 0 for largest.
:param[in]    type:          L_SELECT_BY_WIDTH, L_SELECT_BY_HEIGHT,
L_SELECT_BY_MAX_DIMENSION,
L_SELECT_BY_AREA, L_SELECT_BY_PERIMETER
:param[in]    connectivity:  4 or 8
:param[out]   pbox:          [optional] location of returned component
:returns:  pix with all other components removed, or NULL on error.

<pre>
Notes:
(1) See notes in pixSelectComponentBySize().
(2) This returns a copy of %pixs, with all components removed
except for the selected one.


        """
        args = _convert_params(*args)
        
        return leptonica.pixFilterComponentBySize(*args)
    
    

    try:
        leptonica.pixMakeSymmetricMask.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixMakeSymmetricMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeSymmetricMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeSymmetricMask(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'hf')       
('l_float32', 'vf')       
('l_int32', 'type')       

:param[in]    w,: h    dimensions of output 1 bpp pix
:param[in]    hf:      horizontal fraction of half-width
:param[in]    vf:      vertical fraction of half-height
:param[in]    type:    L_USE_INNER, L_USE_OUTER
:returns:  pixd 1 bpp, or NULL on error.

<pre>
Notes:
(1) This is a convenience function for generating masks with
horizontal and vertical reflection symmetry, over either
the inner or outer parts of an image.
(2) Using L_USE_INNER to generate a mask over the inner part
of the image, the mask is a solid rectangle, and the fractions
describe the distance between the boundary of the image and
the rectangle boundary.  For example, with hf == vf == 0.0,
the mask covers the full image.
(3) Using L_USE_OUTER to generate a mask over an outer frame
of the image, the mask touches the boundary of the image,
and the fractions describe the location of the inner
boundary of the frame.  For example, with hf == vf == 1.0,
the inner boundary is at the center of the image, so the
mask covers the full image.
(4) More examples:
mask covering the inner 70%: hf = vf = 0.3, type = L_USE_INNER
frame covering the outer 30%: hf = vf = 0.3, type = L_USE_OUTER
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeSymmetricMask(*args)
    
    

    try:
        leptonica.pixMakeFrameMask.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixMakeFrameMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeFrameMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeFrameMask(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_float32', 'hf1')       
('l_float32', 'hf2')       
('l_float32', 'vf1')       
('l_float32', 'vf2')       

:param[in]    w,: h  dimensions of output 1 bpp pix
:param[in]    hf1:   horizontal fraction of half-width at outer frame bdry
:param[in]    hf2:   horizontal fraction of half-width at inner frame bdry
:param[in]    vf1:   vertical fraction of half-width at outer frame bdry
:param[in]    vf2:   vertical fraction of half-width at inner frame bdry
:returns:  pixd 1 bpp, or NULL on error.

<pre>
Notes:
(1) This makes an arbitrary 1-component mask with a centered fg
frame, which can have both an inner and an outer boundary.
All input fractional distances are measured from the image
border to the frame boundary, in units of the image half-width
for hf1 and hf2 and the image half-height for vf1 and vf2.
The distances to the outer frame boundary are given by hf1
and vf1; to the inner frame boundary, by hf2 and vf2.
Input fractions are thus in [0.0 ... 1.0], with hf1 <= hf2
and vf1 <= vf2.  Horizontal and vertical frame widths are
thus independently specified.
(2) Special cases:
full fg mask: hf1 = vf1 = 0.0, hf2 = vf2 = 1.0.
empty fg (zero width) mask: set  hf1 = hf2  and vf1 = vf2.
fg rectangle with no hole: set hf2 = vf2 = 1.0.
frame touching outer boundary: set hf1 = vf1 = 0.0.
(3) The vertical thickness of the horizontal mask parts
is 0.5 * (vf2 - vf1) * h.  The horizontal thickness of the
vertical mask parts is 0.5 * (hf2 - hf1) * w.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeFrameMask(*args)
    
    

    try:
        leptonica.pixMakeCoveringOfRectangles.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMakeCoveringOfRectangles.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeCoveringOfRectangles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeCoveringOfRectangles(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxiters')       

:param[in]   pixs:       1 bpp
:param[in]   maxiters:   max iterations: use 0 to iterate to completion
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This iteratively finds the bounding boxes of the connected
components and generates a mask from them.  Two iterations
should suffice for most situations.
(2) Returns an empty pix if %pixs is empty.
(3) If there are many small components in proximity, it may
be useful to merge them with a morphological closing before
calling this one.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeCoveringOfRectangles(*args)
    
    

    try:
        leptonica.pixFractionFgInMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFractionFgInMask.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFractionFgInMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFractionFgInMask(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_float32', '*pfract')       

:param[in]    pix1:    1 bpp
:param[in]    pix2:    1 bpp
:param[out]   pfract:  fraction of fg pixels in 1 that are
aligned with the fg of 2
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This gives the fraction of fg pixels in pix1 that are in
the intersection (i.e., under the fg) of pix2:
|1 & 2|/|1|, where |...| means the number of fg pixels.
Note that this is different from the situation where
pix1 and pix2 are reversed.
(2) Both pix1 and pix2 are registered to the UL corners.  A warning
is issued if pix1 and pix2 have different sizes.
(3) This can also be used to find the fraction of fg pixels in pix1
that are NOT under the fg of pix2: 1.0 - |1 & 2|/|1|
(4) If pix1 or pix2 are empty, this returns %fract = 0.0.
(5) For example, pix2 could be a frame around the outside of the
image, made from pixMakeFrameMask().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFractionFgInMask(*args)
    
    

    try:
        leptonica.pixClipToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipToForeground.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixClipToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipToForeground(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixd')       
('BOX', '**pbox')       

:param[in]    pixs:   1 bpp
:param[out]   ppixd:  [optional] clipped pix returned
:param[out]   pbox:   [optional] bounding box
:returns:  0 if OK; 1 on error or if there are no fg pixels

<pre>
Notes:
(1) At least one of {&pixd, &box} must be specified.
(2) If there are no fg pixels, the returned ptrs are null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipToForeground(*args)
    
    

    try:
        leptonica.pixTestClipToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTestClipToForeground.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTestClipToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTestClipToForeground(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*pcanclip')       

:param[in]    pixs:      1 bpp
:param[out]   pcanclip:  1 if fg does not extend to all four edges
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is a lightweight test to determine if a 1 bpp image
can be further cropped without loss of fg pixels.
If it cannot, canclip is set to 0.
(2) It does not test for the existence of any fg pixels.
If there are no fg pixels, it will return %canclip = 1.
Check the output of the subsequent call to pixClipToForeground().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTestClipToForeground(*args)
    
    

    try:
        leptonica.pixClipBoxToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipBoxToForeground.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixClipBoxToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipBoxToForeground(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*boxs')       
('PIX', '**ppixd')       
('BOX', '**pboxd')       

:param[in]    pixs:   1 bpp
:param[in]    boxs:   [optional] use full image if null
:param[out]   ppixd:  [optional] clipped pix returned
:param[out]   pboxd:  [optional] bounding box
:returns:  0 if OK; 1 on error or if there are no fg pixels

<pre>
Notes:
(1) At least one of {&pixd, &boxd} must be specified.
(2) If there are no fg pixels, the returned ptrs are null.
(3) Do not use &pixs for the 3rd arg or &boxs for the 4th arg;
this will leak memory.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipBoxToForeground(*args)
    
    

    try:
        leptonica.pixScanForForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixScanForForeground.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixScanForForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScanForForeground(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'scanflag')       
('l_int32', '*ploc')       

:param[in]    pixs:      1 bpp
:param[in]    box:       [optional] within which the search is conducted
:param[in]    scanflag:  direction of scan; e.g., L_FROM_LEFT
:param[out]   ploc:      location in scan direction of first black pixel
:returns:  0 if OK; 1 on error or if no fg pixels are found

<pre>
Notes:
(1) If there are no fg pixels, the position is set to 0.
Caller must check the return value!
(2) Use %box == NULL to scan from edge of pixs
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScanForForeground(*args)
    
    

    try:
        leptonica.pixClipBoxToEdges.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClipBoxToEdges.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixClipBoxToEdges not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClipBoxToEdges(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*boxs')       
('l_int32', 'lowthresh')       
('l_int32', 'highthresh')       
('l_int32', 'maxwidth')       
('l_int32', 'factor')       
('PIX', '**ppixd')       
('BOX', '**pboxd')       

:param[in]    pixs:        1 bpp
:param[in]    boxs:        [optional] ; use full image if null
:param[in]    lowthresh:   threshold to choose clipping location
:param[in]    highthresh:  threshold required to find an edge
:param[in]    maxwidth:    max allowed width between low and high thresh locs
:param[in]    factor:      sampling factor along pixel counting direction
:param[out]   ppixd:       [optional] clipped pix returned
:param[out]   pboxd:       [optional] bounding box
:returns:  0 if OK; 1 on error or if a fg edge is not found from
all four sides.

<pre>
Notes:
(1) At least one of {&pixd, &boxd} must be specified.
(2) If there are no fg pixels, the returned ptrs are null.
(3) This function attempts to locate rectangular "image" regions
of high-density fg pixels, that have well-defined edges
on the four sides.
(4) Edges are searched for on each side, iterating in order
from left, right, top and bottom.  As each new edge is
found, the search box is resized to use that location.
Once an edge is found, it is held.  If no more edges
are found in one iteration, the search fails.
(5) See pixScanForEdge() for usage of the thresholds and %maxwidth.
(6) The thresholds must be at least 1, and the low threshold
cannot be larger than the high threshold.
(7) If the low and high thresholds are both 1, this is equivalent
to pixClipBoxToForeground().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClipBoxToEdges(*args)
    
    

    try:
        leptonica.pixScanForEdge.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixScanForEdge.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixScanForEdge not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScanForEdge(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('l_int32', 'lowthresh')       
('l_int32', 'highthresh')       
('l_int32', 'maxwidth')       
('l_int32', 'factor')       
('l_int32', 'scanflag')       
('l_int32', '*ploc')       

:param[in]    pixs:        1 bpp
:param[in]    box:         [optional] within which the search is conducted
:param[in]    lowthresh:   threshold to choose clipping location
:param[in]    highthresh:  threshold required to find an edge
:param[in]    maxwidth:    max allowed width between low and high thresh locs
:param[in]    factor:      sampling factor along pixel counting direction
:param[in]    scanflag:    direction of scan; e.g., L_FROM_LEFT
:param[out]   ploc:        location in scan direction of first black pixel
:returns:  0 if OK; 1 on error or if the edge is not found

<pre>
Notes:
(1) If there are no fg pixels, the position is set to 0.
Caller must check the return value!
(2) Use %box == NULL to scan from edge of pixs
(3) As the scan progresses, the location where the sum of
pixels equals or excees %lowthresh is noted (loc).  The
scan is stopped when the sum of pixels equals or exceeds
%highthresh.  If the scan distance between loc and that
point does not exceed %maxwidth, an edge is found and
its position is taken to be loc.  %maxwidth implicitly
sets a minimum on the required gradient of the edge.
(4) The thresholds must be at least 1, and the low threshold
cannot be larger than the high threshold.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScanForEdge(*args)
    
    

    try:
        leptonica.pixExtractOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixExtractOnLine.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'factor')       

:param[in]    pixs:     1 bpp or 8 bpp; no colormap
:param[in]    x1,: y1   one end point for line
:param[in]    x2,: y2   another end pt for line
:param[in]    factor:   sampling; >= 1
:returns:  na of pixel values along line, or NULL on error.

<pre>
Notes:
(1) Input end points are clipped to the pix.
(2) If the line is either horizontal, or closer to horizontal
than to vertical, the points will be extracted from left
to right in the pix.  Likewise, if the line is vertical,
or closer to vertical than to horizontal, the points will
be extracted from top to bottom.
(3) Can be used with numaCountReverals(), for example, to
characterize the intensity smoothness along a line.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractOnLine(*args)
    
    

    try:
        leptonica.pixAverageOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAverageOnLine.restype = ctypes.c_float
    except AttributeError:
        sys.stderr.write("Warning - function pixAverageOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'factor')       

:param[in]    pixs:     1 bpp or 8 bpp; no colormap
:param[in]    x1,: y1   starting pt for line
:param[in]    x2,: y2   end pt for line
:param[in]    factor:   sampling; >= 1
:returns:  average of pixel values along line, or NULL on error.

<pre>
Notes:
(1) The line must be either horizontal or vertical, so either
y1 == y2 (horizontal) or x1 == x2 (vertical).
(2) If horizontal, x1 must be <= x2.
If vertical, y1 must be <= y2.
characterize the intensity smoothness along a line.
(3) Input end points are clipped to the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageOnLine(*args)
    
    

    try:
        leptonica.pixAverageIntensityProfile.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixAverageIntensityProfile.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAverageIntensityProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAverageIntensityProfile(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'dir')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'factor1')       
('l_int32', 'factor2')       

:param[in]    pixs:      any depth; colormap OK
:param[in]    fract:     fraction of image width or height to be used
:param[in]    dir:       averaging direction: L_HORIZONTAL_LINE or
L_VERTICAL_LINE
:param[in]    first,:    last span of rows or columns to measure
:param[in]    factor1:   sampling along fast scan direction; >= 1
:param[in]    factor2:   sampling along slow scan direction; >= 1
:returns:  na of reversal profile, or NULL on error.

<pre>
Notes:
(1) If d != 1 bpp, colormaps are removed and the result
is converted to 8 bpp.
(2) If %dir == L_HORIZONTAL_LINE, the intensity is averaged
along each horizontal raster line (sampled by %factor1),
and the profile is the array of these averages in the
vertical direction between %first and %last raster lines,
and sampled by %factor2.
(3) If %dir == L_VERTICAL_LINE, the intensity is averaged
along each vertical line (sampled by %factor1),
and the profile is the array of these averages in the
horizontal direction between %first and %last columns,
and sampled by %factor2.
(4) The averages are measured over the central %fract of the image.
Use %fract == 1.0 to average across the entire width or height.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAverageIntensityProfile(*args)
    
    

    try:
        leptonica.pixReversalProfile.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReversalProfile.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReversalProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReversalProfile(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'dir')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'minreversal')       
('l_int32', 'factor1')       
('l_int32', 'factor2')       

:param[in]    pixs:          any depth; colormap OK
:param[in]    fract:         fraction of image width or height to be used
:param[in]    dir:           profile direction: L_HORIZONTAL_LINE or
L_VERTICAL_LINE
:param[in]    first,: last   span of rows or columns to measure
:param[in]    minreversal:   minimum change in intensity to trigger a reversal
:param[in]    factor1:       sampling along raster line (fast scan); >= 1
:param[in]    factor2:       sampling of raster lines (slow scan); >= 1
:returns:  na of reversal profile, or NULL on error.

<pre>
Notes:
(1) If d != 1 bpp, colormaps are removed and the result
is converted to 8 bpp.
(2) If %dir == L_HORIZONTAL_LINE, the the reversals are counted
along each horizontal raster line (sampled by %factor1),
and the profile is the array of these sums in the
vertical direction between %first and %last raster lines,
and sampled by %factor2.
(3) If %dir == L_VERTICAL_LINE, the the reversals are counted
along each vertical column (sampled by %factor1),
and the profile is the array of these sums in the
horizontal direction between %first and %last columns,
and sampled by %factor2.
(4) For each row or column, the reversals are summed over the
central %fract of the image.  Use %fract == 1.0 to sum
across the entire width (of row) or height (of column).
(5) %minreversal is the relative change in intensity that is
required to resolve peaks and valleys.  A typical number for
locating text in 8 bpp might be 50.  For 1 bpp, minreversal
must be 1.
(6) The reversal profile is simply the number of reversals
in a row or column, vs the row or column index.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReversalProfile(*args)
    
    

    try:
        leptonica.pixWindowedVarianceOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixWindowedVarianceOnLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWindowedVarianceOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWindowedVarianceOnLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'loc')       
('l_int32', 'c1')       
('l_int32', 'c2')       
('l_int32', 'size')       
('NUMA', '**pnad')       

:param[in]    pixs:     8 bpp; no colormap
:param[in]    dir:      L_HORIZONTAL_LINE or L_VERTICAL_LINE
:param[in]    loc:      location of the constant coordinate for the line
:param[in]    c1,: c2   end point coordinates for the line
:param[in]    size:     window size; must be > 1
:param[out]   pnad:     windowed square root of variance
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The returned variance array traverses the line starting
from the smallest coordinate, min(c1,c2).
(2) Line end points are clipped to pixs.
(3) The reference point for the variance calculation is the center of
the window.  Therefore, the numa start parameter from
pixExtractOnLine() is incremented by %size/2,
to align the variance values with the pixel coordinate.
(4) The square root of the variance is the RMS deviation from the mean.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWindowedVarianceOnLine(*args)
    
    

    try:
        leptonica.pixMinMaxNearLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMinMaxNearLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMinMaxNearLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMinMaxNearLine(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x1')       
('l_int32', 'y1')       
('l_int32', 'x2')       
('l_int32', 'y2')       
('l_int32', 'dist')       
('l_int32', 'direction')       
('NUMA', '**pnamin')       
('NUMA', '**pnamax')       
('l_float32', '*pminave')       
('l_float32', '*pmaxave')       

:param[in]    pixs:        8 bpp; no colormap
:param[in]    x1,: y1      starting pt for line
:param[in]    x2,: y2      end pt for line
:param[in]    dist:        distance to search from line in each direction
:param[in]    direction:   L_SCAN_NEGATIVE, L_SCAN_POSITIVE, L_SCAN_BOTH
:param[out]   pnamin:      [optional] minimum values
:param[out]   pnamax:      [optional] maximum values
:param[out]   pminave:     [optional] average of minimum values
:param[out]   pmaxave:     [optional] average of maximum values
:returns:  0 if OK; 1 on error or if there are no sampled points
within the image.

<pre>
Notes:
(1) If the line is more horizontal than vertical, the values
are computed for [x1, x2], and the pixels are taken
below and/or above the local y-value.  Otherwise, the
values are computed for [y1, y2] and the pixels are taken
to the left and/or right of the local x value.
(2) %direction specifies which side (or both sides) of the
line are scanned for min and max values.
(3) There are two ways to tell if the returned values of min
and max averages are valid: the returned values cannot be
negative and the function must return 0.
(4) All accessed pixels are clipped to the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMinMaxNearLine(*args)
    
    

    try:
        leptonica.pixRankRowTransform.argtypes = [ctypes.c_void_p]
        leptonica.pixRankRowTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankRowTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankRowTransform(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   8 bpp; no colormap
:returns:  pixd with pixels sorted in each row, from
min to max value

<pre>
Notes:
(1) The time is O(n) in the number of pixels and runs about
100 Mpixels/sec on a 3 GHz machine.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankRowTransform(*args)
    
    

    try:
        leptonica.pixRankColumnTransform.argtypes = [ctypes.c_void_p]
        leptonica.pixRankColumnTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRankColumnTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankColumnTransform(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   8 bpp; no colormap
:returns:  pixd with pixels sorted in each column, from
min to max value

<pre>
Notes:
(1) The time is O(n) in the number of pixels and runs about
50 Mpixels/sec on a 3 GHz machine.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankColumnTransform(*args)
    




class regutils(object):
    """<pre>

Regression test utilities
l_int32    regTestSetup()
l_int32    regTestCleanup()
l_int32    regTestCompareValues()
l_int32    regTestCompareStrings()
l_int32    regTestComparePix()
l_int32    regTestCompareSimilarPix()
l_int32    regTestCheckFile()
l_int32    regTestCompareFiles()
l_int32    regTestWritePixAndCheck()
l_int32    regTestWriteDataAndCheck()
char      *regTestGenLocalFilename()

Static function
char      *getRootNameFromArgv0()

These functions are for testing and development.  They are not intended
for use with programs that run in a production environment, such as a
cloud service with unrestricted access.

See regutils.h for how to use this.  Here is a minimal setup:

main(int argc, char **argv) {
...
L_REGPARAMS  *rp;

if (regTestSetup(argc, argv, &rp))
return 1;
...
regTestWritePixAndCheck(rp, pix, IFF_PNG);  // 0
...
return regTestCleanup(rp);
}
</pre>




"""
    
    try:
        leptonica.regTestSetup.argtypes = [ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.regTestSetup.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestSetup not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestSetup(*args):
        """
        ('l_int32', 'argc')       
('char', '**argv')       
('L_REGPARAMS', '**prp')       

:param[in]    argc:    from invocation; can be either 1 or 2
:param[in]    argv:    to regtest: %argv[1] is one of these:
"generate", "compare", "display"
:param[out]   prp:     all regression params
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Call this function with the args to the reg test.  The first arg
is the name of the reg test.  There are three cases:
Case 1:
There is either only one arg, or the second arg is "compare".
This is the mode in which you run a regression test
(or a set of them), looking for failures and logging
the results to a file.  The output, which includes
logging of all reg test failures plus a SUCCESS or
FAILURE summary for each test, is appended to the file
"/tmp/lept/reg_results.txt.  For this case, as in Case 2,
the display field in rp is set to FALSE, preventing
image display.
Case 2:
The second arg is "generate".  This will cause
generation of new golden files for the reg test.
The results of the reg test are not recorded, and
the display field in rp is set to FALSE.
Case 3:
The second arg is "display".  The test will run and
files will be written.  Comparisons with golden files
will not be carried out, so the only notion of success
or failure is with tests that do not involve golden files.
The display field in rp is TRUE, and this is used by
pixDisplayWithTitle().
(2) See regutils.h for examples of usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestSetup(*args)
    
    

    try:
        leptonica.regTestCleanup.argtypes = [ctypes.c_void_p]
        leptonica.regTestCleanup.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestCleanup not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCleanup(*args):
        """
        ('L_REGPARAMS', '*rp')       

:param[in]    rp:    regression test parameters
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This copies anything written to the temporary file to the
output file /tmp/lept/reg_results.txt.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCleanup(*args)
    
    

    try:
        leptonica.regTestCompareValues.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.regTestCompareValues.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestCompareValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareValues(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_float32', 'val1')       
('l_float32', 'val2')       
('l_float32', 'delta')       

:param[in]    rp:      regtest parameters
:param[in]    val1:    typ. the golden value
:param[in]    val2:    typ. the value computed
:param[in]    delta:   allowed max absolute difference
:returns:  0 if OK, 1 on error a failure in comparison is not an error


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareValues(*args)
    
    

    try:
        leptonica.regTestCompareStrings.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.regTestCompareStrings.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestCompareStrings not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareStrings(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_uint8', '*string1')       
('size_t', 'bytes1')       
('l_uint8', '*string2')       
('size_t', 'bytes2')       

:param[in]    rp:        regtest parameters
:param[in]    string1:   typ. the expected string
:param[in]    bytes1:    size of string1
:param[in]    string2:   typ. the computed string
:param[in]    bytes2:    size of string2
:returns:  0 if OK, 1 on error a failure in comparison is not an error


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareStrings(*args)
    
    

    try:
        leptonica.regTestComparePix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.regTestComparePix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestComparePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestComparePix(*args):
        """
        ('L_REGPARAMS', '*rp')       
('PIX', '*pix1')       
('PIX', '*pix2')       

:param[in]    rp:            regtest parameters
:param[in]    pix1,: pix2    to be tested for equality
:returns:  0 if OK, 1 on error a failure in comparison is not an error

<pre>
Notes:
(1) This function compares two pix for equality.  On failure,
this writes to stderr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestComparePix(*args)
    
    

    try:
        leptonica.regTestCompareSimilarPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.regTestCompareSimilarPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestCompareSimilarPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareSimilarPix(*args):
        """
        ('L_REGPARAMS', '*rp')       
('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'mindiff')       
('l_float32', 'maxfract')       
('l_int32', 'printstats')       

:param[in]    rp:           regtest parameters
:param[in]    pix1,: pix2   to be tested for near equality
:param[in]    mindiff:      minimum pixel difference to be counted; > 0
:param[in]    maxfract:     maximum fraction of pixels allowed to have
diff greater than or equal to mindiff
:param[in]    printstats:   use 1 to print normalized histogram to stderr
:returns:  0 if OK, 1 on error a failure in similarity comparison
is not an error

<pre>
Notes:
(1) This function compares two pix for near equality.  On failure,
this writes to stderr.
(2) The pix are similar if the fraction of non-conforming pixels
does not exceed %maxfract.  Pixels are non-conforming if
the difference in pixel values equals or exceeds %mindiff.
Typical values might be %mindiff = 15 and %maxfract = 0.01.
(3) The input images must have the same size and depth.  The
pixels for comparison are typically subsampled from the images.
(4) Normally, use %printstats = 0.  In debugging mode, to see
the relation between %mindiff and the minimum value of
%maxfract for success, set this to 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareSimilarPix(*args)
    
    

    try:
        leptonica.regTestCheckFile.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.regTestCheckFile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestCheckFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCheckFile(*args):
        """
        ('L_REGPARAMS', '*rp')       
('const char', '*localname')       

:param[in]    rp:         regtest parameters
:param[in]    localname:  name of output file from reg test
:returns:  0 if OK, 1 on error a failure in comparison is not an error

<pre>
Notes:
(1) This function does one of three things, depending on the mode:
"generate": makes a "golden" file as a copy of %localname.
"compare": compares %localname contents with the golden file
"display": this does nothing
(2) The canonical format of the golden filenames is:
/tmp/lept/golden/[root of main name]_golden.[index].
[ext of localname]
e.g.,
/tmp/lept/golden/maze_golden.0.png
(3) The local file can be made in any subdirectory of /tmp/lept,
including /tmp/lept/regout/.
(4) It is important to add an extension to the local name, such as
/tmp/lept/maze/file1.png    (extension ".png")
because the extension is added to the name of the golden file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCheckFile(*args)
    
    

    try:
        leptonica.regTestCompareFiles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.regTestCompareFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestCompareFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestCompareFiles(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_int32', 'index1')       
('l_int32', 'index2')       

:param[in]    rp:        regtest parameters
:param[in]    index1:    of one output file from reg test
:param[in]    index2:    of another output file from reg test
:returns:  0 if OK, 1 on error a failure in comparison is not an error

<pre>
Notes:
(1) This only does something in "compare" mode.
(2) The canonical format of the golden filenames is:
/tmp/lept/golden/[root of main name]_golden.[index].
[ext of localname]
e.g.,
/tmp/lept/golden/maze_golden.0.png
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestCompareFiles(*args)
    
    

    try:
        leptonica.regTestWritePixAndCheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.regTestWritePixAndCheck.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestWritePixAndCheck not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestWritePixAndCheck(*args):
        """
        ('L_REGPARAMS', '*rp')       
('PIX', '*pix')       
('l_int32', 'format')       

:param[in]    rp:       regtest parameters
:param[in]    pix:      to be written
:param[in]    format:   of output pix
:returns:  0 if OK, 1 on error a failure in comparison is not an error

<pre>
Notes:
(1) This function makes it easy to write the pix in a numbered
sequence of files, and either to:
(a) write the golden file ("generate" arg to regression test)
(b) make a local file and "compare" with the golden file
(c) make a local file and "display" the results
(2) The canonical format of the local filename is:
/tmp/lept/regout/[root of main name].[count].[format extension]
e.g., for scale_reg,
/tmp/lept/regout/scale.0.png
The golden file name mirrors this in the usual way.
(3) The check is done between the written files, which requires
the files to be identical. The exception is for GIF, which
only requires that all pixels in the decoded pix are identical.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestWritePixAndCheck(*args)
    
    

    try:
        leptonica.regTestWriteDataAndCheck.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_char_p]
        leptonica.regTestWriteDataAndCheck.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function regTestWriteDataAndCheck not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestWriteDataAndCheck(*args):
        """
        ('L_REGPARAMS', '*rp')       
('void', '*data')       
('size_t', 'nbytes')       
('const char', '*ext')       

:param[in]    rp:      regtest parameters
:param[in]    data:    to be written
:param[in]    nbytes:  of data to be written
:param[in]    ext:     filename extension (e.g.: "ba", "pta")
:returns:  0 if OK, 1 on error a failure in comparison is not an error

<pre>
Notes:
(1) This function makes it easy to write data in a numbered
sequence of files, and either to:
(a) write the golden file ("generate" arg to regression test)
(b) make a local file and "compare" with the golden file
(c) make a local file and "display" the results
(2) The canonical format of the local filename is:
/tmp/lept/regout/[root of main name].[count].[ext]
e.g., for the first boxaa in quadtree_reg,
/tmp/lept/regout/quadtree.0.baa
The golden file name mirrors this in the usual way.
(3) The data can be anything.  It is most useful for serialized
output of data, such as boxa, pta, etc.
(4) The file extension is arbitrary.  It is included simply
to make the content type obvious when examining written files.
(5) The check is done between the written files, which requires
the files to be identical.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestWriteDataAndCheck(*args)
    
    

    try:
        leptonica.regTestGenLocalFilename.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.regTestGenLocalFilename.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function regTestGenLocalFilename not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def regTestGenLocalFilename(*args):
        """
        ('L_REGPARAMS', '*rp')       
('l_int32', 'index')       
('l_int32', 'format')       

:param[in]       rp:      regtest parameters
:param[in]       index:   use -1 for current index
:param[in]       format:  of image; e.g., IFF_PNG
:returns:  filename if OK, or NULL on error

<pre>
Notes:
(1) This is used to get the name of a file in the regout
subdirectory, that has been made and is used to test against
the golden file.  You can either specify a particular index
value, or with %index == -1, this returns the most recently
written file.  The latter case lets you read a pix from a
file that has just been written with regTestWritePixAndCheck(),
which is useful for testing formatted read/write functions.

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.regTestGenLocalFilename(*args)
    




class tiffiostub(object):
    """<pre>

Stubs for tiffio.c functions
</pre>




"""
    



class binexpand(object):
    """<pre>

Replicated expansion (integer scaling)
PIX     *pixExpandBinaryReplicate()

Special case: power of 2 replicated expansion
PIX     *pixExpandBinaryPower2()

Expansion tables for power of 2 expansion
static l_uint16    *makeExpandTab2x()
static l_uint32    *makeExpandTab4x()
static l_uint32    *makeExpandTab8x()
</pre>




"""
    
    try:
        leptonica.pixExpandBinaryReplicate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixExpandBinaryReplicate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExpandBinaryReplicate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExpandBinaryReplicate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xfact')       
('l_int32', 'yfact')       

:param[in]    pixs:   1 bpp
:param[in]    xfact:  integer scale factor for horiz. replicative expansion
:param[in]    yfact:  integer scale factor for vertical replicative expansion
:returns:  pixd scaled up, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExpandBinaryReplicate(*args)
    
    

    try:
        leptonica.pixExpandBinaryPower2.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExpandBinaryPower2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExpandBinaryPower2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExpandBinaryPower2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]    pixs:      1 bpp
:param[in]    factor:    expansion factor: 1, 2, 4, 8, 16
:returns:  pixd expanded 1 bpp by replication, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExpandBinaryPower2(*args)
    




class correlscore(object):
    """"""
    
    try:
        leptonica.pixCorrelationScore.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationScore.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCorrelationScore not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScore(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', '*tab')       
('l_float32', '*pscore')       

:param[in]    pix1:       test pix, 1 bpp
:param[in]    pix2:       exemplar pix, 1 bpp
:param[in]    area1:      number of on pixels in pix1
:param[in]    area2:      number of on pixels in pix2
:param[in]    delx:       x comp of centroid difference
:param[in]    dely:       y comp of centroid difference
:param[in]    maxdiffw:   max width difference of pix1 and pix2
:param[in]    maxdiffh:   max height difference of pix1 and pix2
:param[in]    tab:        sum tab for byte
:param[out]   pscore:     correlation score
:returns:  0 if OK, 1 on error

<pre>
Notes:
We check first that the two pix are roughly the same size.
For jbclass (jbig2) applications at roughly 300 ppi, maxdiffw and
maxdiffh should be at least 2.

Only if they meet that criterion do we compare the bitmaps.
The centroid difference is used to align the two images to the
nearest integer for the correlation.

The correlation score is the ratio of the square of the number of
pixels in the AND of the two bitmaps to the product of the number
of ON pixels in each.  Denote the number of ON pixels in pix1
by |1|, the number in pix2 by |2|, and the number in the AND
of pix1 and pix2 by |1 & 2|.  The correlation score is then
(|1 & 2|)**2 / (|1|*|2|).

This score is compared with an input threshold, which can
be modified depending on the weight of the template.
The modified threshold is
thresh + (1.0 - thresh) * weight * R
where
weight is a fixed input factor between 0.0 and 1.0
R = |2| / area(2)
and area(2) is the total number of pixels in 2 (i.e., width x height).

To understand why a weight factor is useful, consider what happens
with thick, sans-serif characters that look similar and have a value
of R near 1.  Different characters can have a high correlation value,
and the classifier will make incorrect substitutions.  The weight
factor raises the threshold for these characters.

Yet another approach to reduce such substitutions is to run the classifier
in a non-greedy way, matching to the template with the highest
score, not the first template with a score satisfying the matching
constraint.  However, this is not particularly effective.

The implementation here gives the same result as in
pixCorrelationScoreSimple(), where a temporary Pix is made to hold
the AND and implementation uses rasterop:
pixt = pixCreateTemplate(pix1);
pixRasterop(pixt, idelx, idely, wt, ht, PIX_SRC, pix2, 0, 0);
pixRasterop(pixt, 0, 0, wi, hi, PIX_SRC & PIX_DST, pix1, 0, 0);
pixCountPixels(pixt, &count, tab);
pixDestroy(&pixt);
However, here it is done in a streaming fashion, counting as it goes,
and touching memory exactly once, giving a 3-4x speedup over the
simple implementation.  This very fast correlation matcher was
contributed by William Rucklidge.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScore(*args)
    
    

    try:
        leptonica.pixCorrelationScoreThresholded.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixCorrelationScoreThresholded.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixCorrelationScoreThresholded not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScoreThresholded(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', '*tab')       
('l_int32', '*downcount')       
('l_float32', 'score_threshold')       

:param[in]    pix1:         test pix, 1 bpp
:param[in]    pix2:         exemplar pix, 1 bpp
:param[in]    area1:        number of on pixels in pix1
:param[in]    area2:        number of on pixels in pix2
:param[in]    delx:         x comp of centroid difference
:param[in]    dely:         y comp of centroid difference
:param[in]    maxdiffw:     max width difference of pix1 and pix2
:param[in]    maxdiffh:     max height difference of pix1 and pix2
:param[in]    tab:          sum tab for byte
:param[in]    downcount:    count of 1 pixels below each row of pix1
:param[in]    score_threshold:
:returns:  whether the correlation score is >= score_threshold


<pre>
Notes:
We check first that the two pix are roughly the same size.
Only if they meet that criterion do we compare the bitmaps.
The centroid difference is used to align the two images to the
nearest integer for the correlation.

The correlation score is the ratio of the square of the number of
pixels in the AND of the two bitmaps to the product of the number
of ON pixels in each.  Denote the number of ON pixels in pix1
by |1|, the number in pix2 by |2|, and the number in the AND
of pix1 and pix2 by |1 & 2|.  The correlation score is then
(|1 & 2|)**2 / (|1|*|2|).

This score is compared with an input threshold, which can
be modified depending on the weight of the template.
The modified threshold is
thresh + (1.0 - thresh) * weight * R
where
weight is a fixed input factor between 0.0 and 1.0
R = |2| / area(2)
and area(2) is the total number of pixels in 2 (i.e., width x height).

To understand why a weight factor is useful, consider what happens
with thick, sans-serif characters that look similar and have a value
of R near 1.  Different characters can have a high correlation value,
and the classifier will make incorrect substitutions.  The weight
factor raises the threshold for these characters.

Yet another approach to reduce such substitutions is to run the classifier
in a non-greedy way, matching to the template with the highest
score, not the first template with a score satisfying the matching
constraint.  However, this is not particularly effective.

This very fast correlation matcher was contributed by William Rucklidge.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScoreThresholded(*args)
    
    

    try:
        leptonica.pixCorrelationScoreSimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationScoreSimple.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCorrelationScoreSimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScoreSimple(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', '*tab')       
('l_float32', '*pscore')       

:param[in]    pix1:       test pix, 1 bpp
:param[in]    pix2:       exemplar pix, 1 bpp
:param[in]    area1:      number of on pixels in pix1
:param[in]    area2:      number of on pixels in pix2
:param[in]    delx:       x comp of centroid difference
:param[in]    dely:       y comp of centroid difference
:param[in]    maxdiffw:   max width difference of pix1 and pix2
:param[in]    maxdiffh:   max height difference of pix1 and pix2
:param[in]    tab:        sum tab for byte
:param[out]   pscore:     correlation score, in range [0.0 ... 1.0]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This calculates exactly the same value as pixCorrelationScore().
It is 2-3x slower, but much simpler to understand.
(2) The returned correlation score is 0.0 if the width or height
exceed %maxdiffw or %maxdiffh.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScoreSimple(*args)
    
    

    try:
        leptonica.pixCorrelationScoreShifted.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCorrelationScoreShifted.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCorrelationScoreShifted not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCorrelationScoreShifted(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_int32', 'area1')       
('l_int32', 'area2')       
('l_int32', 'delx')       
('l_int32', 'dely')       
('l_int32', '*tab')       
('l_float32', '*pscore')       

:param[in]    pix1:     1 bpp
:param[in]    pix2:     1 bpp
:param[in]    area1:    number of on pixels in pix1
:param[in]    area2:    number of on pixels in pix2
:param[in]    delx: x   translation of pix2 relative to pix1
:param[in]    dely: y   translation of pix2 relative to pix1
:param[in]    tab:      sum tab for byte
:param[out]   pscore:   correlation score
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This finds the correlation between two 1 bpp images,
when pix2 is shifted by (delx, dely) with respect
to each other.
(2) This is implemented by starting with a copy of pix1 and
ANDing its pixels with those of a shifted pix2.
(3) Get the pixel counts for area1 and area2 using piCountPixels().
(4) A good estimate for a shift that would maximize the correlation
is to align the centroids (cx1, cy1; cx2, cy2), giving the
relative translations etransx and etransy:
etransx = cx1 - cx2
etransy = cy1 - cy2
Typically delx is chosen to be near etransx; ditto for dely.
This function is used in pixBestCorrelation(), where the
translations delx and dely are varied to find the best alignment.
(5) We do not check the sizes of pix1 and pix2, because they should
be comparable.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCorrelationScoreShifted(*args)
    




class pixabasic(object):
    """<pre>

Pixa creation, destruction, copying
PIXA     *pixaCreate()
PIXA     *pixaCreateFromPix()
PIXA     *pixaCreateFromBoxa()
PIXA     *pixaSplitPix()
void      pixaDestroy()
PIXA     *pixaCopy()

Pixa addition
l_int32   pixaAddPix()
l_int32   pixaAddBox()
static l_int32   pixaExtendArray()
l_int32   pixaExtendArrayToSize()

Pixa accessors
l_int32   pixaGetCount()
l_int32   pixaChangeRefcount()
PIX      *pixaGetPix()
l_int32   pixaGetPixDimensions()
BOXA     *pixaGetBoxa()
l_int32   pixaGetBoxaCount()
BOX      *pixaGetBox()
l_int32   pixaGetBoxGeometry()
l_int32   pixaSetBoxa()
PIX     **pixaGetPixArray()
l_int32   pixaVerifyDepth()
l_int32   pixaVerifyDimensions()
l_int32   pixaIsFull()
l_int32   pixaCountText()
l_int32   pixaSetText()
void   ***pixaGetLinePtrs()

Pixa output info
l_int32   pixaWriteStreamInfo()

Pixa array modifiers
l_int32   pixaReplacePix()
l_int32   pixaInsertPix()
l_int32   pixaRemovePix()
l_int32   pixaRemovePixAndSave()
l_int32   pixaRemoveSelected()
l_int32   pixaInitFull()
l_int32   pixaClear()

Pixa and Pixaa combination
l_int32   pixaJoin()
PIXA     *pixaInterleave()
l_int32   pixaaJoin()

Pixaa creation, destruction
PIXAA    *pixaaCreate()
PIXAA    *pixaaCreateFromPixa()
void      pixaaDestroy()

Pixaa addition
l_int32   pixaaAddPixa()
static l_int32   pixaaExtendArray()
l_int32   pixaaAddPix()
l_int32   pixaaAddBox()

Pixaa accessors
l_int32   pixaaGetCount()
PIXA     *pixaaGetPixa()
BOXA     *pixaaGetBoxa()
PIX      *pixaaGetPix()
l_int32   pixaaVerifyDepth()
l_int32   pixaaVerifyDimensions()
l_int32   pixaaIsFull()

Pixaa array modifiers
l_int32   pixaaInitFull()
l_int32   pixaaReplacePixa()
l_int32   pixaaClear()
l_int32   pixaaTruncate()

Pixa serialized I/O  (requires png support)
PIXA     *pixaRead()
PIXA     *pixaReadStream()
PIXA     *pixaReadMem()
l_int32   pixaWriteDebug()
l_int32   pixaWrite()
l_int32   pixaWriteStream()
l_int32   pixaWriteMem()
PIXA     *pixaReadBoth()

Pixaa serialized I/O  (requires png support)
PIXAA    *pixaaReadFromFiles()
PIXAA    *pixaaRead()
PIXAA    *pixaaReadStream()
PIXAA    *pixaaReadMem()
l_int32   pixaaWrite()
l_int32   pixaaWriteStream()
l_int32   pixaaWriteMem()


Important note on reference counting:
Reference counting for the Pixa is analogous to that for the Boxa.
See pix.h for details.   pixaCopy() provides three possible modes
of copy.  The basic rule is that however a Pixa is obtained
(e.g., from pixaCreate*(), pixaCopy(), or a Pixaa accessor),
it is necessary to call pixaDestroy() on it.
</pre>




"""
    
    try:
        leptonica.pixaCreate.argtypes = [ctypes.c_int32]
        leptonica.pixaCreate.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial number of ptrs
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) This creates an empty boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreate(*args)
    
    

    try:
        leptonica.pixaCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaCreateFromPix.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreateFromPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'n')       
('l_int32', 'cellw')       
('l_int32', 'cellh')       

:param[in]    pixs:    with individual components on a lattice
:param[in]    n:       number of components
:param[in]    cellw:   width of each cell
:param[in]    cellh:   height of each cell
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) For bpp = 1, we truncate each retrieved pix to the ON
pixels, which we assume for now start at (0,0)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreateFromPix(*args)
    
    

    try:
        leptonica.pixaCreateFromBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaCreateFromBoxa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCreateFromBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreateFromBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'start')       
('l_int32', 'num')       
('l_int32', '*pcropwarn')       

:param[in]    pixs:
:param[in]    boxa:
:param[in]    start:       first box to use
:param[in]    num:         number of boxes; use 0 to go to the end
:param[out]   pcropwarn:   [optional] TRUE if the boxa extent
is larger than pixs.
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) This simply extracts from pixs the region corresponding to each
box in the boxa.  To extract all the regions, set both %start
and %num to 0.
(2) The 5th arg is optional.  If the extent of the boxa exceeds the
size of the pixa, so that some boxes are either clipped
or entirely outside the pix, a warning is returned as TRUE.
(3) pixad will have only the properly clipped elements, and
the internal boxa will be correct.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreateFromBoxa(*args)
    
    

    try:
        leptonica.pixaSplitPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaSplitPix.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSplitPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSplitPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'borderwidth')       
('l_uint32', 'bordercolor')       

:param[in]    pixs:          with individual components on a lattice
:param[in]    nx:            number of mosaic cells horizontally
:param[in]    ny:            number of mosaic cells vertically
:param[in]    borderwidth:   of added border on all sides
:param[in]    bordercolor:   in our RGBA format: 0xrrggbbaa
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) This is a variant on pixaCreateFromPix(), where we
simply divide the image up into (approximately) equal
subunits.  If you want the subimages to have essentially
the same aspect ratio as the input pix, use nx = ny.
(2) If borderwidth is 0, we ignore the input bordercolor and
redefine it to white.
(3) The bordercolor is always used to initialize each tiled pix,
so that if the src is clipped, the unblitted part will
be this color.  This avoids 1 pixel wide black stripes at the
left and lower edges.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSplitPix(*args)
    
    

    try:
        leptonica.pixaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDestroy(*args):
        """
        ('PIXA', '**ppixa')       

:param[in,out]  ppixa:    use ptr address so it will be nulled

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the pixa.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDestroy(*args)
    
    

    try:
        leptonica.pixaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaCopy.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCopy(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'copyflag')       

:param[in]    pixa:
:param[in]    copyflag:  see pix.h for details:
L_COPY makes a new pixa and copies each pix and each box;
L_CLONE gives a new ref-counted handle to the input pixa;
L_COPY_CLONE makes a new pixa and inserts clones of
all pix and boxes
:returns:  new pixa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCopy(*args)
    
    

    try:
        leptonica.pixaAddPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaAddPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaAddPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddPix(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pix')       
('l_int32', 'copyflag')       

:param[in]    pixa:
:param[in]    pix:        to be added
:param[in]    copyflag:   L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddPix(*args)
    
    

    try:
        leptonica.pixaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaAddBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddBox(*args):
        """
        ('PIXA', '*pixa')       
('BOX', '*box')       
('l_int32', 'copyflag')       

:param[in]    pixa:
:param[in]    box:
:param[in]    copyflag:    L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddBox(*args)
    
    

    try:
        leptonica.pixaExtendArrayToSize.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixaExtendArrayToSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaExtendArrayToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaExtendArrayToSize(*args):
        """
        ('PIXA', '*pixa')       
('size_t', 'size')       

:param[in]    pixa:
:param[in]    size:     number of pix ptrs in new array
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If necessary, reallocs new pixa and boxa ptrs arrays to %size.
The pixa and boxa ptr arrays must always be equal in size.
(2) The max number of pix ptrs is 5M.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaExtendArrayToSize(*args)
    
    

    try:
        leptonica.pixaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.pixaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetCount(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:
:returns:  count, or 0 if no pixa


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetCount(*args)
    
    

    try:
        leptonica.pixaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaChangeRefcount(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'delta')       

:param[in]    pixa:
:param[in]    delta:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaChangeRefcount(*args)
    
    

    try:
        leptonica.pixaGetPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaGetPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetPix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       

:param[in]    pixa:
:param[in]    index:        to the index-th pix
:param[in]    accesstype:   L_COPY or L_CLONE
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetPix(*args)
    
    

    try:
        leptonica.pixaGetPixDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetPixDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetPixDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetPixDimensions(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       

:param[in]    pixa:
:param[in]    index:         to the index-th box
:param[out]   pw,: ph, pd    [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetPixDimensions(*args)
    
    

    try:
        leptonica.pixaGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaGetBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBoxa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'accesstype')       

:param[in]    pixa:
:param[in]    accesstype:   L_COPY, L_CLONE, L_COPY_CLONE
:returns:  boxa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBoxa(*args)
    
    

    try:
        leptonica.pixaGetBoxaCount.argtypes = [ctypes.c_void_p]
        leptonica.pixaGetBoxaCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetBoxaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBoxaCount(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBoxaCount(*args)
    
    

    try:
        leptonica.pixaGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaGetBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBox(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       

:param[in]    pixa:
:param[in]    index:        to the index-th pix
:param[in]    accesstype:   L_COPY or L_CLONE
:returns:  box if null, not automatically an error, or NULL on error

<pre>
Notes:
(1) There is always a boxa with a pixa, and it is initialized so
that each box ptr is NULL.
(2) In general, we expect that there is either a box associated
with each pix, or no boxes at all in the boxa.
(3) Having no boxes is thus not an automatic error.  Whether it
is an actual error is determined by the calling program.
If the caller expects to get a box, it is an error; see, e.g.,
pixaGetBoxGeometry().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBox(*args)
    
    

    try:
        leptonica.pixaGetBoxGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetBoxGeometry.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetBoxGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetBoxGeometry(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    pixa:
:param[in]    index:            to the index-th box
:param[out]   px,: py, pw, ph   [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetBoxGeometry(*args)
    
    

    try:
        leptonica.pixaSetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSetBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSetBoxa(*args):
        """
        ('PIXA', '*pixa')       
('BOXA', '*boxa')       
('l_int32', 'accesstype')       

:param[in]    pixa:
:param[in]    boxa:
:param[in]    accesstype:   L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys the existing boxa in the pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSetBoxa(*args)
    
    

    try:
        leptonica.pixaGetPixArray.argtypes = [ctypes.c_void_p]
        leptonica.pixaGetPixArray.restype = ctypes.c_void_p
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetPixArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetPixArray(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:
:returns:  pix array, or NULL on error

<pre>
Notes:
(1) This returns a ptr to the actual array.  The array is
owned by the pixa, so it must not be destroyed.
(2) The caller should always check if the return value is NULL
before accessing any of the pix ptrs in this array!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetPixArray(*args)
    
    

    try:
        leptonica.pixaVerifyDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaVerifyDepth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaVerifyDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaVerifyDepth(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*psame')       
('l_int32', '*pmaxd')       

:param[in]    pixa:
:param[out]   psame:   1 if depth is the same for all pix; 0 otherwise
:param[out]   pmaxd:   [optional] max depth of all pix
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is considered to be an error if there are no pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaVerifyDepth(*args)
    
    

    try:
        leptonica.pixaVerifyDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaVerifyDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaVerifyDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaVerifyDimensions(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*psame')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       

:param[in]    pixa:
:param[out]   psame:   1 if dimensions are the same for all pix; 0 otherwise
:param[out]   pmaxw:   [optional] max width of all pix
:param[out]   pmaxh:   [optional] max height of all pix
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is considered to be an error if there are no pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaVerifyDimensions(*args)
    
    

    try:
        leptonica.pixaIsFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaIsFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaIsFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaIsFull(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pfullpa')       
('l_int32', '*pfullba')       

:param[in]    pixa:
:param[out]   pfullpa:   [optional] 1 if pixa is full
:param[out]   pfullba:   [optional] 1 if boxa is full
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) A pixa is "full" if the array of pix is fully
occupied from index 0 to index (pixa->n - 1).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaIsFull(*args)
    
    

    try:
        leptonica.pixaCountText.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaCountText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaCountText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCountText(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pntext')       

:param[in]    pixa:
:param[out]   pntext:    number of pix with non-empty text strings
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) All pix have non-empty text strings if the returned value %ntext
equals the pixa count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCountText(*args)
    
    

    try:
        leptonica.pixaSetText.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixaSetText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSetText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSetText(*args):
        """
        ('PIXA', '*pixa')       
('const char', '*text')       
('SARRAY', '*sa')       

:param[in]    pixa:
:param[in]    text:  [optional] single text string, to insert in each pix
:param[in]    sa:    [optional] array of text strings, to insert in each pix
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) To clear all the text fields, use %sa == NULL and %text == NULL.
(2) To set all the text fields to the same value %text, use %sa = NULL.
(3) If %sa is defined, we ignore %text and use it; %sa must have
the same count as %pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSetText(*args)
    
    

    try:
        leptonica.pixaGetLinePtrs.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetLinePtrs.restype = ctypes.POINTER(ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p)))
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetLinePtrs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetLinePtrs(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*psize')       

:param[in]    pixa:    of pix that all have the same depth
:param[out]   psize:   [optional] number of pix in the pixa
:returns:  array of array of line ptrs, or NULL on error

<pre>
Notes:
(1) See pixGetLinePtrs() for details.
(2) It is best if all pix in the pixa are the same size.
The size of each line ptr array is equal to the height
of the pix that it refers to.
(3) This is an array of arrays.  To destroy it:
for (i = 0; i < size; i++)
LEPT_FREE(lineset[i]);
LEPT_FREE(lineset);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetLinePtrs(*args)
    
    

    try:
        leptonica.pixaWriteStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaWriteStreamInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteStreamInfo(*args):
        """
        ('FILE', '*fp')       
('PIXA', '*pixa')       

:param[in]    fp:     file stream
:param[in]    pixa:
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) For each pix in the pixa, write out the pix dimensions, spp,
text string (if it exists), and cmap info.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteStreamInfo(*args)
    
    

    try:
        leptonica.pixaReplacePix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaReplacePix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaReplacePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReplacePix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('PIX', '*pix')       
('BOX', '*box')       

:param[in]    pixa:
:param[in]    index:   to the index-th pix
:param[in]    pix:     insert to replace existing one
:param[in]    box:     [optional] insert to replace existing
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place replacement of one pix.
(2) The previous pix at that location is destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReplacePix(*args)
    
    

    try:
        leptonica.pixaInsertPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaInsertPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaInsertPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaInsertPix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('PIX', '*pixs')       
('BOX', '*box')       

:param[in]    pixa:
:param[in]    index:   at which pix is to be inserted
:param[in]    pixs:    new pix to be inserted
:param[in]    box:     [optional] new box to be inserted
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts pixa[i] --> pixa[i + 1] for all i >= index,
and then inserts at pixa[index].
(2) To insert at the beginning of the array, set index = 0.
(3) It should not be used repeatedly on large arrays,
because the function is O(n).
(4) To append a pix to a pixa, it's easier to use pixaAddPix().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaInsertPix(*args)
    
    

    try:
        leptonica.pixaRemovePix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaRemovePix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaRemovePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemovePix(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       

:param[in]    pixa:
:param[in]    index:    of pix to be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts pixa[i] --> pixa[i - 1] for all i > index.
(2) It should not be used repeatedly on large arrays,
because the function is O(n).
(3) The corresponding box is removed as well, if it exists.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemovePix(*args)
    
    

    try:
        leptonica.pixaRemovePixAndSave.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaRemovePixAndSave.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaRemovePixAndSave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemovePixAndSave(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'index')       
('PIX', '**ppix')       
('BOX', '**pbox')       

:param[in]    pixa:
:param[in]    index:   of pix to be removed
:param[out]   ppix:    [optional] removed pix
:param[out]   pbox:    [optional] removed box
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts pixa[i] --> pixa[i - 1] for all i > index.
(2) It should not be used repeatedly on large arrays,
because the function is O(n).
(3) The corresponding box is removed as well, if it exists.
(4) The removed pix and box can either be retained or destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemovePixAndSave(*args)
    
    

    try:
        leptonica.pixaRemoveSelected.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaRemoveSelected.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaRemoveSelected not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemoveSelected(*args):
        """
        ('PIXA', '*pixa')       
('NUMA', '*naindex')       

:param[in]    pixa:
:param[in]    naindex:   numa of indices of pix to be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This gives error messages for invalid indices
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemoveSelected(*args)
    
    

    try:
        leptonica.pixaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaInitFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaInitFull(*args):
        """
        ('PIXA', '*pixa')       
('PIX', '*pix')       
('BOX', '*box')       

:param[in]    pixa:   typically empty
:param[in]    pix:    [optional] to be replicated to the entire pixa ptr array
:param[in]    box:    [optional] to be replicated to the entire boxa ptr array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This initializes a pixa by filling up the entire pix ptr array
with copies of %pix.  If %pix == NULL, we use a tiny placeholder
pix (w = h = d = 1).  Any existing pix are destroyed.
It also optionally fills the boxa with copies of %box.
After this operation, the numbers of pix and (optionally)
boxes are equal to the number of allocated ptrs.
(2) Note that we use pixaReplacePix() instead of pixaInsertPix().
They both have the same effect when inserting into a NULL ptr
in the pixa ptr array:
(3) If the boxa is not initialized (i.e., filled with boxes),
later insertion of boxes will cause an error, because the
'n' field is 0.
(4) Example usage.  This function is useful to prepare for a
random insertion (or replacement) of pix into a pixa.
To randomly insert pix into a pixa, without boxes, up to
some index "max":
Pixa *pixa = pixaCreate(max);
pixaInitFull(pixa, NULL, NULL);
An existing pixa with a smaller ptr array can also be reused:
pixaExtendArrayToSize(pixa, max);
pixaInitFull(pixa, NULL, NULL);
The initialization allows the pixa to always be properly
filled, even if all pix (and boxes) are not later replaced.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaInitFull(*args)
    
    

    try:
        leptonica.pixaClear.argtypes = [ctypes.c_void_p]
        leptonica.pixaClear.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaClear(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys all pix in the pixa, as well as
all boxes in the boxa.  The ptrs in the pix ptr array
are all null'd.  The number of allocated pix, n, is set to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaClear(*args)
    
    

    try:
        leptonica.pixaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaJoin(*args):
        """
        ('PIXA', '*pixad')       
('PIXA', '*pixas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    pixad:    dest pixa; add to this one
:param[in]    pixas:    [optional] source pixa; add from this one
:param[in]    istart:   starting index in pixas
:param[in]    iend:     ending index in pixas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This appends a clone of each indicated pix in pixas to pixad
(2) istart < 0 is taken to mean 'read from the start' (istart = 0)
(3) iend < 0 means 'read to the end'
(4) If pixas is NULL or contains no pix, this is a no-op.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaJoin(*args)
    
    

    try:
        leptonica.pixaInterleave.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaInterleave.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaInterleave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaInterleave(*args):
        """
        ('PIXA', '*pixa1')       
('PIXA', '*pixa2')       
('l_int32', 'copyflag')       

:param[in]    pixa1:      first src pixa
:param[in]    pixa2:      second src pixa
:param[in]    copyflag:   L_CLONE, L_COPY
:returns:  pixa  interleaved from sources, or NULL on error.

<pre>
Notes:
(1) %copyflag determines if the pix are copied or cloned.
The boxes, if they exist, are copied.
(2) If the two pixa have different sizes, a warning is issued,
and the number of pairs returned is the minimum size.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaInterleave(*args)
    
    

    try:
        leptonica.pixaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaJoin(*args):
        """
        ('PIXAA', '*paad')       
('PIXAA', '*paas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    paad:     dest pixaa; add to this one
:param[in]    paas:     [optional] source pixaa; add from this one
:param[in]    istart:   starting index in pixaas
:param[in]    iend:     ending index in pixaas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This appends a clone of each indicated pixa in paas to pixaad
(2) istart < 0 is taken to mean 'read from the start' (istart = 0)
(3) iend < 0 means 'read to the end'
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaJoin(*args)
    
    

    try:
        leptonica.pixaaCreate.argtypes = [ctypes.c_int32]
        leptonica.pixaaCreate.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial number of pixa ptrs
:returns:  paa, or NULL on error

<pre>
Notes:
(1) A pixaa provides a 2-level hierarchy of images.
A common use is for segmentation masks, which are
inexpensive to store in png format.
(2) For example, suppose you want a mask for each textline
in a two-column page.  The textline masks for each column
can be represented by a pixa, of which there are 2 in the pixaa.
The boxes for the textline mask components within a column
can have their origin referred to the column rather than the page.
Then the boxa field can be used to represent the two box (regions)
for the columns, and the (x,y) components of each box can
be used to get the absolute position of the textlines on
the page.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaCreate(*args)
    
    

    try:
        leptonica.pixaaCreateFromPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaCreateFromPixa.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaCreateFromPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaCreateFromPixa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'n')       
('l_int32', 'type')       
('l_int32', 'copyflag')       

:param[in]    pixa:
:param[in]    n:          number specifying subdivision of pixa
:param[in]    type:       L_CHOOSE_CONSECUTIVE, L_CHOOSE_SKIP_BY
:param[in]    copyflag:   L_CLONE, L_COPY
:returns:  paa, or NULL on error

<pre>
Notes:
(1) This subdivides a pixa into a set of smaller pixa that
are accumulated into a pixaa.
(2) If type == L_CHOOSE_CONSECUTIVE, the first 'n' pix are
put in a pixa and added to pixaa, then the next 'n', etc.
If type == L_CHOOSE_SKIP_BY, the first pixa is made by
aggregating pix[0], pix[n], pix[2*n], etc.
(3) The copyflag specifies if each new pix is a copy or a clone.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaCreateFromPixa(*args)
    
    

    try:
        leptonica.pixaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixaaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDestroy(*args):
        """
        ('PIXAA', '**ppaa')       

:param[in,out]   ppaa:    use ptr address so it will be nulled
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDestroy(*args)
    
    

    try:
        leptonica.pixaaAddPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaAddPixa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaAddPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaAddPixa(*args):
        """
        ('PIXAA', '*paa')       
('PIXA', '*pixa')       
('l_int32', 'copyflag')       

:param[in]    paa:
:param[in]    pixa:    to be added
:param[in]    copyflag::
L_INSERT inserts the pixa directly;
L_COPY makes a new pixa and copies each pix and each box;
L_CLONE gives a new handle to the input pixa;
L_COPY_CLONE makes a new pixa and inserts clones of
all pix and boxes
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaAddPixa(*args)
    
    

    try:
        leptonica.pixaaAddPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaAddPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaAddPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaAddPix(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'copyflag')       

:param[in]    paa:        input paa
:param[in]    index:      index of pixa in paa
:param[in]    pix:        to be added
:param[in]    box:        [optional] to be added
:param[in]    copyflag:   L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaAddPix(*args)
    
    

    try:
        leptonica.pixaaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaAddBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaAddBox(*args):
        """
        ('PIXAA', '*paa')       
('BOX', '*box')       
('l_int32', 'copyflag')       

:param[in]    paa:
:param[in]    box:
:param[in]    copyflag:    L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The box can be used, for example, to hold the support region
of a pixa that is being added to the pixaa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaAddBox(*args)
    
    

    try:
        leptonica.pixaaGetCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetCount(*args):
        """
        ('PIXAA', '*paa')       
('NUMA', '**pna')       

:param[in]    paa:
:param[out]   pna:    [optional] number of pix in each pixa
:returns:  count, or 0 if no pixaa

<pre>
Notes:
(1) If paa is empty, a returned na will also be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetCount(*args)
    
    

    try:
        leptonica.pixaaGetPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaGetPixa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaGetPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetPixa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('l_int32', 'accesstype')       

:param[in]    paa:
:param[in]    index:        to the index-th pixa
:param[in]    accesstype:   L_COPY, L_CLONE, L_COPY_CLONE
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) L_COPY makes a new pixa with a copy of every pix
(2) L_CLONE just makes a new reference to the pixa,
and bumps the counter.  You would use this, for example,
when you need to extract some data from a pix within a
pixa within a pixaa.
(3) L_COPY_CLONE makes a new pixa with a clone of every pix
and box
(4) In all cases, you must invoke pixaDestroy() on the returned pixa
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetPixa(*args)
    
    

    try:
        leptonica.pixaaGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaGetBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetBoxa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'accesstype')       

:param[in]    paa:
:param[in]    accesstype:    L_COPY, L_CLONE
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) L_COPY returns a copy; L_CLONE returns a new reference to the boxa.
(2) In both cases, invoke boxaDestroy() on the returned boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetBoxa(*args)
    
    

    try:
        leptonica.pixaaGetPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaGetPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaGetPix(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('l_int32', 'ipix')       
('l_int32', 'accessflag')       

:param[in]    paa:
:param[in]    index:        index into the pixa array in the pixaa
:param[in]    ipix:         index into the pix array in the pixa
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaGetPix(*args)
    
    

    try:
        leptonica.pixaaVerifyDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaVerifyDepth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaVerifyDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaVerifyDepth(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*psame')       
('l_int32', '*pmaxd')       

:param[in]    paa:
:param[out]   psame:   1 if all pix have the same depth; 0 otherwise
:param[out]   pmaxd:   [optional] max depth of all pix in pixaa
:returns:   0 if OK; 1 on error

<pre>
Notes:
(1) It is considered to be an error if any pixa have no pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaVerifyDepth(*args)
    
    

    try:
        leptonica.pixaaVerifyDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaVerifyDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaVerifyDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaVerifyDimensions(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*psame')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       

:param[in]    paa:
:param[out]   psame:   1 if all pix have the same depth; 0 otherwise
:param[out]   pmaxw:   [optional] max width of all pix in pixaa
:param[out]   pmaxh:   [optional] max height of all pix in pixaa
:returns:   0 if OK; 1 on error

<pre>
Notes:
(1) It is considered to be an error if any pixa have no pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaVerifyDimensions(*args)
    
    

    try:
        leptonica.pixaaIsFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaIsFull.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixaaIsFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaIsFull(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*pfull')       

:param[in]    paa:
:param[out]   pfull:    1 if all pixa in the paa have full pix arrays
:returns:  return 0 if OK, 1 on error

<pre>
Notes:
(1) Does not require boxa associated with each pixa to be full.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaIsFull(*args)
    
    

    try:
        leptonica.pixaaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaInitFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaInitFull(*args):
        """
        ('PIXAA', '*paa')       
('PIXA', '*pixa')       

:param[in]    paa:     typically empty
:param[in]    pixa:    to be replicated into the entire pixa ptr array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This initializes a pixaa by filling up the entire pixa ptr array
with copies of %pixa.  Any existing pixa are destroyed.
(2) Example usage.  This function is useful to prepare for a
random insertion (or replacement) of pixa into a pixaa.
To randomly insert pixa into a pixaa, up to some index "max":
Pixaa *paa = pixaaCreate(max);
Pixa *pixa = pixaCreate(1);  // if you want little memory
pixaaInitFull(paa, pixa);  // copy it to entire array
pixaDestroy(&pixa);  // no longer needed
The initialization allows the pixaa to always be properly filled.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaInitFull(*args)
    
    

    try:
        leptonica.pixaaReplacePixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaaReplacePixa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaReplacePixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReplacePixa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'index')       
('PIXA', '*pixa')       

:param[in]    paa:
:param[in]    index:  to the index-th pixa
:param[in]    pixa:   insert to replace existing one
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This allows random insertion of a pixa into a pixaa, with
destruction of any existing pixa at that location.
The input pixa is now owned by the pixaa.
(2) No other pixa in the array are affected.
(3) The index must be within the allowed set.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReplacePixa(*args)
    
    

    try:
        leptonica.pixaaClear.argtypes = [ctypes.c_void_p]
        leptonica.pixaaClear.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaClear(*args):
        """
        ('PIXAA', '*paa')       

:param[in]    paa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys all pixa in the pixaa, and nulls the ptrs
in the pixa ptr array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaClear(*args)
    
    

    try:
        leptonica.pixaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.pixaaTruncate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaTruncate(*args):
        """
        ('PIXAA', '*paa')       

:param[in]    paa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This identifies the largest index containing a pixa that
has any pix within it, destroys all pixa above that index,
and resets the count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaTruncate(*args)
    
    

    try:
        leptonica.pixaRead.argtypes = [ctypes.c_char_p]
        leptonica.pixaRead.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRead(*args)
    
    

    try:
        leptonica.pixaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixaReadStream.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
(2) It is OK for the pixa to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadStream(*args)
    
    

    try:
        leptonica.pixaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixaReadMem.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:   of serialized pixa
:param[in]    size:   of data in bytes
:returns:  pixa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadMem(*args)
    
    

    try:
        leptonica.pixaWriteDebug.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixaWriteDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteDebug(*args):
        """
        ('const char', '*fname')       
('PIXA', '*pixa')       

:param[in]    fname:
:param[in]    pixa:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Debug version, intended for use in the library when writing
to files in a temp directory with names that are compiled in.
This is used instead of pixaWrite() for all such library calls.
(2) The global variable LeptDebugOK defaults to 0, and can be set
or cleared by the function setLeptDebugOK().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteDebug(*args)
    
    

    try:
        leptonica.pixaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWrite(*args):
        """
        ('const char', '*filename')       
('PIXA', '*pixa')       

:param[in]    filename:
:param[in]    pixa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWrite(*args)
    
    

    try:
        leptonica.pixaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXA', '*pixa')       

:param[in]    fp:     file stream opened for "wb"
:param[in]    pixa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteStream(*args)
    
    

    try:
        leptonica.pixaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIXA', '*pixa')       

:param[out]   pdata:    data of serialized pixa
:param[out]   psize:    size of returned data
:param[in]    pixa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a pixa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteMem(*args)
    
    

    try:
        leptonica.pixaReadBoth.argtypes = [ctypes.c_char_p]
        leptonica.pixaReadBoth.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaReadBoth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaReadBoth(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) This reads serialized files of either a pixa or a pixacomp,
and returns a pixa in memory.  It requires png and jpeg libraries.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaReadBoth(*args)
    
    

    try:
        leptonica.pixaaReadFromFiles.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaReadFromFiles.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaReadFromFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReadFromFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'first')       
('l_int32', 'nfiles')       

:param[in]    dirname:   directory
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    first:     0-based
:param[in]    nfiles:    use 0 for everything from %first to the end
:returns:  paa, or NULL on error or if no pixa files are found.

<pre>
Notes:
(1) The files must be serialized pixa files (e.g., *.pa)
If some files cannot be read, warnings are issued.
(2) Use %substr to filter filenames in the directory.  If
%substr == NULL, this takes all files.
(3) After filtering, use %first and %nfiles to select
a contiguous set of files, that have been lexically
sorted in increasing order.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReadFromFiles(*args)
    
    

    try:
        leptonica.pixaaRead.argtypes = [ctypes.c_char_p]
        leptonica.pixaaRead.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  paa, or NULL on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaRead(*args)
    
    

    try:
        leptonica.pixaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixaaReadStream.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  paa, or NULL on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
(2) It is OK for the pixaa to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReadStream(*args)
    
    

    try:
        leptonica.pixaaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixaaReadMem.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:   of serialized pixaa
:param[in]    size:   of data in bytes
:returns:  paa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaReadMem(*args)
    
    

    try:
        leptonica.pixaaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixaaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaWrite(*args):
        """
        ('const char', '*filename')       
('PIXAA', '*paa')       

:param[in]    filename:
:param[in]    paa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaWrite(*args)
    
    

    try:
        leptonica.pixaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXAA', '*paa')       

:param[in]    fp:    file stream opened for "wb"
:param[in]    paa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pix are stored in the file as png.
If the png library is not linked, this will fail.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaWriteStream(*args)
    
    

    try:
        leptonica.pixaaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIXAA', '*paa')       

:param[out]   pdata:   data of serialized pixaa
:param[out]   psize:   size of returned data
:param[in]    paa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a pixaa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaWriteMem(*args)
    




class rop(object):
    """<pre>
General rasterop
l_int32    pixRasterop()

In-place full band translation
l_int32    pixRasteropVip()
l_int32    pixRasteropHip()

Full image translation (general and in-place)
l_int32    pixTranslate()
l_int32    pixRasteropIP()

Full image rasterop with no translation
l_int32    pixRasteropFullImage()
</pre>




"""
    
    try:
        leptonica.pixRasterop.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasterop.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRasterop not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasterop(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'dx')       
('l_int32', 'dy')       
('l_int32', 'dw')       
('l_int32', 'dh')       
('l_int32', 'op')       
('PIX', '*pixs')       
('l_int32', 'sx')       
('l_int32', 'sy')       

:param[in]    pixd:   dest pix
:param[in]    dx:     x val of UL corner of dest rectangle
:param[in]    dy:     y val of UL corner of dest rectangle
:param[in]    dw:     width of dest rectangle
:param[in]    dh:     height of dest rectangle
:param[in]    op:     op code
:param[in]    pixs:   src pix
:param[in]    sx:     x val of UL corner of src rectangle
:param[in]    sy:     y val of UL corner of src rectangle
:returns:  0 if OK; 1 on error.

<pre>
Notes:
(1) This has the standard set of 9 args for rasterop.
This function is your friend; it is worth memorizing!
(2) If the operation involves only dest, this calls
rasteropUniLow().  Otherwise, checks depth of the
src and dest, and if they match, calls rasteropLow().
(3) For the two-image operation, where both pixs and pixd
are defined, they are typically different images.  However
there are cases, such as pixSetMirroredBorder(), where
in-place operations can be done, blitting pixels from
one part of pixd to another.  Consequently, we permit
such operations.  If you use them, be sure that there
is no overlap between the source and destination rectangles
in pixd (!)

Background:
-----------

There are 18 operations, described by the op codes in pix.h.

One, PIX_DST, is a no-op.

Three, PIX_CLR, PIX_SET, and PIX_NOT(PIX_DST) operate only on the dest.
These are handled by the low-level rasteropUniLow().

The other 14 involve the both the src and the dest, and depend on
the bit values of either just the src or the bit values of both
src and dest.  They are handled by rasteropLow():

PIX_SRC                             s
PIX_NOT(PIX_SRC)                   ~s
PIX_SRC | PIX_DST                   s | d
PIX_SRC & PIX_DST                   s & d
PIX_SRC ^ PIX_DST                   s ^ d
PIX_NOT(PIX_SRC) | PIX_DST         ~s | d
PIX_NOT(PIX_SRC) & PIX_DST         ~s & d
PIX_NOT(PIX_SRC) ^ PIX_DST         ~s ^ d
PIX_SRC | PIX_NOT(PIX_DST)          s | ~d
PIX_SRC & PIX_NOT(PIX_DST)          s & ~d
PIX_SRC ^ PIX_NOT(PIX_DST)          s ^ ~d
PIX_NOT(PIX_SRC | PIX_DST)         ~(s | d)
PIX_NOT(PIX_SRC & PIX_DST)         ~(s & d)
PIX_NOT(PIX_SRC ^ PIX_DST)         ~(s ^ d)

Each of these is implemented with one of three low-level
functions, depending on the alignment of the left edge
of the src and dest rectangles:
a fastest implementation if both left edges are
(32-bit) word aligned
a very slightly slower implementation if both left
edges have the same relative (32-bit) word alignment
the general routine that is invoked when
both left edges have different word alignment

Of the 14 binary rasterops above, only 12 are unique
logical combinations (out of a possible 16) of src
and dst bits:

(sd)         (11)   (10)   (01)   (00)
-----------------------------------------------
s            1      1      0      0
~s            0      1      0      1
s | d          1      1      1      0
s & d          1      0      0      0
s ^ d          0      1      1      0
~s | d          1      0      1      1
~s & d          0      0      1      0
~s ^ d          1      0      0      1
s | ~d         1      1      0      1
s & ~d         0      1      0      0
s ^ ~d         1      0      0      1
~(s | d)        0      0      0      1
~(s & d)        0      1      1      1
~(s ^ d)        1      0      0      1

Note that the following three operations are equivalent:
~(s ^ d)
~s ^ d
s ^ ~d
and in the implementation, we call them out with the first form;
namely, ~(s ^ d).

Of the 16 possible binary combinations of src and dest bits,
the remaining 4 unique ones are independent of the src bit.
They depend on either just the dest bit or on neither
the src nor dest bits:

d            1      0      1      0    (indep. of s)
~d            0      1      0      1    (indep. of s)
CLR           0      0      0      0    (indep. of both s & d)
SET           1      1      1      1    (indep. of both s & d)

As mentioned above, three of these are implemented by
rasteropUniLow(), and one is a no-op.

How can these operation codes be represented by bits
in such a way that when the basic operations are performed
on the bits the results are unique for unique
operations, and mimic the logic table given above?

The answer is to choose a particular order of the pairings:
(sd)         (11)   (10)   (01)   (00)
(which happens to be the same as in the above table)
and to translate the result into 4-bit representations
of s and d.  For example, the Sun rasterop choice
(omitting the extra bit for clipping) is

PIX_SRC      0xc
PIX_DST      0xa

This corresponds to our pairing order given above:
(sd)         (11)   (10)   (01)   (00)
where for s = 1 we get the bit pattern
PIX_SRC:        1      1      0      0     (0xc)
and for d = 1 we get the pattern
PIX_DST:         1      0      1      0    (0xa)

OK, that's the pairing order that Sun chose.  How many different
ways can we assign bit patterns to PIX_SRC and PIX_DST to get
the boolean ops to work out?  Any of the 4 pairs can be put
in the first position, any of the remaining 3 pairs can go
in the second; and one of the remaining 2 pairs can go the the third.
There is a total of 4*3*2 = 24 ways these pairs can be permuted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasterop(*args)
    
    

    try:
        leptonica.pixRasteropVip.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasteropVip.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRasteropVip not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropVip(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'bx')       
('l_int32', 'bw')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       

:param[in]    pixd:     in-place
:param[in]    bx:       left edge of vertical band
:param[in]    bw:       width of vertical band
:param[in]    vshift:   vertical shift of band; vshift > 0 is down
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This rasterop translates a vertical band of the
image either up or down, bringing in either white
or black pixels from outside the image.
(2) The vertical band extends the full height of pixd.
(3) If a colormap exists, the nearest color to white or black
is brought in.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropVip(*args)
    
    

    try:
        leptonica.pixRasteropHip.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasteropHip.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRasteropHip not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropHip(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'by')       
('l_int32', 'bh')       
('l_int32', 'hshift')       
('l_int32', 'incolor')       

:param[in]    pixd:     in-place operation
:param[in]    by:       top of horizontal band
:param[in]    bh:       height of horizontal band
:param[in]    hshift:   horizontal shift of band; hshift > 0 is to right
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This rasterop translates a horizontal band of the
image either left or right, bringing in either white
or black pixels from outside the image.
(2) The horizontal band extends the full width of pixd.
(3) If a colormap exists, the nearest color to white or black
is brought in.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropHip(*args)
    
    

    try:
        leptonica.pixTranslate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTranslate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTranslate(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hshift')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       

:param[in]    pixd:    [optional] destination: this can be null,
equal to pixs, or different from pixs
:param[in]    pixs:
:param[in]    hshift:   horizontal shift; hshift > 0 is to right
:param[in]    vshift:   vertical shift; vshift > 0 is down
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) The general pattern is:
pixd = pixTranslate(pixd, pixs, ...);
For clarity, when you know the case, use one of these:
pixd = pixTranslate(NULL, pixs, ...);  // new
pixTranslate(pixs, pixs, ...);         // in-place
pixTranslate(pixd, pixs, ...);         // to existing pixd
(2) If an existing pixd is not the same size as pixs, the
image data will be reallocated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTranslate(*args)
    
    

    try:
        leptonica.pixRasteropIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRasteropIP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRasteropIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropIP(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'hshift')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       

:param[in]    pixd:     in-place translation
:param[in]    hshift:   horizontal shift; hshift > 0 is to right
:param[in]    vshift:   vertical shift; vshift > 0 is down
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropIP(*args)
    
    

    try:
        leptonica.pixRasteropFullImage.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRasteropFullImage.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRasteropFullImage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRasteropFullImage(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'op')       

:param[in]    pixd:
:param[in]    pixs:
:param[in]    op:     any of the op-codes
:returns:  0 if OK; 1 on error

<pre>
Notes:
~ this is a wrapper for a common 2-image raster operation
~ both pixs and pixd must be defined
~ the operation is performed with aligned UL corners of pixs and pixd
~ the operation clips to the smallest pix; if the width or height
of pixd is larger than pixs, some pixels in pixd will be unchanged
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRasteropFullImage(*args)
    




class utils1(object):
    """<pre>

------------------------------------------
This file has these utilities:
- error, warning and info messages
- redirection of stderr
- low-level endian conversions
- file corruption operations
- random and prime number operations
- 64-bit hash functions
- leptonica version number accessor
- timing and date operations
------------------------------------------

Control of error, warning and info messages
l_int32    setMsgSeverity()

Error return functions, invoked by macros
l_int32    returnErrorInt()
l_float32  returnErrorFloat()
void      *returnErrorPtr()

Runtime redirection of stderr
void leptSetStderrHandler()
void lept_stderr()

Test files for equivalence
l_int32    filesAreIdentical()

Byte-swapping data conversion
l_uint16   convertOnBigEnd16()
l_uint32   convertOnBigEnd32()
l_uint16   convertOnLittleEnd16()
l_uint32   convertOnLittleEnd32()

File corruption and byte replacement operations
l_int32    fileCorruptByDeletion()
l_int32    fileCorruptByMutation()
l_int32    fileReplaceBytes()

Generate random integer in given interval
l_int32    genRandomIntOnInterval()

Simple math function
l_int32    lept_roundftoi()

64-bit hash functions
l_int32    l_hashStringToUint64()
l_int32    l_hashPtToUint64()
l_int32    l_hashFloat64ToUint64()

Prime finders
l_int32    findNextLargerPrime()
l_int32    lept_isPrime()

Gray code conversion
l_uint32   convertIntToGrayCode()
l_uint32   convertGrayCodeToInt()

Leptonica version number
char      *getLeptonicaVersion()

Timing
void       startTimer()
l_float32  stopTimer()
L_TIMER    startTimerNested()
l_float32  stopTimerNested()
void       l_getCurrentTime()
L_WALLTIMER  *startWallTimer()
l_float32  stopWallTimer()
void       l_getFormattedDate()

For all issues with cross-platform development, see utils2.c.
</pre>




"""
    
    try:
        leptonica.setMsgSeverity.argtypes = [ctypes.c_int32]
        leptonica.setMsgSeverity.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function setMsgSeverity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def setMsgSeverity(*args):
        """
        ('l_int32', 'newsev')       

:param[in]    newsev:
:returns:  oldsev

<pre>
Notes:
(1) setMsgSeverity() allows the user to specify the desired
message severity threshold.  Messages of equal or greater
severity will be output.  The previous message severity is
returned when the new severity is set.
(2) If L_SEVERITY_EXTERNAL is passed, then the severity will be
obtained from the LEPT_MSG_SEVERITY environment variable.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.setMsgSeverity(*args)
    
    

    try:
        leptonica.returnErrorInt.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.returnErrorInt.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function returnErrorInt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def returnErrorInt(*args):
        """
        ('const char', '*msg')       
('const char', '*procname')       
('l_int32', 'ival')       

:param[in]    msg:        error message
:param[in]    procname:
:param[in]    ival:       return error val
:returns:  ival typically 1 for an error return


        """
        args = _convert_params(*args)
        
        return leptonica.returnErrorInt(*args)
    
    

    try:
        leptonica.returnErrorFloat.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_float]
        leptonica.returnErrorFloat.restype = ctypes.c_float
    except AttributeError:
        sys.stderr.write("Warning - function returnErrorFloat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def returnErrorFloat(*args):
        """
        ('const char', '*msg')       
('const char', '*procname')       
('l_float32', 'fval')       

:param[in]    msg:        error message
:param[in]    procname:
:param[in]    fval:       return error val
:returns:  fval


        """
        args = _convert_params(*args)
        
        return leptonica.returnErrorFloat(*args)
    
    

    try:
        leptonica.returnErrorPtr.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.returnErrorPtr.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function returnErrorPtr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def returnErrorPtr(*args):
        """
        ('const char', '*msg')       
('const char', '*procname')       
('void', '*pval')       

:param[in]    msg:        error message
:param[in]    procname:
:param[in]    pval:       return error val
:returns:  pval  typically null for an error return


        """
        args = _convert_params(*args)
        
        return leptonica.returnErrorPtr(*args)
    
    

    try:
        leptonica.filesAreIdentical.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.filesAreIdentical.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function filesAreIdentical not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def filesAreIdentical(*args):
        """
        ('const char', '*fname1')       
('const char', '*fname2')       
('l_int32', '*psame')       

:param[in]    fname1:
:param[in]    fname2:
:param[out]   psame:     1 if identical; 0 if different
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.filesAreIdentical(*args)
    
    

    try:
        leptonica.fileCorruptByDeletion.argtypes = [ctypes.c_char_p, ctypes.c_float, ctypes.c_float, ctypes.c_char_p]
        leptonica.fileCorruptByDeletion.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fileCorruptByDeletion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileCorruptByDeletion(*args):
        """
        ('const char', '*filein')       
('l_float32', 'loc')       
('l_float32', 'size')       
('const char', '*fileout')       

:param[in]    filein:
:param[in]    loc:       fractional location of start of deletion
:param[in]    size:      fractional size of deletion
:param[in]    fileout:   corrupted file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) %loc and %size are expressed as a fraction of the file size.
(2) This makes a copy of the data in %filein, where bytes in the
specified region have deleted.
(3) If (%loc + %size) >= 1.0, this deletes from the position
represented by %loc to the end of the file.
(4) It is useful for testing robustness of I/O wrappers when the
data is corrupted, by simulating data corruption by deletion.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fileCorruptByDeletion(*args)
    
    

    try:
        leptonica.fileCorruptByMutation.argtypes = [ctypes.c_char_p, ctypes.c_float, ctypes.c_float, ctypes.c_char_p]
        leptonica.fileCorruptByMutation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fileCorruptByMutation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileCorruptByMutation(*args):
        """
        ('const char', '*filein')       
('l_float32', 'loc')       
('l_float32', 'size')       
('const char', '*fileout')       

:param[in]    filein:
:param[in]    loc:       fractional location of start of randomization
:param[in]    size:      fractional size of randomization
:param[in]    fileout:   corrupted file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) %loc and %size are expressed as a fraction of the file size.
(2) This makes a copy of the data in %filein, where bytes in the
specified region have been replaced by random data.
(3) If (%loc + %size) >= 1.0, this modifies data from the position
represented by %loc to the end of the file.
(4) It is useful for testing robustness of I/O wrappers when the
data is corrupted, by simulating data corruption.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fileCorruptByMutation(*args)
    
    

    try:
        leptonica.fileReplaceBytes.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_char_p]
        leptonica.fileReplaceBytes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fileReplaceBytes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileReplaceBytes(*args):
        """
        ('const char', '*filein')       
('l_int32', 'start')       
('l_int32', 'nbytes')       
('l_uint8', '*newdata')       
('size_t', 'newsize')       
('const char', '*fileout')       

:param[in]    filein:      input file
:param[in]    start:       start location for replacement
:param[in]    nbytes:      number of bytes to be removed
:param[in]    newdata:     replacement bytes
:param[in]    newsize:     size of replacement bytes
:param[in]    fileout:     output file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) To remove %nbytes without replacement, set %newdata == NULL.
(2) One use is for replacing the date/time in a pdf file by a
string of 12 '0's, effectively removing the date without
invalidating the byte counters in the pdf file:
fileReplaceBytes(filein 86 12 (char *)"000000000000" 12 fileout
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fileReplaceBytes(*args)
    
    

    try:
        leptonica.genRandomIntOnInterval.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.genRandomIntOnInterval.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function genRandomIntOnInterval not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def genRandomIntOnInterval(*args):
        """
        ('l_int32', 'start')       
('l_int32', 'end')       
('l_int32', 'seed')       
('l_int32', '*pval')       

:param[in]    start:     beginning of interval; >= 0
:param[in]    end:       end of interval; must be > start
:param[in]    seed:      use 0 to skip; otherwise call srand
:param[out]   pval:      random integer in interval [start ... end]
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.genRandomIntOnInterval(*args)
    
    

    try:
        leptonica.lept_roundftoi.argtypes = [ctypes.c_float]
        leptonica.lept_roundftoi.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_roundftoi not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_roundftoi(*args):
        """
        ('l_float32', 'fval')       

:param[in]    fval:
:returns:  value rounded to int

<pre>
Notes:
(1) For fval >= 0, fval --> round(fval) == floor(fval + 0.5)
For fval < 0, fval --> -round(-fval))
This is symmetric around 0.
e.g., for fval in (-0.5 ... 0.5), fval --> 0
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_roundftoi(*args)
    
    

    try:
        leptonica.l_hashStringToUint64.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.l_hashStringToUint64.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_hashStringToUint64 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_hashStringToUint64(*args):
        """
        ('const char', '*str')       
('l_uint64', '*phash')       

:param[in]    str:
:param[out]   phash:    hash value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The intent of the hash is to avoid collisions by mapping
the string as randomly as possible into 64 bits.
(2) To the extent that the hashes are random, the probability of
a collision can be approximated by the square of the number
of strings divided by 2^64.  For 1 million strings, the
collision probability is about 1 in 16 million.
(3) I expect non-randomness of the distribution to be most evident
for small text strings.  This hash function has been tested
for all 5-character text strings composed of 26 letters,
of which there are 26^5 = 12356630.  There are no hash
collisions for this set.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_hashStringToUint64(*args)
    
    

    try:
        leptonica.l_hashPtToUint64.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_hashPtToUint64.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_hashPtToUint64 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_hashPtToUint64(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_uint64', '*phash')       

:param[in]    x,: y
:param[out]   phash:    hash value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This simple hash function has no collisions for
any of 400 million points with x and y up to 20000.
(2) Previously used a much more complicated and slower function:
mulp = 26544357894361;
hash = 104395301;
hash += (x * mulp) ^ (hash >> 5);
hash ^= (hash << 7);
hash += (y * mulp) ^ (hash >> 7);
hash = hash ^ (hash << 11);
Such logical gymnastics to get coverage over the 2^64
values are not required.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_hashPtToUint64(*args)
    
    

    try:
        leptonica.l_hashFloat64ToUint64.argtypes = [ctypes.c_int32, ctypes.c_double, ctypes.c_void_p]
        leptonica.l_hashFloat64ToUint64.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_hashFloat64ToUint64 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_hashFloat64ToUint64(*args):
        """
        ('l_int32', 'nbuckets')       
('l_float64', 'val')       
('l_uint64', '*phash')       

:param[in]    nbuckets:
:param[in]    val:
:param[out]   phash:      hash value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Simple, fast hash for using dnaHash with 64-bit data
(e.g., sets and histograms).
(2) The resulting hash is called a "key" in a lookup
operation.  The bucket for %val in a dnaHash is simply
found by taking the mod of the hash with the number of
buckets (which is prime).  What gets stored in the
dna in that bucket could depend on use, but for the most
flexibility, we store an index into the associated dna.
This is all that is required for generating either a hash set
or a histogram (an example of a hash map).
(3) For example, to generate a histogram, the histogram dna,
a histogram of unique values aligned with the histogram dna,
and a dnahash hashmap are built.  See l_dnaMakeHistoByHash().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_hashFloat64ToUint64(*args)
    
    

    try:
        leptonica.findNextLargerPrime.argtypes = [ctypes.c_int32, ctypes.c_void_p]
        leptonica.findNextLargerPrime.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function findNextLargerPrime not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def findNextLargerPrime(*args):
        """
        ('l_int32', 'start')       
('l_uint32', '*pprime')       

:param[in]    start:
:param[out]   pprime:    first prime larger than %start
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.findNextLargerPrime(*args)
    
    

    try:
        leptonica.lept_isPrime.argtypes = [ctypes.c_uint64, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lept_isPrime.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lept_isPrime not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_isPrime(*args):
        """
        ('l_uint64', 'n')       
('l_int32', '*pis_prime')       
('l_uint32', '*pfactor')       

:param[in]    n:           64-bit unsigned
:param[out]   pis_prime:   1 if prime, 0 otherwise
:param[out]   pfactor:     [optional] smallest divisor, or 0 on error
or if prime
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lept_isPrime(*args)
    
    

    try:
        leptonica.convertIntToGrayCode.argtypes = [ctypes.c_uint32]
        leptonica.convertIntToGrayCode.restype = ctypes.c_uint32
    except AttributeError:
        sys.stderr.write("Warning - function convertIntToGrayCode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertIntToGrayCode(*args):
        """
        ('l_uint32', 'val')       

:param[in]  val:    integer value
:returns:     corresponding gray code value

<pre>
Notes:
(1) Gray code values corresponding to integers differ by
only one bit transition between successive integers.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertIntToGrayCode(*args)
    
    

    try:
        leptonica.convertGrayCodeToInt.argtypes = [ctypes.c_uint32]
        leptonica.convertGrayCodeToInt.restype = ctypes.c_uint32
    except AttributeError:
        sys.stderr.write("Warning - function convertGrayCodeToInt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertGrayCodeToInt(*args):
        """
        ('l_uint32', 'val')       

:param[in]  val:    gray code value
:returns:     corresponding integer value


        """
        args = _convert_params(*args)
        
        return leptonica.convertGrayCodeToInt(*args)
    
    

    try:
        leptonica.getLeptonicaVersion.argtypes = []
        leptonica.getLeptonicaVersion.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function getLeptonicaVersion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getLeptonicaVersion(*args):
        """
               

Return: string of version number (e.g., 'leptonica-1.74.2')

Notes:
(1) The caller has responsibility to free the memory.


        """
        args = _convert_params(*args)
        
        return leptonica.getLeptonicaVersion(*args)
    
    

    try:
        leptonica.startTimer.argtypes = []
        leptonica.startTimer.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function startTimer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def startTimer(*args):
        """
               

Notes:
(1) These measure the cpu time elapsed between the two calls:
startTimer();
....
lept_stderr( "Elapsed time = %7.3f sec\n", stopTimer());


        """
        args = _convert_params(*args)
        
        return leptonica.startTimer(*args)
    
    

    try:
        leptonica.startTimerNested.argtypes = []
        leptonica.startTimerNested.restype = ctypes.c_void_p
    except AttributeError:
        sys.stderr.write("Warning - function startTimerNested not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def startTimerNested(*args):
        """
               

Example of usage:

L_TIMER  t1 = startTimerNested();
....
L_TIMER  t2 = startTimerNested();
....
lept_stderr( "Elapsed time 2 = %7.3f sec\n", stopTimerNested(t2));
....
lept_stderr( "Elapsed time 1 = %7.3f sec\n", stopTimerNested(t1));


        """
        args = _convert_params(*args)
        
        return leptonica.startTimerNested(*args)
    
    

    try:
        leptonica.l_getCurrentTime.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_getCurrentTime.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_getCurrentTime not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getCurrentTime(*args):
        """
        ('l_int32', '*sec')       
('l_int32', '*usec')       

:param[out]   sec:     [optional] in seconds since birth of Unix
:param[out]   usec:    [optional] in microseconds since birth of Unix
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_getCurrentTime(*args)
    
    

    try:
        leptonica.startWallTimer.argtypes = []
        leptonica.startWallTimer.restype = lambda address: L_WALLTIMER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function startWallTimer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def startWallTimer(*args):
        """
               

:returns:  walltimer-ptr

<pre>
Notes:
(1) These measure the wall clock time  elapsed between the two calls:
L_WALLTIMER *timer = startWallTimer();
....
lept_stderr( "Elapsed time = %f sec\n", stopWallTimer(&timer);
(2) Note that the timer object is destroyed by stopWallTimer().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.startWallTimer(*args)
    
    

    try:
        leptonica.stopWallTimer.argtypes = [ctypes.c_void_p]
        leptonica.stopWallTimer.restype = ctypes.c_float
    except AttributeError:
        sys.stderr.write("Warning - function stopWallTimer not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stopWallTimer(*args):
        """
        ('L_WALLTIMER', '**ptimer')       

:param[in,out]  ptimer:     walltimer pointer
:returns:  time wall time elapsed in seconds


        """
        args = _convert_params(*args)
        
        return leptonica.stopWallTimer(*args)
    
    

    try:
        leptonica.l_getFormattedDate.argtypes = []
        leptonica.l_getFormattedDate.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function l_getFormattedDate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getFormattedDate(*args):
        """
               

:returns:  formatted date string, or NULL on error

<pre>
Notes:
(1) This is used in pdf, in the form specified in section 3.8.2 of
http://partners.adobe.com/public/developer/en/pdf/PDFReference.pdf
(2) Contributed by Dave Bryan.  Works on all platforms.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_getFormattedDate(*args)
    




class utils2(object):
    """<pre>

------------------------------------------
This file has these utilities:
- safe string operations
- find/replace operations on strings
- read/write between file and memory
- multi-platform file and directory operations
- file name operations
------------------------------------------

Safe string procs
char      *stringNew()
l_int32    stringCopy()
l_int32    stringCopySegment()
l_int32    stringReplace()
l_int32    stringLength()
l_int32    stringCat()
char      *stringConcatNew()
char      *stringJoin()
l_int32    stringJoinIP()
char      *stringReverse()
char      *strtokSafe()
l_int32    stringSplitOnToken()

Find and replace string and array procs
l_int32    stringCheckForChars()
char      *stringRemoveChars()
char      *stringReplaceEachSubstr()
char      *stringReplaceSubstr()
L_DNA     *stringFindEachSubstr()
l_int32    stringFindSubstr()
l_uint8   *arrayReplaceEachSequence()
L_DNA     *arrayFindEachSequence()
l_int32    arrayFindSequence()

Safe realloc
void      *reallocNew()

Read and write between file and memory
l_uint8   *l_binaryRead()
l_uint8   *l_binaryReadStream()
l_uint8   *l_binaryReadSelect()
l_uint8   *l_binaryReadSelectStream()
l_int32    l_binaryWrite()
l_int32    nbytesInFile()
l_int32    fnbytesInFile()

Copy and compare in memory
l_uint8   *l_binaryCopy()
l_uint8   *l_binaryCompare()

File copy operations
l_int32    fileCopy()
l_int32    fileConcatenate()
l_int32    fileAppendString()

Multi-platform functions for opening file streams
FILE      *fopenReadStream()
FILE      *fopenWriteStream()
FILE      *fopenReadFromMemory()

Opening a windows tmpfile for writing
FILE      *fopenWriteWinTempfile()

Multi-platform functions that avoid C-runtime boundary crossing
with Windows DLLs
FILE      *lept_fopen()
l_int32    lept_fclose()
void      *lept_calloc()
void       lept_free()

Multi-platform file system operations in temp directories
l_int32    lept_mkdir()
l_int32    lept_rmdir()
l_int32    lept_direxists()
l_int32    lept_mv()
l_int32    lept_rm_match()
l_int32    lept_rm()
l_int32    lept_rmfile()
l_int32    lept_cp()

Special debug/test function for calling 'system'
void       callSystemDebug()

General file name operations
l_int32    splitPathAtDirectory()
l_int32    splitPathAtExtension()
char      *pathJoin()
char      *appendSubdirs()

Special file name operations
l_int32    convertSepCharsInPath()
char      *genPathname()
l_int32    makeTempDirname()
l_int32    modifyTrailingSlash()
char      *l_makeTempFilename()
l_int32    extractNumberFromFilename()


Notes on multi-platform development
-----------------------------------
This is important:
(1) With the exception of splitPathAtDirectory(), splitPathAtExtension()
and genPathname(), all input pathnames must have unix separators.
(2) On Windows, when you specify a read or write to "/tmp/...",
the filename is rewritten to use the Windows temp directory:
/tmp  ==>   [Temp]...    (windows)
(3) This filename rewrite, along with the conversion from unix
to windows pathnames, happens in genPathname().
(4) Use fopenReadStream() and fopenWriteStream() to open files,
because these use genPathname() to find the platform-dependent
filenames.  Likewise for l_binaryRead() and l_binaryWrite().
(5) For moving, copying and removing files and directories that are in
subdirectories of /tmp, use the lept_*() file system shell wrappers:
lept_mkdir(), lept_rmdir(), lept_mv(), lept_rm() and lept_cp().
(6) Use the lept_*() C library wrappers.  These work properly on
Windows, where the same DLL must perform complementary operations
on file streams (open/close) and heap memory (malloc/free):
lept_fopen(), lept_fclose(), lept_calloc() and lept_free().
(7) Why read and write files to temp directories?
The library needs the ability to read and write ephemeral
files to default places, both for generating debugging output
and for supporting regression tests.  Applications also need
this ability for debugging.
(8) Why do the pathname rewrite on Windows?
The goal is to have the library, and programs using the library,
run on multiple platforms without changes.  The location of
temporary files depends on the platform as well as the user's
configuration.  Temp files on Windows are in some directory
not known a priori.  To make everything work seamlessly on
Windows, every time you open a file for reading or writing,
use a special function such as fopenReadStream() or
fopenWriteStream(); these call genPathname() to ensure that
if it is a temp file, the correct path is used.  To indicate
that this is a temp file, the application is written with the
root directory of the path in a canonical form: "/tmp".
(9) Why is it that multi-platform directory functions like lept_mkdir()
and lept_rmdir(), as well as associated file functions like
lept_rm(), lept_mv() and lept_cp(), only work in the temp dir?
These functions were designed to provide easy manipulation of
temp files.  The restriction to temp files is for safety -- to
prevent an accidental deletion of important files.  For example,
lept_rmdir() first deletes all files in a specified subdirectory
of temp, and then removes the directory.

</pre>




"""
    
    try:
        leptonica.stringNew.argtypes = [ctypes.c_char_p]
        leptonica.stringNew.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringNew(*args):
        """
        ('const char', '*src')       

:param[in]    src:
:returns:  dest copy of %src string, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.stringNew(*args)
    
    

    try:
        leptonica.stringCopy.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.stringCopy.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function stringCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCopy(*args):
        """
        ('char', '*dest')       
('const char', '*src')       
('l_int32', 'n')       

:param[in]    dest:    existing byte buffer
:param[in]    src:     string [optional] can be null
:param[in]    n:       max number of characters to copy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Relatively safe wrapper for strncpy, that checks the input,
and does not complain if %src is null or %n < 1.
If %n < 1, this is a no-op.
(2) %dest needs to be at least %n bytes in size.
(3) We don't call strncpy() because valgrind complains about
use of uninitialized values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringCopy(*args)
    
    

    try:
        leptonica.stringCopySegment.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.stringCopySegment.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringCopySegment not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCopySegment(*args):
        """
        ('const char', '*src')       
('l_int32', 'start')       
('l_int32', 'nbytes')       


:param[in]    src:      string
:param[in]    start:    byte position at start of segment
:param[in]    nbytes:   number of bytes in the segment; use 0 to go to end
:returns:  copy of segment, or NULL on error

<pre>
Notes:
(1) This is a variant of stringNew() that makes a new string
from a segment of the input string.  The segment is specified
by the starting position and the number of bytes.
(2) The start location %start must be within the string %src.
(3) The copy is truncated to the end of the source string.
Use %nbytes = 0 to copy to the end of %src.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringCopySegment(*args)
    
    

    try:
        leptonica.stringReplace.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringReplace.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function stringReplace not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReplace(*args):
        """
        ('char', '**pdest')       
('const char', '*src')       

:param[out]   pdest:    string copy
:param[in]    src:      [optional] string; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Frees any existing dest string
(2) Puts a copy of src string in the dest
(3) If either or both strings are null, does something reasonable.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringReplace(*args)
    
    

    try:
        leptonica.stringLength.argtypes = [ctypes.c_char_p, ctypes.c_size_t]
        leptonica.stringLength.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function stringLength not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringLength(*args):
        """
        ('const char', '*src')       
('size_t', 'size')       

:param[in]    src:    string can be null or NULL-terminated string
:param[in]    size:   size of src buffer
:returns:  length of src in bytes.

<pre>
Notes:
(1) Safe implementation of strlen that only checks size bytes
for trailing NUL.
(2) Valid returned string lengths are between 0 and size - 1.
If size bytes are checked without finding a NUL byte, then
an error is indicated by returning size.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringLength(*args)
    
    

    try:
        leptonica.stringCat.argtypes = [ctypes.c_char_p, ctypes.c_size_t, ctypes.c_char_p]
        leptonica.stringCat.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function stringCat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCat(*args):
        """
        ('char', '*dest')       
('size_t', 'size')       
('const char', '*src')       

:param[in]    dest:    null-terminated byte buffer
:param[in]    size:    size of dest
:param[in]    src:     string can be null or NULL-terminated string
:returns:  number of bytes added to dest; -1 on error

<pre>
Notes:
(1) Alternative implementation of strncat, that checks the input,
is easier to use (since the size of the dest buffer is specified
rather than the number of bytes to copy), and does not complain
if %src is null.
(2) Never writes past end of dest.
(3) If there is not enough room to append the src, which is an error,
it does nothing.
(4) N.B. The order of 2nd and 3rd args is reversed from that in
strncat, as in the Windows function strcat_s().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringCat(*args)
    
    

    try:
        leptonica.stringJoin.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringJoin.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringJoin(*args):
        """
        ('const char', '*src1')       
('const char', '*src2')       

:param[in]    src1:    [optional] string; can be null
:param[in]    src2:    [optional] string; can be null
:returns:  concatenated string, or NULL on error

<pre>
Notes:
(1) This is a safe version of strcat; it makes a new string.
(2) It is not an error if either or both of the strings
are empty, or if either or both of the pointers are null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringJoin(*args)
    
    

    try:
        leptonica.stringJoinIP.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringJoinIP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function stringJoinIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringJoinIP(*args):
        """
        ('char', '**psrc1')       
('const char', '*src2')       

:param[in,out]  psrc1:   address of string src1; cannot be on the stack
:param[in]      src2:    [optional] string; can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is a safe in-place version of strcat.  The contents of
src1 is replaced by the concatenation of src1 and src2.
(2) It is not an error if either or both of the strings
are empty (""), or if the pointers to the strings (*psrc1, src2)
are null.
(3) src1 should be initialized to null or an empty string
before the first call.  Use one of these:
char *src1 = NULL;
char *src1 = stringNew("");
Then call with:
stringJoinIP(&src1, src2);
(4) This can also be implemented as a macro:
\code
#define stringJoinIP(src1, src2) \
{tmpstr = stringJoin((src1),(src2)); \
LEPT_FREE(src1); \
(src1) = tmpstr;}
\endcode
(5) Another function to consider for joining many strings is
stringConcatNew().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringJoinIP(*args)
    
    

    try:
        leptonica.stringReverse.argtypes = [ctypes.c_char_p]
        leptonica.stringReverse.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReverse(*args):
        """
        ('const char', '*src')       

:param[in]    src:    string
:returns:  dest newly-allocated reversed string


        """
        args = _convert_params(*args)
        
        return leptonica.stringReverse(*args)
    
    

    try:
        leptonica.strtokSafe.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.strtokSafe.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function strtokSafe not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def strtokSafe(*args):
        """
        ('char', '*cstr')       
('const char', '*seps')       
('char', '**psaveptr')       

:param[in]    cstr:      input string to be sequentially parsed;
use NULL after the first call
:param[in]    seps:      a string of character separators
:param[out]   psaveptr:  ptr to the next char after
the last encountered separator
:returns:  substr         a new string that is copied from the previous
saveptr up to but not including the next
separator character, or NULL if end of cstr.

<pre>
Notes:
(1) This is a thread-safe implementation of strtok.
(2) It has the same interface as strtok_r.
(3) It differs from strtok_r in usage in two respects:
(a) the input string is not altered
(b) each returned substring is newly allocated and must
be freed after use.
(4) Let me repeat that.  This is "safe" because the input
string is not altered and because each returned string
is newly allocated on the heap.
(5) It is here because, surprisingly, some C libraries don't
include strtok_r.
(6) Important usage points:
~ Input the string to be parsed on the first invocation.
~ Then input NULL after that; the value returned in saveptr
is used in all subsequent calls.
(7) This is only slightly slower than strtok_r.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.strtokSafe(*args)
    
    

    try:
        leptonica.stringSplitOnToken.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringSplitOnToken.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function stringSplitOnToken not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringSplitOnToken(*args):
        """
        ('char', '*cstr')       
('const char', '*seps')       
('char', '**phead')       
('char', '**ptail')       

:param[in]    cstr:     input string to be split; not altered
:param[in]    seps:     a string of character separators
:param[out]   phead:    ptr to copy of the input string, up to
the first separator token encountered
:param[out]   ptail:    ptr to copy of the part of the input string
starting with the first non-separator character
that occurs after the first separator is found
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The input string is not altered; all split parts are new strings.
(2) The split occurs around the first consecutive sequence of
tokens encountered.
(3) The head goes from the beginning of the string up to
but not including the first token found.
(4) The tail contains the second part of the string, starting
with the first char in that part that is NOT a token.
(5) If no separator token is found, 'head' contains a copy
of the input string and 'tail' is null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringSplitOnToken(*args)
    
    

    try:
        leptonica.stringCheckForChars.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.stringCheckForChars.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function stringCheckForChars not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCheckForChars(*args):
        """
        ('const char', '*src')       
('const char', '*chars')       
('l_int32', '*pfound')       

:param[in]    src:      input string; can be of zero length
:param[in]    chars:    string of chars to be searched for in %src
:param[out]   pfound:   1 if any characters are found; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This can be used to sanitize an operation by checking for
special characters that don't belong in a string.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringCheckForChars(*args)
    
    

    try:
        leptonica.stringRemoveChars.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringRemoveChars.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringRemoveChars not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringRemoveChars(*args):
        """
        ('const char', '*src')       
('const char', '*remchars')       

:param[in]    src:        input string; can be of zero length
:param[in]    remchars:   string of chars to be removed from src
:returns:  dest string with specified chars removed, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.stringRemoveChars(*args)
    
    

    try:
        leptonica.stringReplaceEachSubstr.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.stringReplaceEachSubstr.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringReplaceEachSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReplaceEachSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub1')       
('const char', '*sub2')       
('l_int32', '*pcount')       

:param[in]    src:      input string; can be of zero length
:param[in]    sub1:     substring to be replaced
:param[in]    sub2:     substring to put in; can be ""
:param[out]   pcount:   [optional] the number of times that sub1
is found in src; 0 if not found
:returns:  dest string with substring replaced, or NULL if the
substring not found or on error.

<pre>
Notes:
(1) This is a wrapper for simple string substitution that uses
the more general function arrayReplaceEachSequence().
(2) This finds every non-overlapping occurrence of %sub1 in
%src, and replaces it with %sub2.  By "non-overlapping"
we mean that after it finds each match, it removes the
matching characters, replaces with the substitution string
(if not empty), and continues.  For example, if you replace
'aa' by 'X' in 'baaabbb', you find one match at position 1
and return 'bXabbb'.
(3) To only remove each instance of sub1, use "" for sub2
(4) Returns a copy of %src if sub1 and sub2 are the same.
(5) If the input %src is binary data that can have null characters,
use arrayReplaceEachSequence() directly.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringReplaceEachSubstr(*args)
    
    

    try:
        leptonica.stringReplaceSubstr.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.stringReplaceSubstr.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function stringReplaceSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringReplaceSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub1')       
('const char', '*sub2')       
('l_int32', '*ploc')       
('l_int32', '*pfound')       

:param[in]      src:      input string; can be of zero length
:param[in]      sub1:     substring to be replaced
:param[in]      sub2:     substring to put in; can be ""
:param[in,out]  ploc:     [optional] input start location for search;
returns the loc after replacement
:param[out]     pfound:   [optional] 1 if sub1 is found; 0 otherwise
:returns:  dest string with substring replaced, or NULL on error.

<pre>
Notes:
(1) Replaces the first instance.
(2) To remove sub1 without replacement, use "" for sub2.
(3) Returns a copy of %src if either no instance of %sub1 is found,
or if %sub1 and %sub2 are the same.
(4) If %ploc == NULL, the search will start at the beginning of %src.
If %ploc != NULL, *ploc must be initialized to the byte offset
within %src from which the search starts.  To search the
string from the beginning, set %loc = 0 and input &loc.
After finding %sub1 and replacing it with %sub2, %loc will be
returned as the next position after %sub2 in the output string.
(5) Note that the output string also includes all the characters
from the input string that occur after the single substitution.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringReplaceSubstr(*args)
    
    

    try:
        leptonica.stringFindEachSubstr.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringFindEachSubstr.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function stringFindEachSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringFindEachSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub')       

:param[in]    src:        input string; can be of zero length
:param[in]    sub:        substring to be searched for
:returns:  dna of offsets where the sequence is found, or NULL if
none are found or on error

<pre>
Notes:
(1) This finds every non-overlapping occurrence in %src of %sub.
After it finds each match, it moves forward in %src by the length
of %sub before continuing the search.  So for example,
if you search for the sequence 'aa' in the data 'baaabbb',
you find one match at position 1.

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringFindEachSubstr(*args)
    
    

    try:
        leptonica.stringFindSubstr.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.stringFindSubstr.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function stringFindSubstr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringFindSubstr(*args):
        """
        ('const char', '*src')       
('const char', '*sub')       
('l_int32', '*ploc')       

:param[in]    src:     input string; can be of zero length
:param[in]    sub:     substring to be searched for; must not be empty
:param[out]   ploc:    [optional] location of substring in src
:returns:  1 if found; 0 if not found or on error

<pre>
Notes:
(1) This is a wrapper around strstr().  It finds the first
instance of %sub in %src.  If the substring is not found
and the location is returned, it has the value -1.
(2) Both %src and %sub must be defined, and %sub must have
length of at least 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringFindSubstr(*args)
    
    

    try:
        leptonica.arrayReplaceEachSequence.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.arrayReplaceEachSequence.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function arrayReplaceEachSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def arrayReplaceEachSequence(*args):
        """
        ('const l_uint8', '*datas')       
('size_t', 'dataslen')       
('const l_uint8', '*seq')       
('size_t', 'seqlen')       
('const l_uint8', '*newseq')       
('size_t', 'newseqlen')       
('size_t', '*pdatadlen')       
('l_int32', '*pcount')       

:param[in]    datas:       source byte array
:param[in]    dataslen:    length of source data, in bytes
:param[in]    seq:         subarray of bytes to find in source data
:param[in]    seqlen:      length of subarray, in bytes
:param[in]    newseq:      replacement subarray; can be null
:param[in]    newseqlen:   length of replacement subarray, in bytes
:param[out]   pdatadlen:   length of dest byte array, in bytes
:param[out]   pcount:      [optional] the number of times that sub1
is found in src; 0 if not found
:returns:  datad   with all all subarrays replaced (or removed)

<pre>
Notes:
(1) The byte arrays %datas, %seq and %newseq are not C strings,
because they can contain null bytes.  Therefore, for each
we must give the length of the array.
(2) If %newseq == NULL, this just removes all instances of %seq.
Otherwise, it replaces every non-overlapping occurrence of
%seq in %datas with %newseq. A new array %datad and its
size are returned.  See arrayFindEachSequence() for more
details on finding non-overlapping occurrences.
(3) If no instances of %seq are found, this returns a copy of %datas.
(4) The returned %datad is null terminated.
(5) Can use stringReplaceEachSubstr() if using C strings.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.arrayReplaceEachSequence(*args)
    
    

    try:
        leptonica.arrayFindEachSequence.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.arrayFindEachSequence.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function arrayFindEachSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def arrayFindEachSequence(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'datalen')       
('const l_uint8', '*sequence')       
('size_t', 'seqlen')       

:param[in]    data:       byte array
:param[in]    datalen:    length of data, in bytes
:param[in]    sequence:   subarray of bytes to find in data
:param[in]    seqlen:     length of sequence, in bytes
:returns:  dna of offsets where the sequence is found, or NULL if
none are found or on error

<pre>
Notes:
(1) The byte arrays %data and %sequence are not C strings,
because they can contain null bytes.  Therefore, for each
we must give the length of the array.
(2) This finds every non-overlapping occurrence in %data of %sequence.
After it finds each match, it moves forward by the length
of the sequence before continuing the search.  So for example,
if you search for the sequence 'aa' in the data 'baaabbb',
you find one match at position 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.arrayFindEachSequence(*args)
    
    

    try:
        leptonica.arrayFindSequence.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.arrayFindSequence.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function arrayFindSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def arrayFindSequence(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'datalen')       
('const l_uint8', '*sequence')       
('size_t', 'seqlen')       
('l_int32', '*poffset')       
('l_int32', '*pfound')       

:param[in]    data:       byte array
:param[in]    datalen:    length of data, in bytes
:param[in]    sequence:   subarray of bytes to find in data
:param[in]    seqlen:     length of sequence, in bytes
:param[out]   poffset:    offset from beginning of
data where the sequence begins
:param[out]   pfound:     1 if sequence is found; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The byte arrays 'data' and 'sequence' are not C strings,
because they can contain null bytes.  Therefore, for each
we must give the length of the array.
(2) This searches for the first occurrence in %data of %sequence,
which consists of %seqlen bytes.  The parameter %seqlen
must not exceed the actual length of the %sequence byte array.
(3) If the sequence is not found, the offset will be 0, so you
must check %found.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.arrayFindSequence(*args)
    
    

    try:
        leptonica.reallocNew.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]
        leptonica.reallocNew.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function reallocNew not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def reallocNew(*args):
        """
        ('void', '**pindata')       
('size_t', 'oldsize')       
('size_t', 'newsize')       

:param[in,out]  pindata:    nulls indata before reallocing
:param[in]      oldsize:    size of input data to be copied, in bytes
:param[in]      newsize:    size of buffer to be reallocated in bytes
:returns:  ptr to new data, or NULL on error

Action: !N.B. 3) and (4!
1 Allocates memory, initialized to 0
2 Copies as much of the input data as possible
to the new block, truncating the copy if necessary
3 Frees the input data
4 Zeroes the input data ptr

<pre>
Notes:
(1) If newsize == 0, frees input data and nulls ptr
(2) If input data is null, only callocs new memory
(3) This differs from realloc in that it always allocates
new memory (if newsize > 0) and initializes it to 0,
it requires the amount of old data to be copied,
and it takes the address of the input ptr and
nulls the handle.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.reallocNew(*args)
    
    

    try:
        leptonica.l_binaryRead.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.l_binaryRead.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_binaryRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryRead(*args):
        """
        ('const char', '*filename')       
('size_t', '*pnbytes')       

:param[in]    filename:
:param[out]   pnbytes:    number of bytes read
:returns:  data, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryRead(*args)
    
    

    try:
        leptonica.l_binaryReadStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_binaryReadStream.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_binaryReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryReadStream(*args):
        """
        ('FILE', '*fp')       
('size_t', '*pnbytes')       

:param[in]    fp:        file stream opened to read; can be stdin
:param[out]   pnbytes:   number of bytes read
:returns:  null-terminated array, or NULL on error; reading 0 bytes
is not an error

<pre>
Notes:
(1) The returned array is terminated with a null byte so that it can
be used to read ascii data from a file into a proper C string.
(2) This can be used to capture data that is piped in via stdin,
because it does not require seeking within the file.
(3) For example, you can read an image from stdin into memory
using shell redirection, with one of these shell commands:
\code
cat <imagefile> | readprog
readprog < <imagefile>
\endcode
where readprog is:
\code
l_uint8 *data = l_binaryReadStream(stdin, &nbytes);
Pix *pix = pixReadMem(data, nbytes);
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryReadStream(*args)
    
    

    try:
        leptonica.l_binaryReadSelect.argtypes = [ctypes.c_char_p, ctypes.c_size_t, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.l_binaryReadSelect.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_binaryReadSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryReadSelect(*args):
        """
        ('const char', '*filename')       
('size_t', 'start')       
('size_t', 'nbytes')       
('size_t', '*pnread')       

:param[in]    filename:
:param[in]    start:     first byte to read
:param[in]    nbytes:    number of bytes to read; use 0 to read to end of file
:param[out]   pnread:    number of bytes actually read
:returns:  data, or NULL on error

<pre>
Notes:
(1) The returned array is terminated with a null byte so that it can
be used to read ascii data from a file into a proper C string.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryReadSelect(*args)
    
    

    try:
        leptonica.l_binaryReadSelectStream.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.l_binaryReadSelectStream.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_binaryReadSelectStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryReadSelectStream(*args):
        """
        ('FILE', '*fp')       
('size_t', 'start')       
('size_t', 'nbytes')       
('size_t', '*pnread')       

:param[in]    fp:       file stream
:param[in]    start:    first byte to read
:param[in]    nbytes:   number of bytes to read; use 0 to read to end of file
:param[out]   pnread:   number of bytes actually read
:returns:  null-terminated array, or NULL on error; reading 0 bytes
is not an error

<pre>
Notes:
(1) The returned array is terminated with a null byte so that it can
be used to read ascii data from a file into a proper C string.
If the file to be read is empty and %start == 0, an array
with a single null byte is returned.
(2) Side effect: the stream pointer is re-positioned to the
beginning of the file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryReadSelectStream(*args)
    
    

    try:
        leptonica.l_binaryWrite.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.l_binaryWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_binaryWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryWrite(*args):
        """
        ('const char', '*filename')       
('const char', '*operation')       
('const void', '*data')       
('size_t', 'nbytes')       

:param[in]    filename:     output file
:param[in]    operation:    "w" for write; "a" for append
:param[in]    data:         binary data to be written
:param[in]    nbytes:       size of data array
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryWrite(*args)
    
    

    try:
        leptonica.nbytesInFile.argtypes = [ctypes.c_char_p]
        leptonica.nbytesInFile.restype = ctypes.c_size_t
    except AttributeError:
        sys.stderr.write("Warning - function nbytesInFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def nbytesInFile(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  nbytes in file; 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.nbytesInFile(*args)
    
    

    try:
        leptonica.fnbytesInFile.argtypes = [ctypes.c_void_p]
        leptonica.fnbytesInFile.restype = ctypes.c_size_t
    except AttributeError:
        sys.stderr.write("Warning - function fnbytesInFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fnbytesInFile(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  nbytes in file; 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fnbytesInFile(*args)
    
    

    try:
        leptonica.l_binaryCopy.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.l_binaryCopy.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_binaryCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_binaryCopy(*args):
        """
        ('const l_uint8', '*datas')       
('size_t', 'size')       

:param[in]    datas:
:param[in]    size:    of data array
:returns:  datad on heap, or NULL on error

<pre>
Notes:
(1) We add 4 bytes to the zeroed output because in some cases
(e.g., string handling) it is important to have the data
be null terminated.  This guarantees that after the memcpy,
the result is automatically null terminated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_binaryCopy(*args)
    
    

    try:
        leptonica.fileCopy.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.fileCopy.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fileCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileCopy(*args):
        """
        ('const char', '*srcfile')       
('const char', '*newfile')       

:param[in]    srcfile:   copy from this file
:param[in]    newfile:   copy to this file
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileCopy(*args)
    
    

    try:
        leptonica.fileConcatenate.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.fileConcatenate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fileConcatenate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileConcatenate(*args):
        """
        ('const char', '*srcfile')       
('const char', '*destfile')       

:param[in]    srcfile:   append data from this file
:param[in]    destfile:  add data to this file
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileConcatenate(*args)
    
    

    try:
        leptonica.fileAppendString.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.fileAppendString.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fileAppendString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fileAppendString(*args):
        """
        ('const char', '*filename')       
('const char', '*str')       

:param[in]    filename:
:param[in]    str:       string to append to file
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.fileAppendString(*args)
    
    

    try:
        leptonica.fopenReadStream.argtypes = [ctypes.c_char_p]
        leptonica.fopenReadStream.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function fopenReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fopenReadStream(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  stream, or NULL on error

<pre>
Notes:
(1) This should be used whenever you want to run fopen() to
read from a stream.  Never call fopen() directory.
(2) This handles the temp directory pathname conversion on windows:
/tmp  ==>  [Windows Temp directory]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fopenReadStream(*args)
    
    

    try:
        leptonica.fopenWriteStream.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.fopenWriteStream.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function fopenWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fopenWriteStream(*args):
        """
        ('const char', '*filename')       
('const char', '*modestring')       

:param[in]    filename:
:param[in]    modestring:
:returns:  stream, or NULL on error

<pre>
Notes:
(1) This should be used whenever you want to run fopen() to
write or append to a stream.  Never call fopen() directory.
(2) This handles the temp directory pathname conversion on windows:
/tmp  ==>  [Windows Temp directory]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fopenWriteStream(*args)
    
    

    try:
        leptonica.fopenReadFromMemory.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.fopenReadFromMemory.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function fopenReadFromMemory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fopenReadFromMemory(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data,: size
:returns:  file stream, or NULL on error

<pre>
Notes:
(1) Work-around if fmemopen() not available.
(2) Windows tmpfile() writes into the root C:\ directory, which
requires admin privileges.  This also works around that.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fopenReadFromMemory(*args)
    
    

    try:
        leptonica.fopenWriteWinTempfile.argtypes = []
        leptonica.fopenWriteWinTempfile.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function fopenWriteWinTempfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fopenWriteWinTempfile(*args):
        """
               

:returns:  file stream, or NULL on error

<pre>
Notes:
(1) The Windows version of tmpfile() writes into the root
C:\ directory, which requires admin privileges.  This
function provides an alternative implementation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fopenWriteWinTempfile(*args)
    
    

    try:
        leptonica.lept_fopen.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.lept_fopen.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function lept_fopen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_fopen(*args):
        """
        ('const char', '*filename')       
('const char', '*mode')       

:param[in]    filename:
:param[in]    mode:       same as for fopen(); e.g., "rb"
:returns:  stream or NULL on error

<pre>
Notes:
(1) This must be used by any application that passes
a file handle to a leptonica Windows DLL.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_fopen(*args)
    
    

    try:
        leptonica.lept_fclose.argtypes = [ctypes.c_void_p]
        leptonica.lept_fclose.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lept_fclose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_fclose(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This should be used by any application that accepts
a file handle generated by a leptonica Windows DLL.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_fclose(*args)
    
    

    try:
        leptonica.lept_calloc.argtypes = [ctypes.c_size_t, ctypes.c_size_t]
        leptonica.lept_calloc.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function lept_calloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_calloc(*args):
        """
        ('size_t', 'nmemb')       
('size_t', 'size')       

:param[in]    nmemb:    number of members
:param[in]    size:     of each member
:returns:  void ptr, or NULL on error

<pre>
Notes:
(1) For safety with windows DLLs, this can be used in conjunction
with lept_free() to avoid C-runtime boundary problems.
Just use these two functions throughout your application.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_calloc(*args)
    
    

    try:
        leptonica.lept_free.argtypes = [ctypes.c_void_p]
        leptonica.lept_free.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function lept_free not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_free(*args):
        """
        ('void', '*ptr')       

:param[in]    ptr:

<pre>
Notes:
(1) This should be used by any application that accepts
heap data allocated by a leptonica Windows DLL.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_free(*args)
    
    

    try:
        leptonica.lept_mkdir.argtypes = [ctypes.c_char_p]
        leptonica.lept_mkdir.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_mkdir not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_mkdir(*args):
        """
        ('const char', '*subdir')       

:param[in]    subdir:    of /tmp or its equivalent on Windows
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) %subdir is a partial path that can consist of one or more
directories.
(2) This makes any subdirectories of /tmp that are required.
(3) The root temp directory is:
/tmp    (unix)  [default]
[Temp]  (windows)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_mkdir(*args)
    
    

    try:
        leptonica.lept_rmdir.argtypes = [ctypes.c_char_p]
        leptonica.lept_rmdir.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_rmdir not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rmdir(*args):
        """
        ('const char', '*subdir')       

:param[in]    subdir:    of /tmp or its equivalent on Windows
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) %subdir is a partial path that can consist of one or more
directories.
(2) This removes all files from the specified subdirectory of
the root temp directory:
/tmp    (unix)
[Temp]  (windows)
and then removes the subdirectory.
(3) The combination
lept_rmdir(subdir);
lept_mkdir(subdir);
is guaranteed to give you an empty subdirectory.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rmdir(*args)
    
    

    try:
        leptonica.lept_direxists.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.lept_direxists.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function lept_direxists not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_direxists(*args):
        """
        ('const char', '*dir')       
('l_int32', '*pexists')       

:param[in]    dir:
:param[out]   pexists:    1 if it exists; 0 otherwise
:returns:  void

<pre>
Notes:
(1) Always use unix pathname separators.
(2) By calling genPathname(), if the pathname begins with "/tmp"
this does an automatic directory translation on windows
to a path in the windows [Temp] directory:
"/tmp"  ==>  [Temp] (windows)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_direxists(*args)
    
    

    try:
        leptonica.lept_rm_match.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.lept_rm_match.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_rm_match not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rm_match(*args):
        """
        ('const char', '*subdir')       
('const char', '*substr')       

:param[in]    subdir:    [optional] if NULL, the removed files are in /tmp
:param[in]    substr:    [optional] pattern to match in filename
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) This removes the matched files in /tmp or a subdirectory of /tmp.
Use NULL for %subdir if the files are in /tmp.
(2) If %substr == NULL, this removes all files in the directory.
If %substr == "" (empty), this removes no files.
If both %subdir == NULL and %substr == NULL, this removes
all files in /tmp.
(3) Use unix pathname separators.
(4) By calling genPathname(), if the pathname begins with "/tmp"
this does an automatic directory translation on windows
to a path in the windows [Temp] directory:
"/tmp"  ==>  [Temp] (windows)
(5) Error conditions:
returns -1 if the directory is not found
returns the number of files (> 0) that it was unable to remove.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rm_match(*args)
    
    

    try:
        leptonica.lept_rm.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.lept_rm.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_rm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rm(*args):
        """
        ('const char', '*subdir')       
('const char', '*tail')       

:param[in]    subdir:    [optional] subdir of '/tmp'; can be NULL
:param[in]    tail:      filename without the directory
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) By calling genPathname(), this does an automatic directory
translation on windows to a path in the windows [Temp] directory:
"/tmp/..."  ==>  [Temp]/... (windows)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rm(*args)
    
    

    try:
        leptonica.lept_rmfile.argtypes = [ctypes.c_char_p]
        leptonica.lept_rmfile.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_rmfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_rmfile(*args):
        """
        ('const char', '*filepath')       

lept_rmfile()

:param[in]    filepath:     full path to file including the directory
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) This removes the named file.
(2) Use unix pathname separators.
(3) There is no name translation.
(4) Unlike the other lept_* functions in this section, this can remove
any file -- it is not restricted to files that are in /tmp or a
subdirectory of it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_rmfile(*args)
    
    

    try:
        leptonica.lept_mv.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.lept_mv.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_mv not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_mv(*args):
        """
        ('const char', '*srcfile')       
('const char', '*newdir')       
('const char', '*newtail')       
('char', '**pnewpath')       

:param[in]    srcfile:
:param[in]    newdir:     [optional]; can be NULL
:param[in]    newtail:    [optional]; can be NULL
:param[out]   pnewpath:   [optional] of actual path; can be NULL
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) This moves %srcfile to /tmp or to a subdirectory of /tmp.
(2) %srcfile can either be a full path or relative to the
current directory.
(3) %newdir can either specify an existing subdirectory of /tmp
or can be NULL.  In the latter case, the file will be written
into /tmp.
(4) %newtail can either specify a filename tail or, if NULL,
the filename is taken from src-tail, the tail of %srcfile.
(5) For debugging, the computed newpath can be returned.  It must
be freed by the caller.
(6) Reminders:
(a) specify files using unix pathnames
(b) for windows, translates
/tmp  ==>  [Temp]
where [Temp] is the windows temp directory
(7) Examples:
newdir = NULL,    newtail = NULL    ==> /tmp/src-tail
newdir = NULL,    newtail = abc     ==> /tmp/abc
newdir = def/ghi, newtail = NULL    ==> /tmp/def/ghi/src-tail
newdir = def/ghi, newtail = abc     ==> /tmp/def/ghi/abc
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_mv(*args)
    
    

    try:
        leptonica.lept_cp.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.lept_cp.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lept_cp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lept_cp(*args):
        """
        ('const char', '*srcfile')       
('const char', '*newdir')       
('const char', '*newtail')       
('char', '**pnewpath')       

:param[in]    srcfile:
:param[in]    newdir:    [optional]; can be NULL
:param[in]    newtail:   [optional]; can be NULL
:param[out]   pnewpath:  [optional] of actual path; can be NULL
:returns:  0 on success, non-zero on failure

<pre>
Notes:
(1) This copies %srcfile to /tmp or to a subdirectory of /tmp.
(2) %srcfile can either be a full path or relative to the
current directory.
(3) %newdir can either specify an existing subdirectory of /tmp,
or can be NULL.  In the latter case, the file will be written
into /tmp.
(4) %newtail can either specify a filename tail or, if NULL,
the filename is taken from src-tail, the tail of %srcfile.
(5) For debugging, the computed newpath can be returned.  It must
be freed by the caller.
(6) Reminders:
(a) specify files using unix pathnames
(b) for windows, translates
/tmp  ==>  [Temp]
where [Temp] is the windows temp directory
(7) Examples:
newdir = NULL,    newtail = NULL    ==> /tmp/src-tail
newdir = NULL,    newtail = abc     ==> /tmp/abc
newdir = def/ghi, newtail = NULL    ==> /tmp/def/ghi/src-tail
newdir = def/ghi, newtail = abc     ==> /tmp/def/ghi/abc

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lept_cp(*args)
    
    

    try:
        leptonica.callSystemDebug.argtypes = [ctypes.c_char_p]
        leptonica.callSystemDebug.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function callSystemDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def callSystemDebug(*args):
        """
        ('const char', '*cmd')       

:param[in]    cmd:      command to be exec'd
:returns:  void

<pre>
Notes:
(1) The C library 'system' call is only made through this function.
It only works in debug/test mode, where the global variable
LeptDebugOK == TRUE.  This variable is set to FALSE in the
library as distributed, and calling this function will
generate an error message.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.callSystemDebug(*args)
    
    

    try:
        leptonica.splitPathAtDirectory.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.splitPathAtDirectory.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function splitPathAtDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def splitPathAtDirectory(*args):
        """
        ('const char', '*pathname')       
('char', '**pdir')       
('char', '**ptail')       

:param[in]    pathname:  full path; can be a directory
:param[out]   pdir:      [optional] root directory name of
input path, including trailing '/'
:param[out]   ptail:     [optional] path tail, which is either
the file name within the root directory or
the last sub-directory in the path
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If you only want the tail, input null for the root directory ptr.
(2) If you only want the root directory name, input null for the
tail ptr.
(3) This function makes decisions based only on the lexical
structure of the input.  Examples:
/usr/tmp/abc.d  -->  dir: /usr/tmp/       tail: abc.d
/usr/tmp/       -->  dir: /usr/tmp/       tail: [empty string]
/usr/tmp        -->  dir: /usr/           tail: tmp
abc.d           -->  dir: [empty string]  tail: abc.d
(4  Consider the first example above: /usr/tmp/abc.d.
Suppose you want the stem of the file, abc, without either
the directory or the extension.  This can be extracted in two steps:
splitPathAtDirectory("usr/tmp/abc.d", NULL, &tail);
[sets tail: "abc.d"]
splitPathAtExtension(tail, &basename, NULL);
[sets basename: "abc"]
(5) The input can have either forward (unix) or backward (win)
slash separators.  The output has unix separators.
Note that Win32 pathname functions generally accept both
slash forms, but the windows command line interpreter
only accepts backward slashes, because forward slashes are
used to demarcate switches (vs. dashes in unix).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.splitPathAtDirectory(*args)
    
    

    try:
        leptonica.splitPathAtExtension.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.splitPathAtExtension.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function splitPathAtExtension not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def splitPathAtExtension(*args):
        """
        ('const char', '*pathname')       
('char', '**pbasename')       
('char', '**pextension')       

:param[in]    pathname:    full path; can be a directory
:param[out]   pbasename:   [optional] pathname not including the
last dot and characters after that
:param[out]   pextension:  [optional] path extension, which is
the last dot and the characters after it.  If
there is no extension, it returns the empty string
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If you only want the extension, input null for the basename ptr.
(2) If you only want the basename without extension, input null
for the extension ptr.
(3) This function makes decisions based only on the lexical
structure of the input.  Examples:
/usr/tmp/abc.jpg  -->  basename: /usr/tmp/abc    ext: .jpg
/usr/tmp/.jpg     -->  basename: /usr/tmp/       ext: .jpg
/usr/tmp.jpg/     -->  basename: /usr/tmp.jpg/   ext: [empty str]
./.jpg            -->  basename: ./              ext: .jpg
(4) The input can have either forward (unix) or backward (win)
slash separators.  The output has unix separators.
(5) Note that basename, as used here, is different from the result
of the unix program 'basename'.  Here, basename is the entire
pathname up to a final extension and its preceding dot.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.splitPathAtExtension(*args)
    
    

    try:
        leptonica.pathJoin.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.pathJoin.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function pathJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pathJoin(*args):
        """
        ('const char', '*dir')       
('const char', '*fname')       

:param[in]    dir:     [optional] can be null
:param[in]    fname:   [optional] can be null
:returns:  specially concatenated path, or NULL on error

<pre>
Notes:
(1) Use unix-style pathname separators ('/').
(2) %fname can be the entire path, or part of the path containing
at least one directory, or a tail without a directory, or NULL.
(3) It produces a path that strips multiple slashes to a single
slash, joins %dir and %fname by a slash, and has no trailing
slashes (except in the cases where %dir == "/" and
%fname == NULL, or v.v.).
(4) If both %dir and %fname are null, produces an empty string.
(5) Neither %dir nor %fname can begin with '..'.
(6) The result is not canonicalized or tested for correctness:
garbage in (e.g., /&%), garbage out.
(7) Examples:
//tmp// + //abc/  -->  /tmp/abc
tmp/ + /abc/      -->  tmp/abc
tmp/ + abc/       -->  tmp/abc
/tmp/ + ///       -->  /tmp
/tmp/ + NULL      -->  /tmp
// + /abc//       -->  /abc
// + NULL         -->  /
NULL + /abc/def/  -->  /abc/def
NULL + abc//      -->  abc
NULL + //         -->  /
NULL + NULL       -->  (empty string)
"" + ""           -->  (empty string)
"" + /            -->  /
".." + /etc/foo   -->  NULL
/tmp + ".."       -->  NULL
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pathJoin(*args)
    
    

    try:
        leptonica.appendSubdirs.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.appendSubdirs.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function appendSubdirs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def appendSubdirs(*args):
        """
        ('const char', '*basedir')       
('const char', '*subdirs')       

:param[in]    basedir:
:param[in]    subdirs:
:returns:  concatenated full directory path without trailing slash,
or NULL on error

<pre>
Notes:
(1) Use unix pathname separators
(2) Allocates a new string:  [basedir]/[subdirs]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.appendSubdirs(*args)
    
    

    try:
        leptonica.convertSepCharsInPath.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.convertSepCharsInPath.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertSepCharsInPath not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertSepCharsInPath(*args):
        """
        ('char', '*path')       
('l_int32', 'type')       

:param[in]    path:
:param[in]    type:    UNIX_PATH_SEPCHAR, WIN_PATH_SEPCHAR
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place conversion.
(2) Type is the resulting type:
UNIX_PATH_SEPCHAR:  '\\' ==> '/'
WIN_PATH_SEPCHAR:   '/' ==> '\\'
(3) Virtually all path operations in leptonica use unix separators.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertSepCharsInPath(*args)
    
    

    try:
        leptonica.genPathname.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.genPathname.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function genPathname not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def genPathname(*args):
        """
        ('const char', '*dir')       
('const char', '*fname')       

:param[in]    dir:     [optional] directory or full path name,
with or without the trailing '/'
:param[in]    fname:   [optional] file name within a directory
:returns:  pathname either a directory or full path, or NULL on error

<pre>
Notes:
(1) This function generates actual paths in the following ways:
from two sub-parts (e.g., a directory and a file name).
from a single path full path, placed in %dir, with
%fname == NULL.
from the name of a file in the local directory placed in
%fname, with %dir == NULL.
if in a "/tmp" directory and on windows, the windows
temp directory is used.
(2) On windows, if the root of %dir is '/tmp', this does a name
translation:
"/tmp"  ==>  [Temp] (windows)
where [Temp] is the windows temp directory.
(3) On unix, the TMPDIR variable is ignored.  No rewriting
of temp directories is permitted.
(4) There are four cases for the input:
(a) %dir is a directory and %fname is defined: result is a full path
(b) %dir is a directory and %fname is null: result is a directory
(c) %dir is a full path and %fname is null: result is a full path
(d) %dir is null or an empty string: start in the current dir;
result is a full path
(5) In all cases, the resulting pathname is not terminated with a slash
(6) The caller is responsible for freeing the returned pathname.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.genPathname(*args)
    
    

    try:
        leptonica.makeTempDirname.argtypes = [ctypes.c_char_p, ctypes.c_size_t, ctypes.c_char_p]
        leptonica.makeTempDirname.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function makeTempDirname not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeTempDirname(*args):
        """
        ('char', '*result')       
('size_t', 'nbytes')       
('const char', '*subdir')       

:param[in]    result:    preallocated on stack or heap and passed in
:param[in]    nbytes:    size of %result array, in bytes
:param[in]    subdir:    [optional]; can be NULL or an empty string
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates the directory path for output temp files,
written into %result with unix separators.
(2) Caller allocates %result, large enough to hold the path,
which is:
/tmp/%subdir       (unix)
[Temp]/%subdir     (windows, mac, ios)
where [Temp] is a path determined
- on windows, mac: by GetTempPath()
- on ios: by confstr() (see man page)
and %subdir is in general a set of nested subdirectories:
dir1/dir2/.../dirN
which in use would not typically exceed 2 levels.
(3) Usage example:
\code
char  result[256];
makeTempDirname(result, sizeof(result), "lept/golden");
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeTempDirname(*args)
    
    

    try:
        leptonica.modifyTrailingSlash.argtypes = [ctypes.c_char_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.modifyTrailingSlash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function modifyTrailingSlash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def modifyTrailingSlash(*args):
        """
        ('char', '*path')       
('size_t', 'nbytes')       
('l_int32', 'flag')       

:param[in]    path:     preallocated on stack or heap and passed in
:param[in]    nbytes:   size of %path array, in bytes
:param[in]    flag:     L_ADD_TRAIL_SLASH or L_REMOVE_TRAIL_SLASH
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This carries out the requested action if necessary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.modifyTrailingSlash(*args)
    
    

    try:
        leptonica.l_makeTempFilename.argtypes = []
        leptonica.l_makeTempFilename.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function l_makeTempFilename not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_makeTempFilename(*args):
        """
               

:returns:  fname : heap allocated filename; returns NULL on failure.

<pre>
Notes:
(1) On unix, this makes a filename of the form
"/tmp/lept.XXXXXX",
where each X is a random character.
(2) On windows, this makes a filename of the form
"/[Temp]/lp.XXXXXX".
(3) On all systems, this fails if the file is not writable.
(4) Safest usage is to write to a subdirectory in debug code.
(5) The returned filename must be freed by the caller, using lept_free.
(6) The tail of the filename has a '.', so that cygwin interprets
the file as having an extension.  Otherwise, cygwin assumes it
is an executable and appends ".exe" to the filename.
(7) On unix, whenever possible use tmpfile() instead.  tmpfile()
hides the file name, returns a stream opened for write,
and deletes the temp file when the stream is closed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_makeTempFilename(*args)
    
    

    try:
        leptonica.extractNumberFromFilename.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.extractNumberFromFilename.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function extractNumberFromFilename not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def extractNumberFromFilename(*args):
        """
        ('const char', '*fname')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       

:param[in]    fname:
:param[in]    numpre:    number of characters before the digits to be found
:param[in]    numpost:   number of characters after the digits to be found
:returns:  num number embedded in the filename; -1 on error or if
not found

<pre>
Notes:
(1) The number is to be found in the basename, which is the
filename without either the directory or the last extension.
(2) When a number is found, it is non-negative.  If no number
is found, this returns -1, without an error message.  The
caller needs to check.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.extractNumberFromFilename(*args)
    




class heap(object):
    """<pre>

Create/Destroy L_Heap
L_HEAP         *lheapCreate()
void            lheapDestroy()

Operations to add/remove to/from the heap
l_int32         lheapAdd()
static l_int32  lheapExtendArray()
void           *lheapRemove()

Other accessors
l_int32         lheapGetCount()
void           *lheapGetElement()

Heap sort
l_int32         lheapSort()
l_int32         lheapSortStrictOrder()

Low-level heap operations
static l_int32  lheapSwapUp()
static l_int32  lheapSwapDown()

Debug output
l_int32         lheapPrint()

The L_Heap is useful to implement a priority queue, that is sorted
on a key in each element of the heap.  The heap is an array
of nearly arbitrary structs, with a l_float32 the first field.
This field is the key on which the heap is sorted.

Internally, we keep track of the heap size, n.  The item at the
root of the heap is at the head of the array.  Items are removed
from the head of the array and added to the end of the array.
When an item is removed from the head, the item at the end
of the array is moved to the head.  When items are either
added or removed, it is usually necessary to swap array items
to restore the heap order.  It is guaranteed that the number
of swaps does not exceed log(n).

--------------------------  N.B.  ------------------------------
The items on the heap (or, equivalently, in the array) are cast
to void*.  Their key is a l_float32, and it is REQUIRED that the
key be the first field in the struct.  That allows us to get the
key by simply dereferencing the struct.  Alternatively, we could
choose (but don't) to pass an application-specific comparison
function into the heap operation functions.
--------------------------  N.B.  ------------------------------
</pre>




"""
    
    try:
        leptonica.lheapCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.lheapCreate.restype = lambda address: L_HEAP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function lheapCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapCreate(*args):
        """
        ('l_int32', 'n')       
('l_int32', 'direction')       

:param[in]    n:           size of ptr array to be alloc'd; use 0 for default
:param[in]    direction:   L_SORT_INCREASING, L_SORT_DECREASING
:returns:  lheap, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapCreate(*args)
    
    

    try:
        leptonica.lheapDestroy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lheapDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function lheapDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapDestroy(*args):
        """
        ('L_HEAP', '**plh')       
('l_int32', 'freeflag')       

:param[in,out]   plh:        will be set to null before returning
:param[in]       freeflag:   TRUE to free each remaining struct in the array
:returns:  void

<pre>
Notes:
(1) Use %freeflag == TRUE when the items in the array can be
simply destroyed using free.  If those items require their
own destroy function, they must be destroyed before
calling this function, and then this function is called
with %freeflag == FALSE.
(2) To destroy the lheap, we destroy the ptr array, then
the lheap, and then null the contents of the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lheapDestroy(*args)
    
    

    try:
        leptonica.lheapAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lheapAdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lheapAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapAdd(*args):
        """
        ('L_HEAP', '*lh')       
('void', '*item')       

:param[in]    lh:      heap
:param[in]    item:    to be added to the tail of the heap
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapAdd(*args)
    
    

    try:
        leptonica.lheapRemove.argtypes = [ctypes.c_void_p]
        leptonica.lheapRemove.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function lheapRemove not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapRemove(*args):
        """
        ('L_HEAP', '*lh')       

:param[in]    lh:    heap
:returns:  ptr to item popped from the root of the heap,
or NULL if the heap is empty or on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapRemove(*args)
    
    

    try:
        leptonica.lheapGetCount.argtypes = [ctypes.c_void_p]
        leptonica.lheapGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function lheapGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapGetCount(*args):
        """
        ('L_HEAP', '*lh')       

:param[in]    lh:    heap
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapGetCount(*args)
    
    

    try:
        leptonica.lheapGetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.lheapGetElement.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function lheapGetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapGetElement(*args):
        """
        ('L_HEAP', '*lh')       
('l_int32', 'index')       

:param[in]    lh:       heap
:param[in]    index:    into the internal heap array
:returns:  ptr to the element at array[index], or NULL on error

<pre>
Notes:
(1) This is useful for retrieving an arbitrary element in the
heap array without disturbing the heap.  It allows all the
elements on the heap to be queried in linear time; for
example, to find the min or max of some value.
(2) Tbe retrieved element is owned by the heap.  Do not destroy it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lheapGetElement(*args)
    
    

    try:
        leptonica.lheapSort.argtypes = [ctypes.c_void_p]
        leptonica.lheapSort.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lheapSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapSort(*args):
        """
        ('L_HEAP', '*lh')       

:param[in]    lh:    heap, with internal array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This sorts an array into heap order.  If the heap is already
in heap order for the direction given, this has no effect.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lheapSort(*args)
    
    

    try:
        leptonica.lheapSortStrictOrder.argtypes = [ctypes.c_void_p]
        leptonica.lheapSortStrictOrder.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lheapSortStrictOrder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapSortStrictOrder(*args):
        """
        ('L_HEAP', '*lh')       

:param[in]    lh:    heap, with internal array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This sorts a heap into strict order.
(2) For each element, starting at the end of the array and
working forward, the element is swapped with the head
element and then allowed to swap down onto a heap of
size reduced by one.  The result is that the heap is
reversed but in strict order.  The array elements are
then reversed to put it in the original order.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.lheapSortStrictOrder(*args)
    
    

    try:
        leptonica.lheapPrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.lheapPrint.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function lheapPrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def lheapPrint(*args):
        """
        ('FILE', '*fp')       
('L_HEAP', '*lh')       

:param[in]    fp:    file stream
:param[in]    lh:    heap
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.lheapPrint(*args)
    




class pixacc(object):
    """<pre>

Pixacc creation, destruction
PIXACC   *pixaccCreate()
PIXACC   *pixaccCreateFromPix()
void      pixaccDestroy()

Pixacc finalization
PIX      *pixaccFinal()

Pixacc accessors
PIX      *pixaccGetPix()
l_int32   pixaccGetOffset()

Pixacc accumulators
l_int32   pixaccAdd()
l_int32   pixaccSubtract()
l_int32   pixaccMultConst()
l_int32   pixaccMultConstAccumulate()

This is a simple interface for some of the pixel arithmetic operations
in pixarith.c.  These are easy to code up, but not as fast as
hand-coded functions that do arithmetic on corresponding pixels.

Suppose you want to make a linear combination of pix1 and pix2:
pixd = 0.4 * pix1 + 0.6 * pix2
where pix1 and pix2 are the same size and have depth 'd'.  Then:
Pixacc *pacc = pixaccCreateFromPix(pix1, 0);  // first; addition only
pixaccMultConst(pacc, 0.4);
pixaccMultConstAccumulate(pacc, pix2, 0.6);  // Add in 0.6 of the second
pixd = pixaccFinal(pacc, d);  // Get the result
pixaccDestroy(&pacc);
</pre>




"""
    
    try:
        leptonica.pixaccCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaccCreate.restype = lambda address: PIXACC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaccCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccCreate(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'negflag')       

:param[in]    w,: h      of 32 bpp internal Pix
:param[in]    negflag:   0 if only positive numbers are involved;
1 if there will be negative numbers
:returns:  pixacc, or NULL on error

<pre>
Notes:
(1) Use %negflag = 1 for safety if any negative numbers are going
to be used in the chain of operations.  Negative numbers
arise, e.g., by subtracting a pix, or by adding a pix
that has been pre-multiplied by a negative number.
(2) Initializes the internal 32 bpp pix, similarly to the
initialization in pixInitAccumulate().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccCreate(*args)
    
    

    try:
        leptonica.pixaccCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaccCreateFromPix.restype = lambda address: PIXACC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaccCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'negflag')       

:param[in]    pix:
:param[in]    negflag:   0 if only positive numbers are involved;
1 if there will be negative numbers
:returns:  pixacc, or NULL on error

<pre>
Notes:
(1) See pixaccCreate()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccCreateFromPix(*args)
    
    

    try:
        leptonica.pixaccDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixaccDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixaccDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccDestroy(*args):
        """
        ('PIXACC', '**ppixacc')       

:param[in,out]   ppixacc:   will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccDestroy(*args)
    
    

    try:
        leptonica.pixaccFinal.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaccFinal.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaccFinal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccFinal(*args):
        """
        ('PIXACC', '*pixacc')       
('l_int32', 'outdepth')       

:param[in]    pixacc:
:param[in]    outdepth:    8, 16 or 32 bpp
:returns:  pixd 8, 16 or 32 bpp, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccFinal(*args)
    
    

    try:
        leptonica.pixaccGetPix.argtypes = [ctypes.c_void_p]
        leptonica.pixaccGetPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaccGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccGetPix(*args):
        """
        ('PIXACC', '*pixacc')       

:param[in]    pixacc:
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccGetPix(*args)
    
    

    try:
        leptonica.pixaccGetOffset.argtypes = [ctypes.c_void_p]
        leptonica.pixaccGetOffset.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixaccGetOffset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccGetOffset(*args):
        """
        ('PIXACC', '*pixacc')       

:param[in]    pixacc:
:returns:  offset, or -1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccGetOffset(*args)
    
    

    try:
        leptonica.pixaccAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaccAdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaccAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccAdd(*args):
        """
        ('PIXACC', '*pixacc')       
('PIX', '*pix')       

:param[in]    pixacc:
:param[in]    pix:     to be added
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccAdd(*args)
    
    

    try:
        leptonica.pixaccSubtract.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaccSubtract.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaccSubtract not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccSubtract(*args):
        """
        ('PIXACC', '*pixacc')       
('PIX', '*pix')       

:param[in]    pixacc:
:param[in]    pix:      to be subtracted
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccSubtract(*args)
    
    

    try:
        leptonica.pixaccMultConst.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixaccMultConst.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaccMultConst not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccMultConst(*args):
        """
        ('PIXACC', '*pixacc')       
('l_float32', 'factor')       

:param[in]    pixacc:
:param[in]    factor:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccMultConst(*args)
    
    

    try:
        leptonica.pixaccMultConstAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixaccMultConstAccumulate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaccMultConstAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaccMultConstAccumulate(*args):
        """
        ('PIXACC', '*pixacc')       
('PIX', '*pix')       
('l_float32', 'factor')       

:param[in]    pixacc:
:param[in]    pix:
:param[in]    factor:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This creates a temp pix that is %pix multiplied by the
constant %factor.  It then adds that into %pixacc.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaccMultConstAccumulate(*args)
    




class binreduce(object):
    """<pre>

Subsampled 2x reduction
PIX      *pixReduceBinary2()

Rank filtered 2x reductions
PIX      *pixReduceRankBinaryCascade()
PIX      *pixReduceRankBinary2()

Permutation table for 2x rank binary reduction
l_uint8  *makeSubsampleTab2x(void)
</pre>




"""
    
    try:
        leptonica.pixReduceBinary2.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixReduceBinary2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReduceBinary2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReduceBinary2(*args):
        """
        ('PIX', '*pixs')       
('l_uint8', '*intab')       

:param[in]    pixs:
:param[in]    intab:   [optional]; if null, a table is made here
and destroyed before exit
:returns:  pixd 2x subsampled, or NULL on error

<pre>
Notes:
(1) After folding, the data is in bytes 0 and 2 of the word,
and the bits in each byte are in the following order
(with 0 being the leftmost originating pair and 7 being
the rightmost originating pair):
0 4 1 5 2 6 3 7
These need to be permuted to
0 1 2 3 4 5 6 7
which is done with an 8-bit table generated by makeSubsampleTab2x().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReduceBinary2(*args)
    
    

    try:
        leptonica.pixReduceRankBinaryCascade.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReduceRankBinaryCascade.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReduceRankBinaryCascade not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReduceRankBinaryCascade(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level1')       
('l_int32', 'level2')       
('l_int32', 'level3')       
('l_int32', 'level4')       

:param[in]    pixs:    1 bpp
:param[in]    level1:  threshold, in the set {0, 1, 2, 3, 4}
:param[in]    level2:  threshold, in the set {0, 1, 2, 3, 4}
:param[in]    level3:  threshold, in the set {0, 1, 2, 3, 4}
:param[in]    level4:  threshold, in the set {0, 1, 2, 3, 4}
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This performs up to four cascaded 2x rank reductions.
(2) Use level = 0 to truncate the cascade.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReduceRankBinaryCascade(*args)
    
    

    try:
        leptonica.pixReduceRankBinary2.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixReduceRankBinary2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReduceRankBinary2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReduceRankBinary2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level')       
('l_uint8', '*intab')       

:param[in]    pixs:    1 bpp
:param[in]    level:   rank threshold: 1, 2, 3, 4
:param[in]    intab:   [optional]; if null, a table is made here
and destroyed before exit
:returns:  pixd   1 bpp, 2x rank threshold reduced, or NULL on error

<pre>
Notes:
(1) pixd is downscaled by 2x from pixs.
(2) The rank threshold specifies the minimum number of ON
pixels in each 2x2 region of pixs that are required to
set the corresponding pixel ON in pixd.
(3) Rank filtering is done to the UL corner of each 2x2 pixel block,
using only logical operations.  Then these pixels are chosen
in the 2x subsampling process, subsampled, as described
above in pixReduceBinary2().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReduceRankBinary2(*args)
    
    

    try:
        leptonica.makeSubsampleTab2x.argtypes = []
        leptonica.makeSubsampleTab2x.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function makeSubsampleTab2x not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeSubsampleTab2x(*args):
        """
               

:returns: tab   table of 256 permutations, or NULL on error

<pre>
Notes:
Permutation table for 2x rank binary reduction
This table permutes the bits in a byte, from
0 4 1 5 2 6 3 7
to
0 1 2 3 4 5 6 7
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeSubsampleTab2x(*args)
    




class jbclass(object):
    """"""
    
    try:
        leptonica.jbRankHausInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.jbRankHausInit.restype = lambda address: JBCLASSER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbRankHausInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbRankHausInit(*args):
        """
        ('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_int32', 'size')       
('l_float32', 'rank')       

:param[in]  components:  JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:param[in]  maxwidth:    of component; use 0 for default
:param[in]  maxheight:   of component; use 0 for default
:param[in]  size:        of square structuring element; 2, representing
2x2 sel, is necessary for reasonable accuracy of
small components; combine this with rank ~ 0.97
to avoid undue class expansion
:param[in]    rank:      rank val of match, each way; in [0.5 - 1.0];
when using size = 2, 0.97 is a reasonable value
:returns:  jbclasser if OK; NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbRankHausInit(*args)
    
    

    try:
        leptonica.jbCorrelationInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.jbCorrelationInit.restype = lambda address: JBCLASSER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbCorrelationInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbCorrelationInit(*args):
        """
        ('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_float32', 'thresh')       
('l_float32', 'weightfactor')       

:param[in]  components:    JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:param[in]  maxwidth:      of component; use 0 for default
:param[in]  maxheight:     of component; use 0 for default
:param[in]  thresh:        value for correlation score: in [0.4 - 0.98]
:param[in]  weightfactor:  corrects thresh for thick characters [0.0 - 1.0]
:returns:  jbclasser if OK; NULL on error

<pre>
Notes:
(1) For scanned text, suggested input values are:
thresh ~ [0.8 - 0.85]
weightfactor ~ [0.5 - 0.6]
(2) For electronically generated fonts (e.g., rasterized pdf),
a very high thresh (e.g., 0.95) will not cause a significant
increase in the number of classes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbCorrelationInit(*args)
    
    

    try:
        leptonica.jbCorrelationInitWithoutComponents.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.jbCorrelationInitWithoutComponents.restype = lambda address: JBCLASSER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbCorrelationInitWithoutComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbCorrelationInitWithoutComponents(*args):
        """
        ('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_float32', 'thresh')       
('l_float32', 'weightfactor')       

:param[in]  components:    JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:param[in]  maxwidth:      of component; use 0 for default
:param[in]  maxheight:     of component; use 0 for default
:param[in]  thresh: value  for correlation score: in [0.4 - 0.98]
:param[in]  weightfactor:  corrects thresh for thick characters [0.0 - 1.0]
:returns:  jbclasser if OK; NULL on error

<pre>
Notes:
Acts the same as jbCorrelationInit(), but the resulting
object doesn't keep a list of all the components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbCorrelationInitWithoutComponents(*args)
    
    

    try:
        leptonica.jbAddPages.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAddPages.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbAddPages not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAddPages(*args):
        """
        ('JBCLASSER', '*classer')       
('SARRAY', '*safiles')       

:param[in]    jbclasser:
:param[in]    safiles:      of page image file names
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) jbclasser makes a copy of the array of file names.
(2) The caller is still responsible for destroying the input array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbAddPages(*args)
    
    

    try:
        leptonica.jbAddPage.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAddPage.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbAddPage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAddPage(*args):
        """
        ('JBCLASSER', '*classer')       
('PIX', '*pixs')       

:param[in]    jbclasser:
:param[in]    pixs:      input page
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbAddPage(*args)
    
    

    try:
        leptonica.jbAddPageComponents.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAddPageComponents.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbAddPageComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAddPageComponents(*args):
        """
        ('JBCLASSER', '*classer')       
('PIX', '*pixs')       
('BOXA', '*boxas')       
('PIXA', '*pixas')       

:param[in]    jbclasser:
:param[in]    pixs:      input page
:param[in]    boxas:     b.b. of components for this page
:param[in]    pixas:     components for this page
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If there are no components on the page, we don't require input
of empty boxas or pixas, although that's the typical situation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbAddPageComponents(*args)
    
    

    try:
        leptonica.jbClassifyRankHaus.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbClassifyRankHaus.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbClassifyRankHaus not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbClassifyRankHaus(*args):
        """
        ('JBCLASSER', '*classer')       
('BOXA', '*boxa')       
('PIXA', '*pixas')       

:param[in]    jbclasser:
:param[in]    boxa:      new components for classification
:param[in]    pixas:     new components for classification
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbClassifyRankHaus(*args)
    
    

    try:
        leptonica.pixHaustest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHaustest.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixHaustest not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHaustest(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('PIX', '*pix3')       
('PIX', '*pix4')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       

:param[in]  pix1:      new pix, not dilated
:param[in]  pix2:      new pix, dilated
:param[in]  pix3:      exemplar pix, not dilated
:param[in]  pix4:      exemplar pix, dilated
:param[in]  delx:      x comp of centroid difference
:param[in]  dely:      y comp of centroid difference
:param[in]  maxdiffw:  max width difference of pix1 and pix2
:param[in]  maxdiffh:  max height difference of pix1 and pix2
:returns:  0 FALSE) if no match, 1 (TRUE if the new
pix is in the same class as the exemplar.

<pre>
Notes:
We check first that the two pix are roughly
the same size.  Only if they meet that criterion do
we compare the bitmaps.  The Hausdorff is a 2-way
check.  The centroid difference is used to align the two
images to the nearest integer for each of the checks.
These check that the dilated image of one contains
ALL the pixels of the undilated image of the other.
Checks are done in both direction.  A single pixel not
contained in either direction results in failure of the test.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHaustest(*args)
    
    

    try:
        leptonica.pixRankHaustest.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixRankHaustest.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixRankHaustest not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRankHaustest(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('PIX', '*pix3')       
('PIX', '*pix4')       
('l_float32', 'delx')       
('l_float32', 'dely')       
('l_int32', 'maxdiffw')       
('l_int32', 'maxdiffh')       
('l_int32', 'area1')       
('l_int32', 'area3')       
('l_float32', 'rank')       
('l_int32', '*tab8')       

:param[in]   pix1:      new pix, not dilated
:param[in]   pix2:      new pix, dilated
:param[in]   pix3:      exemplar pix, not dilated
:param[in]   pix4:      exemplar pix, dilated
:param[in]   delx:      x comp of centroid difference
:param[in]   dely:      y comp of centroid difference
:param[in]   maxdiffw:  max width difference of pix1 and pix2
:param[in]   maxdiffh:  max height difference of pix1 and pix2
:param[in]   area1:     fg pixels in pix1
:param[in]   area3:     fg pixels in pix3
:param[in]   rank:      rank value of test, each way
:param[in]   tab8:      table of pixel sums for byte
:returns:  0 FALSE) if no match, 1 (TRUE if the new
pix is in the same class as the exemplar.

<pre>
Notes:
We check first that the two pix are roughly
the same size.  Only if they meet that criterion do
we compare the bitmaps.  We convert the rank value to
a number of pixels by multiplying the rank fraction by the number
of pixels in the undilated image.  The Hausdorff is a 2-way
check.  The centroid difference is used to align the two
images to the nearest integer for each of the checks.
The rank hausdorff checks that the dilated image of one
contains the rank fraction of the pixels of the undilated
image of the other.   Checks are done in both direction.
Failure of the test in either direction results in failure
of the test.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRankHaustest(*args)
    
    

    try:
        leptonica.jbClassifyCorrelation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbClassifyCorrelation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbClassifyCorrelation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbClassifyCorrelation(*args):
        """
        ('JBCLASSER', '*classer')       
('BOXA', '*boxa')       
('PIXA', '*pixas')       

:param[in]   jbclasser:
:param[in]   boxa:      new components for classification
:param[in]   pixas:     new components for classification
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbClassifyCorrelation(*args)
    
    

    try:
        leptonica.jbGetComponents.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbGetComponents.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbGetComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbGetComponents(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'components')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxad')       
('PIXA', '**ppixad')       

:param[in]    pixs:        1 bpp
:param[in]    components:  JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:param[in]    maxwidth:    of saved components; larger are discarded
:param[in]    maxheight:   of saved components; larger are discarded
:param[out]   ppboxa:      b.b. of component items
:param[out]   pppixa:      component items
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbGetComponents(*args)
    
    

    try:
        leptonica.pixWordMaskByDilation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWordMaskByDilation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWordMaskByDilation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWordMaskByDilation(*args):
        """
        ('PIX', '*pixs')       
('PIX', '**ppixm')       
('l_int32', '*psize')       
('PIXA', '*pixadb')       

:param[in]    pixs:    1 bpp; typ. at 75 to 150 ppi
:param[out]   pmask:   [optional] dilated word mask
:param[out]   psize:   [optional] size of good horizontal dilation
:param[out]   pixadb:  [optional] debug: pixa of intermediate steps
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This gives an estimate of the word masks.  See
pixWordBoxesByDilation() for further filtering of the word boxes.
(2) The resolution should be between 75 and 150 ppi, and the optimal
dilation will be between 3 and 10.
(3) A good size for dilating to get word masks is optionally returned.
(4) Typically, the number of c.c. reduced with each successive
dilation (stored in nadiff) decreases quickly to a minimum
(where the characters in a word are joined), and then
increases again as the smaller number of words are joined.
For the typical case, you can then look for this minimum
and dilate to get the word mask.  However, there are many
cases where the function is not so simple. For example, if the
pix has been upscaled 2x, the nadiff function oscillates, with
every other value being zero!  And for some images it tails
off without a clear minimum to indicate where to break.
So a more simple and robust method is to find the dilation
where the initial number of c.c. has been reduced by some
fraction (we use a 70% reduction).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWordMaskByDilation(*args)
    
    

    try:
        leptonica.pixWordBoxesByDilation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWordBoxesByDilation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWordBoxesByDilation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWordBoxesByDilation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minwidth')       
('l_int32', 'minheight')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxa')       
('l_int32', '*psize')       
('PIXA', '*pixadb')       

:param[in]    pixs:       1 bpp; typ. 75 - 200 ppi
:param[in]    minwidth:   saved components; smaller are discarded
:param[in]    minheight:  saved components; smaller are discarded
:param[in]    maxwidth:   saved components; larger are discarded
:param[in]    maxheight:  saved components; larger are discarded
:param[out]   pboxa:      of dilated word mask
:param[out]   psize:      [optional] size of good horizontal dilation
:param[out]   pixadb:     [optional] debug: pixa of intermediate steps
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Returns a pruned set of word boxes.
(2) See pixWordMaskByDilation().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWordBoxesByDilation(*args)
    
    

    try:
        leptonica.jbAccumulateComposites.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbAccumulateComposites.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbAccumulateComposites not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbAccumulateComposites(*args):
        """
        ('PIXAA', '*pixaa')       
('NUMA', '**pna')       
('PTA', '**pptat')       

:param[in]    pixaa:   one pixa for each class
:param[out]   ppna:    number of samples used to build each composite
:param[out]   pptat:   centroids of bordered composites
:returns:  pixad accumulated sum of samples in each class, or NULL on error



        """
        args = _convert_params(*args)
        
        return leptonica.jbAccumulateComposites(*args)
    
    

    try:
        leptonica.jbTemplatesFromComposites.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbTemplatesFromComposites.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbTemplatesFromComposites not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbTemplatesFromComposites(*args):
        """
        ('PIXA', '*pixac')       
('NUMA', '*na')       

:param[in]    pixac:   one pix of composites for each class
:param[in]    na:      number of samples used for each class composite
:returns:  pixad 8 bpp templates for each class, or NULL on error



        """
        args = _convert_params(*args)
        
        return leptonica.jbTemplatesFromComposites(*args)
    
    

    try:
        leptonica.jbClasserCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.jbClasserCreate.restype = lambda address: JBCLASSER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbClasserCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbClasserCreate(*args):
        """
        ('l_int32', 'method')       
('l_int32', 'components')       

:param[in]    method:      JB_RANKHAUS, JB_CORRELATION
:param[in]    components:  JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:returns:  jbclasser, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbClasserCreate(*args)
    
    

    try:
        leptonica.jbDataSave.argtypes = [ctypes.c_void_p]
        leptonica.jbDataSave.restype = lambda address: JBDATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbDataSave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataSave(*args):
        """
        ('JBCLASSER', '*classer')       

:param[in]    jbclasser:
:param[in]    latticew:   cell width used to store each connected
component in the composite
:param[in]    latticeh:   ditto for cell height
:returns:  jbdata, or NULL on error

<pre>
Notes:
(1) This routine stores the jbig2-type data required for
generating a lossy jbig2 version of the image.
It can be losslessly written to (and read from) two files.
(2) It generates and stores the mosaic of templates.
(3) It clones the Numa and Pta arrays, so these must all
be destroyed by the caller.
(4) Input 0 to use the default values for latticew and/or latticeh,
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataSave(*args)
    
    

    try:
        leptonica.jbDataWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.jbDataWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbDataWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataWrite(*args):
        """
        ('const char', '*rootout')       
('JBDATA', '*jbdata')       

:param[in]  rootname:    for output files; everything but the extension
:param[in]  jbdata:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serialization function that writes data in jbdata to file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataWrite(*args)
    
    

    try:
        leptonica.jbDataRead.argtypes = [ctypes.c_char_p]
        leptonica.jbDataRead.restype = lambda address: JBDATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbDataRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataRead(*args):
        """
        ('const char', '*rootname')       

:param[in]  rootname:    for template and data files
:returns:  jbdata, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataRead(*args)
    
    

    try:
        leptonica.jbDataRender.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.jbDataRender.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbDataRender not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbDataRender(*args):
        """
        ('JBDATA', '*data')       
('l_int32', 'debugflag')       

:param[in]  jbdata:
:param[in]  debugflag:   if TRUE, writes into 2 bpp pix and adds
component outlines in color
:returns:  pixa reconstruction of original images, using templates or
NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.jbDataRender(*args)
    
    

    try:
        leptonica.jbGetULCorners.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.jbGetULCorners.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbGetULCorners not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbGetULCorners(*args):
        """
        ('JBCLASSER', '*classer')       
('PIX', '*pixs')       
('BOXA', '*boxa')       

:param[in]  jbclasser:
:param[in]  pixs:       full res image
:param[in]  boxa:       of c.c. bounding rectangles for this page
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes the ptaul field, which has the global UL corners,
adjusted for each specific component, so that each component
can be replaced by the template for its class and have the
centroid in the template in the same position as the
centroid of the original connected component.  It is important
that this be done properly to avoid a wavy baseline in the
result.
(2) The array fields ptac and ptact give the centroids of
those components relative to the UL corner of each component.
Here, we compute the difference in each component, round to
nearest integer, and correct the box->x and box->y by
the appropriate integral difference.
(3) The templates and stored instances are all bordered.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbGetULCorners(*args)
    
    

    try:
        leptonica.jbGetLLCorners.argtypes = [ctypes.c_void_p]
        leptonica.jbGetLLCorners.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbGetLLCorners not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbGetLLCorners(*args):
        """
        ('JBCLASSER', '*classer')       

:param[in]    jbclasser:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes the ptall field, which has the global LL corners,
adjusted for each specific component, so that each component
can be replaced by the template for its class and have the
centroid in the template in the same position as the
centroid of the original connected component. It is important
that this be done properly to avoid a wavy baseline in the result.
(2) It is computed here from the corresponding UL corners, where
the input templates and stored instances are all bordered.
This should be done after all pages have been processed.
(3) For proper substitution, the templates whose LL corners are
placed in these locations must be UN-bordered.
This is available for a realistic jbig2 encoder, which would
(1) encode each template without a border, and (2) encode
the position using the LL corner (rather than the UL
corner) because the difference between y-values
of successive instances is typically close to zero.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbGetLLCorners(*args)
    




class pixafunc1(object):
    """<pre>

Filters
PIX      *pixSelectBySize()
PIXA     *pixaSelectBySize()
NUMA     *pixaMakeSizeIndicator()

PIX      *pixSelectByPerimToAreaRatio()
PIXA     *pixaSelectByPerimToAreaRatio()
PIX      *pixSelectByPerimSizeRatio()
PIXA     *pixaSelectByPerimSizeRatio()
PIX      *pixSelectByAreaFraction()
PIXA     *pixaSelectByAreaFraction()
PIX      *pixSelectByArea()
PIXA     *pixaSelectByArea()
PIX      *pixSelectByWidthHeightRatio()
PIXA     *pixaSelectByWidthHeightRatio()
PIXA     *pixaSelectByNumConnComp()

PIXA     *pixaSelectWithIndicator()
l_int32   pixRemoveWithIndicator()
l_int32   pixAddWithIndicator()
PIXA     *pixaSelectWithString()
PIX      *pixaRenderComponent()

Sort functions
PIXA     *pixaSort()
PIXA     *pixaBinSort()
PIXA     *pixaSortByIndex()
PIXAA    *pixaSort2dByIndex()

Pixa and Pixaa range selection
PIXA     *pixaSelectRange()
PIXAA    *pixaaSelectRange()

Pixa and Pixaa scaling
PIXAA    *pixaaScaleToSize()
PIXAA    *pixaaScaleToSizeVar()
PIXA     *pixaScaleToSize()
PIXA     *pixaScaleToSizeRel()
PIXA     *pixaScale()
PIXA     *pixaScaleBySampling()

Pixa rotation and translation
PIXA     *pixaRotate()
PIXA     *pixaRotateOrth()
PIXA     *pixaTranslate()

Miscellaneous
PIXA     *pixaAddBorderGeneral()
PIXA     *pixaaFlattenToPixa()
l_int32   pixaaSizeRange()
l_int32   pixaSizeRange()
PIXA     *pixaClipToPix()
PIXA     *pixaClipToForeground()
l_int32   pixaGetRenderingDepth()
l_int32   pixaHasColor()
l_int32   pixaAnyColormaps()
l_int32   pixaGetDepthInfo()
PIXA     *pixaConvertToSameDepth()
l_int32   pixaEqual()
l_int32   pixaSetFullSizeBoxa()
</pre>




"""
    
    try:
        leptonica.pixSelectBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectBySize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectBySize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       

:param[in]    pixs:           1 bpp
:param[in]    width,: height  threshold dimensions
:param[in]    connectivity:   4 or 8
:param[in]    type:           L_SELECT_WIDTH, L_SELECT_HEIGHT,
L_SELECT_IF_EITHER, L_SELECT_IF_BOTH
:param[in]    relation:       L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:       [optional] 1 if changed; 0 otherwise
:returns:  filtered pixd, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) If unchanged, returns a copy of pixs.  Otherwise,
returns a new pix with the filtered components.
(3) If the selection type is L_SELECT_WIDTH, the input
height is ignored, and v.v.
(4) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectBySize(*args)
    
    

    try:
        leptonica.pixaSelectBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectBySize.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectBySize(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'type')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    width,: height  threshold dimensions
:param[in]    type:           L_SELECT_WIDTH, L_SELECT_HEIGHT,
L_SELECT_IF_EITHER, L_SELECT_IF_BOTH
:param[in]    relation:       L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:       [optional] 1 if changed; 0 otherwise
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) Uses pix and box clones in the new pixa.
(3) If the selection type is L_SELECT_WIDTH, the input
height is ignored, and v.v.
(4) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectBySize(*args)
    
    

    try:
        leptonica.pixaMakeSizeIndicator.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMakeSizeIndicator.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaMakeSizeIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMakeSizeIndicator(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'type')       
('l_int32', 'relation')       

:param[in]    pixa:
:param[in]    width,: height  threshold dimensions
:param[in]    type:           L_SELECT_WIDTH, L_SELECT_HEIGHT,
L_SELECT_IF_EITHER, L_SELECT_IF_BOTH
:param[in]    relation:       L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:  na indicator array, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) If the selection type is L_SELECT_WIDTH, the input
height is ignored, and v.v.
(3) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMakeSizeIndicator(*args)
    
    

    try:
        leptonica.pixSelectByPerimToAreaRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByPerimToAreaRatio.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectByPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByPerimToAreaRatio(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixs:          1 bpp
:param[in]    thresh:        threshold ratio of fg boundary to fg pixels
:param[in]    connectivity:  4 or 8
:param[in]    type:          L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:      [optional] 1 if changed; 0 if clone returned
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) If unchanged, returns a copy of pixs.  Otherwise,
returns a new pix with the filtered components.
(3) This filters "thick" components, where a thick component
is defined to have a ratio of boundary to interior pixels
that is smaller than a given threshold value.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the thicker
components, and L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixaSelectByPerimToAreaRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByPerimToAreaRatio.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectByPerimToAreaRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByPerimToAreaRatio(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    thresh:     threshold ratio of fg boundary to fg pixels
:param[in]    type:       L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:   [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) See pixSelectByPerimToAreaRatio().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByPerimToAreaRatio(*args)
    
    

    try:
        leptonica.pixSelectByPerimSizeRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByPerimSizeRatio.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectByPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByPerimSizeRatio(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixs:          1 bpp
:param[in]    thresh:        threshold ratio of fg boundary to fg pixels
:param[in]    connectivity:  4 or 8
:param[in]    type:          L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:      [optional] 1 if changed; 0 if clone returned
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) If unchanged, returns a copy of pixs.  Otherwise,
returns a new pix with the filtered components.
(3) This filters components with smooth vs. dendritic shape, using
the ratio of the fg boundary pixels to the circumference of
the bounding box, and comparing it to a threshold value.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save the smooth
boundary components, and L_SELECT_IF_GT or L_SELECT_IF_GTE
to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixaSelectByPerimSizeRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByPerimSizeRatio.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectByPerimSizeRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByPerimSizeRatio(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    thresh:    threshold ratio of fg boundary to b.b. circumference
:param[in]    type:      L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:  [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) See pixSelectByPerimSizeRatio().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByPerimSizeRatio(*args)
    
    

    try:
        leptonica.pixSelectByAreaFraction.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByAreaFraction.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectByAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByAreaFraction(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixs:          1 bpp
:param[in]    thresh:        threshold ratio of fg pixels to (w * h)
:param[in]    connectivity:  4 or 8
:param[in]    type:          L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:      [optional] 1 if changed; 0 if clone returned
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the amount of foreground
coverage of the components that are kept.
(2) If unchanged, returns a copy of pixs.  Otherwise,
returns a new pix with the filtered components.
(3) This filters components based on the fraction of fg pixels
of the component in its bounding box.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
with less than the threshold fraction of foreground, and
L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByAreaFraction(*args)
    
    

    try:
        leptonica.pixaSelectByAreaFraction.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByAreaFraction.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectByAreaFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByAreaFraction(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    thresh:      threshold ratio of fg pixels to (w * h)
:param[in]    type:        L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:    [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) This filters components based on the fraction of fg pixels
of the component in its bounding box.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
with less than the threshold fraction of foreground, and
L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByAreaFraction(*args)
    
    

    try:
        leptonica.pixSelectByArea.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByArea.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectByArea not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByArea(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixs:          1 bpp
:param[in]    thresh:        threshold number of FG pixels
:param[in]    connectivity:  4 or 8
:param[in]    type:          L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:      [optional] 1 if changed; 0 if clone returned
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the number of foreground
pixels in the components that are kept.
(2) If unchanged, returns a copy of pixs.  Otherwise,
returns a new pix with the filtered components.
(3) This filters components based on the number of fg pixels
in each component.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
with less than the threshold number of fg pixels, and
L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByArea(*args)
    
    

    try:
        leptonica.pixaSelectByArea.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByArea.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectByArea not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByArea(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    thresh:      threshold number of fg pixels
:param[in]    type:        L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:    [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) This filters components based on the number of fg pixels
in the component.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
with less than the threshold number of fg pixels, and
L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByArea(*args)
    
    

    try:
        leptonica.pixSelectByWidthHeightRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSelectByWidthHeightRatio.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectByWidthHeightRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectByWidthHeightRatio(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', 'connectivity')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixs:          1 bpp
:param[in]    thresh:        threshold ratio of width/height
:param[in]    connectivity:  4 or 8
:param[in]    type:          L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:      [optional] 1 if changed; 0 if clone returned
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the width-to-height ratio
for components that are kept.
(2) If unchanged, returns a copy of pixs.  Otherwise,
returns a new pix with the filtered components.
(3) This filters components based on the width-to-height ratios.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
with less than the threshold ratio, and
L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectByWidthHeightRatio(*args)
    
    

    try:
        leptonica.pixaSelectByWidthHeightRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByWidthHeightRatio.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectByWidthHeightRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByWidthHeightRatio(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'thresh')       
('l_int32', 'type')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    thresh:      threshold ratio of width/height
:param[in]    type:        L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:    [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) This filters components based on the width-to-height ratio
of each pix.
(4) Use L_SELECT_IF_LT or L_SELECT_IF_LTE to save components
with less than the threshold ratio, and
L_SELECT_IF_GT or L_SELECT_IF_GTE to remove them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByWidthHeightRatio(*args)
    
    

    try:
        leptonica.pixaSelectByNumConnComp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaSelectByNumConnComp.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectByNumConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectByNumConnComp(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'nmin')       
('l_int32', 'nmax')       
('l_int32', 'connectivity')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    nmin:          minimum number of components
:param[in]    nmax:          maximum number of components
:param[in]    connectivity:  4 or 8
:param[out]   pchanged:      [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) This filters by the number of connected components in
a given range.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectByNumConnComp(*args)
    
    

    try:
        leptonica.pixaSelectWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaSelectWithIndicator.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectWithIndicator(*args):
        """
        ('PIXA', '*pixas')       
('NUMA', '*na')       
('l_int32', '*pchanged')       

:param[in]    pixas:
:param[in]    na:         indicator numa
:param[out]   pchanged:   [optional] 1 if changed; 0 if clone returned
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa clone if no components are removed.
(2) Uses pix and box clones in the new pixa.
(3) The indicator numa has values 0 (ignore) and 1 (accept).
(4) If the source boxa is not fully populated, it is left
empty in the dest pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectWithIndicator(*args)
    
    

    try:
        leptonica.pixRemoveWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRemoveWithIndicator.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveWithIndicator(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('NUMA', '*na')       

:param[in]    pixs:     1 bpp pix from which components are removed; in-place
:param[in]    pixa:     of connected components in pixs
:param[in]    na:       numa indicator: remove components corresponding to 1s
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This complements pixAddWithIndicator().   Here, the selected
components are set subtracted from pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveWithIndicator(*args)
    
    

    try:
        leptonica.pixAddWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddWithIndicator.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAddWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddWithIndicator(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('NUMA', '*na')       

:param[in]    pixs:     1 bpp pix from which components are added; in-place
:param[in]    pixa:     of connected components, some of which will be put
into pixs
:param[in]    na:       numa indicator: add components corresponding to 1s
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This complements pixRemoveWithIndicator().   Here, the selected
components are added to pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddWithIndicator(*args)
    
    

    try:
        leptonica.pixaSelectWithString.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixaSelectWithString.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectWithString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectWithString(*args):
        """
        ('PIXA', '*pixas')       
('const char', '*str')       
('l_int32', '*perror')       

:param[in]    pixas:
:param[in]    str:      string of indices into pixa, giving the pix to
be selected
:param[out]   perror:   [optional] 1 if any indices are invalid;
0 if all indices are valid
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Returns a pixa with copies of selected pix.
(2) Associated boxes are also copied, if fully populated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectWithString(*args)
    
    

    try:
        leptonica.pixaRenderComponent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaRenderComponent.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaRenderComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRenderComponent(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_int32', 'index')       

:param[in]    pixs:    [optional] 1 bpp pix
:param[in]    pixa:    of 1 bpp connected components, one of which will
be rendered in pixs, with its origin determined
by the associated box.
:param[in]    index:   of component to be rendered
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) If pixs is null, this generates an empty pix of a size determined
by union of the component bounding boxes, and including the origin.
(2) The selected component is blitted into pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRenderComponent(*args)
    
    

    try:
        leptonica.pixaSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSort.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSort(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       

:param[in]    pixas:
:param[in]    sorttype:   L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,
L_SORT_BY_HEIGHT, L_SORT_BY_MIN_DIMENSION,
L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER,
L_SORT_BY_AREA, L_SORT_BY_ASPECT_RATIO
:param[in]    sortorder:  L_SORT_INCREASING, L_SORT_DECREASING
:param[out]   pnaindex:   [optional] index of sorted order into
original array
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  pixad sorted version of pixas, or NULL on error

<pre>
Notes:
(1) This sorts based on the data in the boxa.  If the boxa
count is not the same as the pixa count, this returns an error.
(2) If the boxa is empty, it makes one corresponding to the
dimensions of each pix, which allows meaningful sorting on
all types except x and y.
(3) The copyflag refers to the pix and box copies that are
inserted into the sorted pixa.  These are either L_COPY
or L_CLONE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSort(*args)
    
    

    try:
        leptonica.pixaBinSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaBinSort.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaBinSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaBinSort(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       

:param[in]    pixas:
:param[in]    sorttype:    L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,
L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER
:param[in]    sortorder:   L_SORT_INCREASING, L_SORT_DECREASING
:param[out]   pnaindex:    [optional] index of sorted order into
original array
:param[in]    copyflag:    L_COPY, L_CLONE
:returns:  pixad sorted version of pixas, or NULL on error

<pre>
Notes:
(1) This sorts based on the data in the boxa.  If the boxa
count is not the same as the pixa count, this returns an error.
(2) The copyflag refers to the pix and box copies that are
inserted into the sorted pixa.  These are either L_COPY
or L_CLONE.
(3) For a large number of boxes (say, greater than 1000), this
O(n) binsort is much faster than the O(nlogn) shellsort.
For 5000 components, this is over 20x faster than boxaSort().
(4) Consequently, pixaSort() calls this function if it will
likely go much faster.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaBinSort(*args)
    
    

    try:
        leptonica.pixaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSortByIndex.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSortByIndex(*args):
        """
        ('PIXA', '*pixas')       
('NUMA', '*naindex')       
('l_int32', 'copyflag')       

:param[in]    pixas:
:param[in]    naindex:    na that maps from the new pixa to the input pixa
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  pixad sorted, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSortByIndex(*args)
    
    

    try:
        leptonica.pixaSort2dByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaSort2dByIndex.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSort2dByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSort2dByIndex(*args):
        """
        ('PIXA', '*pixas')       
('NUMAA', '*naa')       
('l_int32', 'copyflag')       

:param[in]    pixas:
:param[in]    naa:       numaa that maps from the new pixaa to the input pixas
:param[in]    copyflag:  L_CLONE or L_COPY
:returns:  paa sorted, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSort2dByIndex(*args)
    
    

    try:
        leptonica.pixaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaSelectRange.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectRange(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'copyflag')       

:param[in]    pixas:
:param[in]    first:     use 0 to select from the beginning
:param[in]    last:      use -1 to select to the end
:param[in]    copyflag:  L_COPY, L_CLONE
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) The copyflag specifies what we do with each pix from pixas.
Specifically, L_CLONE inserts a clone into pixad of each
selected pix from pixas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectRange(*args)
    
    

    try:
        leptonica.pixaaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaSelectRange.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaSelectRange(*args):
        """
        ('PIXAA', '*paas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'copyflag')       

:param[in]    paas:
:param[in]    first:    use 0 to select from the beginning
:param[in]    last:     use -1 to select to the end
:param[in]    copyflag: L_COPY, L_CLONE
:returns:  paad, or NULL on error

<pre>
Notes:
(1) The copyflag specifies what we do with each pixa from paas.
Specifically, L_CLONE inserts a clone into paad of each
selected pixa from paas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaSelectRange(*args)
    
    

    try:
        leptonica.pixaaScaleToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaScaleToSize.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaScaleToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaScaleToSize(*args):
        """
        ('PIXAA', '*paas')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    paas:
:param[in]    wd:    target width; use 0 if using height as target
:param[in]    hd:    target height; use 0 if using width as target
:returns:  paad, or NULL on error

<pre>
Notes:
(1) This guarantees that each output scaled image has the
dimension(s) you specify.
~ To specify the width with isotropic scaling, set %hd = 0.
~ To specify the height with isotropic scaling, set %wd = 0.
~ If both %wd and %hd are specified, the image is scaled
(in general, anisotropically) to that size.
~ It is an error to set both %wd and %hd to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaScaleToSize(*args)
    
    

    try:
        leptonica.pixaaScaleToSizeVar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaScaleToSizeVar.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaScaleToSizeVar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaScaleToSizeVar(*args):
        """
        ('PIXAA', '*paas')       
('NUMA', '*nawd')       
('NUMA', '*nahd')       

:param[in]    paas:
:param[in]    nawd:  [optional] target widths; use NULL if using height
:param[in]    nahd:  [optional] target height; use NULL if using width
:returns:  paad, or NULL on error

<pre>
Notes:
(1) This guarantees that the scaled images in each pixa have the
dimension(s) you specify in the numas.
~ To specify the width with isotropic scaling, set %nahd = NULL.
~ To specify the height with isotropic scaling, set %nawd = NULL.
~ If both %nawd and %nahd are specified, the image is scaled
(in general, anisotropically) to that size.
~ It is an error to set both %nawd and %nahd to NULL.
(2) If either nawd and/or nahd is defined, it must have the same
count as the number of pixa in paas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaScaleToSizeVar(*args)
    
    

    try:
        leptonica.pixaScaleToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaScaleToSize.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaScaleToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaScaleToSize(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    pixas:
:param[in]    wd:    target width; use 0 if using height as target
:param[in]    hd:    target height; use 0 if using width as target
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) See pixaaScaleToSize()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaScaleToSize(*args)
    
    

    try:
        leptonica.pixaScaleToSizeRel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaScaleToSizeRel.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaScaleToSizeRel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaScaleToSizeRel(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'delw')       
('l_int32', 'delh')       

:param[in]    pixas:
:param[in]    delw:   change in width, in pixels; 0 means no change
:param[in]    delh:   change in height, in pixels; 0 means no change
return  pixad, or NULL on error

<pre>
Notes:
(1) If a requested change in a pix is not possible because
either the requested width or height is <= 0, issue a
warning and return a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaScaleToSizeRel(*args)
    
    

    try:
        leptonica.pixaScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixaScale.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaScale(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixas:
:param[in]    scalex:
:param[in]    scaley:
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) If pixas has a full boxes, it is scaled as well.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaScale(*args)
    
    

    try:
        leptonica.pixaScaleBySampling.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixaScaleBySampling.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaScaleBySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaScaleBySampling(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixas:
:param[in]    scalex:
:param[in]    scaley:
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) If pixas has a full boxes, it is scaled as well.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaScaleBySampling(*args)
    
    

    try:
        leptonica.pixaRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaRotate.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRotate(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'angle')       
('l_int32', 'type')       
('l_int32', 'incolor')       
('l_int32', 'width')       
('l_int32', 'height')       

:param[in]    pixas:    1, 2, 4, 8, 32 bpp rgb
:param[in]    angle:    rotation angle in radians; clockwise is positive
:param[in]    type:     L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:param[in]    width:    original width; use 0 to avoid embedding
:param[in]    height:   original height; use 0 to avoid embedding
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Each pix is rotated about its center.  See pixRotate() for details.
(2) The boxa array is copied.  Why is it not rotated?
If a boxa exists, the array of boxes is in 1-to-1
correspondence with the array of pix, and each box typically
represents the location of the pix relative to an image from
which it has been extracted.  Like the pix, we could rotate
each box around its center, and then generate a box that
contains all four corners, as is done in boxaRotate(), but
this seems unnecessary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRotate(*args)
    
    

    try:
        leptonica.pixaRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaRotateOrth.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRotateOrth(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'rotation')       

:param[in]    pixas:
:param[in]    rotation:    0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;
all rotations are clockwise
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) Rotates each pix in the pixa.  Rotates and saves the boxes in
the boxa if the boxa is full.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRotateOrth(*args)
    
    

    try:
        leptonica.pixaTranslate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaTranslate.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaTranslate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaTranslate(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'hshift')       
('l_int32', 'vshift')       
('l_int32', 'incolor')       

:param[in]    pixas:
:param[in]    hshift:   horizontal shift; hshift > 0 is to right
:param[in]    vshift:   vertical shift; vshift > 0 is down
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixad, or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixaTranslate(*args)
    
    

    try:
        leptonica.pixaAddBorderGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaAddBorderGeneral.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaAddBorderGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAddBorderGeneral(*args):
        """
        ('PIXA', '*pixad')       
('PIXA', '*pixas')       
('l_int32', 'left')       
('l_int32', 'right')       
('l_int32', 'top')       
('l_int32', 'bot')       
('l_uint32', 'val')       

:param[in]    pixad:    can be null or equal to pixas
:param[in]    pixas:    containing pix of all depths; colormap ok
:param[in]    left,: right, top, bot     number of pixels added
:param[in]    val:      value of added border pixels
:returns:  pixad with border added to each pix, including on error

<pre>
Notes:
(1) For binary images:
white:  val = 0
black:  val = 1
For grayscale images:
white:  val = 2 ** d - 1
black:  val = 0
For rgb color images:
white:  val = 0xffffff00
black:  val = 0
For colormapped images, use 'index' found this way:
white: pixcmapGetRankIntensity(cmap, 1.0, &index);
black: pixcmapGetRankIntensity(cmap, 0.0, &index);
(2) For in-place replacement of each pix with a bordered version,
use %pixad = %pixas.  To make a new pixa, use %pixad = NULL.
(3) In both cases, the boxa has sides adjusted as if it were
expanded by the border.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAddBorderGeneral(*args)
    
    

    try:
        leptonica.pixaaFlattenToPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaaFlattenToPixa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaFlattenToPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaFlattenToPixa(*args):
        """
        ('PIXAA', '*paa')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       

:param[in]    paa:
:param[out]   pnaindex:  [optional] the pixa index in the pixaa
:param[in]    copyflag:  L_COPY or L_CLONE
:returns:  pixa, or NULL on error

<pre>
Notes:
(1) This 'flattens' the pixaa to a pixa, taking the pix in
order in the first pixa, then the second, etc.
(2) If &naindex is defined, we generate a Numa that gives, for
each pix in the pixaa, the index of the pixa to which it belongs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaFlattenToPixa(*args)
    
    

    try:
        leptonica.pixaaSizeRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaaSizeRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaaSizeRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaSizeRange(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', '*pminw')       
('l_int32', '*pminh')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       

:param[in]    paa:
:param[out]   pminw,: pminh, pmaxw, pmaxh   [optional] range of
dimensions of all boxes
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaSizeRange(*args)
    
    

    try:
        leptonica.pixaSizeRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaSizeRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSizeRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSizeRange(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pminw')       
('l_int32', '*pminh')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       

:param[in]    pixa:
:param[out]   pminw,: pminh, pmaxw, pmaxh   [optional] range of
dimensions of pix in the array
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSizeRange(*args)
    
    

    try:
        leptonica.pixaClipToPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaClipToPix.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaClipToPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaClipToPix(*args):
        """
        ('PIXA', '*pixas')       
('PIX', '*pixs')       

:param[in]    pixas:
:param[in]    pixs:
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) This is intended for use in situations where pixas
was originally generated from the input pixs.
(2) Returns a pixad where each pix in pixas is ANDed
with its associated region of the input pixs.  This
region is specified by the the box that is associated
with the pix.
(3) In a typical application of this function, pixas has
a set of region masks, so this generates a pixa of
the parts of pixs that correspond to each region
mask component, along with the bounding box for
the region.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaClipToPix(*args)
    
    

    try:
        leptonica.pixaClipToForeground.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaClipToForeground.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaClipToForeground not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaClipToForeground(*args):
        """
        ('PIXA', '*pixas')       
('PIXA', '**ppixad')       
('BOXA', '**pboxa')       

:param[in]    pixas:
:param[out]   ppixad:   [optional] pixa of clipped pix returned
:param[out]   pboxa:    [optional] clipping boxes returned
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) At least one of [&pixd, &boxa] must be specified.
(2) Any pix with no fg pixels is skipped.
(3) See pixClipToForeground().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaClipToForeground(*args)
    
    

    try:
        leptonica.pixaGetRenderingDepth.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetRenderingDepth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetRenderingDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetRenderingDepth(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pdepth')       

:param[in]    pixa:
:param[out]   pdepth:   depth required to render if all colormaps are removed
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetRenderingDepth(*args)
    
    

    try:
        leptonica.pixaHasColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaHasColor.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaHasColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaHasColor(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*phascolor')       

:param[in]    pixa:
:param[out]   phascolor:   1 if any pix is rgb or has a colormap with color;
0 otherwise
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaHasColor(*args)
    
    

    try:
        leptonica.pixaAnyColormaps.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaAnyColormaps.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaAnyColormaps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAnyColormaps(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*phascmap')       

:param[in]    pixa:
:param[out]   phascmap:    1 if any pix has a colormap; 0 otherwise
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAnyColormaps(*args)
    
    

    try:
        leptonica.pixaGetDepthInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetDepthInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetDepthInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetDepthInfo(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', '*pmaxdepth')       
('l_int32', '*psame')       

:param[in]    pixa:
:param[out]   pmaxdepth:  [optional] max pixel depth of pix in pixa
:param[out]   psame:      [optional] true if all depths are equal
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetDepthInfo(*args)
    
    

    try:
        leptonica.pixaConvertToSameDepth.argtypes = [ctypes.c_void_p]
        leptonica.pixaConvertToSameDepth.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertToSameDepth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertToSameDepth(*args):
        """
        ('PIXA', '*pixas')       

:param[in]    pixas:
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) If any pix has a colormap, they are all converted to rgb.
Otherwise, they are all converted to the maximum depth of
all the pix.
(2) This can be used to allow lossless rendering onto a single pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertToSameDepth(*args)
    
    

    try:
        leptonica.pixaEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaEqual.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaEqual(*args):
        """
        ('PIXA', '*pixa1')       
('PIXA', '*pixa2')       
('l_int32', 'maxdist')       
('NUMA', '**pnaindex')       
('l_int32', '*psame')       

:param[in]    pixa1:
:param[in]    pixa2:
:param[in]    maxdist:
:param[out]   pnaindex:  [optional] index array of correspondences
:param[out]   psame:     1 if equal; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The two pixa are the "same" if they contain the same
boxa and the same ordered set of pix.  However, if they
have boxa, the pix in each pixa can differ in ordering
by an amount given by the parameter %maxdist.  If they
don't have a boxa, the %maxdist parameter is ignored,
and the ordering of the pix must be identical.
(2) This applies only to boxa geometry, pixels and ordering;
other fields in the pix are ignored.
(3) naindex[i] gives the position of the box in pixa2 that
corresponds to box i in pixa1.  It is only returned if the
pixa have boxa and the boxa are equal.
(4) In situations where the ordering is very different, so that
a large %maxdist is required for "equality", this should be
implemented with a hash function for efficiency.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaEqual(*args)
    
    

    try:
        leptonica.pixaSetFullSizeBoxa.argtypes = [ctypes.c_void_p]
        leptonica.pixaSetFullSizeBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSetFullSizeBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSetFullSizeBoxa(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Replaces the existing boxa.  Each box gives the dimensions
of the corresponding pix.  This is needed for functions
like pixaSort() that sort based on the boxes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSetFullSizeBoxa(*args)
    




class warper(object):
    """<pre>

High-level captcha interface
PIX               *pixSimpleCaptcha()

Random sinusoidal warping
PIX               *pixRandomHarmonicWarp()

Helper functions
static l_float64  *generateRandomNumberArray()
static l_int32     applyWarpTransform()

Version using a LUT for sin
PIX               *pixRandomHarmonicWarpLUT()
static l_int32     applyWarpTransformLUT()
static l_int32     makeSinLUT()
static l_float32   getSinFromLUT()

Stereoscopic warping
PIX               *pixWarpStereoscopic()

Linear and quadratic horizontal stretching
PIX               *pixStretchHorizontal()
PIX               *pixStretchHorizontalSampled()
PIX               *pixStretchHorizontalLI()

Quadratic vertical shear
PIX               *pixQuadraticVShear()
PIX               *pixQuadraticVShearSampled()
PIX               *pixQuadraticVShearLI()

Stereo from a pair of images
PIX               *pixStereoFromPair()
</pre>




"""
    
    try:
        leptonica.pixSimpleCaptcha.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSimpleCaptcha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSimpleCaptcha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSimpleCaptcha(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'border')       
('l_int32', 'nterms')       
('l_uint32', 'seed')       
('l_uint32', 'color')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      8 bpp; no colormap
:param[in]    border:    added white pixels on each side
:param[in]    nterms:    number of x and y harmonic terms
:param[in]    seed:      of random number generator
:param[in]    color:     for colorizing; in 0xrrggbb00 format; use 0 for black
:param[in]    cmapflag:  1 for colormap output; 0 for rgb
:returns:  pixd   8 bpp cmap or 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This uses typical default values for generating captchas.
The magnitudes of the harmonic warp are typically to be
smaller when more terms are used, even though the phases
are random.  See, for example, prog/warptest.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSimpleCaptcha(*args)
    
    

    try:
        leptonica.pixRandomHarmonicWarp.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixRandomHarmonicWarp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRandomHarmonicWarp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRandomHarmonicWarp(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'xmag')       
('l_float32', 'ymag')       
('l_float32', 'xfreq')       
('l_float32', 'yfreq')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_uint32', 'seed')       
('l_int32', 'grayval')       

:param[in]    pixs:          8 bpp; no colormap
:param[in]    xmag,: ymag    maximum magnitude of x and y distortion
:param[in]    xfreq,: yfreq  maximum magnitude of x and y frequency
:param[in]    nx,: ny        number of x and y harmonic terms
:param[in]    seed:          of random number generator
:param[in]    grayval:       color brought in from the outside;
0 for black, 255 for white
:returns:  pixd   8 bpp; no colormap, or NULL on error

<pre>
Notes:
(1) To generate the warped image p(x',y'), set up the transforms
that are in getWarpTransform().  For each (x',y') in the
dest, the warp function computes the originating location
(x, y) in the src.  The differences (x - x') and (y - y')
are given as a sum of products of sinusoidal terms.  Each
term is multiplied by a maximum amplitude (in pixels), and the
angle is determined by a frequency and phase, and depends
on the (x', y') value of the dest.  Random numbers with
a variable input seed are used to allow the warping to be
unpredictable.  A linear interpolation is used to find
the value for the source at (x, y); this value is written
into the dest.
(2) This can be used to generate 'captcha's, which are somewhat
randomly distorted images of text.  A typical set of parameters
for a captcha are:
xmag = 4.0     ymag = 6.0
xfreq = 0.10   yfreq = 0.13
nx = 3         ny = 3
Other examples can be found in prog/warptest.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRandomHarmonicWarp(*args)
    
    

    try:
        leptonica.pixWarpStereoscopic.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWarpStereoscopic.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixWarpStereoscopic not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWarpStereoscopic(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'zbend')       
('l_int32', 'zshiftt')       
('l_int32', 'zshiftb')       
('l_int32', 'ybendt')       
('l_int32', 'ybendb')       
('l_int32', 'redleft')       

:param[in]    pixs:      any depth, colormap ok
:param[in]    zbend:     horizontal separation in pixels of red and cyan
at the left and right sides, that gives rise to
quadratic curvature out of the image plane
:param[in]    zshiftt:   uniform pixel translation difference between
red and cyan, that pushes the top of the image
plane away from the viewer (zshiftt > 0) or
towards the viewer (zshiftt < 0)
:param[in]    zshiftb:   uniform pixel translation difference between
red and cyan, that pushes the bottom of the image
plane away from the viewer (zshiftb > 0) or
towards the viewer (zshiftb < 0)
:param[in]    ybendt:    multiplicative parameter for in-plane vertical
displacement at the left or right edge at the top:
y = ybendt * (2x/w - 1)^2
:param[in]    ybendb:    same as ybendt, except at the left or right edge
at the bottom
:param[in]    redleft:   1 if the red filter is on the left; 0 otherwise
:returns:  pixd   32 bpp, or NULL on error

<pre>
Notes:
(1) This function splits out the red channel, mucks around with
it, then recombines with the unmolested cyan channel.
(2) By using a quadratically increasing shift of the red
pixels horizontally and away from the vertical centerline,
the image appears to bend quadratically out of the image
plane, symmetrically with respect to the vertical center
line.  A positive value of %zbend causes the plane to be
curved away from the viewer.  We use linearly interpolated
stretching to avoid the appearance of kinks in the curve.
(3) The parameters %zshiftt and %zshiftb tilt the image plane
about a horizontal line through the center, and at the
same time move that line either in toward the viewer or away.
This is implemented by a combination of horizontal shear
about the center line (for the tilt) and horizontal
translation (to move the entire plane in or out).
A positive value of %zshiftt moves the top of the plane
away from the viewer, and a positive value of %zshiftb
moves the bottom of the plane away.  We use linear interpolated
shear to avoid visible vertical steps in the tilted image.
(4) The image can be bent in the plane and about the vertical
centerline.  The centerline does not shift, and the
parameter %ybend gives the relative shift at left and right
edges, with a downward shift for positive values of %ybend.
(6) When writing out a steroscopic (red/cyan) image in jpeg,
first call pixSetChromaSampling(pix, 0) to get sufficient
resolution in the red channel.
(7) Typical values are:
zbend = 20
zshiftt = 15
zshiftb = -15
ybendt = 30
ybendb = 0
If the disparity z-values are too large, it is difficult for
the brain to register the two images.
(8) This function has been cleverly reimplemented by Jeff Breidenbach.
The original implementation used two 32 bpp rgb images,
and merged them at the end.  The result is somewhat faded,
and has a parameter "thresh" that controls the amount of
color in the result.  (The present implementation avoids these
two problems, skipping both the colorization and the alpha
blending at the end, and is about 3x faster)
The basic operations with 32 bpp are as follows:
// Immediate conversion to 32 bpp
Pix *pixt1 = pixConvertTo32(pixs);
// Do vertical shear
Pix *pixr = pixQuadraticVerticalShear(pixt1, L_WARP_TO_RIGHT,
ybendt, ybendb,
L_BRING_IN_WHITE);
// Colorize two versions, toward red and cyan
Pix *pixc = pixCopy(NULL, pixr);
l_int32 thresh = 150;  // if higher, get less original color
pixColorGray(pixr, NULL, L_PAINT_DARK, thresh, 255, 0, 0);
pixColorGray(pixc, NULL, L_PAINT_DARK, thresh, 0, 255, 255);
// Shift the red pixels; e.g., by stretching
Pix *pixrs = pixStretchHorizontal(pixr, L_WARP_TO_RIGHT,
L_QUADRATIC_WARP, zbend,
L_INTERPOLATED,
L_BRING_IN_WHITE);
// Blend the shifted red and unshifted cyan 50:50
Pix *pixg = pixCreate(w, h, 8);
pixSetAllArbitrary(pixg, 128);
pixd = pixBlendWithGrayMask(pixrs, pixc, pixg, 0, 0);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWarpStereoscopic(*args)
    
    

    try:
        leptonica.pixStretchHorizontal.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStretchHorizontal.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixStretchHorizontal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStretchHorizontal(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'type')       
('l_int32', 'hmax')       
('l_int32', 'operation')       
('l_int32', 'incolor')       

:param[in]    pixs:        1, 8 or 32 bpp
:param[in]    dir:         L_WARP_TO_LEFT or L_WARP_TO_RIGHT
:param[in]    type:        L_LINEAR_WARP or L_QUADRATIC_WARP
:param[in]    hmax:        horizontal displacement at edge
:param[in]    operation:   L_SAMPLED or L_INTERPOLATED
:param[in]    incolor:     L_BRING_IN_WHITE or L_BRING_IN_BLACK
:returns:  pixd   stretched/compressed, or NULL on error

<pre>
Notes:
(1) If %hmax > 0, this is an increase in the coordinate value of
pixels in pixd, relative to the same pixel in pixs.
(2) If %dir == L_WARP_TO_LEFT, the pixels on the right edge of
the image are not moved. So, for example, if %hmax > 0
and %dir == L_WARP_TO_LEFT, the pixels in pixd are
contracted toward the right edge of the image, relative
to those in pixs.
(3) If %type == L_LINEAR_WARP, the pixel positions are moved
to the left or right by an amount that varies linearly with
the horizontal location.
(4) If %operation == L_SAMPLED, the dest pixels are taken from
the nearest src pixel.  Otherwise, we use linear interpolation
between pairs of sampled pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixStretchHorizontal(*args)
    
    

    try:
        leptonica.pixStretchHorizontalSampled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStretchHorizontalSampled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixStretchHorizontalSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStretchHorizontalSampled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'type')       
('l_int32', 'hmax')       
('l_int32', 'incolor')       

:param[in]    pixs:      1, 8 or 32 bpp
:param[in]    dir:       L_WARP_TO_LEFT or L_WARP_TO_RIGHT
:param[in]    type:      L_LINEAR_WARP or L_QUADRATIC_WARP
:param[in]    hmax:      horizontal displacement at edge
:param[in]    incolor:   L_BRING_IN_WHITE or L_BRING_IN_BLACK
:returns:  pixd   stretched/compressed, or NULL on error

<pre>
Notes:
(1) See pixStretchHorizontal() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixStretchHorizontalSampled(*args)
    
    

    try:
        leptonica.pixStretchHorizontalLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStretchHorizontalLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixStretchHorizontalLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStretchHorizontalLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'type')       
('l_int32', 'hmax')       
('l_int32', 'incolor')       

:param[in]    pixs:      1, 8 or 32 bpp
:param[in]    dir:       L_WARP_TO_LEFT or L_WARP_TO_RIGHT
:param[in]    type:      L_LINEAR_WARP or L_QUADRATIC_WARP
:param[in]    hmax:      horizontal displacement at edge
:param[in]    incolor:   L_BRING_IN_WHITE or L_BRING_IN_BLACK
:returns:  pixd   stretched/compressed, or NULL on error

<pre>
Notes:
(1) See pixStretchHorizontal() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixStretchHorizontalLI(*args)
    
    

    try:
        leptonica.pixQuadraticVShear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuadraticVShear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixQuadraticVShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadraticVShear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'vmaxt')       
('l_int32', 'vmaxb')       
('l_int32', 'operation')       
('l_int32', 'incolor')       

:param[in]    pixs:        1, 8 or 32 bpp
:param[in]    dir:         L_WARP_TO_LEFT or L_WARP_TO_RIGHT
:param[in]    vmaxt:       max vertical displacement at edge and at top
:param[in]    vmaxb:       max vertical displacement at edge and at bottom
:param[in]    operation:   L_SAMPLED or L_INTERPOLATED
:param[in]    incolor:     L_BRING_IN_WHITE or L_BRING_IN_BLACK
:returns:  pixd   stretched, or NULL on error

<pre>
Notes:
(1) This gives a quadratic bending, upward or downward, as you
move to the left or right.
(2) If %dir == L_WARP_TO_LEFT, the right edge is unchanged, and
the left edge pixels are moved maximally up or down.
(3) Parameters %vmaxt and %vmaxb control the maximum amount of
vertical pixel shear at the top and bottom, respectively.
If %vmaxt > 0, the vertical displacement of pixels at the
top is downward.  Likewise, if %vmaxb > 0, the vertical
displacement of pixels at the bottom is downward.
(4) If %operation == L_SAMPLED, the dest pixels are taken from
the nearest src pixel.  Otherwise, we use linear interpolation
between pairs of sampled pixels.
(5) This is for quadratic shear.  For uniform (linear) shear,
use the standard shear operators.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadraticVShear(*args)
    
    

    try:
        leptonica.pixQuadraticVShearSampled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuadraticVShearSampled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixQuadraticVShearSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadraticVShearSampled(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'vmaxt')       
('l_int32', 'vmaxb')       
('l_int32', 'incolor')       

:param[in]    pixs:      1, 8 or 32 bpp
:param[in]    dir:       L_WARP_TO_LEFT or L_WARP_TO_RIGHT
:param[in]    vmaxt:     max vertical displacement at edge and at top
:param[in]    vmaxb:     max vertical displacement at edge and at bottom
:param[in]    incolor:   L_BRING_IN_WHITE or L_BRING_IN_BLACK
:returns:  pixd   stretched, or NULL on error

<pre>
Notes:
(1) See pixQuadraticVShear() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadraticVShearSampled(*args)
    
    

    try:
        leptonica.pixQuadraticVShearLI.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixQuadraticVShearLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixQuadraticVShearLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadraticVShearLI(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'vmaxt')       
('l_int32', 'vmaxb')       
('l_int32', 'incolor')       

:param[in]    pixs:      8 or 32 bpp, or colormapped
:param[in]    dir:       L_WARP_TO_LEFT or L_WARP_TO_RIGHT
:param[in]    vmaxt:     max vertical displacement at edge and at top
:param[in]    vmaxb:     max vertical displacement at edge and at bottom
:param[in]    incolor:   L_BRING_IN_WHITE or L_BRING_IN_BLACK
:returns:  pixd   stretched, or NULL on error

<pre>
Notes:
(1) See pixQuadraticVShear() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadraticVShearLI(*args)
    
    

    try:
        leptonica.pixStereoFromPair.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixStereoFromPair.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixStereoFromPair not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStereoFromPair(*args):
        """
        ('PIX', '*pix1')       
('PIX', '*pix2')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       

:param[in]    pix1:   32 bpp rgb
:param[in]    pix2:   32 bpp rgb
:param[in]    rwt,: gwt, bwt   weighting factors used for each component in
pix1 to determine the output red channel
:returns:  pixd   stereo enhanced, or NULL on error

<pre>
Notes:
(1) pix1 and pix2 are a pair of stereo images, ideally taken
concurrently in the same plane, with some lateral translation.
(2) The output red channel is determined from %pix1.
The output green and blue channels are taken from the green
and blue channels, respectively, of %pix2.
(3) The weights determine how much of each component in %pix1
goes into the output red channel.  The sum of weights
must be 1.0.  If it's not, we scale the weights to
satisfy this criterion.
(4) The most general pixel mapping allowed here is:
rval = rwt * r1 + gwt * g1 + bwt * b1  (from pix1)
gval = g2   (from pix2)
bval = b2   (from pix2)
(5) The simplest method is to use rwt = 1.0, gwt = 0.0, bwt = 0.0,
but this causes unpleasant visual artifacts with red in the image.
Use of green and blue from %pix1 in the red channel,
instead of red, tends to fix that problem.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixStereoFromPair(*args)
    




class jpegio(object):
    """<pre>

Read jpeg from file
PIX             *pixReadJpeg()  [special top level]
PIX             *pixReadStreamJpeg()

Read jpeg metadata from file
l_int32          readHeaderJpeg()
l_int32          freadHeaderJpeg()
l_int32          fgetJpegResolution()
l_int32          fgetJpegComment()

Write jpeg to file
l_int32          pixWriteJpeg()  [special top level]
l_int32          pixWriteStreamJpeg()

Read/write to memory
PIX             *pixReadMemJpeg()
l_int32          readHeaderMemJpeg()
l_int32          readResolutionMemJpeg()
l_int32          pixWriteMemJpeg()

Setting special flag for chroma sampling on write
l_int32          pixSetChromaSampling()

Static system helpers
static void      jpeg_error_catch_all_1()
static void      jpeg_error_catch_all_2()
static l_uint8   jpeg_getc()
static l_int32   jpeg_comment_callback()

Documentation: libjpeg.doc can be found, along with all
source code, at ftp://ftp.uu.net/graphics/jpeg
Download and untar the file:  jpegsrc.v6b.tar.gz
A good paper on jpeg can also be found there: wallace.ps.gz

The functions in libjpeg make it very simple to compress
and decompress images.  On input (decompression from file),
3 component color images can be read into either an 8 bpp Pix
with a colormap or a 32 bpp Pix with RGB components.  For output
(compression to file), all color Pix, whether 8 bpp with a
colormap or 32 bpp, are written compressed as a set of three
8 bpp (rgb) images.

Low-level error handling
------------------------
The default behavior of the jpeg library is to call exit.
This is often undesirable, and the caller should make the
decision when to abort a process.  To prevent the jpeg library
from calling exit(), setjmp() has been inserted into all
readers and writers, and the cinfo struct has been set up so that
the low-level jpeg library will call a special error handler
that doesn't exit, instead of the default function error_exit().

To avoid race conditions and make these functions thread-safe in
the rare situation where calls to two threads are simultaneously
failing on bad jpegs, we insert a local copy of the jmp_buf struct
into the cinfo.client_data field, and use this on longjmp.
For extracting the jpeg comment, we have the added complication
that the client_data field must also return the jpeg comment,
and we use a different error handler.

How to avoid subsampling the chroma channels
--------------------------------------------
When writing, you can avoid subsampling the U,V (chroma)
channels.  This gives higher quality for the color, which is
important for some situations.  The default subsampling is 2x2 on
both channels.  Before writing, call pixSetChromaSampling(pix, 0)
to prevent chroma subsampling.

How to extract just the luminance channel in reading RGB
--------------------------------------------------------
For higher resolution and faster decoding of an RGB image, you
can extract just the 8 bpp luminance channel, using pixReadJpeg(),
where you use L_JPEG_READ_LUMINANCE for the %hint arg.

How to fail to read if the data is corrupted
---------------------------------------------
By default, if the low-level jpeg library functions do not abort,
a pix will be returned, even if the data is corrupted and warnings
are issued.  In order to be most likely to fail to read when there
is data corruption, use L_JPEG_FAIL_ON_BAD_DATA in the %hint arg.

Compressing to memory and decompressing from memory
---------------------------------------------------
On systems like windows without fmemopen() and open_memstream(),
we write data to a temp file and read it back for operations
between pix and compressed-data, such as pixReadMemJpeg() and
pixWriteMemJpeg().

Vestigial code: parsing the jpeg file for header metadata
---------------------------------------------------------
For extracting header metadata, we previously parsed the file, looking
for specific markers.  This is error-prone because of non-standard
jpeg files, and we now use readHeaderJpeg() and readHeaderMemJpeg().
The vestigial code is retained in jpegio_notused.c to help you
understand a bit about how to parse jpeg markers.  It is not compiled
into the library.
</pre>




"""
    
    try:
        leptonica.pixReadJpeg.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadJpeg.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadJpeg(*args):
        """
        ('const char', '*filename')       
('l_int32', 'cmapflag')       
('l_int32', 'reduction')       
('l_int32', '*pnwarn')       
('l_int32', 'hint')       

:param[in]    filename:
:param[in]    cmapflag:   0 for no colormap in returned pix;
1 to return an 8 bpp cmapped pix if spp = 3 or 4
:param[in]    reduction:  scaling factor: 1, 2, 4 or 8
:param[out]   pnwarn:     [optional] number of warnings about
corrupted data
:param[in]    hint:       a bitwise OR of L_JPEG_* values; 0 for default
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This is a special function for reading jpeg files.
(2) Use this if you want the jpeg library to create
an 8 bpp colormapped image.
(3) Images reduced by factors of 2, 4 or 8 can be returned
significantly faster than full resolution images.
(4) If the jpeg data is bad, the jpeg library will continue
silently, or return warnings, or attempt to exit.  Depending
on the severity of the data corruption, there are two possible
outcomes:
(a) a possibly damaged pix can be generated, along with zero
or more warnings, or
(b) the library will attempt to exit (caught by our error
handler) and no pix will be returned.
If a pix is generated with at least one warning of data
corruption, and if L_JPEG_FAIL_ON_BAD_DATA is included in %hint,
no pix will be returned.
(5) The possible hint values are given in the enum in imageio.h:
L_JPEG_READ_LUMINANCE
L_JPEG_FAIL_ON_BAD_DATA
Default (0) is to do neither.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadJpeg(*args)
    
    

    try:
        leptonica.pixReadStreamJpeg.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadStreamJpeg.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamJpeg(*args):
        """
        ('FILE', '*fp')       
('l_int32', 'cmapflag')       
('l_int32', 'reduction')       
('l_int32', '*pnwarn')       
('l_int32', 'hint')       

:param[in]    fp:         file stream
:param[in]    cmapflag:   0 for no colormap in returned pix;
1 to return an 8 bpp cmapped pix if spp = 3 or 4
:param[in]    reduction:  scaling factor: 1, 2, 4 or 8
:param[out]   pnwarn:     [optional] number of warnings
:param[in]    hint:       a bitwise OR of L_JPEG_* values; 0 for default
:returns:  pix, or NULL on error

Usage: see pixReadJpeg
<pre>
Notes:
(1) The jpeg comment, if it exists, is not stored in the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamJpeg(*args)
    
    

    try:
        leptonica.readHeaderJpeg.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderJpeg(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
('l_int32', '*pycck')       
('l_int32', '*pcmyk')       

:param[in]    filename:
:param[out]   pw:     [optional]
:param[out]   ph:     [optional]
:param[out]   pspp:   [optional] samples/pixel
:param[out]   pycck:  [optional] 1 if ycck color space; 0 otherwise
:param[out]   pcmyk:  [optional] 1 if cmyk color space; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderJpeg(*args)
    
    

    try:
        leptonica.freadHeaderJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function freadHeaderJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderJpeg(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
('l_int32', '*pycck')       
('l_int32', '*pcmyk')       

:param[in]    fp:     file stream
:param[out]   pw:     [optional]
:param[out]   ph:     [optional]
:param[out]   pspp:   [optional]  samples/pixel
:param[out]   pycck:  [optional]  1 if ycck color space; 0 otherwise
:param[out]   pcmyk:  [optional]  1 if cmyk color space; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderJpeg(*args)
    
    

    try:
        leptonica.pixWriteJpeg.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteJpeg(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'progressive')       

:param[in]    filename:
:param[in]    pix:           any depth; cmap is OK
:param[in]    quality:       1 - 100; 75 is default
:param[in]    progressive:   0 for baseline sequential; 1 for progressive
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteJpeg(*args)
    
    

    try:
        leptonica.pixWriteStreamJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteStreamJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamJpeg(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'progressive')       

:param[in]    fp:           file stream
:param[in]    pixs:         any depth; cmap is OK
:param[in]    quality:      1 - 100; 75 is default value; 0 is also default
:param[in]    progressive:  0 for baseline sequential; 1 for progressive
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Progressive encoding gives better compression, at the
expense of slower encoding and decoding.
(2) Standard chroma subsampling is 2x2 on both the U and V
channels.  For highest quality, use no subsampling; this
option is set by pixSetChromaSampling(pix, 0).
(3) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
and 32 bpp.  However, it is possible, and in some cases desirable,
to write out a jpeg file using an rgb pix that has 24 bpp.
This can be created by appending the raster data for a 24 bpp
image (with proper scanline padding) directly to a 24 bpp
pix that was created without a data array.
(4) There are two compression paths in this function:
Grayscale image, no colormap: compress as 8 bpp image.
rgb full color image: copy each line into the color
line buffer, and compress as three 8 bpp images.
(5) Under the covers, the jpeg library transforms rgb to a
luminance-chromaticity triple, each component of which is
also 8 bits, and compresses that.  It uses 2 Huffman tables,
a higher resolution one (with more quantization levels)
for luminosity and a lower resolution one for the chromas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamJpeg(*args)
    
    

    try:
        leptonica.pixReadMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixReadMemJpeg.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemJpeg(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', 'cmflag')       
('l_int32', 'reduction')       
('l_int32', '*pnwarn')       
('l_int32', 'hint')       

:param[in]    data:       const; jpeg-encoded
:param[in]    size:       of data
:param[in]    cmflag:     colormap flag 0 means return RGB image if color;
1 means create a colormap and return
an 8 bpp colormapped image if color
:param[in]    reduction:  scaling factor: 1, 2, 4 or 8
:param[out]   pnwarn:     [optional] number of warnings
:param[in]    hint:       a bitwise OR of L_JPEG_* values; 0 for default
:returns:  pix, or NULL on error

<pre>
Notes:
(1) The %size byte of %data must be a null character.
(2) The only hint flag so far is L_JPEG_READ_LUMINANCE,
given in the enum in imageio.h.
(3) See pixReadJpeg() for usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemJpeg(*args)
    
    

    try:
        leptonica.readHeaderMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemJpeg(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       
('l_int32', '*pycck')       
('l_int32', '*pcmyk')       

:param[in]    data:    const; jpeg-encoded
:param[in]    size:    of data
:param[out]   pw:      [optional] width
:param[out]   ph:      [optional] height
:param[out]   pspp:    [optional] samples/pixel
:param[out]   pycck:   [optional] 1 if ycck color space; 0 otherwise
:param[out]   pcmyk:   [optional] 1 if cmyk color space; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemJpeg(*args)
    
    

    try:
        leptonica.readResolutionMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readResolutionMemJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readResolutionMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readResolutionMemJpeg(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       

:param[in]   data:    const; jpeg-encoded
:param[in]   size:    of data
:param[out]  pxres:   [optional]
:param[out]  pyres:   [optional]
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readResolutionMemJpeg(*args)
    
    

    try:
        leptonica.pixWriteMemJpeg.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteMemJpeg.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemJpeg not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemJpeg(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'progressive')       

:param[out]   pdata:        data of jpeg compressed image
:param[out]   psize:        size of returned data
:param[in]    pix:          any depth; cmap is OK
:param[in]    quality:      1 - 100; 75 is default value; 0 is also default
:param[in]    progressive:  0 for baseline sequential; 1 for progressive
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteStreamJpeg() for usage.  This version writes to
memory instead of to a file stream.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemJpeg(*args)
    
    

    try:
        leptonica.pixSetChromaSampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetChromaSampling.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetChromaSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetChromaSampling(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'sampling')       

:param[in]    pix:
:param[in]    sampling:    1 for subsampling; 0 for no subsampling
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The default is for 2x2 chroma subsampling because the files are
considerably smaller and the appearance is typically satisfactory.
To get full resolution output in the chroma channels for
jpeg writing, call this with %sampling == 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetChromaSampling(*args)
    




class pixafunc2(object):
    """<pre>

Pixa display (render into a pix)
PIX      *pixaDisplay()
PIX      *pixaDisplayRandomCmap()
PIX      *pixaDisplayLinearly()
PIX      *pixaDisplayOnLattice()
PIX      *pixaDisplayUnsplit()
PIX      *pixaDisplayTiled()
PIX      *pixaDisplayTiledInRows()
PIX      *pixaDisplayTiledInColumns()
PIX      *pixaDisplayTiledAndScaled()
PIX      *pixaDisplayTiledWithText()
PIX      *pixaDisplayTiledByIndex()

Pixaa display (render into a pix)
PIX      *pixaaDisplay()
PIX      *pixaaDisplayByPixa()
PIXA     *pixaaDisplayTiledAndScaled()

Conversion of all pix to specified type (e.g., depth)
PIXA     *pixaConvertTo1()
PIXA     *pixaConvertTo8()
PIXA     *pixaConvertTo8Colormap()
PIXA     *pixaConvertTo32()

Pixa constrained selection and pdf generation
PIXA     *pixaConstrainedSelect()
l_int32   pixaSelectToPdf()

Generate pixa from tiled images
PIXA     *pixaMakeFromTiledPixa()
PIXA     *pixaMakeFromTiledPix()
l_int32   pixGetTileCount()

Pixa display into multiple tiles
PIXA     *pixaDisplayMultiTiled()

Split pixa into files
l_int32   pixaSplitIntoFiles()

Tile N-Up
l_int32   convertToNUpFiles()
PIXA     *convertToNUpPixa()
PIXA     *pixaConvertToNUpPixa()

Render two pixa side-by-side for comparison
l_int32   pixaCompareInPdf()

We give twelve pixaDisplay*() methods for tiling a pixa in a pix.
Some work for 1 bpp input; others for any input depth.
Some give an output depth that depends on the input depth;
others give a different output depth or allow you to choose it.
Some use a boxes to determine where each pix goes; others tile
onto a regular lattice; others tile onto an irregular lattice;
one uses an associated index array to determine which column
each pix goes into.

Here is a brief description of what the pixa display functions do.

pixaDisplay()
This uses the boxes in the pixa to lay out each pix.  This
can be used to reconstruct a pix that has been broken into
components, if the boxes represents the positions of the
components in the original image.
pixaDisplayRandomCmap()
This also uses the boxes to lay out each pix.  However, it creates
a colormapped dest, where each 1 bpp pix is given a randomly
generated color (up to 256 are used).
pixaDisplayLinearly()
This puts each pix, sequentially, in a line, either horizontally
or vertically.
pixaDisplayOnLattice()
This puts each pix, sequentially, onto a regular lattice,
omitting any pix that are too big for the lattice size.
This is useful, for example, to store bitmapped fonts,
where all the characters are stored in a single image.
pixaDisplayUnsplit()
This lays out a mosaic of tiles (the pix in the pixa) that
are all of equal size.  (Don't use this for unequal sized pix!)
For example, it can be used to invert the action of
pixaSplitPix().
pixaDisplayTiled()
Like pixaDisplayOnLattice(), this places each pix on a regular
lattice, but here the lattice size is determined by the
largest component, and no components are omitted.  This is
dangerous if there are thousands of small components and
one or more very large one, because the size of the resulting
pix can be huge!
pixaDisplayTiledInRows()
This puts each pix down in a series of rows, where the upper
edges of each pix in a row are aligned and there is a uniform
spacing between the pix.  The height of each row is determined
by the tallest pix that was put in the row.  This function
is a reasonably efficient way to pack the subimages.
A boxa of the locations of each input pix is stored in the output.
pixaDisplayTiledInColumns()
This puts each pix down in a series of rows, each row having
a specified number of pix.  The upper edges of each pix in a
row are aligned and there is a uniform spacing between the pix.
The height of each row is determined by the tallest pix that
was put in the row.  A boxa of the locations of each input
pix is stored in the output.
pixaDisplayTiledAndScaled()
This scales each pix to a given width and output depth, and then
tiles them in rows with a given number placed in each row.
This is useful for presenting a sequence of images that can be
at different resolutions, but which are derived from the same
initial image.
pixaDisplayTiledWithText()
This is a version of pixaDisplayTiledInRows() that prints, below
each pix, the text in the pix text field.  It renders a pixa
to an image with white background that does not exceed a
given value in width.
pixaDisplayTiledByIndex()
This scales each pix to a given width and output depth,
and then tiles them in columns corresponding to the value
in an associated numa.  All pix with the same index value are
rendered in the same column.  Text in the pix text field are
rendered below the pix.

To render mosaics of images in a pixaa, display functions are
provided that handle situations where the images are all scaled to
the same size, or the number of images on each row needs to vary.
</pre>




"""
    
    try:
        leptonica.pixaDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplay.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplay(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    pixa:
:param[in]    w,: h    if set to 0, the size is determined from the
bounding box of the components in pixa
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This uses the boxes to place each pix in the rendered composite.
(2) Set w = h = 0 to use the b.b. of the components to determine
the size of the returned pix.
(3) Uses the first pix in pixa to determine the depth.
(4) The background is written "white".  On 1 bpp, each successive
pix is "painted" (adding foreground), whereas for grayscale
or color each successive pix is blitted with just the src.
(5) If the pixa is empty, returns an empty 1 bpp pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplay(*args)
    
    

    try:
        leptonica.pixaDisplayRandomCmap.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayRandomCmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayRandomCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayRandomCmap(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    pixa:    1 bpp regions, with boxa delineating those regions
:param[in]    w,: h    if set to 0, the size is determined from the
bounding box of the components in pixa
:returns:  pix   8 bpp, cmapped, with random colors assigned to each region,
or NULL on error.

<pre>
Notes:
(1) This uses the boxes to place each pix in the rendered composite.
The fg of each pix in %pixa, such as a single connected
component or a line of text, is given a random color.
(2) By default, the background color is black (cmap index 0).
This can be changed by pixcmapResetColor()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayRandomCmap(*args)
    
    

    try:
        leptonica.pixaDisplayLinearly.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaDisplayLinearly.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayLinearly not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayLinearly(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'direction')       
('l_float32', 'scalefactor')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('BOXA', '**pboxa')       

:param[in]    pixas:
:param[in]    direction:    L_HORIZ or L_VERT
:param[in]    scalefactor:  applied to every pix; use 1.0 for no scaling
:param[in]    background:   0 for white, 1 for black; this is the color
of the spacing between the images
:param[in]    spacing:      between images, and on outside
:param[in]    border:       width of black border added to each image;
use 0 for no border
:param[out]   pboxa:        [optional] location of images in output pix
:returns:  pix of composite images, or NULL on error

<pre>
Notes:
(1) This puts each pix, sequentially, in a line, either horizontally
or vertically.
(2) If any pix has a colormap, all pix are rendered in rgb.
(3) The boxa gives the location of each image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayLinearly(*args)
    
    

    try:
        leptonica.pixaDisplayOnLattice.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaDisplayOnLattice.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayOnLattice not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayOnLattice(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'cellw')       
('l_int32', 'cellh')       
('l_int32', '*pncols')       
('BOXA', '**pboxa')       

:param[in]    pixa:
:param[in]    cellw:    lattice cell width
:param[in]    cellh:    lattice cell height
:param[out]   pncols:   [optional] number of columns in output lattice
:param[out]   pboxa:    [optional] location of images in lattice
:returns:  pix of composite images, or NULL on error

<pre>
Notes:
(1) This places each pix on sequentially on a regular lattice
in the rendered composite.  If a pix is too large to fit in the
allocated lattice space, it is not rendered.
(2) If any pix has a colormap, all pix are rendered in rgb.
(3) This is useful when putting bitmaps of components,
such as characters, into a single image.
(4) Save the number of tiled images in the text field of the pix,
in the format: n = %d.  This survives write/read into png files,
for example.
(5) The boxa gives the location of each image.  The UL corner
of each image is on a lattice cell corner.  Omitted images
(due to size) are assigned an invalid width and height of 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayOnLattice(*args)
    
    

    try:
        leptonica.pixaDisplayUnsplit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaDisplayUnsplit.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayUnsplit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayUnsplit(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'borderwidth')       
('l_uint32', 'bordercolor')       

:param[in]    pixa:
:param[in]    nx:           number of mosaic cells horizontally
:param[in]    ny:           number of mosaic cells vertically
:param[in]    borderwidth:  of added border on all sides
:param[in]    bordercolor:  in our RGBA format: 0xrrggbbaa
:returns:  pix of tiled images, or NULL on error

<pre>
Notes:
(1) This is a logical inverse of pixaSplitPix().  It
constructs a pix from a mosaic of tiles, all of equal size.
(2) For added generality, a border of arbitrary color can
be added to each of the tiles.
(3) In use, pixa will typically have either been generated
from pixaSplitPix() or will derived from a pixa that
was so generated.
(4) All pix in the pixa must be of equal depth, and, if
colormapped, have the same colormap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayUnsplit(*args)
    
    

    try:
        leptonica.pixaDisplayTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiled(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'maxwidth')       
('l_int32', 'background')       
('l_int32', 'spacing')       

:param[in]    pixa:
:param[in]    maxwidth:     of output image
:param[in]    background:   0 for white, 1 for black
:param[in]    spacing:
:returns:  pix of tiled images, or NULL on error

<pre>
Notes:
(1) This renders a pixa to a single image of width not to
exceed maxwidth, with background color either white or black,
and with each subimage spaced on a regular lattice.
(2) The lattice size is determined from the largest width and height,
separately, of all pix in the pixa.
(3) All pix in the pixa must be of equal depth.
(4) If any pix has a colormap, all pix are rendered in rgb.
(5) Careful: because no components are omitted, this is
dangerous if there are thousands of small components and
one or more very large one, because the size of the
resulting pix can be huge!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiled(*args)
    
    

    try:
        leptonica.pixaDisplayTiledInRows.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiledInRows.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayTiledInRows not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledInRows(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'outdepth')       
('l_int32', 'maxwidth')       
('l_float32', 'scalefactor')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    pixa:
:param[in]    outdepth:     output depth: 1, 8 or 32 bpp
:param[in]    maxwidth:     of output image
:param[in]    scalefactor:  applied to every pix; use 1.0 for no scaling
:param[in]    background:   0 for white, 1 for black; this is the color
of the spacing between the images
:param[in]    spacing:      between images, and on outside
:param[in]    border:       width of black border added to each image;
use 0 for no border
:returns:  pixd of tiled images, or NULL on error

<pre>
Notes:
(1) This renders a pixa to a single image of width not to
exceed maxwidth, with background color either white or black,
and with each row tiled such that the top of each pix is
aligned and separated by 'spacing' from the next one.
A black border can be added to each pix.
(2) All pix are converted to outdepth; existing colormaps are removed.
(3) This does a reasonably spacewise-efficient job of laying
out the individual pix images into a tiled composite.
(4) A serialized boxa giving the location in pixd of each input
pix (without added border) is stored in the text string of pixd.
This allows, e.g., regeneration of a pixa from pixd, using
pixaCreateFromBoxa().  If there is no scaling and the depth of
each input pix in the pixa is the same, this tiling operation
can be inverted using the boxa (except for loss of text in
each of the input pix):
pix1 = pixaDisplayTiledInRows(pixa1, 1, 1500, 1.0, 0, 30, 0);
char *boxatxt = pixGetText(pix1);
boxa1 = boxaReadMem((l_uint8 *)boxatxt, strlen(boxatxt));
pixa2 = pixaCreateFromBoxa(pix1, boxa1, 0, 0, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledInRows(*args)
    
    

    try:
        leptonica.pixaDisplayTiledInColumns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiledInColumns.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayTiledInColumns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledInColumns(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'nx')       
('l_float32', 'scalefactor')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    pixas:
:param[in]    nx:           number of columns in output image
:param[in]    scalefactor:  applied to every pix; use 1.0 for no scaling
:param[in]    spacing:      between images, and on outside
:param[in]    border:       width of black border added to each image;
use 0 for no border
:returns:  pixd of tiled images, or NULL on error

<pre>
Notes:
(1) This renders a pixa to a single image with &nx columns of
subimages.  The background color is white, and each row
is tiled such that the top of each pix is aligned and
each pix is separated by 'spacing' from the next one.
A black border can be added to each pix.
(2) The output depth is determined by the largest depth
required by the pix in the pixa.  Colormaps are removed.
(3) A serialized boxa giving the location in pixd of each input
pix (without added border) is stored in the text string of pixd.
This allows, e.g., regeneration of a pixa from pixd, using
pixaCreateFromBoxa().  If there is no scaling and the depth of
each input pix in the pixa is the same, this tiling operation
can be inverted using the boxa (except for loss of text in
each of the input pix):
pix1 = pixaDisplayTiledInColumns(pixa1, 3, 1.0, 0, 30, 2);
char *boxatxt = pixGetText(pix1);
boxa1 = boxaReadMem((l_uint8 *)boxatxt, strlen(boxatxt));
pixa2 = pixaCreateFromBoxa(pix1, boxa1, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledInColumns(*args)
    
    

    try:
        leptonica.pixaDisplayTiledAndScaled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayTiledAndScaled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayTiledAndScaled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledAndScaled(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'outdepth')       
('l_int32', 'tilewidth')       
('l_int32', 'ncols')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    pixa:
:param[in]    outdepth:    output depth: 1, 8 or 32 bpp
:param[in]    tilewidth:   each pix is scaled to this width
:param[in]    ncols:       number of tiles in each row
:param[in]    background:  0 for white, 1 for black; this is the color
of the spacing between the images
:param[in]    spacing:     between images, and on outside
:param[in]    border:      width of additional black border on each image;
use 0 for no border
:returns:  pix of tiled images, or NULL on error

<pre>
Notes:
(1) This can be used to tile a number of renderings of
an image that are at different scales and depths.
(2) Each image, after scaling and optionally adding the
black border, has width 'tilewidth'.  Thus, the border does
not affect the spacing between the image tiles.  The
maximum allowed border width is tilewidth / 5.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledAndScaled(*args)
    
    

    try:
        leptonica.pixaDisplayTiledWithText.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaDisplayTiledWithText.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayTiledWithText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledWithText(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'maxwidth')       
('l_float32', 'scalefactor')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('l_int32', 'fontsize')       
('l_uint32', 'textcolor')       

:param[in]    pixa:
:param[in]    maxwidth:     of output image
:param[in]    scalefactor:  applied to every pix; use 1.0 for no scaling
:param[in]    spacing:      between images, and on outside
:param[in]    border:       width of black border added to each image;
use 0 for no border
:param[in]    fontsize:     4, 6, ... 20
:param[in]    textcolor:    0xrrggbb00
:returns:  pixd of tiled images, or NULL on error

<pre>
Notes:
(1) This is a version of pixaDisplayTiledInRows() that prints, below
each pix, the text in the pix text field.  Up to 127 chars
of text in the pix text field are rendered below each pix.
(2) It renders a pixa to a single image of width not to
exceed %maxwidth, with white background color, with each row
tiled such that the top of each pix is aligned and separated
by %spacing from the next one.
(3) All pix are converted to 32 bpp.
(4) This does a reasonably spacewise-efficient job of laying
out the individual pix images into a tiled composite.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledWithText(*args)
    
    

    try:
        leptonica.pixaDisplayTiledByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixaDisplayTiledByIndex.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayTiledByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayTiledByIndex(*args):
        """
        ('PIXA', '*pixa')       
('NUMA', '*na')       
('l_int32', 'width')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('l_int32', 'fontsize')       
('l_uint32', 'textcolor')       

:param[in]    pixa:
:param[in]    na:         numa with indices corresponding to the pix in pixa
:param[in]    width:      each pix is scaled to this width
:param[in]    spacing:    between images, and on outside
:param[in]    border:     width of black border added to each image;
use 0 for no border
:param[in]    fontsize:   4, 6, ... 20
:param[in]    textcolor:  0xrrggbb00
:returns:  pixd of tiled images, or NULL on error

<pre>
Notes:
(1) This renders a pixa to a single image with white
background color, where the pix are placed in columns
given by the index value in the numa.  Each pix
is separated by %spacing from the adjacent ones, and
an optional border is placed around them.
(2) Up to 127 chars of text in the pix text field are rendered
below each pix.  Use newlines in the text field to write
the text in multiple lines that fit within the pix width.
(3) To avoid having empty columns, if there are N different
index values, they should be in [0 ... N-1].
(4) All pix are converted to 32 bpp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayTiledByIndex(*args)
    
    

    try:
        leptonica.pixaaDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaDisplay.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDisplay(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    paa:
:param[in]    w,: h   if set to 0, the size is determined from the
bounding box of the components in pixa
:returns:  pix, or NULL on error

<pre>
Notes:
(1) Each pix of the paa is displayed at the location given by
its box, translated by the box of the containing pixa
if it exists.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDisplay(*args)
    
    

    try:
        leptonica.pixaaDisplayByPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaDisplayByPixa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaDisplayByPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDisplayByPixa(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'maxnx')       
('l_float32', 'scalefactor')       
('l_int32', 'hspacing')       
('l_int32', 'vspacing')       
('l_int32', 'border')       

:param[in]    paa:
:param[in]    maxnx:        maximum number of columns for rendering each pixa
:param[in]    scalefactor:  applied to every pix; use 1.0 for no scaling
:param[in]    hspacing:     between images on a row (in the pixa)
:param[in]    vspacing:     between tiles rows, each corresponding to a pixa
:param[in]    border:       width of black border added to each image;
use 0 for no border
:returns:  pixd of images in %paa, tiled by pixa in row-major order

<pre>
Notes:
(1) This renders a pixaa into a single image.  The pix from each pixa
are rendered on a row.  If the number of pix in the pixa is
larger than %maxnx, the pix will be rendered into more than 1 row.
To insure that each pixa is rendered into one row, use %maxnx
at least as large as the max number of pix in the pixa.
(2) Each row is tiled such that the top of each pix is aligned and
each pix is separated by %hspacing from the next one.
A black border can be added to each pix.
(3) The resulting pix from each row are then rendered vertically,
separated by %vspacing from each other.
(4) The output depth is determined by the largest depth of all
the pix in %paa. Colormaps are removed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDisplayByPixa(*args)
    
    

    try:
        leptonica.pixaaDisplayTiledAndScaled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaaDisplayTiledAndScaled.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaaDisplayTiledAndScaled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaaDisplayTiledAndScaled(*args):
        """
        ('PIXAA', '*paa')       
('l_int32', 'outdepth')       
('l_int32', 'tilewidth')       
('l_int32', 'ncols')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    paa:
:param[in]    outdepth:    output depth: 1, 8 or 32 bpp
:param[in]    tilewidth:   each pix is scaled to this width
:param[in]    ncols:       number of tiles in each row
:param[in]    background:  0 for white, 1 for black; this is the color
of the spacing between the images
:param[in]    spacing:     between images, and on outside
:param[in]    border:      width of additional black border on each image;
use 0 for no border
:returns:  pixa of tiled images, one image for each pixa in
the paa, or NULL on error

<pre>
Notes:
(1) For each pixa, this generates from all the pix a
tiled/scaled output pix, and puts it in the output pixa.
(2) See comments in pixaDisplayTiledAndScaled().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaaDisplayTiledAndScaled(*args)
    
    

    try:
        leptonica.pixaConvertTo1.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaConvertTo1.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertTo1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo1(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'thresh')       

:param[in]    pixas:
:param[in]    thresh:    threshold for final binarization from 8 bpp gray
:returns:  pixad, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo1(*args)
    
    

    try:
        leptonica.pixaConvertTo8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaConvertTo8.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertTo8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo8(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'cmapflag')       

:param[in]    pixas:
:param[in]    cmapflag:   1 to give pixd a colormap; 0 otherwise
:returns:  pixad each pix is 8 bpp, or NULL on error

<pre>
Notes:
(1) See notes for pixConvertTo8(), applied to each pix in pixas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo8(*args)
    
    

    try:
        leptonica.pixaConvertTo8Colormap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaConvertTo8Colormap.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertTo8Colormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo8Colormap(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'dither')       

:param[in]    pixas:
:param[in]    dither:   1 to dither if necessary; 0 otherwise
:returns:  pixad each pix is 8 bpp, or NULL on error

<pre>
Notes:
(1) See notes for pixConvertTo8Colormap(), applied to each pix in pixas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo8Colormap(*args)
    
    

    try:
        leptonica.pixaConvertTo32.argtypes = [ctypes.c_void_p]
        leptonica.pixaConvertTo32.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertTo32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertTo32(*args):
        """
        ('PIXA', '*pixas')       

:param[in]    pixas:
:returns:  pixad 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) See notes for pixConvertTo32(), applied to each pix in pixas.
(2) This can be used to allow 1 bpp pix in a pixa to be displayed
with color.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertTo32(*args)
    
    

    try:
        leptonica.pixaConstrainedSelect.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaConstrainedSelect.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConstrainedSelect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConstrainedSelect(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'nmax')       
('l_int32', 'use_pairs')       
('l_int32', 'copyflag')       

:param[in]    pixas:
:param[in]    first:      first index to choose; >= 0
:param[in]    last:       biggest possible index to reach;
use -1 to go to the end; otherwise, last >= first
:param[in]    nmax:       maximum number of pix to select; > 0
:param[in]    use_pairs:  1 = select pairs of adjacent pix;
0 = select individual pix
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  pixad if OK, NULL on error

<pre>
Notes:
(1) See notes in genConstrainedNumaInRange() for how selection
is made.
(2) This returns a selection of the pix in the input pixa.
(3) Use copyflag == L_COPY if you don't want changes in the pix
in the returned pixa to affect those in the input pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConstrainedSelect(*args)
    
    

    try:
        leptonica.pixaSelectToPdf.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixaSelectToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSelectToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSelectToPdf(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('l_uint32', 'color')       
('l_int32', 'fontsize')       
('const char', '*fileout')       

:param[in]    pixas:
:param[in]    first:     first index to choose; >= 0
:param[in]    last:      biggest possible index to reach;
use -1 to go to the end; otherwise, last >= first
:param[in]    res:       override the resolution of each input image, in ppi;
use 0 to respect the resolution embedded in the input
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:      encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, or 0 for default
:param[in]    quality:   used for JPEG only; 0 for default (75)
:param[in]    color:     of numbers added to each image (e.g., 0xff000000)
:param[in]    fontsize:  to print number below each image.  The valid set
is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.
:param[in]    fileout:   pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This writes a pdf of the selected images from %pixas, one to
a page.  They are optionally scaled and annotated with the
index printed to the left of the image.
(2) If the input images are 1 bpp and you want the numbers to be
in color, first promote each pix to 8 bpp with a colormap:
pixa1 = pixaConvertTo8(pixas, 1);
and then call this function with the specified color
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSelectToPdf(*args)
    
    

    try:
        leptonica.pixaMakeFromTiledPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMakeFromTiledPixa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaMakeFromTiledPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMakeFromTiledPixa(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'nsamp')       

:param[in]    pixas:    of mosaiced templates, one for each digit
:param[in]    w:        width of samples (use 0 for default = 20)
:param[in]    h:        height of samples (use 0 for default = 30)
:param[in]    nsamp:    number of requested samples (use 0 for default = 100)
:returns:  pixa of individual, scaled templates, or NULL on error

<pre>
Notes:
(1) This converts from a compressed representation of 1 bpp digit
templates to a pixa where each pix has a single labeled template.
(2) The mosaics hold 100 templates each, and the number of templates
%nsamp selected for each digit can be between 1 and 100.
(3) Each mosaic has the number of images written in the text field,
and the i-th pix contains samples of the i-th digit.  That value
is written into the text field of each template in the output.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMakeFromTiledPixa(*args)
    
    

    try:
        leptonica.pixaMakeFromTiledPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixaMakeFromTiledPix.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaMakeFromTiledPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMakeFromTiledPix(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'start')       
('l_int32', 'num')       
('BOXA', '*boxa')       

:param[in]    pixs:        any depth; colormap OK
:param[in]    w:           width of each tile
:param[in]    h:           height of each tile
:param[in]    start:       first tile to use
:param[in]    num:         number of tiles; use 0 to go to the end
:param[in]    boxa:        [optional] location of rectangular regions
to be extracted
:returns:  pixa if OK, NULL on error

<pre>
Notes:
(1) Operations that generate a pix by tiling from a pixa, and
the inverse that generate a pixa from tiles of a pix,
are useful.  One such pair is pixaDisplayUnsplit() and
pixaSplitPix().  This function is a very simple one that
generates a pixa from tiles of a pix. There are two cases:
- the tiles can all be the same size (the inverse of
pixaDisplayOnLattice(), or
- the tiles can differ in size, where there is an
associated boxa (the inverse of pixaCreateFromBoxa().
(2) If all tiles are the same size, %w by %h, use %boxa = NULL.
If the tiles differ in size, use %boxa to extract the
individual images (%w and %h are then ignored).
(3) If the pix was made by pixaDisplayOnLattice(), the number
of tiled images is written into the text field, in the format
n = <number>.
(4) Typical usage: a set of character templates all scaled to
the same size can be stored on a lattice of that size in
a pix, and this function can regenerate the pixa.  If the
templates differ in size, a boxa generated when the tiled
pix was made can be used to indicate the location of
the templates.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMakeFromTiledPix(*args)
    
    

    try:
        leptonica.pixGetTileCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetTileCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetTileCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetTileCount(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pn')       

:param[in]    pix:
:param[out]  *pn:     number embedded in pix text field
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If the pix was made by pixaDisplayOnLattice(), the number
of tiled images is written into the text field, in the format
n = <number>.
(2) This returns 0 if the data is not in the text field, or on error.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetTileCount(*args)
    
    

    try:
        leptonica.pixaDisplayMultiTiled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayMultiTiled.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayMultiTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayMultiTiled(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'maxw')       
('l_int32', 'maxh')       
('l_float32', 'scalefactor')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    pixas:
:param[in]    nx,: ny       in [1, ... 50], tiling factors in each direction
:param[in]    maxw,: maxh   max sizes to keep
:param[in]    scalefactor:  scale each image by this
:param[in]    spacing:      between images, and on outside
:param[in]    border:       width of additional black border on each image;
use 0 for no border
:returns:  pixad if OK, NULL on error

<pre>
Notes:
(1) Each set of %nx * %ny images is optionally scaled and saved
into a new pix, and then aggregated.
(2) Set %maxw = %maxh = 0 if you want to include all pix from %pixs.
(3) This is useful for generating a pdf from the output pixa, where
each page is a tile of (%nx * %ny) images from the input pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayMultiTiled(*args)
    
    

    try:
        leptonica.pixaSplitIntoFiles.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaSplitIntoFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSplitIntoFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSplitIntoFiles(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'nsplit')       
('l_float32', 'scale')       
('l_int32', 'outwidth')       
('l_int32', 'write_pixa')       
('l_int32', 'write_pix')       
('l_int32', 'write_pdf')       

:param[in]    pixas:
:param[in]    nsplit:       split pixas into this number of pixa; >= 2
:param[in]    scale:        scalefactor applied to each pix
:param[in]    outwidth:     the maxwidth parameter of tiled images
for write_pix
:param[in]    write_pixa:  1 to write the split pixa as separate files
:param[in]    write_pix:   1 to write tiled images of the split pixa
:param[in]    write_pdf:   1 to write pdfs of the split pixa
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For each requested output, %nsplit files are written into
directory /tmp/lept/split/.
(2) This is useful when a pixa is so large that the images
are not conveniently displayed as a single tiled image at
full resolution.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSplitIntoFiles(*args)
    
    

    try:
        leptonica.convertToNUpFiles.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.convertToNUpFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertToNUpFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToNUpFiles(*args):
        """
        ('const char', '*dir')       
('const char', '*substr')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'tw')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('l_int32', 'fontsize')       
('const char', '*outdir')       

:param[in]    dir:        full path to directory of images
:param[in]    substr:     [optional] can be null
:param[in]    nx,: ny     in [1, ... 50], tiling factors in each direction
:param[in]    tw:         target width, in pixels; must be >= 20
:param[in]    spacing:    between images, and on outside
:param[in]    border:     width of additional black border on each image;
use 0 for no border
:param[in]    fontsize:   to print tail of filename with image.  Valid set is
{4,6,8,10,12,14,16,18,20}.  Use 0 to disable.
:param[in]    outdir:     subdirectory of /tmp to put N-up tiled images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Each set of %nx * %ny images is scaled and tiled into a single
image, that is written out to %outdir.
(2) All images in each %nx * %ny set are scaled to the same
width, %tw.  This is typically used when all images are
roughly the same size.
(3) This is useful for generating a pdf from the set of input
files, where each page is a tile of (%nx * %ny) input images.
Typical values for %nx and %ny are in the range [2 ... 5].
(4) If %fontsize != 0, each image has the tail of its filename
rendered below it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertToNUpFiles(*args)
    
    

    try:
        leptonica.convertToNUpPixa.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertToNUpPixa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function convertToNUpPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToNUpPixa(*args):
        """
        ('const char', '*dir')       
('const char', '*substr')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'tw')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('l_int32', 'fontsize')       

:param[in]    dir:       full path to directory of images
:param[in]    substr:    [optional] can be null
:param[in]    nx,: ny    in [1, ... 50], tiling factors in each direction
:param[in]    tw:        target width, in pixels; must be >= 20
:param[in]    spacing:   between images, and on outside
:param[in]    border:    width of additional black border on each image;
use 0 for no border
:param[in]    fontsize:  to print tail of filename with image.  Valid set is
{4,6,8,10,12,14,16,18,20}.  Use 0 to disable.
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) See notes for convertToNUpFiles()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertToNUpPixa(*args)
    
    

    try:
        leptonica.pixaConvertToNUpPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaConvertToNUpPixa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertToNUpPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertToNUpPixa(*args):
        """
        ('PIXA', '*pixas')       
('SARRAY', '*sa')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'tw')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('l_int32', 'fontsize')       

:param[in]    pixas:
:param[in]    sa:        [optional] array of strings associated with each pix
:param[in]    nx,: ny    in [1, ... 50], tiling factors in each direction
:param[in]    tw:        target width, in pixels; must be >= 20
:param[in]    spacing:   between images, and on outside
:param[in]    border:    width of additional black border on each image;
use 0 for no border
:param[in]    fontsize:  to print string with each image.  Valid set is
{4,6,8,10,12,14,16,18,20}.  Use 0 to disable.
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) This takes an input pixa and an optional array of strings, and
generates a pixa of NUp tiles from the input, labeled with
the strings if they exist and %fontsize != 0.
(2) See notes for convertToNUpFiles()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertToNUpPixa(*args)
    
    

    try:
        leptonica.pixaCompareInPdf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixaCompareInPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaCompareInPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCompareInPdf(*args):
        """
        ('PIXA', '*pixa1')       
('PIXA', '*pixa2')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'tw')       
('l_int32', 'spacing')       
('l_int32', 'border')       
('l_int32', 'fontsize')       
('const char', '*fileout')       

:param[in]    pixa1:
:param[in]    pixa2:
:param[in]    nx,: ny     in [1, ... 20], tiling factors in each direction
:param[in]    tw:         target width, in pixels; must be >= 20
:param[in]    spacing:    between images, and on outside
:param[in]    border:     width of additional black border on each image
and on each pair; use 0 for no border
:param[in]    fontsize:   to print index of each pair of images.  Valid set
is {4,6,8,10,12,14,16,18,20}.  Use 0 to disable.
:param[in]    fileout:    output pdf file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This takes two pixa and renders them interleaved, side-by-side
in a pdf.  A warning is issued if the input pixa arrays
have different lengths.
(2) %nx and %ny specify how many side-by-side pairs are displayed
on each pdf page.  For example, if %nx = 1 and %ny = 2, then
two pairs are shown, one above the other, on each page.
(3) The input pix are scaled to a target width of %tw, and
then paired with optional %spacing between and optional
black border of width %border.
(4) After a pixa is generated of these tiled images, it is
written to %fileout as a pdf.
(5) Typical numbers for the input parameters are:
%nx = small integer (1 - 4)
%ny = 2 * %nx
%tw = 200 - 500 pixels
%spacing = 10
%border = 2
%fontsize = 10
(6) If %fontsize != 0, the index of the pix pair in their pixa
is printed out below each pair.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCompareInPdf(*args)
    




class rotateam(object):
    """<pre>

Grayscale and color rotation for area mapping (== interpolation)

Rotation about the image center
PIX         *pixRotateAM()
PIX         *pixRotateAMColor()
PIX         *pixRotateAMGray()
static void  rotateAMColorLow()
static void  rotateAMGrayLow()

Rotation about the UL corner of the image
PIX         *pixRotateAMCorner()
PIX         *pixRotateAMColorCorner()
PIX         *pixRotateAMGrayCorner()
static void  rotateAMColorCornerLow()
static void  rotateAMGrayCornerLow()

Faster color rotation about the image center
PIX         *pixRotateAMColorFast()
static void  rotateAMColorFastLow()

Rotations are measured in radians; clockwise is positive.

The basic area mapping grayscale rotation works on 8 bpp images.
For color, the same method is applied to each color separately.
This can be done in two ways: (1) as here, computing each dest
rgb pixel from the appropriate four src rgb pixels, or (2) separating
the color image into three 8 bpp images, rotate each of these,
and then combine the result.  Method (1) is about 2.5x faster.
We have also implemented a fast approximation for color area-mapping
rotation (pixRotateAMColorFast()), which is about 25% faster
than the standard color rotator.  If you need the extra speed,
use it.

Area mapping works as follows.  For each dest
pixel you find the 4 source pixels that it partially
covers.  You then compute the dest pixel value as
the area-weighted average of those 4 source pixels.
We make two simplifying approximations:

~  For simplicity, compute the areas as if the dest
pixel were translated but not rotated.

~  Compute area overlaps on a discrete sub-pixel grid.
Because we are using 8 bpp images with 256 levels,
it is convenient to break each pixel into a
16x16 sub-pixel grid, and count the number of
overlapped sub-pixels.

It is interesting to note that the digital filter that
implements the area mapping algorithm for rotation
is identical to the digital filter used for linear
interpolation when arbitrarily scaling grayscale images.

The advantage of area mapping over pixel sampling
in grayscale rotation is that the former naturally
blurs sharp edges ("anti-aliasing"), so that stair-step
artifacts are not introduced.  The disadvantage is that
it is significantly slower.

But it is still pretty fast.  With standard 3 GHz hardware,
the anti-aliased (area-mapped) color rotation speed is
about 15 million pixels/sec.

The function pixRotateAMColorFast() is about 10-20% faster
than pixRotateAMColor().  The quality is slightly worse,
and if you make many successive small rotations, with a
total angle of 360 degrees, it has been noted that the
center wanders -- it seems to be doing a 1 pixel translation
in addition to the rotation.

Consider again the comparison of image quality between sampling
and area mapping.  With sampling, sharp edges such as found in
text images remain sharp.  However, sampling artifacts such as
characters randomly bouncing up and down by one pixel, or
one pixel horizontal shear lines going through a line of text
(causing the characters to look like badly rendered italic),
are highly visible.  It does not help to sample the source pixel
with the largest area covering each dest pixel; the result has
the same ugly sampling artifacts.

With area mapping, these annoying artifacts are avoided, but the
blurring of edges makes small text a bit more difficult to read.
However, if you are willing to do more computation, you can have
the best of both worlds: no sampling artifacts and sharp edges.
Use area mapping to avoid sampling issues, and follow it with
unsharp masking.  Experiment with the sharpening parameters.
I have found that a small amount of sharpening is sufficient to
restore the sharp edges in text; e.g.,
pix2 = pixUnsharpMasking(pix1, 1, 0.3);
</pre>




"""
    
    try:
        leptonica.pixRotateAM.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateAM.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAM not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAM(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs: 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB
:param[in]    angle: radians; clockwise is positive
:param[in]    incolor: L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Rotates about image center.
(2) A positive angle gives a clockwise rotation.
(3) Brings in either black or white pixels from the boundary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAM(*args)
    
    

    try:
        leptonica.pixRotateAMColor.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixRotateAMColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAMColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint32', 'colorval')       

:param[in]    pixs: 32 bpp
:param[in]    angle: radians; clockwise is positive
:param[in]    colorval: e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Rotates about image center.
(2) A positive angle gives a clockwise rotation.
(3) Specify the color to be brought in from outside the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMColor(*args)
    
    

    try:
        leptonica.pixRotateAMGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_ubyte]
        leptonica.pixRotateAMGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAMGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint8', 'grayval')       

:param[in]    pixs: 8 bpp
:param[in]    angle: radians; clockwise is positive
:param[in]    grayval: 0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Rotates about image center.
(2) A positive angle gives a clockwise rotation.
(3) Specify the grayvalue to be brought in from outside the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMGray(*args)
    
    

    try:
        leptonica.pixRotateAMCorner.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateAMCorner.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAMCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMCorner(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs: 1, 2, 4, 8 bpp gray or colormapped, or 32 bpp RGB
:param[in]    angle: radians; clockwise is positive
:param[in]    incolor: L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Rotates about the UL corner of the image.
(2) A positive angle gives a clockwise rotation.
(3) Brings in either black or white pixels from the boundary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMCorner(*args)
    
    

    try:
        leptonica.pixRotateAMColorCorner.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixRotateAMColorCorner.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAMColorCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMColorCorner(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint32', 'fillval')       

:param[in]    pixs:
:param[in]    angle: radians; clockwise is positive
:param[in]    fillval: e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Rotates the image about the UL corner.
(2) A positive angle gives a clockwise rotation.
(3) Specify the color to be brought in from outside the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMColorCorner(*args)
    
    

    try:
        leptonica.pixRotateAMGrayCorner.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_ubyte]
        leptonica.pixRotateAMGrayCorner.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAMGrayCorner not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMGrayCorner(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint8', 'grayval')       

:param[in]    pixs:
:param[in]    angle: radians; clockwise is positive
:param[in]    grayval: 0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Rotates the image about the UL corner.
(2) A positive angle gives a clockwise rotation.
(3) Specify the grayvalue to be brought in from outside the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMGrayCorner(*args)
    
    

    try:
        leptonica.pixRotateAMColorFast.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixRotateAMColorFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateAMColorFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateAMColorFast(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_uint32', 'colorval')       

:param[in]    pixs:
:param[in]    angle: radians; clockwise is positive
:param[in]    colorval: e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This rotates a color image about the image center.
(2) A positive angle gives a clockwise rotation.
(3) It uses area mapping, dividing each pixel into
16 subpixels.
(4) It is about 10% to 20% faster than the more accurate linear
interpolation function pixRotateAMColor(),
which uses 256 subpixels.
(5) For some reason it shifts the image center.
No attempt is made to rotate the alpha component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateAMColorFast(*args)
    




class watershed(object):
    """<pre>

Top-level
L_WSHED         *wshedCreate()
void             wshedDestroy()
l_int32          wshedApply()

Helpers
static l_int32   identifyWatershedBasin()
static l_int32   mergeLookup()
static l_int32   wshedGetHeight()
static void      pushNewPixel()
static void      popNewPixel()
static void      pushWSPixel()
static void      popWSPixel()
static void      debugPrintLUT()
static void      debugWshedMerge()

Output
l_int32          wshedBasins()
PIX             *wshedRenderFill()
PIX             *wshedRenderColors()

The watershed function identifies the "catch basins" of the input
8 bpp image, with respect to the specified seeds or "markers".
The use is in segmentation, but the selection of the markers is
critical to getting meaningful results.

How are the markers selected?  You can't simply use the local
minima, because a typical image has sufficient noise so that
a useful catch basin can easily have multiple local minima.  However
they are selected, the question for the watershed function is
how to handle local minima that are not markers.  The reason
this is important is because of the algorithm used to find the
watersheds, which is roughly like this:

(1) Identify the markers and the local minima, and enter them
into a priority queue based on the pixel value.  Each marker
is shrunk to a single pixel, if necessary, before the
operation starts.
(2) Feed the priority queue with neighbors of pixels that are
popped off the queue.  Each of these queue pixels is labeled
with the index value of its parent.
(3) Each pixel is also labeled, in a 32-bit image, with the marker
or local minimum index, from which it was originally derived.
(4) There are actually 3 classes of labels: seeds, minima, and
fillers.  The fillers are labels of regions that have already
been identified as watersheds and are continuing to fill, for
the purpose of finding higher watersheds.
(5) When a pixel is popped that has already been labeled in the
32-bit image and that label differs from the label of its
parent (stored in the queue pixel), a boundary has been crossed.
There are several cases:
(a) Both parents are derived from markers but at least one
is not deep enough to become a watershed.  Absorb the
shallower basin into the deeper one, fixing the LUT to
redirect the shallower index to the deeper one.
(b) Both parents are derived from markers and both are deep
enough.  Identify and save the watershed for each marker.
(c) One parent was derived from a marker and the other from
a minima: absorb the minima basin into the marker basin.
(d) One parent was derived from a marker and the other is
a filler: identify and save the watershed for the marker.
(e) Both parents are derived from minima: merge them.
(f) One parent is a filler and the other is derived from a
minima: merge the minima into the filler.
(6) The output of the watershed operation consists of:
~ a pixa of the basins
~ a pta of the markers
~ a numa of the watershed levels

Typical usage:
L_WShed *wshed = wshedCreate(pixs, pixseed, mindepth, 0);
wshedApply(wshed);

wshedBasins(wshed, &pixa, &nalevels);
... do something with pixa, nalevels ...
pixaDestroy(&pixa);
numaDestroy(&nalevels);

Pix *pixd = wshedRenderFill(wshed);

wshedDestroy(&wshed);
</pre>




"""
    
    try:
        leptonica.wshedCreate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.wshedCreate.restype = lambda address: L_WSHED(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function wshedCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedCreate(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'mindepth')       
('l_int32', 'debugflag')       

:param[in]    pixs:  8 bpp source
:param[in]    pixm:  1 bpp 'marker' seed
:param[in]    mindepth: minimum depth; anything less is not saved
:param[in]    debugflag: 1 for debug output
:returns:  WShed, or NULL on error

<pre>
Notes:
(1) It is not necessary for the fg pixels in the seed image
be at minima, or that they be isolated.  We extract a
single pixel from each connected component, and a seed
anywhere in a watershed will eventually label the watershed
when the filling level reaches it.
(2) Set mindepth to some value to ignore noise in pixs that
can create small local minima.  Any watershed shallower
than mindepth, even if it has a seed, will not be saved;
It will either be incorporated in another watershed or
eliminated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.wshedCreate(*args)
    
    

    try:
        leptonica.wshedDestroy.argtypes = [ctypes.c_void_p]
        leptonica.wshedDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function wshedDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedDestroy(*args):
        """
        ('L_WSHED', '**pwshed')       

:param[in,out]   pwshed: will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.wshedDestroy(*args)
    
    

    try:
        leptonica.wshedApply.argtypes = [ctypes.c_void_p]
        leptonica.wshedApply.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function wshedApply not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedApply(*args):
        """
        ('L_WSHED', '*wshed')       

:param[in]    wshed: generated from wshedCreate()
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) N.B. This is buggy!  It seems to locate watersheds that are
duplicates.  The watershed extraction after complete fill
grabs some regions belonging to existing watersheds.
See prog/watershedtest.c for testing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.wshedApply(*args)
    
    

    try:
        leptonica.wshedBasins.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.wshedBasins.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function wshedBasins not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedBasins(*args):
        """
        ('L_WSHED', '*wshed')       
('PIXA', '**ppixa')       
('NUMA', '**pnalevels')       

:param[in]    wshed:
:param[out]   ppixa:       [optional] mask of watershed basins
:param[out]   pnalevels:   [optional] watershed levels
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.wshedBasins(*args)
    
    

    try:
        leptonica.wshedRenderFill.argtypes = [ctypes.c_void_p]
        leptonica.wshedRenderFill.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function wshedRenderFill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedRenderFill(*args):
        """
        ('L_WSHED', '*wshed')       

:param[in]    wshed:
:returns:  pixd   initial image with all basins filled, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.wshedRenderFill(*args)
    
    

    try:
        leptonica.wshedRenderColors.argtypes = [ctypes.c_void_p]
        leptonica.wshedRenderColors.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function wshedRenderColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def wshedRenderColors(*args):
        """
        ('L_WSHED', '*wshed')       

:param[in]    wshed:
:returns:  pixd   initial image with all basins filled, or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.wshedRenderColors(*args)
    




class blend(object):
    """<pre>

Blending two images that are not colormapped
PIX             *pixBlend()
PIX             *pixBlendMask()
PIX             *pixBlendGray()
PIX             *pixBlendGrayInverse()
PIX             *pixBlendColor()
PIX             *pixBlendColorByChannel()
PIX             *pixBlendGrayAdapt()
static l_int32   blendComponents()
PIX             *pixFadeWithGray()
PIX             *pixBlendHardLight()
static l_int32   blendHardLightComponents()

Blending two colormapped images
l_int32          pixBlendCmap()

Blending two images using a third (alpha mask)
PIX             *pixBlendWithGrayMask()

Blending background to a specific color
PIX             *pixBlendBackgroundToColor()

Multiplying by a specific color
PIX             *pixMultiplyByColor()

Rendering with alpha blending over a uniform background
PIX             *pixAlphaBlendUniform()

Adding an alpha layer for blending
PIX             *pixAddAlphaToBlend()

Setting a transparent alpha component over a white background
PIX             *pixSetAlphaOverWhite()

Fading from the edge
l_int32          pixLinearEdgeFade()

In blending operations a new pix is produced where typically
a subset of pixels in src1 are changed by the set of pixels
in src2, when src2 is located in a given position relative
to src1.  This is similar to rasterop, except that the
blending operations we allow are more complex, and typically
result in dest pixels that are a linear combination of two
pixels, such as src1 and its inverse.  I find it convenient
to think of src2 as the "blender" (the one that takes the action)
and src1 as the "blendee" (the one that changes).

Blending works best when src1 is 8 or 32 bpp.  We also allow
src1 to be colormapped, but the colormap is removed before blending,
so if src1 is colormapped, we can't allow in-place blending.

Because src2 is typically smaller than src1, we can implement by
clipping src2 to src1 and then transforming some of the dest
pixels that are under the support of src2.  In practice, we
do the clipping in the inner pixel loop.  For grayscale and
color src2, we also allow a simple form of transparency, where
pixels of a particular value in src2 are transparent; for those pixels,
no blending is done.

The blending functions are categorized by the depth of src2,
the blender, and not that of src1, the blendee.

~ If src2 is 1 bpp, we can do one of three things:
(1) L_BLEND_WITH_INVERSE: Blend a given fraction of src1 with its
inverse color for those pixels in src2 that are fg (ON),
and leave the dest pixels unchanged for pixels in src2 that
are bg (OFF).
(2) L_BLEND_TO_WHITE: Fade the src1 pixels toward white by a
given fraction for those pixels in src2 that are fg (ON),
and leave the dest pixels unchanged for pixels in src2 that
are bg (OFF).
(3) L_BLEND_TO_BLACK: Fade the src1 pixels toward black by a
given fraction for those pixels in src2 that are fg (ON),
and leave the dest pixels unchanged for pixels in src2 that
are bg (OFF).
The blending function is pixBlendMask().

~ If src2 is 8 bpp grayscale, we can do one of two things
(but see pixFadeWithGray() below):
(1) L_BLEND_GRAY: If src1 is 8 bpp, mix the two values, using
a fraction of src2 and (1 - fraction) of src1.
If src1 is 32 bpp (rgb), mix the fraction of src2 with
each of the color components in src1.
(2) L_BLEND_GRAY_WITH_INVERSE: Use the grayscale value in src2
to determine how much of the inverse of a src1 pixel is
to be combined with the pixel value.  The input fraction
further acts to scale the change in the src1 pixel.
The blending function is pixBlendGray().

~ If src2 is color, we blend a given fraction of src2 with
src1.  If src1 is 8 bpp, the resulting image is 32 bpp.
The blending function is pixBlendColor().

~ For all three blending functions -- pixBlendMask(), pixBlendGray()
and pixBlendColor() -- you can apply the blender to the blendee
either in-place or generating a new pix.  For the in-place
operation, this requires that the depth of the resulting pix
must equal that of the input pixs1.

~ We remove colormaps from src1 and src2 before blending.
Any quantization would have to be done after blending.

We include another function, pixFadeWithGray(), that blends
a gray or color src1 with a gray src2.  It does one of these things:
(1) L_BLEND_TO_WHITE: Fade the src1 pixels toward white by
a number times the value in src2.
(2) L_BLEND_TO_BLACK: Fade the src1 pixels toward black by
a number times the value in src2.

Also included is a generalization of the so-called "hard light"
blending: pixBlendHardLight().  We generalize by allowing a fraction < 1.0
of the blender to be admixed with the blendee.  The standard function
does full mixing.
</pre>




"""
    
    try:
        leptonica.pixBlend.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixBlend.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlend(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       

:param[in]    pixs1:    blendee
:param[in]    pixs2:    blender; typ. smaller
:param[in]    x,y:      origin [UL corner] of pixs2 relative to
the origin of pixs1; can be < 0
:param[in]    fract:    blending fraction
:returns:  pixd blended image, or null on error

<pre>
Notes:
(1) This is a simple top-level interface.  For more flexibility,
call directly into pixBlendMask(), etc.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlend(*args)
    
    

    try:
        leptonica.pixBlendMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixBlendMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendMask(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'type')       

:param[in]    pixd:    [optional]; either NULL or equal to pixs1 for in-place
:param[in]    pixs1:   blendee, depth > 1
:param[in]    pixs2:   blender, 1 bpp; typ. smaller in size than pixs1
:param[in]    x,y:     origin [UL corner] of pixs2 relative to
the origin of pixs1; can be < 0
:param[in]    fract:   blending fraction
:param[in]    type:    L_BLEND_WITH_INVERSE, L_BLEND_TO_WHITE,
L_BLEND_TO_BLACK
:returns:  pixd if OK; null on error

<pre>
Notes:
(1) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
(2) If pixs1 has a colormap, it is removed.
(3) For inplace operation (pixs1 not cmapped), call it this way:
pixBlendMask(pixs1, pixs1, pixs2, ...)
(4) For generating a new pixd:
pixd = pixBlendMask(NULL, pixs1, pixs2, ...)
(5) Only call in-place if pixs1 does not have a colormap.
(6) Invalid %fract defaults to 0.5 with a warning.
Invalid %type defaults to L_BLEND_WITH_INVERSE with a warning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendMask(*args)
    
    

    try:
        leptonica.pixBlendGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixBlendGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'type')       
('l_int32', 'transparent')       
('l_uint32', 'transpix')       

:param[in]    pixd:         [optional] either equal to pixs1 for in-place,
or NULL
:param[in]    pixs1:        blendee, depth > 1
:param[in]    pixs2:        blender, any depth; typically, the area of
pixs2 is smaller than pixs1
:param[in]    x,y:          origin [UL corner] of pixs2 relative to
the origin of pixs1; can be < 0
:param[in]    fract:        blending fraction
:param[in]    type:         L_BLEND_GRAY, L_BLEND_GRAY_WITH_INVERSE
:param[in]    transparent:  1 to use transparency; 0 otherwise
:param[in]    transpix:     pixel grayval in pixs2 that is to be transparent
:returns:  pixd if OK; pixs1 on error

<pre>
Notes:
(1) For inplace operation (pixs1 not cmapped), call it this way:
pixBlendGray(pixs1, pixs1, pixs2, ...)
(2) For generating a new pixd:
pixd = pixBlendGray(NULL, pixs1, pixs2, ...)
(3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
(4) If pixs1 has a colormap, it is removed; otherwise, if pixs1
has depth < 8, it is unpacked to generate a 8 bpp pix.
(5) If transparent = 0, the blending fraction (fract) is
applied equally to all pixels.
(6) If transparent = 1, all pixels of value transpix (typically
either 0 or 0xff) in pixs2 are transparent in the blend.
(7) After processing pixs1, it is either 8 bpp or 32 bpp:
~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
~ if 32 bpp, each component of pixs1 is mixed with
the same fraction of pixs2.
(8) For L_BLEND_GRAY_WITH_INVERSE, the white values of the blendee
(cval == 255 in the code below) result in a delta of 0.
Thus, these pixels are intrinsically transparent!
The "pivot" value of the src, at which no blending occurs, is
128.  Compare with the adaptive pivot in pixBlendGrayAdapt().
(9) Invalid %fract defaults to 0.5 with a warning.
Invalid %type defaults to L_BLEND_GRAY with a warning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendGray(*args)
    
    

    try:
        leptonica.pixBlendGrayInverse.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.pixBlendGrayInverse.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendGrayInverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendGrayInverse(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       

:param[in]    pixd:     [optional] either equal to pixs1 for in-place, or NULL
:param[in]    pixd:     [optional] either NULL or equal to pixs1 for in-place
:param[in]    pixs1:    blendee, depth > 1
:param[in]    pixs2:    blender, any depth; typ. smaller in size than pixs1
:param[in]    x,y:      origin [UL corner] of pixs2 relative to
the origin of pixs1; can be < 0
:param[in]    fract:    blending fraction
:returns:  pixd if OK; pixs1 on error

<pre>
Notes:
(1) For inplace operation (pixs1 not cmapped), call it this way:
pixBlendGrayInverse(pixs1, pixs1, pixs2, ...)
(2) For generating a new pixd:
pixd = pixBlendGrayInverse(NULL, pixs1, pixs2, ...)
(3) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
(4) If pixs1 has a colormap, it is removed; otherwise if pixs1
has depth < 8, it is unpacked to generate a 8 bpp pix.
(5) This is a no-nonsense blender.  It changes the src1 pixel except
when the src1 pixel is midlevel gray.  Use fract == 1 for the most
aggressive blending, where, if the gray pixel in pixs2 is 0,
we get a complete inversion of the color of the src pixel in pixs1.
(6) The basic logic is that each component transforms by:
d  -->  c * d + (1 - c ) * (f * (1 - d) + d * (1 - f))
where c is the blender pixel from pixs2,
f is %fract,
c and d are normalized to [0...1]
This has the property that for f == 0 (no blend) or c == 1 (white):
d  -->  d
For c == 0 (black) we get maximum inversion:
d  -->  f * (1 - d) + d * (1 - f)   [inversion by fraction f]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendGrayInverse(*args)
    
    

    try:
        leptonica.pixBlendColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixBlendColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'transparent')       
('l_uint32', 'transpix')       

:param[in]    pixd:          [optional] either equal to pixs1 for in-place,
or NULL
:param[in]    pixs1:         blendee; depth > 1
:param[in]    pixs2:         blender, any depth; typically, the area of
pixs2 is smaller than pixs1
:param[in]    x,y:           origin [UL corner] of pixs2 relative to
the origin of pixs1
:param[in]    fract:         blending fraction
:param[in]    transparent:   1 to use transparency; 0 otherwise
:param[in]    transpix:      pixel color in pixs2 that is to be transparent
:returns:  pixd, or null on error

<pre>
Notes:
(1) For inplace operation (pixs1 must be 32 bpp), call it this way:
pixBlendColor(pixs1, pixs1, pixs2, ...)
(2) For generating a new pixd:
pixd = pixBlendColor(NULL, pixs1, pixs2, ...)
(3) If pixs2 is not 32 bpp rgb, it is converted.
(4) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
(5) If pixs1 has a colormap, it is removed to generate a 32 bpp pix.
(6) If pixs1 has depth < 32, it is unpacked to generate a 32 bpp pix.
(7) If transparent = 0, the blending fraction (fract) is
applied equally to all pixels.
(8) If transparent = 1, all pixels of value transpix (typically
either 0 or 0xffffff00) in pixs2 are transparent in the blend.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendColor(*args)
    
    

    try:
        leptonica.pixBlendGrayAdapt.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixBlendGrayAdapt.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendGrayAdapt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendGrayAdapt(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'fract')       
('l_int32', 'shift')       

:param[in]    pixd:    [optional] either equal to pixs1 for in-place, or NULL
:param[in]    pixs1:   blendee; depth > 1
:param[in]    pixs2:   blender, any depth; typically, the area of
pixs2 is smaller than pixs1
:param[in]    x,y:     origin [UL corner] of pixs2 relative to
the origin of pixs1; can be < 0
:param[in]    fract:   blending fraction
:param[in]    shift:   >= 0 but <= 128: shift of zero blend value from
median source; use -1 for default value;
:returns:  pixd if OK; pixs1 on error

<pre>
Notes:
(1) For inplace operation (pixs1 not cmapped), call it this way:
pixBlendGrayAdapt(pixs1, pixs1, pixs2, ...)
For generating a new pixd:
pixd = pixBlendGrayAdapt(NULL, pixs1, pixs2, ...)
(2) Clipping of pixs2 to pixs1 is done in the inner pixel loop.
(3) If pixs1 has a colormap, it is removed.
(4) If pixs1 has depth < 8, it is unpacked to generate a 8 bpp pix.
(5) This does a blend with inverse.  Whereas in pixGlendGray(), the
zero blend point is where the blendee pixel is 128, here
the zero blend point is found adaptively, with respect to the
median of the blendee region.  If the median is < 128,
the zero blend point is found from
median + shift.
Otherwise, if the median >= 128, the zero blend point is
median - shift.
The purpose of shifting the zero blend point away from the
median is to prevent a situation in pixBlendGray() where
the median is 128 and the blender is not visible.
The default value of shift is 64.
(6) After processing pixs1, it is either 8 bpp or 32 bpp:
~ if 8 bpp, the fraction of pixs2 is mixed with pixs1.
~ if 32 bpp, each component of pixs1 is mixed with
the same fraction of pixs2.
(7) The darker the blender, the more it mixes with the blendee.
A blender value of 0 has maximum mixing; a value of 255
has no mixing and hence is transparent.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendGrayAdapt(*args)
    
    

    try:
        leptonica.pixFadeWithGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixFadeWithGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFadeWithGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFadeWithGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('l_float32', 'factor')       
('l_int32', 'type')       

:param[in]    pixs:     colormapped or 8 bpp or 32 bpp
:param[in]    pixb:     8 bpp blender
:param[in]    factor:   multiplicative factor to apply to blender value
:param[in]    type:     L_BLEND_TO_WHITE, L_BLEND_TO_BLACK
:returns:  pixd, or null on error

<pre>
Notes:
(1) This function combines two pix aligned to the UL corner; they
need not be the same size.
(2) Each pixel in pixb is multiplied by 'factor' divided by 255, and
clipped to the range [0 ... 1].  This gives the fade fraction
to be applied to pixs.  Fade either to white (L_BLEND_TO_WHITE)
or to black (L_BLEND_TO_BLACK).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFadeWithGray(*args)
    
    

    try:
        leptonica.pixBlendCmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlendCmap.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendCmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendCmap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'sindex')       

:param[in]    pixs:     2, 4 or 8 bpp, with colormap
:param[in]    pixb:     colormapped blender
:param[in]    x,: y     UL corner of blender relative to pixs
:param[in]    sindex:   colormap index of pixels in pixs to be changed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function combines two colormaps, and replaces the pixels
in pixs that have a specified color value with those in pixb.
(2) sindex must be in the existing colormap; otherwise an
error is returned.  In use, sindex will typically be the index
for white (255, 255, 255).
(3) Blender colors that already exist in the colormap are used;
others are added.  If any blender colors cannot be
stored in the colormap, an error is returned.
(4) In the implementation, a mapping is generated from each
original blender colormap index to the corresponding index
in the expanded colormap for pixs.  Then for each pixel in
pixs with value sindex, and which is covered by a blender pixel,
the new index corresponding to the blender pixel is substituted
for sindex.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendCmap(*args)
    
    

    try:
        leptonica.pixBlendWithGrayMask.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlendWithGrayMask.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendWithGrayMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendWithGrayMask(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('PIX', '*pixg')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pixs1:   8 bpp gray, rgb, rgba or colormapped
:param[in]    pixs2:   8 bpp gray, rgb, rgba or colormapped
:param[in]    pixg:    [optional] 8 bpp gray, for transparency of pixs2;
can be null
:param[in]    x,: y    UL corner of pixs2 and pixg with respect to pixs1
:returns:  pixd blended image, or null on error

<pre>
Notes:
(1) The result is 8 bpp grayscale if both pixs1 and pixs2 are
8 bpp gray.  Otherwise, the result is 32 bpp rgb.
(2) pixg is an 8 bpp transparency image, where 0 is transparent
and 255 is opaque.  It determines the transparency of pixs2
when applied over pixs1.  It can be null if pixs2 is rgba,
in which case we use the alpha component of pixs2.
(3) If pixg exists, it need not be the same size as pixs2.
However, we assume their UL corners are aligned with each other,
and placed at the location (x, y) in pixs1.
(4) The pixels in pixd are a combination of those in pixs1
and pixs2, where the amount from pixs2 is proportional to
the value of the pixel (p) in pixg, and the amount from pixs1
is proportional to (255 - p).  Thus pixg is a transparency
image (usually called an alpha blender) where each pixel
can be associated with a pixel in pixs2, and determines
the amount of the pixs2 pixel in the final result.
For example, if pixg is all 0, pixs2 is transparent and
the result in pixd is simply pixs1.
(5) A typical use is for the pixs2/pixg combination to be
a small watermark that is applied to pixs1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendWithGrayMask(*args)
    
    

    try:
        leptonica.pixBlendBackgroundToColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBlendBackgroundToColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendBackgroundToColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendBackgroundToColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', 'color')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       

:param[in]    pixd:    can be NULL or pixs
:param[in]    pixs:    32 bpp rgb
:param[in]    box:     region for blending; can be NULL)
:param[in]    color:   32 bit color in 0xrrggbb00 format
:param[in]    gamma,: minval, maxval    args for grayscale TRC mapping
:returns:  pixd always

<pre>
Notes:
(1) This in effect replaces light background pixels in pixs
by the input color.  It does it by alpha blending so that
there are no visible artifacts from hard cutoffs.
(2) If pixd == pixs, this is done in-place.
(3) If box == NULL, this is performed on all of pixs.
(4) The alpha component for blending is derived from pixs,
by converting to grayscale and enhancing with a TRC.
(5) The last three arguments specify the TRC operation.
Suggested values are: %gamma = 0.3, %minval = 50, %maxval = 200.
To skip the TRC, use %gamma == 1, %minval = 0, %maxval = 255.
See pixGammaTRC() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendBackgroundToColor(*args)
    
    

    try:
        leptonica.pixMultiplyByColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixMultiplyByColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMultiplyByColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultiplyByColor(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('BOX', '*box')       
('l_uint32', 'color')       

:param[in]    pixd:    can be NULL or pixs
:param[in]    pixs:    32 bpp rgb
:param[in]    box:     region for filtering; can be NULL)
:param[in]    color:   32 bit color in 0xrrggbb00 format
:returns:  pixd always

<pre>
Notes:
(1) This filters all pixels in the specified region by
multiplying each component by the input color.
This leaves black invariant and transforms white to the
input color.
(2) If pixd == pixs, this is done in-place.
(3) If box == NULL, this is performed on all of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultiplyByColor(*args)
    
    

    try:
        leptonica.pixAlphaBlendUniform.argtypes = [ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixAlphaBlendUniform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAlphaBlendUniform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAlphaBlendUniform(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'color')       

:param[in]    pixs:    32 bpp rgba, with alpha
:param[in]    color:   32 bit color in 0xrrggbb00 format
:returns:  pixd 32 bpp rgb: pixs blended over uniform color %color,
a clone of pixs if no alpha, and null on error

<pre>
Notes:
(1) This is a convenience function that renders 32 bpp RGBA images
(with an alpha channel) over a uniform background of
value %color.  To render over a white background,
use %color = 0xffffff00.  The result is an RGB image.
(2) If pixs does not have an alpha channel, it returns a clone
of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAlphaBlendUniform(*args)
    
    

    try:
        leptonica.pixAddAlphaToBlend.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixAddAlphaToBlend.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddAlphaToBlend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddAlphaToBlend(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'invert')       

:param[in]    pixs:     any depth
:param[in]    fract:    fade fraction in the alpha component
:param[in]    invert:   1 to photometrically invert pixs
:returns:  pixd 32 bpp with alpha, or null on error

<pre>
Notes:
(1) This is a simple alpha layer generator, where typically white has
maximum transparency and black has minimum.
(2) If %invert == 1, generate the same alpha layer but invert
the input image photometrically.  This is useful for blending
over dark images, where you want dark regions in pixs, such
as text, to be lighter in the blended image.
(3) The fade %fract gives the minimum transparency (i.e.,
maximum opacity).  A small fraction is useful for adding
a watermark to an image.
(4) If pixs has a colormap, it is removed to rgb.
(5) If pixs already has an alpha layer, it is overwritten.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddAlphaToBlend(*args)
    
    

    try:
        leptonica.pixSetAlphaOverWhite.argtypes = [ctypes.c_void_p]
        leptonica.pixSetAlphaOverWhite.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSetAlphaOverWhite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetAlphaOverWhite(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    colormapped or 32 bpp rgb; no alpha
:returns:  pixd new pix with meaningful alpha component,
or null on error

<pre>
Notes:
(1) The generated alpha component is transparent over white
(background) pixels in pixs, and quickly grades to opaque
away from the transparent parts.  This is a cheap and
dirty alpha generator.  The 2 pixel gradation is useful
to blur the boundary between the transparent region
(that will render entirely from a backing image) and
the remainder which renders from pixs.
(2) All alpha component bits in pixs are overwritten.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetAlphaOverWhite(*args)
    
    

    try:
        leptonica.pixLinearEdgeFade.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixLinearEdgeFade.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixLinearEdgeFade not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLinearEdgeFade(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dir')       
('l_int32', 'fadeto')       
('l_float32', 'distfract')       
('l_float32', 'maxfade')       

:param[in]    pixs:       8 or 32 bpp; no colormap
:param[in]    dir:        L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT
:param[in]    fadeto:     L_BLEND_TO_WHITE, L_BLEND_TO_BLACK
:param[in]    distfract:  fraction of width or height over which fading occurs
:param[in]    maxfade:    fraction of fading at the edge, <= 1.0
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place operation.
(2) Maximum fading fraction %maxfade occurs at the edge of the image,
and the fraction goes to 0 at the fractional distance %distfract
from the edge.  %maxfade must be in [0, 1].
(3) %distrfact must be in [0, 1], and typically it would be <= 0.5.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixLinearEdgeFade(*args)
    




class edge(object):
    """<pre>

Sobel edge detecting filter
PIX      *pixSobelEdgeFilter()

Two-sided edge gradient filter
PIX      *pixTwoSidedEdgeFilter()

Measurement of edge smoothness
l_int32   pixMeasureEdgeSmoothness()
NUMA     *pixGetEdgeProfile()
l_int32   pixGetLastOffPixelInRun()
l_int32   pixGetLastOnPixelInRun()


The Sobel edge detector uses these two simple gradient filters.

1    2    1             1    0   -1
0    0    0             2    0   -2
-1   -2   -1             1    0   -1

(horizontal)             (vertical)

To use both the vertical and horizontal filters, set the orientation
flag to L_ALL_EDGES; this sums the abs. value of their outputs,
clipped to 255.

See comments below for displaying the resulting image with
the edges dark, both for 8 bpp and 1 bpp.
</pre>




"""
    
    try:
        leptonica.pixSobelEdgeFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSobelEdgeFilter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSobelEdgeFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSobelEdgeFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'orientflag')       

:param[in]    pixs:         8 bpp; no colormap
:param[in]    orientflag:   L_HORIZONTAL_EDGES, L_VERTICAL_EDGES, L_ALL_EDGES
:returns:  pixd   8 bpp, edges are brighter, or NULL on error

<pre>
Notes:
(1) Invert pixd to see larger gradients as darker (grayscale).
(2) To generate a binary image of the edges, threshold
the result using pixThresholdToBinary().  If the high
edge values are to be fg (1), invert after running
pixThresholdToBinary().
(3) Label the pixels as follows:
1    4    7
2    5    8
3    6    9
Read the data incrementally across the image and unroll
the loop.
(4) This runs at about 45 Mpix/sec on a 3 GHz processor.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSobelEdgeFilter(*args)
    
    

    try:
        leptonica.pixTwoSidedEdgeFilter.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixTwoSidedEdgeFilter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixTwoSidedEdgeFilter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTwoSidedEdgeFilter(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'orientflag')       

:param[in]    pixs:         8 bpp; no colormap
:param[in]    orientflag:   L_HORIZONTAL_EDGES, L_VERTICAL_EDGES
:returns:  pixd    8 bpp, edges are brighter, or NULL on error

<pre>
Notes:
(1) For detecting vertical edges, this considers the
difference of the central pixel from those on the left
and right.  For situations where the gradient is the same
sign on both sides, this computes and stores the minimum
(absolute value of the) difference.  The reason for
checking the sign is that we are looking for pixels within
a transition.  By contrast, for single pixel noise, the pixel
value is either larger than or smaller than its neighbors,
so the gradient would change direction on each side.  Horizontal
edges are handled similarly, looking for vertical gradients.
(2) To generate a binary image of the edges, threshold
the result using pixThresholdToBinary().  If the high
edge values are to be fg (1), invert after running
pixThresholdToBinary().
(3) This runs at about 60 Mpix/sec on a 3 GHz processor.
It is about 30% faster than Sobel, and the results are
similar.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTwoSidedEdgeFilter(*args)
    
    

    try:
        leptonica.pixMeasureEdgeSmoothness.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixMeasureEdgeSmoothness.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMeasureEdgeSmoothness not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeasureEdgeSmoothness(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'side')       
('l_int32', 'minjump')       
('l_int32', 'minreversal')       
('l_float32', '*pjpl')       
('l_float32', '*pjspl')       
('l_float32', '*prpl')       
('const char', '*debugfile')       

:param[in]    pixs:          1 bpp
:param[in]    side:          L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT
:param[in]    minjump:       minimum jump to be counted; >= 1
:param[in]    minreversal:   minimum reversal size for new peak or valley
:param[out]   pjpl:          [optional] jumps/length: number of jumps,
normalized to length of component side
:param[out]   pjspl:         [optional] jumpsum/length: sum of all
sufficiently large jumps, normalized to length
of component side
:param[out]   prpl:          [optional] reversals/length: number of
peak-to-valley or valley-to-peak reversals,
normalized to length of component side
:param[in]    debugfile:     [optional] displays constructed edge; use NULL
for no output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes three measures of smoothness of the edge of a
connected component:
jumps/length: (jpl) the number of jumps of size >= %minjump,
normalized to the length of the side
jump sum/length: (jspl) the sum of all jump lengths of
size >= %minjump, normalized to the length of the side
reversals/length: (rpl) the number of peak <--> valley
reversals, using %minreverse as a minimum deviation of
the peak or valley from its preceding extremum,
normalized to the length of the side
(2) The input pix should be a single connected component, but
this is not required.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeasureEdgeSmoothness(*args)
    
    

    try:
        leptonica.pixGetEdgeProfile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixGetEdgeProfile.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetEdgeProfile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetEdgeProfile(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'side')       
('const char', '*debugfile')       

:param[in]    pixs:        1 bpp
:param[in]    side:        L_FROM_LEFT, L_FROM_RIGHT, L_FROM_TOP, L_FROM_BOT
:param[in]    debugfile:   [optional] displays constructed edge; use NULL
for no output
:returns:  na   of fg edge pixel locations, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetEdgeProfile(*args)
    




class jpegiostub(object):
    """<pre>

Stubs for jpegio.c functions
</pre>




"""
    



class pixalloc(object):
    """<pre>

Custom memory storage with allocator and deallocator

l_int32       pmsCreate()
void          pmsDestroy()
void         *pmsCustomAlloc()
void          pmsCustomDealloc()
void         *pmsGetAlloc()
l_int32       pmsGetLevelForAlloc()
l_int32       pmsGetLevelForDealloc()
void          pmsLogInfo()
</pre>




"""
    
    try:
        leptonica.pmsCreate.argtypes = [ctypes.c_size_t, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pmsCreate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pmsCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsCreate(*args):
        """
        ('size_t', 'minsize')       
('size_t', 'smallest')       
('NUMA', '*numalloc')       
('const char', '*logfile')       

:param[in]    minsize:    of data chunk that can be supplied by pms
:param[in]    smallest:   bytes of the smallest pre-allocated data chunk.
:param[in]    numalloc:   array with the number of data chunks for each
size that are in the memory store
:param[in]    logfile:    use for debugging; null otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes the size of the block of memory required
and allocates it.  Each chunk starts on a 32-bit word boundary.
The chunk sizes are in powers of 2, starting at %smallest,
and the number of levels and chunks at each level is
specified by %numalloc.
(2) This is intended to manage the image data for a small number
of relatively large pix.  The system malloc is expected to
handle very large numbers of small chunks efficiently.
(3) Important: set the allocators and call this function
before any pix have been allocated.  Destroy all the pix
in the normal way before calling pmsDestroy().
(4) The pms struct is stored in a static global, so this function
is not thread-safe.  When used, there must be only one thread
per process.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pmsCreate(*args)
    
    

    try:
        leptonica.pmsDestroy.argtypes = []
        leptonica.pmsDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pmsDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsDestroy(*args):
        """
               

<pre>
Notes:
(1) Important: call this function at the end of the program, after
the last pix has been destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pmsDestroy(*args)
    
    

    try:
        leptonica.pmsCustomAlloc.argtypes = [ctypes.c_size_t]
        leptonica.pmsCustomAlloc.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function pmsCustomAlloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsCustomAlloc(*args):
        """
        ('size_t', 'nbytes')       

:param[in]   nbytes:    min number of bytes in the chunk to be retrieved
:returns:  data ptr to chunk

<pre>
Notes:
(1) This attempts to find a suitable pre-allocated chunk.
If not found, it dynamically allocates the chunk.
(2) If logging is turned on, the allocations that are not taken
from the memory store, and are at least as large as the
minimum size the store can handle, are logged to file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pmsCustomAlloc(*args)
    
    

    try:
        leptonica.pmsCustomDealloc.argtypes = [ctypes.c_void_p]
        leptonica.pmsCustomDealloc.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pmsCustomDealloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsCustomDealloc(*args):
        """
        ('void', '*data')       

:param[in]   data:    to be freed or returned to the storage
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.pmsCustomDealloc(*args)
    
    

    try:
        leptonica.pmsGetAlloc.argtypes = [ctypes.c_size_t]
        leptonica.pmsGetAlloc.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function pmsGetAlloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsGetAlloc(*args):
        """
        ('size_t', 'nbytes')       

:param[in]    nbytes:
:returns:  data

<pre>
Notes:
(1) This is called when a request for pix data cannot be
obtained from the preallocated memory store.  After use it
is freed like normal memory.
(2) If logging is on, only write out allocs that are as large as
the minimum size handled by the memory store.
(3) size_t is %lu on 64 bit platforms and %u on 32 bit platforms.
The C99 platform-independent format specifier for size_t is %zu.
Windows since at least VC-2015 is conforming; we can now use %zu.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pmsGetAlloc(*args)
    
    

    try:
        leptonica.pmsGetLevelForAlloc.argtypes = [ctypes.c_size_t, ctypes.c_void_p]
        leptonica.pmsGetLevelForAlloc.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pmsGetLevelForAlloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsGetLevelForAlloc(*args):
        """
        ('size_t', 'nbytes')       
('l_int32', '*plevel')       

:param[in]   nbytes: min number of bytes in the chunk to be retrieved
:param[out]  plevel:  -1 if either too small or too large
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pmsGetLevelForAlloc(*args)
    
    

    try:
        leptonica.pmsGetLevelForDealloc.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pmsGetLevelForDealloc.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pmsGetLevelForDealloc not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsGetLevelForDealloc(*args):
        """
        ('void', '*data')       
('l_int32', '*plevel')       

:param[in]   data: ptr to memory chunk
:param[out]  plevel: level in memory store; -1 if allocated
outside the store
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pmsGetLevelForDealloc(*args)
    
    

    try:
        leptonica.pmsLogInfo.argtypes = []
        leptonica.pmsLogInfo.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pmsLogInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pmsLogInfo(*args):
        """
               


        """
        args = _convert_params(*args)
        
        return leptonica.pmsLogInfo(*args)
    




class webpio(object):
    """<pre>

Reading WebP
PIX             *pixReadStreamWebP()
PIX             *pixReadMemWebP()

Reading WebP header
l_int32          readHeaderWebP()
l_int32          readHeaderMemWebP()

Writing WebP
l_int32          pixWriteWebP()  [ special top level ]
l_int32          pixWriteStreamWebP()
l_int32          pixWriteMemWebP()
</pre>




"""
    
    try:
        leptonica.pixReadStreamWebP.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamWebP.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamWebP(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream corresponding to WebP image
:returns:  pix 32 bpp, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamWebP(*args)
    
    

    try:
        leptonica.pixReadMemWebP.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemWebP.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemWebP(*args):
        """
        ('const l_uint8', '*filedata')       
('size_t', 'filesize')       

:param[in]  filedata:    webp compressed data in memory
:param[in]  filesize:    number of bytes in data
:returns:  pix 32 bpp, or NULL on error

<pre>
Notes:
(1) When the encoded data only has 3 channels (no alpha),
WebPDecodeRGBAInto() generates a raster of 32-bit pixels, with
the alpha channel set to opaque (255).
(2) We don't need to use the gnu runtime functions like fmemopen()
for redirecting data from a stream to memory, because
the webp library has been written with memory-to-memory
functions at the lowest level (which is good!).  And, in
any event, fmemopen() doesn't work with l_binaryReadStream().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemWebP(*args)
    
    

    try:
        leptonica.readHeaderWebP.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderWebP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderWebP(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       

:param[in]   filename:
:param[out]  pw:        width
:param[out]  ph:        height
:param[out]  pspp:      spp (3 or 4)
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderWebP(*args)
    
    

    try:
        leptonica.readHeaderMemWebP.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemWebP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderMemWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemWebP(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pspp')       

:param[in]    data:
:param[in]    size:    100 bytes is sufficient
:param[out]   pw:      width
:param[out]   ph:      height
:param[out]   pspp:    spp (3 or 4)
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemWebP(*args)
    
    

    try:
        leptonica.pixWriteWebP.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteWebP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteWebP(*args):
        """
        ('const char', '*filename')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'lossless')       

:param[in]   filename:
:param[in]   pixs:
:param[in]   quality:    0 - 100; default ~80
:param[in]   lossless:   use 1 for lossless; 0 for lossy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Special top-level function allowing specification of quality.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteWebP(*args)
    
    

    try:
        leptonica.pixWriteStreamWebP.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteStreamWebP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamWebP(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'lossless')       

:param[in]   fp: file stream
:param[in]   pixs:      all depths
:param[in]   quality:   0 - 100; default ~80
:param[in]   lossless:  use 1 for lossless; 0 for lossy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteMemWebP() for details.
(2) Use 'free', and not leptonica's 'LEPT_FREE', for all heap data
that is returned from the WebP library.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamWebP(*args)
    
    

    try:
        leptonica.pixWriteMemWebP.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteMemWebP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemWebP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemWebP(*args):
        """
        ('l_uint8', '**pencdata')       
('size_t', '*pencsize')       
('PIX', '*pixs')       
('l_int32', 'quality')       
('l_int32', 'lossless')       

:param[out]   pencdata:   webp encoded data of pixs
:param[out]   pencsize:   size of webp encoded data
:param[in]    pixs:       any depth, cmapped OK
:param[in]    quality:    0 - 100; default ~80
:param[in]    lossless:   use 1 for lossless; 0 for lossy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Lossless and lossy encoding are entirely different in webp.
%quality applies to lossy, and is ignored for lossless.
(2) The input image is converted to RGB if necessary.  If spp == 3,
we set the alpha channel to fully opaque (255), and
WebPEncodeRGBA() then removes the alpha chunk when encoding,
setting the internal header field has_alpha to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemWebP(*args)
    




class webpanimio(object):
    """<pre>

Writing animated WebP
l_int32          pixaWriteWebPAnim()
l_int32          pixaWriteStreamWebPAnim()
l_int32          pixaWriteMemWebPAnim()
</pre>




"""
    
    try:
        leptonica.pixaWriteWebPAnim.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaWriteWebPAnim.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteWebPAnim not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteWebPAnim(*args):
        """
        ('const char', '*filename')       
('PIXA', '*pixa')       
('l_int32', 'loopcount')       
('l_int32', 'duration')       
('l_int32', 'quality')       
('l_int32', 'lossless')       

:param[in]    filename:
:param[in]    pixa:        with images of all depths; cmap OK
:param[in]    loopcount:   [0 for infinite]
:param[in]    duration:    in ms, for each image
:param[in]    quality:     0 - 100 for lossy; default ~80
:param[in]    lossless:    use 1 for lossless; 0 for lossy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Special top-level function allowing specification of quality.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteWebPAnim(*args)
    
    

    try:
        leptonica.pixaWriteStreamWebPAnim.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaWriteStreamWebPAnim.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteStreamWebPAnim not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteStreamWebPAnim(*args):
        """
        ('FILE', '*fp')       
('PIXA', '*pixa')       
('l_int32', 'loopcount')       
('l_int32', 'duration')       
('l_int32', 'quality')       
('l_int32', 'lossless')       

:param[in]    fp:          file stream
:param[in]    pixa:        with images of all depths; cmap OK
:param[in]    loopcount:   [0 for infinite]
:param[in]    duration:    in ms, for each image
:param[in]    quality:     0 - 100 for lossy; default ~80
:param[in]    lossless:    use 1 for lossless; 0 for lossy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteMemWebP() for details.
(2) Use 'free', and not leptonica's 'LEPT_FREE', for all heap data
that is returned from the WebP library.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteStreamWebPAnim(*args)
    
    

    try:
        leptonica.pixaWriteMemWebPAnim.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaWriteMemWebPAnim.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteMemWebPAnim not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteMemWebPAnim(*args):
        """
        ('l_uint8', '**pencdata')       
('size_t', '*pencsize')       
('PIXA', '*pixa')       
('l_int32', 'loopcount')       
('l_int32', 'duration')       
('l_int32', 'quality')       
('l_int32', 'lossless')       

:param[out]   pencdata:    webp encoded data of pixs
:param[out]   pencsize:    size of webp encoded data
:param[in]    pixa:        with images of any depth, cmapped OK
:param[in]    loopcount:   [0 for infinite]
:param[in]    duration:    in ms, for each image
:param[in]    quality:     0 - 100 for lossy; default ~80
:param[in]    lossless:    use 1 for lossless; 0 for lossy
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteMemWebP() for details of webp encoding of images.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteMemWebPAnim(*args)
    




class webpanimiostub(object):
    """<pre>

Stubs for webpanimio.c functions
</pre>




"""
    



class bmf(object):
    """<pre>

Acquisition and generation of bitmap fonts.

L_BMF           *bmfCreate()
L_BMF           *bmfDestroy()

PIX             *bmfGetPix()
l_int32          bmfGetWidth()
l_int32          bmfGetBaseline()

PIXA            *pixaGetFont()
l_int32          pixaSaveFont()
static PIXA     *pixaGenerateFontFromFile()
static PIXA     *pixaGenerateFontFromString()
static PIXA     *pixaGenerateFont()
static l_int32   pixGetTextBaseline()
static l_int32   bmfMakeAsciiTables()

This is not a very general utility, because it only uses bitmap
representations of a single font, Palatino-Roman, with the
normal style.  It uses bitmaps generated for nine sizes, from
4 to 20 pts, rendered at 300 ppi.  Generalization to different
fonts, styles and sizes is straightforward.

I chose Palatino-Roman is because I like it.
The input font images were generated from a set of small
PostScript files, such as chars-12.ps, which were rendered
into the inputfont[] bitmap files using GhostScript.  See, for
example, the bash script prog/ps2tiff, which will "rip" a
PostScript file into a set of ccitt-g4 compressed tiff files.

The set of ascii characters from 32 through 126 are the 95
printable ascii chars.  Palatino-Roman is missing char 92, '\'.
I have substituted an LR flip of '/', char 47, for 92, so that
there are no missing printable chars in this set.  The space is
char 32, and I have given it a width equal to twice the width of '!'.
</pre>




"""
    
    try:
        leptonica.bmfCreate.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.bmfCreate.restype = lambda address: L_BMF(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function bmfCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfCreate(*args):
        """
        ('const char', '*dir')       
('l_int32', 'fontsize')       

:param[in]    dir:        [optional] directory holding pixa of character set
:param[in]    fontsize:   4, 6, 8, ... , 20
:returns:  bmf    holding the bitmap font and associated information

<pre>
Notes:
(1) If %dir == null, this generates the font bitmaps from a
compiled string.
(2) Otherwise, this tries to read a pre-computed pixa file with the
95 ascii chars in it.  If the file is not found, it then
attempts to generate the pixa and associated baseline
data from a tiff image containing all the characters.  If
that fails, it uses the compiled string.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.bmfCreate(*args)
    
    

    try:
        leptonica.bmfDestroy.argtypes = [ctypes.c_void_p]
        leptonica.bmfDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function bmfDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfDestroy(*args):
        """
        ('L_BMF', '**pbmf')       

:param[in,out]   pbmf:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.bmfDestroy(*args)
    
    

    try:
        leptonica.bmfGetPix.argtypes = [ctypes.c_void_p, ctypes.c_char]
        leptonica.bmfGetPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function bmfGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetPix(*args):
        """
        ('L_BMF', '*bmf')       
('char', 'chr')       

:param[in]    bmf:
:param[in]    chr:    should be one of the 95 supported printable bitmaps
:returns:  pix    clone of pix in bmf, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetPix(*args)
    
    

    try:
        leptonica.bmfGetWidth.argtypes = [ctypes.c_void_p, ctypes.c_char, ctypes.c_void_p]
        leptonica.bmfGetWidth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bmfGetWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetWidth(*args):
        """
        ('L_BMF', '*bmf')       
('char', 'chr')       
('l_int32', '*pw')       

:param[in]    bmf:
:param[in]    chr:    should be one of the 95 supported bitmaps
:param[out]   pw:     character width; -1 if not printable
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetWidth(*args)
    
    

    try:
        leptonica.bmfGetBaseline.argtypes = [ctypes.c_void_p, ctypes.c_char, ctypes.c_void_p]
        leptonica.bmfGetBaseline.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function bmfGetBaseline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def bmfGetBaseline(*args):
        """
        ('L_BMF', '*bmf')       
('char', 'chr')       
('l_int32', '*pbaseline')       

:param[in]    bmf:
:param[in]    chr:         should be one of the 95 supported bitmaps
:param[out]   pbaseline:   distance below UL corner of bitmap char
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.bmfGetBaseline(*args)
    
    

    try:
        leptonica.pixaGetFont.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaGetFont.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaGetFont not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaGetFont(*args):
        """
        ('const char', '*dir')       
('l_int32', 'fontsize')       
('l_int32', '*pbl0')       
('l_int32', '*pbl1')       
('l_int32', '*pbl2')       

:param[in]    dir:         directory holding pixa of character set
:param[in]    fontsize:    4, 6, 8, ... , 20
:param[out]   pbl0:        baseline of row 1
:param[out]   pbl1:        baseline of row 2
:param[out]   pbl2:        baseline of row 3
:returns:  pixa    of font bitmaps for 95 characters, or NULL on error

<pre>
Notes:
(1) This reads a pre-computed pixa file with the 95 ascii chars.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaGetFont(*args)
    
    

    try:
        leptonica.pixaSaveFont.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixaSaveFont.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaSaveFont not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSaveFont(*args):
        """
        ('const char', '*indir')       
('const char', '*outdir')       
('l_int32', 'fontsize')       

:param[in]    indir:      [optional] directory holding image of character set
:param[in]    outdir:     directory into which the output pixa file
will be written
:param[in]    fontsize:   in pts, at 300 ppi
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This saves a font of a particular size.
(2) If %indir == null, this generates the font bitmaps from a
compiled string.
(3) prog/genfonts calls this function for each of the
nine font sizes, to generate all the font pixa files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSaveFont(*args)
    




class kernel(object):
    """<pre>

Basic operations on kernels for image convolution

Create/destroy/copy
L_KERNEL   *kernelCreate()
void        kernelDestroy()
L_KERNEL   *kernelCopy()

Accessors:
l_int32     kernelGetElement()
l_int32     kernelSetElement()
l_int32     kernelGetParameters()
l_int32     kernelSetOrigin()
l_int32     kernelGetSum()
l_int32     kernelGetMinMax()

Normalize/invert
L_KERNEL   *kernelNormalize()
L_KERNEL   *kernelInvert()

Helper function
l_float32 **create2dFloatArray()

Serialized I/O
L_KERNEL   *kernelRead()
L_KERNEL   *kernelReadStream()
l_int32     kernelWrite()
l_int32     kernelWriteStream()

Making a kernel from a compiled string
L_KERNEL   *kernelCreateFromString()

Making a kernel from a simple file format
L_KERNEL   *kernelCreateFromFile()

Making a kernel from a Pix
L_KERNEL   *kernelCreateFromPix()

Display a kernel in a pix
PIX        *kernelDisplayInPix()

Parse string to extract numbers
NUMA       *parseStringForNumbers()

Simple parametric kernels
L_KERNEL   *makeFlatKernel()
L_KERNEL   *makeGaussianKernel()
L_KERNEL   *makeGaussianKernelSep()
L_KERNEL   *makeDoGKernel()
</pre>




"""
    
    try:
        leptonica.kernelCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelCreate.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreate(*args):
        """
        ('l_int32', 'height')       
('l_int32', 'width')       

:param[in]    height,: width
:returns:  kernel, or NULL on error

<pre>
Notes:
(1) kernelCreate() initializes all values to 0.
(2) After this call, (cy,cx) and nonzero data values must be
assigned.
(2) The number of kernel elements must be less than 2^29.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreate(*args)
    
    

    try:
        leptonica.kernelDestroy.argtypes = [ctypes.c_void_p]
        leptonica.kernelDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function kernelDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelDestroy(*args):
        """
        ('L_KERNEL', '**pkel')       

:param[in,out]   pkel:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.kernelDestroy(*args)
    
    

    try:
        leptonica.kernelCopy.argtypes = [ctypes.c_void_p]
        leptonica.kernelCopy.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCopy(*args):
        """
        ('L_KERNEL', '*kels')       

:param[in]    kels:    source kernel
:returns:  keld   copy of kels, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCopy(*args)
    
    

    try:
        leptonica.kernelGetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.kernelGetElement.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelGetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetElement(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_float32', '*pval')       

:param[in]    kel:
:param[in]    row:
:param[in]    col:
:param[out]   pval:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetElement(*args)
    
    

    try:
        leptonica.kernelSetElement.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.kernelSetElement.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelSetElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelSetElement(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'row')       
('l_int32', 'col')       
('l_float32', 'val')       

:param[in]    kel: kernel
:param[in]    row:
:param[in]    col:
:param[in]    val:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelSetElement(*args)
    
    

    try:
        leptonica.kernelGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelGetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetParameters(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', '*psy')       
('l_int32', '*psx')       
('l_int32', '*pcy')       
('l_int32', '*pcx')       

:param[in]    kel:                  kernel
:param[out]   psy,: psx, pcy, pcx   [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetParameters(*args)
    
    

    try:
        leptonica.kernelSetOrigin.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelSetOrigin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelSetOrigin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelSetOrigin(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'cy')       
('l_int32', 'cx')       

:param[in]    kel:       kernel
:param[in]    cy,: cx
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelSetOrigin(*args)
    
    

    try:
        leptonica.kernelGetSum.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelGetSum.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelGetSum not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetSum(*args):
        """
        ('L_KERNEL', '*kel')       
('l_float32', '*psum')       

:param[in]    kel:      kernel
:param[out]   psum:     sum of all kernel values
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetSum(*args)
    
    

    try:
        leptonica.kernelGetMinMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelGetMinMax.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelGetMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelGetMinMax(*args):
        """
        ('L_KERNEL', '*kel')       
('l_float32', '*pmin')       
('l_float32', '*pmax')       

:param[in]    kel:      kernel
:param[out]   pmin:     [optional] minimum value
:param[out]   pmax:     [optional] maximum value
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelGetMinMax(*args)
    
    

    try:
        leptonica.kernelNormalize.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.kernelNormalize.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelNormalize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelNormalize(*args):
        """
        ('L_KERNEL', '*kels')       
('l_float32', 'normsum')       

:param[in]    kels:      source kel, to be normalized
:param[in]    normsum:   desired sum of elements in keld
:returns:  keld   normalized version of kels, or NULL on error
or if sum of elements is very close to 0)

<pre>
Notes:
(1) If the sum of kernel elements is close to 0, do not
try to calculate the normalized kernel.  Instead,
return a copy of the input kernel, with a warning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelNormalize(*args)
    
    

    try:
        leptonica.kernelInvert.argtypes = [ctypes.c_void_p]
        leptonica.kernelInvert.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelInvert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelInvert(*args):
        """
        ('L_KERNEL', '*kels')       

:param[in]    kels:   source kel, to be inverted
:returns:  keld   spatially inverted, about the origin, or NULL on error

<pre>
Notes:
(1) For convolution, the kernel is spatially inverted before
a "correlation" operation is done between the kernel and the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelInvert(*args)
    
    

    try:
        leptonica.create2dFloatArray.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.create2dFloatArray.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_float))
    except AttributeError:
        sys.stderr.write("Warning - function create2dFloatArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def create2dFloatArray(*args):
        """
        ('l_int32', 'sy')       
('l_int32', 'sx')       

:param[in]    sy:   rows == height
:param[in]    sx:   columns == width
:returns:  doubly indexed array i.e., an array of sy row pointers,
each of which points to an array of sx floats

<pre>
Notes:
(1) The array[%sy][%sx] is indexed in standard "matrix notation",
with the row index first.
(2) The caller kernelCreate() limits the size to < 2^29 pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.create2dFloatArray(*args)
    
    

    try:
        leptonica.kernelRead.argtypes = [ctypes.c_char_p]
        leptonica.kernelRead.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelRead(*args):
        """
        ('const char', '*fname')       

:param[in]    fname:    filename
:returns:  kernel, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelRead(*args)
    
    

    try:
        leptonica.kernelReadStream.argtypes = [ctypes.c_void_p]
        leptonica.kernelReadStream.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  kernel, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelReadStream(*args)
    
    

    try:
        leptonica.kernelWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.kernelWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelWrite(*args):
        """
        ('const char', '*fname')       
('L_KERNEL', '*kel')       

:param[in]    fname:    output file
:param[in]    kel:      kernel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelWrite(*args)
    
    

    try:
        leptonica.kernelWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.kernelWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function kernelWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_KERNEL', '*kel')       

:param[in]    fp:    file stream
:param[in]    kel:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.kernelWriteStream(*args)
    
    

    try:
        leptonica.kernelCreateFromString.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.kernelCreateFromString.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreateFromString(*args):
        """
        ('l_int32', 'h')       
('l_int32', 'w')       
('l_int32', 'cy')       
('l_int32', 'cx')       
('const char', '*kdata')       

:param[in]    h,: w     height, width
:param[in]    cy,: cx   origin
:param[in]    kdata:
:returns:  kernel of the given size, or NULL on error

<pre>
Notes:
(1) The data is an array of chars, in row-major order, giving
space separated integers in the range [-255 ... 255].
(2) The only other formatting limitation is that you must
leave space between the last number in each row and
the double-quote.  If possible, it's also nice to have each
line in the string represent a line in the kernel; e.g.,
static const char *kdata =
" 20   50   20 "
" 70  140   70 "
" 20   50   20 ";
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreateFromString(*args)
    
    

    try:
        leptonica.kernelCreateFromFile.argtypes = [ctypes.c_char_p]
        leptonica.kernelCreateFromFile.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreateFromFile(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  kernel, or NULL on error

<pre>
Notes:
(1) The file contains, in the following order:
~ Any number of comment lines starting with '#' are ignored
~ The height and width of the kernel
~ The y and x values of the kernel origin
~ The kernel data, formatted as lines of numbers (integers
or floats) for the kernel values in row-major order,
and with no other punctuation.
(Note: this differs from kernelCreateFromString(),
where each line must begin and end with a double-quote
to tell the compiler it's part of a string.)
~ The kernel specification ends when a blank line,
a comment line, or the end of file is reached.
(2) All lines must be left-justified.
(3) See kernelCreateFromString() for a description of the string
format for the kernel data.  As an example, here are the lines
of a valid kernel description file  In the file, all lines
are left-justified:
\code
# small 3x3 kernel
3 3
1 1
25.5   51    24.3
70.2  146.3  73.4
20     50.9  18.4
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreateFromFile(*args)
    
    

    try:
        leptonica.kernelCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelCreateFromPix.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'cy')       
('l_int32', 'cx')       

:param[in]    pix:
:param[in]    cy,: cx    origin of kernel
:returns:  kernel, or NULL on error

<pre>
Notes:
(1) The origin must be positive and within the dimensions of the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelCreateFromPix(*args)
    
    

    try:
        leptonica.kernelDisplayInPix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.kernelDisplayInPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function kernelDisplayInPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def kernelDisplayInPix(*args):
        """
        ('L_KERNEL', '*kel')       
('l_int32', 'size')       
('l_int32', 'gthick')       

:param[in]    kel:       kernel
:param[in]    size:      of grid interiors; odd; either 1 or a minimum size
of 17 is enforced
:param[in]    gthick:    grid thickness; either 0 or a minimum size of 2
is enforced
:returns:  pix   display of kernel, or NULL on error

<pre>
Notes:
(1) This gives a visual representation of a kernel.
(2) There are two modes of display:
(a) Grid lines of minimum width 2, surrounding regions
representing kernel elements of minimum size 17,
with a "plus" mark at the kernel origin, or
(b) A pix without grid lines and using 1 pixel per kernel element.
(3) For both cases, the kernel absolute value is displayed,
normalized such that the maximum absolute value is 255.
(4) Large 2D separable kernels should be used for convolution
with two 1D kernels.  However, for the bilateral filter,
the computation time is independent of the size of the
2D content kernel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.kernelDisplayInPix(*args)
    
    

    try:
        leptonica.parseStringForNumbers.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.parseStringForNumbers.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function parseStringForNumbers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def parseStringForNumbers(*args):
        """
        ('const char', '*str')       
('const char', '*seps')       

:param[in]    str:     string containing numbers; not changed
:param[in]    seps:    string of characters that can be used between ints
:returns:  numa   of numbers found, or NULL on error

<pre>
Notes:
(1) The numbers can be ints or floats.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.parseStringForNumbers(*args)
    
    

    try:
        leptonica.makeFlatKernel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makeFlatKernel.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeFlatKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeFlatKernel(*args):
        """
        ('l_int32', 'height')       
('l_int32', 'width')       
('l_int32', 'cy')       
('l_int32', 'cx')       

:param[in]    height,: width
:param[in]    cy,: cx          origin of kernel
:returns:  kernel, or NULL on error

<pre>
Notes:
(1) This is the same low-pass filtering kernel that is used
in the block convolution functions.
(2) The kernel origin (%cy, %cx) is typically placed as near
the center of the kernel as possible.  If height and
width are odd, then using %cy = height / 2 and
%cx = width / 2 places the origin at the exact center.
(3) This returns a normalized kernel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeFlatKernel(*args)
    
    

    try:
        leptonica.makeGaussianKernel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.makeGaussianKernel.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeGaussianKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGaussianKernel(*args):
        """
        ('l_int32', 'halfh')       
('l_int32', 'halfw')       
('l_float32', 'stdev')       
('l_float32', 'max')       

:param[in]    halfh:     sy = 2 * halfh + 1
:param[in]    halfw:     sx = 2 * halfw + 1
:param[in]    stdev:     standard deviation
:param[in]    max:       value at (cx,cy)
:returns:  kernel, or NULL on error

<pre>
Notes:
(1) The kernel size (sx, sy) = (2 * %halfw + 1, 2 * %halfh + 1)
(2) The kernel center (cx, cy) = (%halfw, %halfh).
(3) %halfw and %halfh are typically equal, and
are typically several times larger than the standard deviation.
(4) If pixConvolve() is invoked with normalization (the sum of
kernel elements = 1.0), use 1.0 for max (or any number that's
not too small or too large).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeGaussianKernel(*args)
    
    

    try:
        leptonica.makeGaussianKernelSep.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.makeGaussianKernelSep.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function makeGaussianKernelSep not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeGaussianKernelSep(*args):
        """
        ('l_int32', 'halfh')       
('l_int32', 'halfw')       
('l_float32', 'stdev')       
('l_float32', 'max')       
('L_KERNEL', '**pkelx')       
('L_KERNEL', '**pkely')       

:param[in]    halfh:     sy = 2 * halfh + 1
:param[in]    halfw:     sx = 2 * halfw + 1
:param[in]    stdev:     standard deviation
:param[in]    max:       value at (cx,cy)
:param[out]   pkelx:     x part of kernel
:param[out]   pkely:     y part of kernel
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See makeGaussianKernel() for description of input parameters.
(2) These kernels are constructed so that the result of both
normalized and un-normalized convolution will be the same
as when convolving with pixConvolve() using the full kernel.
(3) The trick for the un-normalized convolution is to have the
product of the two kernel elemets at (cx,cy) be equal to %max,
not max**2.  That's why %max for kely is 1.0.  If instead
we use sqrt(%max) for both, the results are slightly less
accurate, when compared to using the full kernel in
makeGaussianKernel().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeGaussianKernelSep(*args)
    
    

    try:
        leptonica.makeDoGKernel.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.makeDoGKernel.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeDoGKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeDoGKernel(*args):
        """
        ('l_int32', 'halfh')       
('l_int32', 'halfw')       
('l_float32', 'stdev')       
('l_float32', 'ratio')       

:param[in]    halfh:     sy = 2 * halfh + 1
:param[in]    halfw:     sx = 2 * halfw + 1
:param[in]    stdev:     standard deviation of narrower gaussian
:param[in]    ratio:     of stdev for wide filter to stdev for narrow one
:returns:  kernel, or NULL on error

<pre>
Notes:
(1) The DoG (difference of gaussians) is a wavelet mother
function with null total sum.  By subtracting two blurred
versions of the image, it acts as a bandpass filter for
frequencies passed by the narrow gaussian but stopped
by the wide one.See:
http://en.wikipedia.org/wiki/Difference_of_Gaussians
(2) The kernel size (sx, sy) = (2 * halfw + 1, 2 * halfh + 1).
(3) The kernel center (cx, cy) = (halfw, halfh).
(4) %halfw and %halfh are typically equal, and are typically
several times larger than the standard deviation.
(5) %ratio is the ratio of standard deviations of the wide
to narrow gaussian.  It must be >= 1.0; 1.0 is a no-op.
(6) Because the kernel is a null sum, it must be invoked without
normalization in pixConvolve().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeDoGKernel(*args)
    




class pixarith(object):
    """<pre>

One-image grayscale arithmetic operations (8, 16, 32 bpp)
l_int32     pixAddConstantGray()
l_int32     pixMultConstantGray()

Two-image grayscale arithmetic operations (8, 16, 32 bpp)
PIX        *pixAddGray()
PIX        *pixSubtractGray()
PIX        *pixMultiplyGray()

Grayscale threshold operation (8, 16, 32 bpp)
PIX        *pixThresholdToValue()

Image accumulator arithmetic operations
PIX        *pixInitAccumulate()
PIX        *pixFinalAccumulate()
PIX        *pixFinalAccumulateThreshold()
l_int32     pixAccumulate()
l_int32     pixMultConstAccumulate()

Absolute value of difference
PIX        *pixAbsDifference()

Sum of color images
PIX        *pixAddRGB()

Two-image min and max operations (8 and 16 bpp)
PIX        *pixMinOrMax()

Scale pix for maximum dynamic range
PIX        *pixMaxDynamicRange()
PIX        *pixMaxDynamicRangeRGB()

RGB pixel value scaling
l_uint32    linearScaleRGBVal()
l_uint32    logScaleRGBVal()

Log base2 lookup
l_float32  *makeLogBase2Tab()
l_float32   getLogBase2()

The image accumulator operations are used when you expect
overflow from 8 bits on intermediate results.  For example,
you might want a tophat contrast operator which is
3*I - opening(I,S) - closing(I,S)
To use these operations, first use the init to generate
a 16 bpp image, use the accumulate to add or subtract 8 bpp
images from that, or the multiply constant to multiply
by a small constant (much less than 256 -- we don't want
overflow from the 16 bit images!), and when you're finished
use final to bring the result back to 8 bpp, clipped
if necessary.  There is also a divide function, which
can be used to divide one image by another, scaling the
result for maximum dynamic range, and giving back the
8 bpp result.

A simpler interface to the arithmetic operations is
provided in pixacc.c.
</pre>




"""
    
    try:
        leptonica.pixAddConstantGray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAddConstantGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAddConstantGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddConstantGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'val')       

:param[in]    pixs:   8, 16 or 32 bpp
:param[in]    val:    amount to add to each pixel
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place operation.
(2) No clipping for 32 bpp.
(3) For 8 and 16 bpp, if val > 0 the result is clipped
to 0xff and 0xffff, rsp.
(4) For 8 and 16 bpp, if val < 0 the result is clipped to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddConstantGray(*args)
    
    

    try:
        leptonica.pixMultConstantGray.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixMultConstantGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMultConstantGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultConstantGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'val')       

:param[in]    pixs:   8, 16 or 32 bpp
:param[in]    val:    >= 0.0; amount to multiply by each pixel
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place operation; val must be >= 0.
(2) No clipping for 32 bpp.
(3) For 8 and 16 bpp, the result is clipped to 0xff and 0xffff, rsp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultConstantGray(*args)
    
    

    try:
        leptonica.pixAddGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs1, or
different from pixs1
:param[in]    pixs1:   can be equal to pixd
:param[in]    pixs2:
:returns:  pixd always

<pre>
Notes:
(1) Arithmetic addition of two 8, 16 or 32 bpp images.
(2) For 8 and 16 bpp, we do explicit clipping to 0xff and 0xffff,
respectively.
(3) Alignment is to UL corner.
(4) There are 3 cases.  The result can go to a new dest,
in-place to pixs1, or to an existing input dest:
pixd == null:   (src1 + src2) --> new pixd
pixd == pixs1:  (src1 + src2) --> src1  (in-place)
pixd != pixs1:  (src1 + src2) --> input pixd
(5) pixs2 must be different from both pixd and pixs1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddGray(*args)
    
    

    try:
        leptonica.pixSubtractGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSubtractGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSubtractGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSubtractGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs1, or
different from pixs1
:param[in]    pixs1:    can be equal to pixd
:param[in]    pixs2:
:returns:  pixd always

<pre>
Notes:
(1) Arithmetic subtraction of two 8, 16 or 32 bpp images.
(2) Source pixs2 is always subtracted from source pixs1.
(3) Do explicit clipping to 0.
(4) Alignment is to UL corner.
(5) There are 3 cases.  The result can go to a new dest,
in-place to pixs1, or to an existing input dest:
(a) pixd == null   (src1 - src2) --> new pixd
(b) pixd == pixs1  (src1 - src2) --> src1  (in-place)
(d) pixd != pixs1  (src1 - src2) --> input pixd
(6) pixs2 must be different from both pixd and pixs1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSubtractGray(*args)
    
    

    try:
        leptonica.pixMultiplyGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixMultiplyGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMultiplyGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultiplyGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixg')       
('l_float32', 'norm')       

:param[in]    pixs:    32 bpp rgb or 8 bpp gray
:param[in]    pixg:    8 bpp gray
:param[in]    norm:    multiplicative factor to avoid overflow; 0 for default
:returns:  pixd, or null on error

<pre>
Notes:
(1) This function can be used for correcting a scanned image
under non-uniform illumination.  For that application,
%pixs is the scanned image, %pixg is an image whose values
are inversely related to light from a uniform (say, white)
target, and %norm is typically the inverse of the maximum
pixel value in %pixg.
(2) Set norm = 0 to get the default value, which is the inverse
of the max value in %pixg.  This avoids overflow in the product.
(3) For 32 bpp %pixs, all 3 components are multiplied by the
same number.
(4) Alignment is to UL corner.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultiplyGray(*args)
    
    

    try:
        leptonica.pixThresholdToValue.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThresholdToValue.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThresholdToValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThresholdToValue(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'threshval')       
('l_int32', 'setval')       

:param[in]    pixd:       [optional]; if not null, must be equal to pixs
:param[in]    pixs:       8, 16, 32 bpp
:param[in]    threshval:
:param[in]    setval:
:returns:  pixd always

<pre>
Notes:
~ operation can be in-place (pixs == pixd) or to a new pixd
~ if %setval > %threshval, sets pixels with a value >= threshval to setval
~ if %setval < %threshval, sets pixels with a value <= threshval to setval
~ if %setval == %threshval, no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThresholdToValue(*args)
    
    

    try:
        leptonica.pixInitAccumulate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixInitAccumulate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixInitAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixInitAccumulate(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_uint32', 'offset')       

:param[in]    w,: h      of accumulate array
:param[in]    offset:    initialize the 32 bpp to have this
value; not more than 0x40000000
:returns:  pixd   32 bpp, or NULL on error

<pre>
Notes:
(1) %offset must be >= 0.
(2) %offset is used so that we can do arithmetic
with negative number results on l_uint32 data; it
prevents the l_uint32 data from going negative.
(3) Because we use l_int32 intermediate data results,
these should never exceed the max of l_int32 (0x7fffffff).
We do not permit the offset to be above 0x40000000,
which is half way between 0 and the max of l_int32.
(4) The same offset should be used for initialization,
multiplication by a constant, and final extraction!
(5) If you're only adding positive values, %offset can be 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixInitAccumulate(*args)
    
    

    try:
        leptonica.pixFinalAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixFinalAccumulate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFinalAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFinalAccumulate(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'offset')       
('l_int32', 'depth')       

:param[in]    pixs:     32 bpp
:param[in]    offset:   same as used for initialization
:param[in]    depth:    8, 16 or 32 bpp, of destination
:returns:  pixd   8, 16 or 32 bpp, or NULL on error

<pre>
Notes:
(1) %offset must be >= 0 and should not exceed 0x40000000.
(2) %offset is subtracted from the src 32 bpp image
(3) For 8 bpp dest, the result is clipped to [0, 0xff]
(4) For 16 bpp dest, the result is clipped to [0, 0xffff]
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFinalAccumulate(*args)
    
    

    try:
        leptonica.pixFinalAccumulateThreshold.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixFinalAccumulateThreshold.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFinalAccumulateThreshold not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFinalAccumulateThreshold(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'offset')       
('l_uint32', 'threshold')       

:param[in]    pixs:        32 bpp
:param[in]    offset:      same as used for initialization
:param[in]    threshold:   values less than this are set in the destination
:returns:  pixd   1 bpp, or NULL on error

<pre>
Notes:
(1) %offset must be >= 0 and should not exceed 0x40000000.
(2) %offset is subtracted from the src 32 bpp image
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFinalAccumulateThreshold(*args)
    
    

    try:
        leptonica.pixAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixAccumulate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAccumulate(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'op')       

:param[in]    pixd:    32 bpp
:param[in]    pixs:    1, 8, 16 or 32 bpp
:param[in]    op:      L_ARITH_ADD or L_ARITH_SUBTRACT
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This adds or subtracts each pixs value from pixd.
(2) This clips to the minimum of pixs and pixd, so they
do not need to be the same size.
(3) The alignment is to the origin [UL corner] of pixs & pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAccumulate(*args)
    
    

    try:
        leptonica.pixMultConstAccumulate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_uint32]
        leptonica.pixMultConstAccumulate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMultConstAccumulate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultConstAccumulate(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'factor')       
('l_uint32', 'offset')       

:param[in]    pixs:      32 bpp
:param[in]    factor:
:param[in]    offset:    same as used for initialization
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) %offset must be >= 0 and should not exceed 0x40000000.
(2) This multiplies each pixel, relative to offset, by %factor.
(3) The result is returned with %offset back in place.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultConstAccumulate(*args)
    
    

    try:
        leptonica.pixAbsDifference.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAbsDifference.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAbsDifference not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAbsDifference(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]    pixs1,: pixs2    both either 8 or 16 bpp gray, or 32 bpp RGB
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The depth of pixs1 and pixs2 must be equal.
(2) Clips computation to the min size, aligning the UL corners
(3) For 8 and 16 bpp, assumes one gray component.
(4) For 32 bpp, assumes 3 color components, and ignores the
LSB of each word (the alpha channel)
(5) Computes the absolute value of the difference between
each component value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAbsDifference(*args)
    
    

    try:
        leptonica.pixAddRGB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddRGB(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]    pixs1,: pixs2    32 bpp RGB, or colormapped
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Clips computation to the minimum size, aligning the UL corners.
(2) Removes any colormap to RGB, and ignores the LSB of each
pixel word (the alpha channel).
(3) Adds each component value, pixelwise, clipping to 255.
(4) This is useful to combine two images where most of the
pixels are essentially black, such as in pixPerceptualDiff().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddRGB(*args)
    
    

    try:
        leptonica.pixMinOrMax.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMinOrMax.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMinOrMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMinOrMax(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_int32', 'type')       

:param[in]    pixd:     [optional] destination: this can be null,
equal to pixs1, or different from pixs1
:param[in]    pixs1:    can be equal to pixd
:param[in]    pixs2:
:param[in]    type:     L_CHOOSE_MIN, L_CHOOSE_MAX
:returns:  pixd always

<pre>
Notes:
(1) This gives the min or max of two images, component-wise.
(2) The depth can be 8 or 16 bpp for 1 component, and 32 bpp
for a 3 component image.  For 32 bpp, ignore the LSB
of each word (the alpha channel)
(3) There are 3 cases:
~  if pixd == null,   Min(src1, src2) --> new pixd
~  if pixd == pixs1,  Min(src1, src2) --> src1  (in-place)
~  if pixd != pixs1,  Min(src1, src2) --> input pixd
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMinOrMax(*args)
    
    

    try:
        leptonica.pixMaxDynamicRange.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMaxDynamicRange.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaxDynamicRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaxDynamicRange(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:    4, 8, 16 or 32 bpp source
:param[in]    type:    L_LINEAR_SCALE or L_LOG_SCALE
:returns:  pixd    8 bpp, or NULL on error

<pre>
Notes:
(1) Scales pixel values to fit maximally within the dest 8 bpp pixd
(2) Assumes the source 'pixels' are a 1-component scalar.  For
a 32 bpp source, each pixel is treated as a single number --
not as a 3-component rgb pixel value.
(3) Uses a LUT for log scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaxDynamicRange(*args)
    
    

    try:
        leptonica.pixMaxDynamicRangeRGB.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMaxDynamicRangeRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaxDynamicRangeRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaxDynamicRangeRGB(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:    32 bpp rgb source
:param[in]    type:    L_LINEAR_SCALE or L_LOG_SCALE
:returns:  pixd   32 bpp, or NULL on error

<pre>
Notes:
(1) Scales pixel values to fit maximally within a 32 bpp dest pixd
(2) All color components are scaled with the same factor, based
on the maximum r,g or b component in the image.  This should
not be used if the 32-bit value is a single number (e.g., a
count in a histogram generated by pixMakeHistoHS()).
(3) Uses a LUT for log scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaxDynamicRangeRGB(*args)
    
    

    try:
        leptonica.linearScaleRGBVal.argtypes = [ctypes.c_uint32, ctypes.c_float]
        leptonica.linearScaleRGBVal.restype = ctypes.c_uint32
    except AttributeError:
        sys.stderr.write("Warning - function linearScaleRGBVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def linearScaleRGBVal(*args):
        """
        ('l_uint32', 'sval')       
('l_float32', 'factor')       

:param[in]    sval:     32-bit rgb pixel value
:param[in]    factor:   multiplication factor on each component
:returns:  dval  linearly scaled version of %sval

<pre>
Notes:
(1) %factor must be chosen to be not greater than (255 / maxcomp),
where maxcomp is the maximum value of the pixel components.
Otherwise, the product will overflow a uint8.  In use, factor
is the same for all pixels in a pix.
(2) No scaling is performed on the transparency ("A") component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.linearScaleRGBVal(*args)
    
    

    try:
        leptonica.logScaleRGBVal.argtypes = [ctypes.c_uint32, ctypes.c_void_p, ctypes.c_float]
        leptonica.logScaleRGBVal.restype = ctypes.c_uint32
    except AttributeError:
        sys.stderr.write("Warning - function logScaleRGBVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def logScaleRGBVal(*args):
        """
        ('l_uint32', 'sval')       
('l_float32', '*tab')       
('l_float32', 'factor')       

:param[in]    sval:     32-bit rgb pixel value
:param[in]    tab:      256 entry log-base-2 table
:param[in]    factor:   multiplication factor on each component
:returns:  dval  log scaled version of %sval

<pre>
Notes:
(1) %tab is made with makeLogBase2Tab().
(2) %factor must be chosen to be not greater than
255.0 / log[base2](maxcomp), where maxcomp is the maximum
value of the pixel components.  Otherwise, the product
will overflow a uint8.  In use, factor is the same for
all pixels in a pix.
(3) No scaling is performed on the transparency ("A") component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.logScaleRGBVal(*args)
    




class rotate(object):
    """<pre>

General rotation about image center
PIX     *pixRotate()
PIX     *pixEmbedForRotation()

General rotation by sampling
PIX     *pixRotateBySampling()

Nice (slow) rotation of 1 bpp image
PIX     *pixRotateBinaryNice()

Rotation including alpha (blend) component
PIX     *pixRotateWithAlpha()

Rotations are measured in radians; clockwise is positive.

The general rotation pixRotate() does the best job for
rotating about the image center.  For 1 bpp, it uses shear;
for others, it uses either shear or area mapping.
If requested, it expands the output image so that no pixels are lost
in the rotation, and this can be done on multiple successive shears
without expanding beyond the maximum necessary size.
</pre>




"""
    
    try:
        leptonica.pixRotate.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRotate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'type')       
('l_int32', 'incolor')       
('l_int32', 'width')       
('l_int32', 'height')       

:param[in]    pixs:     1, 2, 4, 8, 32 bpp rgb
:param[in]    angle:    radians; clockwise is positive
:param[in]    type:     L_ROTATE_AREA_MAP, L_ROTATE_SHEAR, L_ROTATE_SAMPLING
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:param[in]    width:    original width; use 0 to avoid embedding
:param[in]    height:   original height; use 0 to avoid embedding
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is a high-level, simple interface for rotating images
about their center.
(2) For very small rotations, just return a clone.
(3) Rotation brings either white or black pixels in
from outside the image.
(4) The rotation type is adjusted if necessary for the image
depth and size of rotation angle.  For 1 bpp images, we
rotate either by shear or sampling.
(5) Colormaps are removed for rotation by area mapping.
(6) The dest can be expanded so that no image pixels
are lost.  To invoke expansion, input the original
width and height.  For repeated rotation, use of the
original width and height allows the expansion to
stop at the maximum required size, which is a square
with side = sqrt(w*w + h*h).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate(*args)
    
    

    try:
        leptonica.pixEmbedForRotation.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixEmbedForRotation.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixEmbedForRotation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEmbedForRotation(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       
('l_int32', 'width')       
('l_int32', 'height')       

:param[in]    pixs:      1, 2, 4, 8, 32 bpp rgb
:param[in]    angle:     radians; clockwise is positive
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:param[in]    width:     original width; use 0 to avoid embedding
:param[in]    height:    original height; use 0 to avoid embedding
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) For very small rotations, just return a clone.
(2) Generate larger image to embed pixs if necessary, and
place the center of the input image in the center.
(3) Rotation brings either white or black pixels in
from outside the image.  For colormapped images where
there is no white or black, a new color is added if
possible for these pixels; otherwise, either the
lightest or darkest color is used.  In most cases,
the colormap will be removed prior to rotation.
(4) The dest is to be expanded so that no image pixels
are lost after rotation.  Input of the original width
and height allows the expansion to stop at the maximum
required size, which is a square with side equal to
sqrt(w*w + h*h).
(5) For an arbitrary angle, the expansion can be found by
considering the UL and UR corners.  As the image is
rotated, these move in an arc centered at the center of
the image.  Normalize to a unit circle by dividing by half
the image diagonal.  After a rotation of T radians, the UL
and UR corners are at points T radians along the unit
circle.  Compute the x and y coordinates of both these
points and take the max of absolute values; these represent
the half width and half height of the containing rectangle.
The arithmetic is done using formulas for sin(a+b) and cos(a+b),
where b = T.  For the UR corner, sin(a) = h/d and cos(a) = w/d.
For the UL corner, replace a by (pi - a), and you have
sin(pi - a) = h/d, cos(pi - a) = -w/d.  The equations
given below follow directly.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEmbedForRotation(*args)
    
    

    try:
        leptonica.pixRotateBySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateBySampling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateBySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateBySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:     1, 2, 4, 8, 16, 32 bpp rgb; can be cmapped
:param[in]    xcen:     x value of center of rotation
:param[in]    ycen:     y value of center of rotation
:param[in]    angle:    radians; clockwise is positive
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) For very small rotations, just return a clone.
(2) Rotation brings either white or black pixels in
from outside the image.
(3) Colormaps are retained.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateBySampling(*args)
    
    

    try:
        leptonica.pixRotateBinaryNice.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateBinaryNice.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateBinaryNice not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateBinaryNice(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:     1 bpp
:param[in]    angle:    radians; clockwise is positive; about the center
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) For very small rotations, just return a clone.
(2) This does a computationally expensive rotation of 1 bpp images.
The fastest rotators (using shears or subsampling) leave
visible horizontal and vertical shear lines across which
the image shear changes by one pixel.  To ameliorate the
visual effect one can introduce random dithering.  One
way to do this in a not-too-random fashion is given here.
We convert to 8 bpp, do a very small blur, rotate using
linear interpolation (same as area mapping), do a
small amount of sharpening to compensate for the initial
blur, and threshold back to binary.  The shear lines
are magically removed.
(3) This operation is about 5x slower than rotation by sampling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateBinaryNice(*args)
    
    

    try:
        leptonica.pixRotateWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixRotateWithAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('PIX', '*pixg')       
('l_float32', 'fract')       

:param[in]    pixs:     32 bpp rgb or cmapped
:param[in]    angle:    radians; clockwise is positive
:param[in]    pixg:     [optional] 8 bpp, can be null
:param[in]    fract:    between 0.0 and 1.0, with 0.0 fully transparent
and 1.0 fully opaque
:returns:  pixd 32 bpp rgba, or NULL on error

<pre>
Notes:
(1) The alpha channel is transformed separately from pixs,
and aligns with it, being fully transparent outside the
boundary of the transformed pixs.  For pixels that are fully
transparent, a blending function like pixBlendWithGrayMask()
will give zero weight to corresponding pixels in pixs.
(2) Rotation is about the center of the image; for very small
rotations, just return a clone.  The dest is automatically
expanded so that no image pixels are lost.
(3) Rotation is by area mapping.  It doesn't matter what
color is brought in because the alpha channel will
be transparent (black) there.
(4) If pixg is NULL, it is generated as an alpha layer that is
partially opaque, using %fract.  Otherwise, it is cropped
to pixs if required and %fract is ignored.  The alpha
channel in pixs is never used.
(4) Colormaps are removed to 32 bpp.
(5) The default setting for the border values in the alpha channel
is 0 (transparent) for the outermost ring of pixels and
(0.5 * fract * 255) for the second ring.  When blended over
a second image, this
(a) shrinks the visible image to make a clean overlap edge
with an image below, and
(b) softens the edges by weakening the aliasing there.
Use l_setAlphaMaskBorder() to change these values.
(6) A subtle use of gamma correction is to remove gamma correction
before rotation and restore it afterwards.  This is done
by sandwiching this function between a gamma/inverse-gamma
photometric transform:
pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
pixd = pixRotateWithAlpha(pixt, angle, NULL, fract);
pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
pixDestroy(&pixt);
This has the side-effect of producing artifacts in the very
dark regions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateWithAlpha(*args)
    




class webpiostub(object):
    """<pre>

Stubs for webpio.c functions
</pre>




"""
    



class bmpio(object):
    """<pre>

Read bmp
PIX          *pixReadStreamBmp()
PIX          *pixReadMemBmp()

Write bmp
l_int32       pixWriteStreamBmp()
l_int32       pixWriteMemBmp()

</pre>




"""
    
    try:
        leptonica.pixReadStreamBmp.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamBmp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamBmp(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp: file stream opened for read
:returns:  pix, or NULL on error

<pre>
Notes:
(1) Here are references on the bmp file format:
http://en.wikipedia.org/wiki/BMP_file_format
http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamBmp(*args)
    
    

    try:
        leptonica.pixReadMemBmp.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemBmp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemBmp(*args):
        """
        ('const l_uint8', '*cdata')       
('size_t', 'size')       

:param[in]    cdata:    bmp data
:param[in]    size:     number of bytes of bmp-formatted data
:returns:  pix, or NULL on error

<pre>
Notes:
(1) The BMP file is organized as follows:
14 byte fileheader
Variable size infoheader: 40, 108 or 124 bytes.
We only use data in he first 40 bytes.
Optional colormap, with size 4 * ncolors (in bytes)
Image data
(2) 2 bpp bmp files are not valid in the original spec, but they
are valid in later versions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemBmp(*args)
    
    

    try:
        leptonica.pixWriteStreamBmp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamBmp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamBmp(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       

:param[in]    fp:     file stream
:param[in]    pix:    all depths
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamBmp(*args)
    
    

    try:
        leptonica.pixWriteMemBmp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemBmp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemBmp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemBmp(*args):
        """
        ('l_uint8', '**pfdata')       
('size_t', '*pfsize')       
('PIX', '*pixs')       

:param[out]   pfdata:   data of bmp formatted image
:param[out]   pfsize:    size of returned data
:param[in]    pixs:      1, 2, 4, 8, 16, 32 bpp
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) 2 bpp bmp files are not valid in the original spec, and are
written as 8 bpp.
(2) pix with depth <= 8 bpp are written with a colormap.
16 bpp gray and 32 bpp rgb pix are written without a colormap.
(3) The transparency component in an rgb pix is ignored.
All 32 bpp pix have the bmp alpha component set to 255 (opaque).
(4) The bmp colormap entries, RGBA_QUAD, are the same as
the ones used for colormaps in leptonica.  This allows
a simple memcpy for bmp output.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemBmp(*args)
    




class enhance(object):
    """<pre>

Gamma TRC (tone reproduction curve) mapping
PIX     *pixGammaTRC()
PIX     *pixGammaTRCMasked()
PIX     *pixGammaTRCWithAlpha()
NUMA    *numaGammaTRC()

Contrast enhancement
PIX     *pixContrastTRC()
PIX     *pixContrastTRCMasked()
NUMA    *numaContrastTRC()

Histogram equalization
PIX     *pixEqualizeTRC()
NUMA    *numaEqualizeTRC()

Generic TRC mapper
PIX     *pixTRCMap()
PIX     *pixTRCMapGeneral()

Unsharp-masking
PIX     *pixUnsharpMasking()
PIX     *pixUnsharpMaskingGray()
PIX     *pixUnsharpMaskingFast()
PIX     *pixUnsharpMaskingGrayFast()
PIX     *pixUnsharpMaskingGray1D()
PIX     *pixUnsharpMaskingGray2D()

Hue and saturation modification
PIX     *pixModifyHue()
PIX     *pixModifySaturation()
l_int32  pixMeasureSaturation()
PIX     *pixModifyBrightness()

Color shifting
PIX     *pixMosaicColorShiftRGB()
PIX     *pixColorShiftRGB()

Darken gray (unsaturated) pixels
PIX     *pixDarkenGray()

General multiplicative constant color transform
PIX     *pixMultConstantColor()
PIX     *pixMultMatrixColor()

Edge by bandpass
PIX     *pixHalfEdgeByBandpass()

Gamma correction, contrast enhancement and histogram equalization
apply a simple mapping function to each pixel (or, for color
images, to each sample (i.e., r,g,b) of the pixel).

~ Gamma correction either lightens the image or darkens
it, depending on whether the gamma factor is greater
or less than 1.0, respectively.

~ Contrast enhancement darkens the pixels that are already
darker than the middle of the dynamic range (128)
and lightens pixels that are lighter than 128.

~ Histogram equalization remaps to have the same number
of image pixels at each of 256 intensity values.  This is
a quick and dirty method of adjusting contrast and brightness
to bring out details in both light and dark regions.

Unsharp masking is a more complicated enhancement.
A "high frequency" image, generated by subtracting
the smoothed ("low frequency") part of the image from
itself, has all the energy at the edges.  This "edge image"
has 0 average value.  A fraction of the edge image is
then added to the original, enhancing the differences
between pixel values at edges.  Because we represent
images as l_uint8 arrays, we preserve dynamic range and
handle negative values by doing all the arithmetic on
shifted l_uint16 arrays; the l_uint8 values are recovered
at the end.

Hue and saturation modification work in HSV space.  Because
this is too large for efficient table lookup, each pixel value
is transformed to HSV, modified, and transformed back.
It's not the fastest way to do this, but the method is
easily understood.

Unsharp masking is never in-place, and returns a clone if no
operation is to be performed.
</pre>




"""
    
    try:
        leptonica.pixGammaTRC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGammaTRC.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGammaTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGammaTRC(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       

:param[in]    pixd:     [optional] null or equal to pixs
:param[in]    pixs:     8 or 32 bpp; or 2, 4 or 8 bpp with colormap
:param[in]    gamma:    gamma correction; must be > 0.0
:param[in]    minval:   input value that gives 0 for output; can be < 0
:param[in]    maxval:   input value that gives 255 for output; can be > 255
:returns:  pixd always

<pre>
Notes:
(1) pixd must either be null or equal to pixs.
For in-place operation, set pixd == pixs:
pixGammaTRC(pixs, pixs, ...);
To get a new image, set pixd == null:
pixd = pixGammaTRC(NULL, pixs, ...);
(2) If pixs is colormapped, the colormap is transformed,
either in-place or in a copy of pixs.
(3) We use a gamma mapping between minval and maxval.
(4) If gamma < 1.0, the image will appear darker;
if gamma > 1.0, the image will appear lighter;
(5) If gamma = 1.0 and minval = 0 and maxval = 255, no
enhancement is performed; return a copy unless in-place,
in which case this is a no-op.
(6) For color images that are not colormapped, the mapping
is applied to each component.
(7) minval and maxval are not restricted to the interval [0, 255].
If minval < 0, an input value of 0 is mapped to a
nonzero output.  This will turn black to gray.
If maxval > 255, an input value of 255 is mapped to
an output value less than 255.  This will turn
white (e.g., in the background) to gray.
(8) Increasing minval darkens the image.
(9) Decreasing maxval bleaches the image.
(10) Simultaneously increasing minval and decreasing maxval
will darken the image and make the colors more intense;
e.g., minval = 50, maxval = 200.
(11) See numaGammaTRC() for further examples of use.
(12) Use pixTRCMapGeneral() if applying different mappings
to each channel in an RGB image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGammaTRC(*args)
    
    

    try:
        leptonica.pixGammaTRCMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGammaTRCMasked.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGammaTRCMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGammaTRCMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       

:param[in]    pixd:      [optional] null or equal to pixs
:param[in]    pixs:      8 or 32 bpp; not colormapped
:param[in]    pixm:      [optional] null or 1 bpp
:param[in]    gamma:     gamma correction; must be > 0.0
:param[in]    minval:    input value that gives 0 for output; can be < 0
:param[in]    maxval:    input value that gives 255 for output; can be > 255
:returns:  pixd always

<pre>
Notes:
(1) Same as pixGammaTRC() except mapping is optionally over
a subset of pixels described by pixm.
(2) Masking does not work for colormapped images.
(3) See pixGammaTRC() for details on how to use the parameters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGammaTRCMasked(*args)
    
    

    try:
        leptonica.pixGammaTRCWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGammaTRCWithAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGammaTRCWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGammaTRCWithAlpha(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       

:param[in]    pixd:     [optional] null or equal to pixs
:param[in]    pixs:     32 bpp
:param[in]    gamma:    gamma correction; must be > 0.0
:param[in]    minval:   input value that gives 0 for output; can be < 0
:param[in]    maxval:   input value that gives 255 for output; can be > 255
:returns:  pixd always

<pre>
Notes:
(1) See usage notes in pixGammaTRC().
(2) This version saves the alpha channel.  It is only valid
for 32 bpp (no colormap), and is a bit slower.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGammaTRCWithAlpha(*args)
    
    

    try:
        leptonica.numaGammaTRC.argtypes = [ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaGammaTRC.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaGammaTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGammaTRC(*args):
        """
        ('l_float32', 'gamma')       
('l_int32', 'minval')       
('l_int32', 'maxval')       

:param[in]    gamma:   gamma factor; must be > 0.0
:param[in]    minval:  input value that gives 0 for output
:param[in]    maxval:  input value that gives 255 for output
:returns:  na, or NULL on error

<pre>
Notes:
(1) The map is returned as a numa; values are clipped to [0, 255].
(2) For a linear mapping, set gamma = 1.0.
(3) To force all intensities into a range within fraction delta
of white, use: minval = -256 * (1 - delta) / delta
maxval = 255
(4) To force all intensities into a range within fraction delta
of black, use: minval = 0
maxval = 256 * (1 - delta) / delta
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGammaTRC(*args)
    
    

    try:
        leptonica.pixContrastTRC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixContrastTRC.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixContrastTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixContrastTRC(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'factor')       

:param[in]    pixd:     [optional] null or equal to pixs
:param[in]    pixs:     8 or 32 bpp; or 2, 4 or 8 bpp with colormap
:param[in]    factor:   0.0 is no enhancement
:returns:  pixd always

<pre>
Notes:
(1) pixd must either be null or equal to pixs.
For in-place operation, set pixd == pixs:
pixContrastTRC(pixs, pixs, ...);
To get a new image, set pixd == null:
pixd = pixContrastTRC(NULL, pixs, ...);
(2) If pixs is colormapped, the colormap is transformed,
either in-place or in a copy of pixs.
(3) Contrast is enhanced by mapping each color component
using an atan function with maximum slope at 127.
Pixels below 127 are lowered in intensity and pixels
above 127 are increased.
(4) The useful range for the contrast factor is scaled to
be in (0.0 to 1.0), but larger values can also be used.
(5) If factor == 0.0, no enhancement is performed; return a copy
unless in-place, in which case this is a no-op.
(6) For color images that are not colormapped, the mapping
is applied to each component.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixContrastTRC(*args)
    
    

    try:
        leptonica.pixContrastTRCMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixContrastTRCMasked.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixContrastTRCMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixContrastTRCMasked(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_float32', 'factor')       

:param[in]    pixd:     [optional] null or equal to pixs
:param[in]    pixs:     8 or 32 bpp; or 2, 4 or 8 bpp with colormap
:param[in]    pixm:     [optional] null or 1 bpp
:param[in]    factor:   0.0 is no enhancement
:returns:  pixd always

<pre>
Notes:
(1) Same as pixContrastTRC() except mapping is optionally over
a subset of pixels described by pixm.
(2) Masking does not work for colormapped images.
(3) See pixContrastTRC() for details on how to use the parameters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixContrastTRCMasked(*args)
    
    

    try:
        leptonica.numaContrastTRC.argtypes = [ctypes.c_float]
        leptonica.numaContrastTRC.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaContrastTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaContrastTRC(*args):
        """
        ('l_float32', 'factor')       

:param[in]    factor:   generally between 0.0 [no enhancement]
and 1.0, but can be larger than 1.0
:returns:  na, or NULL on error

<pre>
Notes:
(1) The mapping is monotonic increasing, where 0 is mapped
to 0 and 255 is mapped to 255.
(2) As 'factor' is increased from 0.0 (where the mapping is linear),
the map gets closer to its limit as a step function that
jumps from 0 to 255 at the center (input value = 127).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaContrastTRC(*args)
    
    

    try:
        leptonica.pixEqualizeTRC.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixEqualizeTRC.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixEqualizeTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixEqualizeTRC(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       
('l_int32', 'factor')       

:param[in]    pixd:     [optional] null or equal to pixs
:param[in]    pixs:     8 bpp gray, 32 bpp rgb, or colormapped
:param[in]    fract:    fraction of equalization movement of pixel values
:param[in]    factor:   subsampling factor; integer >= 1
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) pixd must either be null or equal to pixs.
For in-place operation, set pixd == pixs:
pixEqualizeTRC(pixs, pixs, ...);
To get a new image, set pixd == null:
pixd = pixEqualizeTRC(NULL, pixs, ...);
(2) In histogram equalization, a tone reproduction curve
mapping is used to make the number of pixels at each
intensity equal.
(3) If fract == 0.0, no equalization is performed; return a copy
unless in-place, in which case this is a no-op.
If fract == 1.0, equalization is complete.
(4) Set the subsampling factor > 1 to reduce the amount of computation.
(5) If pixs is colormapped, the colormap is removed and
converted to rgb or grayscale.
(6) If pixs has color, equalization is done in each channel
separately.
(7) Note that even if there is a colormap, we can get an
in-place operation because the intermediate image pixt
is copied back to pixs (which for in-place is the same
as pixd).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixEqualizeTRC(*args)
    
    

    try:
        leptonica.numaEqualizeTRC.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.numaEqualizeTRC.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaEqualizeTRC not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEqualizeTRC(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'fract')       
('l_int32', 'factor')       

:param[in]    pix:     8 bpp, no colormap
:param[in]    fract:   fraction of equalization movement of pixel values
:param[in]    factor:  subsampling factor; integer >= 1
:returns:  nad, or NULL on error

<pre>
Notes:
(1) If fract == 0.0, no equalization will be performed.
If fract == 1.0, equalization is complete.
(2) Set the subsampling factor > 1 to reduce the amount of computation.
(3) The map is returned as a numa with 256 values, specifying
the equalized value (array value) for every input value
(the array index).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaEqualizeTRC(*args)
    
    

    try:
        leptonica.pixTRCMap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTRCMap.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixTRCMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTRCMap(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('NUMA', '*na')       

:param[in]    pixs:    8 grayscale or 32 bpp rgb; not colormapped
:param[in]    pixm:    [optional] 1 bpp mask
:param[in]    na:      mapping array
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This operation is in-place on pixs.
(2) For 32 bpp, this applies the same map to each of the r,g,b
components.
(3) The mapping array is of size 256, and it maps the input
index into values in the range [0, 255].
(4) If defined, the optional 1 bpp mask pixm has its origin
aligned with pixs, and the map function is applied only
to pixels in pixs under the fg of pixm.
(5) For 32 bpp, this does not save the alpha channel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTRCMap(*args)
    
    

    try:
        leptonica.pixTRCMapGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTRCMapGeneral.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixTRCMapGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTRCMapGeneral(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('NUMA', '*nar')       
('NUMA', '*nag')       
('NUMA', '*nab')       

:param[in]    pixs:             32 bpp rgb; not colormapped
:param[in]    pixm:             [optional] 1 bpp mask
:param[in]    nar,: nag, nab    mapping arrays
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This operation is in-place on %pixs.
(2) Each of the r,g,b mapping arrays is of size 256. They map the
input value for that color component into values in the
range [0, 255].
(3) In the special case where the r, g and b mapping arrays are
all the same, call pixTRCMap() instead.
(4) If defined, the optional 1 bpp mask %pixm has its origin
aligned with %pixs, and the map function is applied only
to pixels in %pixs under the fg of pixm.
(5) The alpha channel is not saved.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTRCMapGeneral(*args)
    
    

    try:
        leptonica.pixUnsharpMasking.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixUnsharpMasking.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnsharpMasking not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMasking(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       

:param[in]    pixs:       all depths except 1 bpp; with or without colormaps
:param[in]    halfwidth:  "half-width" of smoothing filter
:param[in]    fract:      fraction of edge added back into image
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) We use symmetric smoothing filters of odd dimension,
typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
for these is (size - 1)/2; i.e., 1, 2, 3, etc.
(2) The fract parameter is typically taken in the
range:  0.2 < fract < 0.7
(3) Returns a clone if no sharpening is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMasking(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixUnsharpMaskingGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnsharpMaskingGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGray(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       

:param[in]    pixs:       8 bpp; no colormap
:param[in]    halfwidth:  "half-width" of smoothing filter
:param[in]    fract:      fraction of edge added back into image
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) We use symmetric smoothing filters of odd dimension,
typically use sizes of 3, 5, 7, etc.  The %halfwidth parameter
for these is (size - 1)/2; i.e., 1, 2, 3, etc.
(2) The fract parameter is typically taken in the range:
0.2 < fract < 0.7
(3) Returns a clone if no sharpening is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGray(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixUnsharpMaskingFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnsharpMaskingFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
('l_int32', 'direction')       

:param[in]    pixs:       all depths except 1 bpp; with or without colormaps
:param[in]    halfwidth:  "half-width" of smoothing filter; 1 and 2 only
:param[in]    fract:      fraction of high frequency added to image
:param[in]    direction:  L_HORIZ, L_VERT, L_BOTH_DIRECTIONS
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The fast version uses separable 1-D filters directly on
the input image.  The halfwidth is either 1 (full width = 3)
or 2 (full width = 5).
(2) The fract parameter is typically taken in the
range:  0.2 < fract < 0.7
(3) To skip horizontal sharpening, use %fracth = 0.0; ditto for %fractv
(4) For one dimensional filtering (as an example):
For %halfwidth = 1, the low-pass filter is
L:    1/3    1/3   1/3
and the high-pass filter is
H = I - L:   -1/3   2/3   -1/3
For %halfwidth = 2, the low-pass filter is
L:    1/5    1/5   1/5    1/5    1/5
and the high-pass filter is
H = I - L:   -1/5  -1/5   4/5  -1/5   -1/5
The new sharpened pixel value is found by adding some fraction
of the high-pass filter value (which sums to 0) to the
initial pixel value:
N = I + fract * H
(5) For 2D, the sharpening filter is not separable, because the
vertical filter depends on the horizontal location relative
to the filter origin, and v.v.   So we either do the full
2D filter (for %halfwidth == 1) or do the low-pass
convolution separably and then compose with the original pix.
(6) Returns a clone if no sharpening is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingFast(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGrayFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixUnsharpMaskingGrayFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnsharpMaskingGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGrayFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
('l_int32', 'direction')       

:param[in]    pixs:       8 bpp; no colormap
:param[in]    halfwidth:  "half-width" of smoothing filter: 1 or 2
:param[in]    fract:      fraction of high frequency added to image
:param[in]    direction:  L_HORIZ, L_VERT, L_BOTH_DIRECTIONS
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) For usage and explanation of the algorithm, see notes
in pixUnsharpMaskingFast().
(2) Returns a clone if no sharpening is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGrayFast(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGray1D.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixUnsharpMaskingGray1D.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnsharpMaskingGray1D not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGray1D(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       
('l_int32', 'direction')       

:param[in]    pixs:        8 bpp; no colormap
:param[in]    halfwidth:   "half-width" of smoothing filter: 1 or 2
:param[in]    fract:       fraction of high frequency added to image
:param[in]    direction:   filtering direction; use L_HORIZ or L_VERT
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) For usage and explanation of the algorithm, see notes
in pixUnsharpMaskingFast().
(2) Returns a clone if no sharpening is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGray1D(*args)
    
    

    try:
        leptonica.pixUnsharpMaskingGray2D.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.pixUnsharpMaskingGray2D.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnsharpMaskingGray2D not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnsharpMaskingGray2D(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'halfwidth')       
('l_float32', 'fract')       

:param[in]    pixs:       8 bpp; no colormap
:param[in]    halfwidth:  "half-width" of smoothing filter: 1 or 2
:param[in]    fract:      fraction of high frequency added to image
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is for %halfwidth == 1, 2.
(2) The lowpass filter is implemented separably.
(3) Returns a clone if no sharpening is requested.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnsharpMaskingGray2D(*args)
    
    

    try:
        leptonica.pixModifyHue.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixModifyHue.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixModifyHue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifyHue(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       

:param[in]    pixd:      [optional] can be null or equal to pixs
:param[in]    pixs:      32 bpp rgb
:param[in]    fract:     between -1.0 and 1.0
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) pixd must either be null or equal to pixs.
For in-place operation, set pixd == pixs:
pixEqualizeTRC(pixs, pixs, ...);
To get a new image, set pixd == null:
pixd = pixEqualizeTRC(NULL, pixs, ...);
(2) Use fract > 0.0 to increase hue value; < 0.0 to decrease it.
1.0 (or -1.0) represents a 360 degree rotation; i.e., no change.
(3) If no modification is requested (fract = -1.0 or 0 or 1.0),
return a copy unless in-place, in which case this is a no-op.
(4) This leaves saturation and intensity invariant.
(5) See discussion of color-modification methods, in coloring.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifyHue(*args)
    
    

    try:
        leptonica.pixModifySaturation.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixModifySaturation.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixModifySaturation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifySaturation(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       

:param[in]    pixd:     [optional] can be null, existing or equal to pixs
:param[in]    pixs:     32 bpp rgb
:param[in]    fract:    between -1.0 and 1.0
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) If fract > 0.0, it gives the fraction that the pixel
saturation is moved from its initial value toward 255.
If fract < 0.0, it gives the fraction that the pixel
saturation is moved from its initial value toward 0.
The limiting values for fract = -1.0 (1.0) thus set the
saturation to 0 (255).
(2) If fract = 0, no modification is requested; return a copy
unless in-place, in which case this is a no-op.
(3) This leaves hue and intensity invariant.
(4) See discussion of color-modification methods, in coloring.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifySaturation(*args)
    
    

    try:
        leptonica.pixMeasureSaturation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMeasureSaturation.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixMeasureSaturation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeasureSaturation(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_float32', '*psat')       

:param[in]    pixs:     32 bpp rgb
:param[in]    factor:   subsampling factor; integer >= 1
:param[out]   psat:     average saturation
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeasureSaturation(*args)
    
    

    try:
        leptonica.pixModifyBrightness.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixModifyBrightness.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixModifyBrightness not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifyBrightness(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'fract')       

:param[in]    pixd:     [optional] can be null, existing or equal to pixs
:param[in]    pixs:     32 bpp rgb
:param[in]    fract:    between -1.0 and 1.0
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) If fract > 0.0, it gives the fraction that the v-parameter,
which is max(r,g,b), is moved from its initial value toward 255.
If fract < 0.0, it gives the fraction that the v-parameter
is moved from its initial value toward 0.
The limiting values for fract = -1.0 (1.0) thus set the
v-parameter to 0 (255).
(2) If fract = 0, no modification is requested; return a copy
unless in-place, in which case this is a no-op.
(3) This leaves hue and saturation invariant.
(4) See discussion of color-modification methods, in coloring.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifyBrightness(*args)
    
    

    try:
        leptonica.pixMosaicColorShiftRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixMosaicColorShiftRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMosaicColorShiftRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMosaicColorShiftRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'roff')       
('l_float32', 'goff')       
('l_float32', 'boff')       
('l_float32', 'delta')       
('l_int32', 'nincr')       

:param[in]    pixs:     32 bpp rgb
:param[in]    roff:   center offset of red component
:param[in]    goff:   center offset of green component
:param[in]    boff:   center offset of blue component
:param[in]    delta:  increments from center offsets [0.0 - 0.1];
use 0.0 to get the default (0.04)
:param[in]    nincr:  number of increments in each (positive and negative)
direction; use 0 to get the default (2).
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This generates a mosaic view of the effect of shifting the RGB
components.  See pixColorShiftRGB() for details on the shifting.
(2) The offsets (%roff, %goff, %boff) set the color center point,
and the deviations from this are shown separately for deltas
in r, g and b.  For each component, we show 2 * %nincr + 1
images.
(3) Usage: color prints differ from the original due to three factors:
illumination, calibration of the camera in acquisition,
and calibration of the printer.  This function can be used
to iteratively match a color print to the original.  On each
iteration, the center offsets are set to the best match so
far, and the %delta increments are typically reduced.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMosaicColorShiftRGB(*args)
    
    

    try:
        leptonica.pixColorShiftRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixColorShiftRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorShiftRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorShiftRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rfract')       
('l_float32', 'gfract')       
('l_float32', 'bfract')       

:param[in]    pixs:     32 bpp rgb
:param[in]    rfract:   fractional shift in red component
:param[in]    gfract:   fractional shift in green component
:param[in]    bfract:   fractional shift in blue component
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This allows independent fractional shifts of the r,g and b
components.  A positive shift pushes to saturation (255);
a negative shift pushes toward 0 (black).
(2) The effect can be imagined using a color wheel that consists
(for our purposes) of these 6 colors, separated by 60 degrees:
red, magenta, blue, cyan, green, yellow
(3) So, for example, a negative shift of the blue component
(bfract < 0) could be accompanied by positive shifts
of red and green to make an image more yellow.
(4) Examples of limiting cases:
rfract = 1 ==> r = 255
rfract = -1 ==> r = 0
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorShiftRGB(*args)
    
    

    try:
        leptonica.pixDarkenGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDarkenGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDarkenGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDarkenGray(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'thresh')       
('l_int32', 'satlimit')       

:param[in]    pixd:      [optional] can be null or equal to pixs
:param[in]    pixs:      32 bpp rgb
:param[in]    thresh:    pixels with max component >= %thresh are unchanged
:param[in]    satlimit:  pixels with saturation >= %satlimit are unchanged
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This darkens gray pixels, by a fraction (sat/%satlimit), where
the saturation, sat, is the component difference (max - min).
The pixel value is unchanged if sat >= %satlimit.  A typical
value of %satlimit might be 40; the larger the value, the
more that pixels with a smaller saturation will be darkened.
(2) Pixels with max component >= %thresh are unchanged. This can be
used to prevent bright pixels with low saturation from being
darkened.  Setting thresh == 0 is a no-op; setting %thresh == 255
causes the darkening to be applied to all pixels.
(3) This function is useful to enhance pixels relative to a
gray background.
(4) A related function that builds a 1 bpp mask over the gray
pixels is pixMaskOverGrayPixels().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDarkenGray(*args)
    
    

    try:
        leptonica.pixMultConstantColor.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixMultConstantColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMultConstantColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultConstantColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rfact')       
('l_float32', 'gfact')       
('l_float32', 'bfact')       

:param[in]    pixs:     colormapped or rgb
:param[in]    rfact:    red multiplicative factor
:param[in]    gfact:    green multiplicative factor
:param[in]    bfact:    blue multiplicative factor
:returns:  pixd colormapped or rgb, with colors scaled, or NULL on error

<pre>
Notes:
(1) rfact, gfact and bfact can only have non-negative values.
They can be greater than 1.0.  All transformed component
values are clipped to the interval [0, 255].
(2) For multiplication with a general 3x3 matrix of constants,
use pixMultMatrixColor().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultConstantColor(*args)
    
    

    try:
        leptonica.pixMultMatrixColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMultMatrixColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMultMatrixColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMultMatrixColor(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*kel')       

:param[in]    pixs:    colormapped or rgb
:param[in]    kel:     kernel 3x3 matrix of floats
:returns:  pixd colormapped or rgb, or NULL on error

<pre>
Notes:
(1) The kernel is a data structure used mostly for floating point
convolution.  Here it is a 3x3 matrix of floats that are used
to transform the pixel values by matrix multiplication:
nrval = a[0,0] * rval + a[0,1] * gval + a[0,2] * bval
ngval = a[1,0] * rval + a[1,1] * gval + a[1,2] * bval
nbval = a[2,0] * rval + a[2,1] * gval + a[2,2] * bval
(2) The matrix can be generated in several ways.
See kernel.c for details.  Here are two of them:
(a) kel = kernelCreate(3, 3);
kernelSetElement(kel, 0, 0, val00);
kernelSetElement(kel, 0, 1, val01);
...
(b) from a static string; e.g.,:
const char *kdata = " 0.6  0.3 -0.2 "
" 0.1  1.2  0.4 "
" -0.4 0.2  0.9 ";
kel = kernelCreateFromString(3, 3, 0, 0, kdata);
(3) For the special case where the matrix is diagonal, it is easier
to use pixMultConstantColor().
(4) Matrix entries can have positive and negative values, and can
be larger than 1.0.  All transformed component values
are clipped to [0, 255].
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMultMatrixColor(*args)
    
    

    try:
        leptonica.pixHalfEdgeByBandpass.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHalfEdgeByBandpass.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHalfEdgeByBandpass not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHalfEdgeByBandpass(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'sm1h')       
('l_int32', 'sm1v')       
('l_int32', 'sm2h')       
('l_int32', 'sm2v')       

:param[in]    pixs:         8 bpp gray or 32 bpp rgb
:param[in]    sm1h,: sm1v   "half-widths" of smoothing filter sm1
:param[in]    sm2h,: sm2v   "half-widths" of smoothing filter sm2;
require sm2 != sm1
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) We use symmetric smoothing filters of odd dimension,
typically use 3, 5, 7, etc.  The smoothing parameters
for these are 1, 2, 3, etc.  The filter size is related
to the smoothing parameter by
size = 2 * smoothing + 1
(2) Because we take the difference of two lowpass filters,
this is actually a bandpass filter.
(3) We allow both filters to be anisotropic.
(4) Consider either the h or v component of the 2 filters.
Depending on whether sm1 > sm2 or sm2 > sm1, we get
different halves of the smoothed gradients (or "edges").
This difference of smoothed signals looks more like
a second derivative of a transition, which we rectify
by not allowing the signal to go below zero.  If sm1 < sm2,
the sm2 transition is broader, so the difference between
sm1 and sm2 signals is positive on the upper half of
the transition.  Likewise, if sm1 > sm2, the sm1 - sm2
signal difference is positive on the lower half of
the transition.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHalfEdgeByBandpass(*args)
    




class leptwin(object):
    """<pre>

This file contains Leptonica routines needed only on Microsoft Windows

Currently it only contains one public function
(based on dibsectn.c by jmh, 03-30-98):

HBITMAP    pixGetWindowsHBITMAP(PIX *pix)
</pre>




"""
    



class pixcomp(object):
    """<pre>

Pixcomp creation and destruction
PIXC     *pixcompCreateFromPix()
PIXC     *pixcompCreateFromString()
PIXC     *pixcompCreateFromFile()
void      pixcompDestroy()
PIXC     *pixcompCopy()

Pixcomp accessors
l_int32   pixcompGetDimensions()
l_int32   pixcompGetParameters()

Pixcomp compression selection
l_int32   pixcompDetermineFormat()

Pixcomp conversion to Pix
PIX      *pixCreateFromPixcomp()

Pixacomp creation and destruction
PIXAC    *pixacompCreate()
PIXAC    *pixacompCreateWithInit()
PIXAC    *pixacompCreateFromPixa()
PIXAC    *pixacompCreateFromFiles()
PIXAC    *pixacompCreateFromSA()
void      pixacompDestroy()

Pixacomp addition/replacement
l_int32   pixacompAddPix()
l_int32   pixacompAddPixcomp()
static l_int32  pixacompExtendArray()
l_int32   pixacompReplacePix()
l_int32   pixacompReplacePixcomp()
l_int32   pixacompAddBox()

Pixacomp accessors
l_int32   pixacompGetCount()
PIXC     *pixacompGetPixcomp()
PIX      *pixacompGetPix()
l_int32   pixacompGetPixDimensions()
BOXA     *pixacompGetBoxa()
l_int32   pixacompGetBoxaCount()
BOX      *pixacompGetBox()
l_int32   pixacompGetBoxGeometry()
l_int32   pixacompGetOffset()
l_int32   pixacompSetOffset()

Pixacomp conversion to Pixa
PIXA     *pixaCreateFromPixacomp()

Combining pixacomp
l_int32   pixacompJoin()
PIXAC    *pixacompInterleave()

Pixacomp serialized I/O
PIXAC    *pixacompRead()
PIXAC    *pixacompReadStream()
PIXAC    *pixacompReadMem()
l_int32   pixacompWrite()
l_int32   pixacompWriteStream()
l_int32   pixacompWriteMem()

Conversion to pdf
l_int32   pixacompConvertToPdf()
l_int32   pixacompConvertToPdfData()
l_int32   pixacompFastConvertToPdfData()

Output for debugging
l_int32   pixacompWriteStreamInfo()
l_int32   pixcompWriteStreamInfo()
PIX      *pixacompDisplayTiledAndScaled()
l_int32   pixacompWriteFiles()
l_int32   pixcompWriteFile()

The Pixacomp is an array of Pixcomp, where each Pixcomp is a compressed
string of the image.  We don't use reference counting here.
The basic application is to allow a large array of highly
compressible images to reside in memory.  We purposely don't
reuse the Pixa for this, to avoid confusion and programming errors.

Three compression formats are used: g4, png and jpeg.
The compression type can be either specified or defaulted.
If specified and it is not possible to compress (for example,
you specify a jpeg on a 1 bpp image or one with a colormap),
the compression type defaults to png.  The jpeg compression quality
can be specified using l_setJpegQuality(); otherwise the default is 75.

The serialized version of the Pixacomp is similar to that for
a Pixa, except that each Pixcomp can be compressed by one of
tiffg4, png, or jpeg.  Unlike serialization of the Pixa,
serialization of the Pixacomp does not require any imaging
libraries because it simply reads and writes the compressed data.

There are two modes of use in accumulating images:
(1) addition to the end of the array
(2) random insertion (replacement) into the array

In use, we assume that the array is fully populated up to the
index value (n - 1), where n is the value of the pixcomp field n.
Addition can only be made to the end of the fully populated array,
at the index value n.  Insertion can be made randomly, but again
only within the array of pixcomps; i.e., within the set of
indices {0 .... n-1}.  The functions are pixacompReplacePix()
and pixacompReplacePixcomp(), and they destroy the existing pixcomp.

For addition to the end of the array, initialize the pixacomp with
pixacompCreate(), which generates an empty array of pixcomps ptrs.
For random insertion and replacement of pixcomp into a pixacomp,
initialize a fully populated array using pixacompCreateWithInit().

The offset field allows you to use an offset-based index to
access the 0-based ptr array in the pixacomp.  This would typically
be used to map the pixacomp array index to a page number, or v.v.
By default, the offset is 0.  For example, suppose you have 50 images,
corresponding to page numbers 10 - 59.  Then you could use
pixac = pixacompCreateWithInit(50, 10, ...);
This would allocate an array of 50 pixcomps, but if you asked for
the pix at index 10, using pixacompGetPix(pixac, 10), it would
apply the offset internally, returning the pix at index 0 in the array.
</pre>




"""
    
    try:
        leptonica.pixcompCreateFromPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixcompCreateFromPix.restype = lambda address: PIXC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcompCreateFromPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCreateFromPix(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'comptype')       

:param[in]    pix:
:param[in]    comptype:   IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  pixc, or NULL on error

<pre>
Notes:
(1) Use %comptype == IFF_DEFAULT to have the compression
type automatically determined.
(2) To compress jpeg with a quality other than the default (75), use
l_jpegSetQuality()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCreateFromPix(*args)
    
    

    try:
        leptonica.pixcompCreateFromString.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.pixcompCreateFromString.restype = lambda address: PIXC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcompCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCreateFromString(*args):
        """
        ('l_uint8', '*data')       
('size_t', 'size')       
('l_int32', 'copyflag')       

:param[in]    data:        compressed string
:param[in]    size:        number of bytes
:param[in]    copyflag:    L_INSERT or L_COPY
:returns:  pixc, or NULL on error

<pre>
Notes:
(1) This works when the compressed string is png, jpeg or tiffg4.
(2) The copyflag determines if the data in the new Pixcomp is
a copy of the input data.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCreateFromString(*args)
    
    

    try:
        leptonica.pixcompCreateFromFile.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixcompCreateFromFile.restype = lambda address: PIXC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcompCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCreateFromFile(*args):
        """
        ('const char', '*filename')       
('l_int32', 'comptype')       

:param[in]    filename:
:param[in]    comptype:    IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  pixc, or NULL on error

<pre>
Notes:
(1) Use %comptype == IFF_DEFAULT to have the compression
type automatically determined.
(2) If the comptype is invalid for this file, the default will
be substituted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCreateFromFile(*args)
    
    

    try:
        leptonica.pixcompDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixcompDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixcompDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompDestroy(*args):
        """
        ('PIXC', '**ppixc')       

:param[in,out]   ppixc:   use ptr address so it will be nulled
:returns:  void

<pre>
Notes:
(1) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompDestroy(*args)
    
    

    try:
        leptonica.pixcompCopy.argtypes = [ctypes.c_void_p]
        leptonica.pixcompCopy.restype = lambda address: PIXC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixcompCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompCopy(*args):
        """
        ('PIXC', '*pixcs')       

:param[in]    pixcs:
:returns:  pixcd, or NULL on error

<pre>
Notes:
(1) Limit the size of the compressed pix to 500 MB.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompCopy(*args)
    
    

    try:
        leptonica.pixcompGetDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcompGetDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcompGetDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompGetDimensions(*args):
        """
        ('PIXC', '*pixc')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       

:param[in]    pixc:
:param[out]   pw,: ph, pd    [optional]
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompGetDimensions(*args)
    
    

    try:
        leptonica.pixcompGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixcompGetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcompGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompGetParameters(*args):
        """
        ('PIXC', '*pixc')       
('l_int32', '*pxres')       
('l_int32', '*pyres')       
('l_int32', '*pcomptype')       
('l_int32', '*pcmapflag')       

:param[in]    pixc:
:param[out]   pxres,: pyres, pcomptype, pcmapflag   [optional]
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompGetParameters(*args)
    
    

    try:
        leptonica.pixcompDetermineFormat.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixcompDetermineFormat.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcompDetermineFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompDetermineFormat(*args):
        """
        ('l_int32', 'comptype')       
('l_int32', 'd')       
('l_int32', 'cmapflag')       
('l_int32', '*pformat')       

:param[in]    comptype:   IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:param[in]    d:          pix depth
:param[in]    cmapflag:   1 if pix to be compressed as a colormap; 0 otherwise
:param[out]   pformat:    IFF_TIFF, IFF_PNG or IFF_JFIF_JPEG
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This determines the best format for a pix, given both
the request (%comptype) and the image characteristics.
(2) If %comptype == IFF_DEFAULT, this does not necessarily result
in png encoding.  Instead, it returns one of the three formats
that is both valid and most likely to give best compression.
(3) If %d == 8 with no colormap and:
you wish to compress with png, use %comptype == IFF_PNG
you wish to compress with jpeg, use either
%comptype == IFF_JFIF_JPEG or %comptype == IFF_DEFAULT.
(4) If the pix cannot be compressed by the input value of
%comptype, this selects IFF_PNG, which can compress all pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompDetermineFormat(*args)
    
    

    try:
        leptonica.pixCreateFromPixcomp.argtypes = [ctypes.c_void_p]
        leptonica.pixCreateFromPixcomp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCreateFromPixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCreateFromPixcomp(*args):
        """
        ('PIXC', '*pixc')       

:param[in]    pixc:
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixCreateFromPixcomp(*args)
    
    

    try:
        leptonica.pixacompCreate.argtypes = [ctypes.c_int32]
        leptonica.pixacompCreate.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial number of ptrs
:returns:  pixac, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreate(*args)
    
    

    try:
        leptonica.pixacompCreateWithInit.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompCreateWithInit.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompCreateWithInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateWithInit(*args):
        """
        ('l_int32', 'n')       
('l_int32', 'offset')       
('PIX', '*pix')       
('l_int32', 'comptype')       

:param[in]    n:          initial number of ptrs
:param[in]    offset:     difference: accessor index - pixacomp array index
:param[in]    pix:        [optional] initialize each ptr in pixacomp
to this pix; can be NULL
:param[in]    comptype:   IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  pixac, or NULL on error

<pre>
Notes:
(1) Initializes a pixacomp to be fully populated with %pix,
compressed using %comptype.  If %pix == NULL, %comptype
is ignored.
(2) Typically, the array is initialized with a tiny pix.
This is most easily done by setting %pix == NULL, causing
initialization of each array element with a tiny placeholder
pix (w = h = d = 1), using comptype = IFF_TIFF_G4 .
(3) Example usage:
// Generate pixacomp for pages 30 - 49.  This has an array
// size of 20 and the page number offset is 30.
PixaComp *pixac = pixacompCreateWithInit(20, 30, NULL,
IFF_TIFF_G4);
// Now insert png-compressed images into the initialized array
for (pageno = 30; pageno < 50; pageno++) {
Pix *pixt = ...   // derived from image[pageno]
if (pixt)
pixacompReplacePix(pixac, pageno, pixt, IFF_PNG);
pixDestroy(&pixt);
}
The result is a pixac with 20 compressed strings, and with
selected pixt replacing the placeholders.
To extract the image for page 38, which is decompressed
from element 8 in the array, use:
pixt = pixacompGetPix(pixac, 38);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateWithInit(*args)
    
    

    try:
        leptonica.pixacompCreateFromPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompCreateFromPixa.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompCreateFromPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateFromPixa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'comptype')       
('l_int32', 'accesstype')       

:param[in]    pixa:
:param[in]    comptype:    IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:param[in]    accesstype:  L_COPY, L_CLONE, L_COPY_CLONE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %format == IFF_DEFAULT, the conversion format for each
image is chosen automatically.  Otherwise, we use the
specified format unless it can't be done (e.g., jpeg
for a 1, 2 or 4 bpp pix, or a pix with a colormap),
in which case we use the default (assumed best) compression.
(2) %accesstype is used to extract a boxa from %pixa.
(3) To compress jpeg with a quality other than the default (75), use
l_jpegSetQuality()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateFromPixa(*args)
    
    

    try:
        leptonica.pixacompCreateFromFiles.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixacompCreateFromFiles.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompCreateFromFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateFromFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'comptype')       

:param[in]    dirname:
:param[in]    substr:    [optional] substring filter on filenames; can be null
:param[in]    comptype:  IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  pixac, or NULL on error

<pre>
Notes:
(1) %dirname is the full path for the directory.
(2) %substr is the part of the file name (excluding
the directory) that is to be matched.  All matching
filenames are read into the Pixa.  If substr is NULL,
all filenames are read into the Pixa.
(3) Use %comptype == IFF_DEFAULT to have the compression
type automatically determined for each file.
(4) If the comptype is invalid for a file, the default will
be substituted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateFromFiles(*args)
    
    

    try:
        leptonica.pixacompCreateFromSA.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompCreateFromSA.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompCreateFromSA not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompCreateFromSA(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'comptype')       

:param[in]    sa:         full pathnames for all files
:param[in]    comptype:   IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  pixac, or NULL on error

<pre>
Notes:
(1) Use %comptype == IFF_DEFAULT to have the compression
type automatically determined for each file.
(2) If the comptype is invalid for a file, the default will
be substituted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompCreateFromSA(*args)
    
    

    try:
        leptonica.pixacompDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixacompDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompDestroy(*args):
        """
        ('PIXAC', '**ppixac')       

:param[in,out]   ppixac:   use ptr address so it will be nulled
:returns:  void

<pre>
Notes:
(1) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompDestroy(*args)
    
    

    try:
        leptonica.pixacompAddPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompAddPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompAddPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompAddPix(*args):
        """
        ('PIXAC', '*pixac')       
('PIX', '*pix')       
('l_int32', 'comptype')       

:param[in]    pixac:
:param[in]    pix:        to be added
:param[in]    comptype:   IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The array is filled up to the (n-1)-th element, and this
converts the input pix to a pixc and adds it at
the n-th position.
(2) The pixc produced from the pix is owned by the pixac.
The input pix is not affected.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompAddPix(*args)
    
    

    try:
        leptonica.pixacompAddPixcomp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompAddPixcomp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompAddPixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompAddPixcomp(*args):
        """
        ('PIXAC', '*pixac')       
('PIXC', '*pixc')       
('l_int32', 'copyflag')       

:param[in]    pixac:
:param[in]    pixc:       to be added by insertion
:param[in]    copyflag:   L_INSERT, L_COPY
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Anything added to a pixac is owned by the pixac.
So do not L_INSERT a pixc that is owned by another pixac,
or destroy a pixc that has been L_INSERTed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompAddPixcomp(*args)
    
    

    try:
        leptonica.pixacompReplacePix.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompReplacePix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompReplacePix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReplacePix(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('PIX', '*pix')       
('l_int32', 'comptype')       

:param[in]    pixac:
:param[in]    index:      caller's view of index within pixac; includes offset
:param[in]    pix:        owned by the caller
:param[in]    comptype:   IFF_DEFAULT, IFF_TIFF_G4, IFF_PNG, IFF_JFIF_JPEG
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
(2) The input %pix is converted to a pixc, which is then inserted
into the pixac.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReplacePix(*args)
    
    

    try:
        leptonica.pixacompReplacePixcomp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixacompReplacePixcomp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompReplacePixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReplacePixcomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('PIXC', '*pixc')       

:param[in]    pixac:
:param[in]    index:   caller's view of index within pixac; includes offset
:param[in]    pixc:    to replace existing one, which is destroyed
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
(2) The inserted %pixc is now owned by the pixac.  The caller
must not destroy it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReplacePixcomp(*args)
    
    

    try:
        leptonica.pixacompAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompAddBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompAddBox(*args):
        """
        ('PIXAC', '*pixac')       
('BOX', '*box')       
('l_int32', 'copyflag')       

:param[in]    pixac:
:param[in]    box:
:param[in]    copyflag:   L_INSERT, L_COPY
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompAddBox(*args)
    
    

    try:
        leptonica.pixacompGetCount.argtypes = [ctypes.c_void_p]
        leptonica.pixacompGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetCount(*args):
        """
        ('PIXAC', '*pixac')       

:param[in]    pixac:
:returns:  count, or 0 if no pixa


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetCount(*args)
    
    

    try:
        leptonica.pixacompGetPixcomp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompGetPixcomp.restype = lambda address: PIXC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetPixcomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetPixcomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', 'copyflag')       

:param[in]    pixac:
:param[in]    index:      caller's view of index within pixac; includes offset
:param[in]    copyflag:   L_NOCOPY, L_COPY
:returns:  pixc, or NULL on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
(2) If copyflag == L_NOCOPY, the pixc is owned by %pixac; do
not destroy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetPixcomp(*args)
    
    

    try:
        leptonica.pixacompGetPix.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompGetPix.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetPix(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       

:param[in]    pixac:
:param[in]    index:   caller's view of index within pixac; includes offset
:returns:  pix, or NULL on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetPix(*args)
    
    

    try:
        leptonica.pixacompGetPixDimensions.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompGetPixDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetPixDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetPixDimensions(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       

:param[in]    pixac:
:param[in]    index:       caller's view of index within pixac;
includes offset
:param[out]   pw,: ph, pd  [optional] each can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetPixDimensions(*args)
    
    

    try:
        leptonica.pixacompGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompGetBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBoxa(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'accesstype')       

:param[in]    pixac:
:param[in]    accesstype:   L_COPY, L_CLONE, L_COPY_CLONE
:returns:  boxa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBoxa(*args)
    
    

    try:
        leptonica.pixacompGetBoxaCount.argtypes = [ctypes.c_void_p]
        leptonica.pixacompGetBoxaCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetBoxaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBoxaCount(*args):
        """
        ('PIXAC', '*pixac')       

:param[in]    pixac:
:returns:  count, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBoxaCount(*args)
    
    

    try:
        leptonica.pixacompGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompGetBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBox(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', 'accesstype')       

:param[in]    pixac:
:param[in]    index:        caller's view of index within pixac;
includes offset
:param[in]    accesstype:   L_COPY or L_CLONE
:returns:  box if null, not automatically an error, or NULL on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
(2) There is always a boxa with a pixac, and it is initialized so
that each box ptr is NULL.
(3) In general, we expect that there is either a box associated
with each pixc, or no boxes at all in the boxa.
(4) Having no boxes is thus not an automatic error.  Whether it
is an actual error is determined by the calling program.
If the caller expects to get a box, it is an error; see, e.g.,
pixacGetBoxGeometry().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBox(*args)
    
    

    try:
        leptonica.pixacompGetBoxGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompGetBoxGeometry.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetBoxGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetBoxGeometry(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    pixac:
:param[in]    index:            caller's view of index within pixac;
includes offset
:param[out]   px,: py, pw, ph   [optional] each can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The %index includes the offset, which must be subtracted
to get the actual index into the ptr array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetBoxGeometry(*args)
    
    

    try:
        leptonica.pixacompGetOffset.argtypes = [ctypes.c_void_p]
        leptonica.pixacompGetOffset.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixacompGetOffset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompGetOffset(*args):
        """
        ('PIXAC', '*pixac')       

:param[in]    pixac:
:returns:  offset, or 0 on error

<pre>
Notes:
(1) The offset is the difference between the caller's view of
the index into the array and the actual array index.
By default it is 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompGetOffset(*args)
    
    

    try:
        leptonica.pixacompSetOffset.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixacompSetOffset.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompSetOffset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompSetOffset(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'offset')       

:param[in]    pixac:
:param[in]    offset:    non-negative
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The offset is the difference between the caller's view of
the index into the array and the actual array index.
By default it is 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompSetOffset(*args)
    
    

    try:
        leptonica.pixaCreateFromPixacomp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaCreateFromPixacomp.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCreateFromPixacomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCreateFromPixacomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'accesstype')       

:param[in]    pixac:
:param[in]    accesstype:   L_COPY, L_CLONE, L_COPY_CLONE; for boxa
:returns:  pixa if OK, or NULL on error

<pre>
Notes:
(1) Because the pixa has no notion of offset, the offset must
be set to 0 before the conversion, so that pixacompGetPix()
fetches all the pixcomps.  It is reset at the end.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCreateFromPixacomp(*args)
    
    

    try:
        leptonica.pixacompJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompJoin(*args):
        """
        ('PIXAC', '*pixacd')       
('PIXAC', '*pixacs')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    pixacd:    dest pixac; add to this one
:param[in]    pixacs:    [optional] source pixac; add from this one
:param[in]    istart:    starting index in pixacs
:param[in]    iend:      ending index in pixacs; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This appends a clone of each indicated pixc in pixcas to pixcad
(2) istart < 0 is taken to mean 'read from the start' (istart = 0)
(3) iend < 0 means 'read to the end'
(4) If pixacs is NULL or contains no pixc, this is a no-op.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompJoin(*args)
    
    

    try:
        leptonica.pixacompInterleave.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompInterleave.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompInterleave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompInterleave(*args):
        """
        ('PIXAC', '*pixac1')       
('PIXAC', '*pixac2')       

:param[in]    pixac1:    first src pixac
:param[in]    pixac2:    second src pixac
:returns:  pixacd  interleaved from sources, or NULL on error.

<pre>
Notes:
(1) If the two pixac have different sizes, a warning is issued,
and the number of pairs returned is the minimum size.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompInterleave(*args)
    
    

    try:
        leptonica.pixacompRead.argtypes = [ctypes.c_char_p]
        leptonica.pixacompRead.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  pixac, or NULL on error

<pre>
Notes:
(1) Unlike the situation with serialized Pixa, where the image
data is stored in png format, the Pixacomp image data
can be stored in tiffg4, png and jpg formats.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompRead(*args)
    
    

    try:
        leptonica.pixacompReadStream.argtypes = [ctypes.c_void_p]
        leptonica.pixacompReadStream.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:   file stream
:returns:  pixac, or NULL on error

<pre>
Notes:
(1) It is OK for the pixacomp to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReadStream(*args)
    
    

    try:
        leptonica.pixacompReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixacompReadMem.restype = lambda address: PIXAC(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:     in pixacomp format
:param[in]    size:     of data
:returns:  pixac, or NULL on error

<pre>
Notes:
(1) Deseralizes a buffer of pixacomp data into a pixac in memory.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompReadMem(*args)
    
    

    try:
        leptonica.pixacompWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixacompWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWrite(*args):
        """
        ('const char', '*filename')       
('PIXAC', '*pixac')       

:param[in]    filename:
:param[in]    pixac:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Unlike the situation with serialized Pixa, where the image
data is stored in png format, the Pixacomp image data
can be stored in tiffg4, png and jpg formats.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWrite(*args)
    
    

    try:
        leptonica.pixacompWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIXAC', '*pixac')       

:param[in]    fp:     file stream
:param[in]    pixac:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWriteStream(*args)
    
    

    try:
        leptonica.pixacompWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIXAC', '*pixac')       

:param[out]   pdata:   serialized data of pixac
:param[out]   psize:   size of serialized data
:param[in]    pixac:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a pixac in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWriteMem(*args)
    
    

    try:
        leptonica.pixacompConvertToPdf.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.pixacompConvertToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompConvertToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompConvertToPdf(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    pixac:         containing images all at the same resolution
:param[in]    res:           override the resolution of each input image,
in ppi; 0 to respect the resolution embedded
in the input
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:          encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE, or
L_DEFAULT_ENCODE for default)
:param[in]    quality:       used for JPEG only; 0 for default (75)
:param[in]    title:         [optional] pdf title
:param[in]    fileout:       pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This follows closely the function pixaConvertToPdf() in pdfio.c.
(2) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
colormap and many colors, or 32 bpp; FLATE for anything else.
(3) The scalefactor must be > 0.0; otherwise it is set to 1.0.
(4) Specifying one of the three encoding types for %type forces
all images to be compressed with that type.  Use 0 to have
the type determined for each image based on depth and whether
or not it has a colormap.
(5) If all images are jpeg compressed, don't require scaling
and have the same resolution, it is much faster to skip
transcoding with pixacompFastConvertToPdfData(), and then
write the data out to file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompConvertToPdf(*args)
    
    

    try:
        leptonica.pixacompConvertToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompConvertToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompConvertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompConvertToPdfData(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pixac:         containing images all at the same resolution
:param[in]    res:           input resolution of all images
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:          encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE, or
L_DEFAULT_ENCODE for default)
:param[in]    quality:       used for JPEG only; 0 for default (75)
:param[in]    title:         [optional] pdf title
:param[out]   pdata:         output pdf data (of all images
:param[out]   pnbytes:       size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixacompConvertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompConvertToPdfData(*args)
    
    

    try:
        leptonica.pixacompFastConvertToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixacompFastConvertToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompFastConvertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompFastConvertToPdfData(*args):
        """
        ('PIXAC', '*pixac')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pixac:     containing images all at the same resolution
:param[in]    title:     [optional] pdf title
:param[out]   pdata:     output pdf data (of all images
:param[out]   pnbytes:   size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates the pdf without transcoding if all the
images in %pixac are compressed with jpeg.
Images not jpeg compressed are skipped.
(2) It assumes all images have the same resolution, and that
the resolution embedded in each jpeg file is correct.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompFastConvertToPdfData(*args)
    
    

    try:
        leptonica.pixacompWriteStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixacompWriteStreamInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompWriteStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWriteStreamInfo(*args):
        """
        ('FILE', '*fp')       
('PIXAC', '*pixac')       
('const char', '*text')       

:param[in]    fp:      file stream
:param[in]    pixac:
:param[in]    text:    [optional] identifying string; can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWriteStreamInfo(*args)
    
    

    try:
        leptonica.pixcompWriteStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixcompWriteStreamInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcompWriteStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompWriteStreamInfo(*args):
        """
        ('FILE', '*fp')       
('PIXC', '*pixc')       
('const char', '*text')       

:param[in]    fp:     file stream
:param[in]    pixc:
:param[in]    text:   [optional] identifying string; can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompWriteStreamInfo(*args)
    
    

    try:
        leptonica.pixacompDisplayTiledAndScaled.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixacompDisplayTiledAndScaled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixacompDisplayTiledAndScaled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompDisplayTiledAndScaled(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'outdepth')       
('l_int32', 'tilewidth')       
('l_int32', 'ncols')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    pixac:
:param[in]    outdepth:     output depth: 1, 8 or 32 bpp
:param[in]    tilewidth:    each pix is scaled to this width
:param[in]    ncols:        number of tiles in each row
:param[in]    background:   0 for white, 1 for black; this is the color
of the spacing between the images
:param[in]    spacing:      between images, and on outside
:param[in]    border:       width of additional black border on each image;
use 0 for no border
:returns:  pix of tiled images, or NULL on error

<pre>
Notes:
(1) This is the same function as pixaDisplayTiledAndScaled(),
except it works on a Pixacomp instead of a Pix.  It is particularly
useful for showing the images in a Pixacomp at reduced resolution.
(2) See pixaDisplayTiledAndScaled() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompDisplayTiledAndScaled(*args)
    
    

    try:
        leptonica.pixacompWriteFiles.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixacompWriteFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixacompWriteFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixacompWriteFiles(*args):
        """
        ('PIXAC', '*pixac')       
('const char', '*subdir')       

:param[in]    pixac:
:param[in]    subdir:    subdirectory of /tmp
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixacompWriteFiles(*args)
    
    

    try:
        leptonica.pixcompWriteFile.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixcompWriteFile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixcompWriteFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixcompWriteFile(*args):
        """
        ('const char', '*rootname')       
('PIXC', '*pixc')       

:param[in]    rootname:
:param[in]    pixc:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The compressed data is written to file, and the filename is
generated by appending the format extension to %rootname.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixcompWriteFile(*args)
    




class rotateorth(object):
    """<pre>

Top-level rotation by multiples of 90 degrees
PIX             *pixRotateOrth()

180-degree rotation
PIX             *pixRotate180()

90-degree rotation (both directions)
PIX             *pixRotate90()

Left-right flip
PIX             *pixFlipLR()

Top-bottom flip
PIX             *pixFlipTB()

Byte reverse tables
static l_uint8  *makeReverseByteTab1()
static l_uint8  *makeReverseByteTab2()
static l_uint8  *makeReverseByteTab4()
</pre>




"""
    
    try:
        leptonica.pixRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRotateOrth.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateOrth(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'quads')       

:param[in]    pixs:       all depths
:param[in]    quads:      0-3; number of 90 degree cw rotations
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateOrth(*args)
    
    

    try:
        leptonica.pixRotate180.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixRotate180.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotate180 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate180(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:    [optional]; can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    all depths
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does a 180 rotation of the image about the center,
which is equivalent to a left-right flip about a vertical
line through the image center, followed by a top-bottom
flip about a horizontal line through the image center.
(2) There are 3 cases for input:
(a) pixd == null (creates a new pixd)
(b) pixd == pixs (in-place operation)
(c) pixd != pixs (existing pixd)
(3) For clarity, use these three patterns, respectively:
(a) pixd = pixRotate180(NULL, pixs);
(b) pixRotate180(pixs, pixs);
(c) pixRotate180(pixd, pixs);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate180(*args)
    
    

    try:
        leptonica.pixRotate90.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRotate90.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotate90 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate90(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'direction')       

:param[in]    pixs:         all depths
:param[in]    direction:    clockwise = 1, counterclockwise = -1
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does a 90 degree rotation of the image about the center,
either cw or ccw, returning a new pix.
(2) The direction must be either 1 (cw) or -1 (ccw).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate90(*args)
    
    

    try:
        leptonica.pixFlipLR.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFlipLR.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFlipLR not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFlipLR(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:    [optional]; can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    all depths
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does a left-right flip of the image, which is
equivalent to a rotation out of the plane about a
vertical line through the image center.
(2) There are 3 cases for input:
(a) pixd == null (creates a new pixd)
(b) pixd == pixs (in-place operation)
(c) pixd != pixs (existing pixd)
(3) For clarity, use these three patterns, respectively:
(a) pixd = pixFlipLR(NULL, pixs);
(b) pixFlipLR(pixs, pixs);
(c) pixFlipLR(pixd, pixs);
(4) If an existing pixd is not the same size as pixs, the
image data will be reallocated.
(5) The pixel access routines allow a trivial implementation.
However, for d < 8, it is more efficient to right-justify
each line to a 32-bit boundary and then extract bytes and
do pixel reversing.   In those cases, as in the 180 degree
rotation, we right-shift the data (if necessary) to
right-justify on the 32 bit boundary, and then read the
bytes off each raster line in reverse order, reversing
the pixels in each byte using a table.  These functions
for 1, 2 and 4 bpp were tested against the "trivial"
version (shown here for 4 bpp):
for (i = 0; i < h; i++) {
line = data + i * wpl;
memcpy(buffer, line, bpl);
for (j = 0; j < w; j++) {
val = GET_DATA_QBIT(buffer, w - 1 - j);
SET_DATA_QBIT(line, j, val);
}
}
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFlipLR(*args)
    
    

    try:
        leptonica.pixFlipTB.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFlipTB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFlipTB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFlipTB(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:   [optional]; can be null, equal to pixs,
or different from pixs
:param[in]    pixs:   all depths
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does a top-bottom flip of the image, which is
equivalent to a rotation out of the plane about a
horizontal line through the image center.
(2) There are 3 cases for input:
(a) pixd == null (creates a new pixd)
(b) pixd == pixs (in-place operation)
(c) pixd != pixs (existing pixd)
(3) For clarity, use these three patterns, respectively:
(a) pixd = pixFlipTB(NULL, pixs);
(b) pixFlipTB(pixs, pixs);
(c) pixFlipTB(pixd, pixs);
(4) If an existing pixd is not the same size as pixs, the
image data will be reallocated.
(5) This is simple and fast.  We use the memcpy function
to do all the work on aligned data, regardless of pixel
depth.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFlipTB(*args)
    




class writefile(object):
    """"""
    
    try:
        leptonica.l_jpegSetQuality.argtypes = [ctypes.c_int32]
        leptonica.l_jpegSetQuality.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_jpegSetQuality not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_jpegSetQuality(*args):
        """
        ('l_int32', 'new_quality')       

:param[in]    new_quality:    1 - 100; 75 is default; 0 defaults to 75
:returns:       prev           previous quality

<pre>
Notes:
(1) This variable is used in pixWriteStream() and pixWriteMem(),
to control the jpeg quality.  The default is 75.
(2) It returns the previous quality, so for example:
l_int32  prev = l_jpegSetQuality(85);  //sets to 85
pixWriteStream(...);
l_jpegSetQuality(prev);   // resets to previous value
(3) On error, logs a message and does not change the variable.


        """
        args = _convert_params(*args)
        
        return leptonica.l_jpegSetQuality(*args)
    
    

    try:
        leptonica.setLeptDebugOK.argtypes = [ctypes.c_int32]
        leptonica.setLeptDebugOK.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function setLeptDebugOK not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def setLeptDebugOK(*args):
        """
        ('l_int32', 'allow')       

:param[in]    allow:     TRUE (1) or FALSE (0)
:returns:       void

<pre>
Notes:
(1) This sets or clears the global variable LeptDebugOK, to
control writing files in a temp directory with names that
are compiled in.
(2) The default in the library distribution is 0.  Call with
%allow = 1 for development and debugging.


        """
        args = _convert_params(*args)
        
        return leptonica.setLeptDebugOK(*args)
    
    

    try:
        leptonica.pixaWriteFiles.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaWriteFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaWriteFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaWriteFiles(*args):
        """
        ('const char', '*rootname')       
('PIXA', '*pixa')       
('l_int32', 'format')       

:param[in]    rootname:
:param[in]    pixa:
:param[in]    format:  defined in imageio.h; see notes for default
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Use %format = IFF_DEFAULT to decide the output format
individually for each pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaWriteFiles(*args)
    
    

    try:
        leptonica.pixWriteDebug.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteDebug(*args):
        """
        ('const char', '*fname')       
('PIX', '*pix')       
('l_int32', 'format')       

:param[in]    fname:
:param[in]    pix:
:param[in]    format:  defined in imageio.h
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Debug version, intended for use in the library when writing
to files in a temp directory with names that are compiled in.
This is used instead of pixWrite() for all such library calls.
(2) The global variable LeptDebugOK defaults to 0, and can be set
or cleared by the function setLeptDebugOK().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteDebug(*args)
    
    

    try:
        leptonica.pixWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWrite(*args):
        """
        ('const char', '*fname')       
('PIX', '*pix')       
('l_int32', 'format')       

:param[in]    fname:
:param[in]    pix:
:param[in]    format:  defined in imageio.h
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Open for write using binary mode (with the "b" flag)
to avoid having Windows automatically translate the NL
into CRLF, which corrupts image files.  On non-windows
systems this flag should be ignored, per ISO C90.
Thanks to Dave Bryan for pointing this out.
(2) If the default image format IFF_DEFAULT is requested:
use the input format if known; otherwise, use a lossless format.
(3) The default jpeg quality is 75.  For some other value,
Use l_jpegSetQuality().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWrite(*args)
    
    

    try:
        leptonica.pixWriteAutoFormat.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.pixWriteAutoFormat.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteAutoFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteAutoFormat(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       

:param[in]    filename:
:param[in]    pix:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteAutoFormat(*args)
    
    

    try:
        leptonica.pixWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStream(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'format')       

:param[in]    fp: file stream
:param[in]    pix:
:param[in]    format:
:returns:  0 if OK; 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStream(*args)
    
    

    try:
        leptonica.pixWriteImpliedFormat.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteImpliedFormat.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteImpliedFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteImpliedFormat(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'progressive')       

:param[in]    filename:
:param[in]    pix:
:param[in]    quality: iff JPEG; 1 - 100, 0 for default
:param[in]    progressive: iff JPEG; 0 for baseline seq., 1 for progressive
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This determines the output format from the filename extension.
(2) The last two args are ignored except for requests for jpeg files.
(3) The jpeg default quality is 75.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteImpliedFormat(*args)
    
    

    try:
        leptonica.pixChooseOutputFormat.argtypes = [ctypes.c_void_p]
        leptonica.pixChooseOutputFormat.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixChooseOutputFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixChooseOutputFormat(*args):
        """
        ('PIX', '*pix')       

:param[in]    pix:
:returns:  output format, or 0 on error

<pre>
Notes:
(1) This should only be called if the requested format is IFF_DEFAULT.
(2) If the pix wasn't read from a file, its input format value
will be IFF_UNKNOWN, and in that case it is written out
in a compressed but lossless format.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixChooseOutputFormat(*args)
    
    

    try:
        leptonica.getImpliedFileFormat.argtypes = [ctypes.c_char_p]
        leptonica.getImpliedFileFormat.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function getImpliedFileFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getImpliedFileFormat(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  output format, or IFF_UNKNOWN on error or invalid extension.

<pre>
Notes:
(1) This determines the output file format from the extension
of the input filename.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getImpliedFileFormat(*args)
    
    

    try:
        leptonica.pixGetAutoFormat.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetAutoFormat.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetAutoFormat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAutoFormat(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*pformat')       

:param[in]    pix:
:param[in]    &format:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The output formats are restricted to tiff, jpeg and png
because these are the most commonly used image formats and
the ones that are typically installed with leptonica.
(2) This decides what compression to use based on the pix.
It chooses tiff-g4 if 1 bpp without a colormap, jpeg with
quality 75 if grayscale, rgb or rgba (where it loses
the alpha layer), and lossless png for all other situations.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAutoFormat(*args)
    
    

    try:
        leptonica.getFormatExtension.argtypes = [ctypes.c_int32]
        leptonica.getFormatExtension.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function getFormatExtension not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getFormatExtension(*args):
        """
        ('l_int32', 'format')       

:param[in]    format: integer
:returns:  extension string, or NULL if format is out of range

<pre>
Notes:
(1) This string is NOT owned by the caller; it is just a pointer
to a global string.  Do not free it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getFormatExtension(*args)
    
    

    try:
        leptonica.pixWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'format')       

:param[out]   pdata: data of tiff compressed image
:param[out]   psize: size of returned data
:param[in]    pix:
:param[in]    format:  defined in imageio.h
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) On windows, this will only write tiff and PostScript to memory.
For other formats, it requires open_memstream(3).
(2) PostScript output is uncompressed, in hex ascii.
Most printers support level 2 compression (tiff_g4 for 1 bpp,
jpeg for 8 and 32 bpp).
(3) The default jpeg quality is 75.  For some other value,
Use l_jpegSetQuality().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMem(*args)
    
    

    try:
        leptonica.l_fileDisplay.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.l_fileDisplay.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_fileDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_fileDisplay(*args):
        """
        ('const char', '*fname')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'scale')       

:param[in]    fname:
:param[in]    x,: y  location of display frame on the screen
:param[in]    scale:  scale factor (use 0 to skip display)
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is a convenient wrapper for displaying image files.
(2) It does nothing unless LeptDebugOK == TRUE.
(2) Set %scale = 0 to disable display.
(3) This downscales 1 bpp to gray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_fileDisplay(*args)
    
    

    try:
        leptonica.pixDisplay.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDisplay.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplay(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    pix: 1, 2, 4, 8, 16, 32 bpp
:param[in]    x,: y  location of display frame on the screen
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This is debugging code that displays an image on the screen.
It uses a static internal variable to number the output files
written by a single process.  Behavior with a shared library
may be unpredictable.
(2) It does nothing unless LeptDebugOK == TRUE.
(3) It uses these programs to display the image:
On Unix: xzgv, xli or xv
On Windows: i_view
The display program must be on your $PATH variable.  It is
chosen by setting the global var_DISPLAY_PROG, using
l_chooseDisplayProg().  Default on Unix is xzgv.
(4) Images with dimensions larger than MaxDisplayWidth or
MaxDisplayHeight are downscaled to fit those constraints.
This is particularly important for displaying 1 bpp images
with xv, because xv automatically downscales large images
by subsampling, which looks poor.  For 1 bpp, we use
scale-to-gray to get decent-looking anti-aliased images.
In all cases, we write a temporary file to /tmp/lept/disp,
that is read by the display program.
(5) The temporary file is written as png if, after initial
processing for special cases, any of these obtain:
pix dimensions are smaller than some thresholds
pix depth is less than 8 bpp
pix is colormapped
(6) For spp == 4, we call pixDisplayLayersRGBA() to show 3
versions of the image: the image with a fully opaque
alpha, the alpha, and the image as it would appear with
a white background.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplay(*args)
    
    

    try:
        leptonica.pixDisplayWithTitle.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixDisplayWithTitle.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayWithTitle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayWithTitle(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('const char', '*title')       
('l_int32', 'dispflag')       

:param[in]    pix: 1, 2, 4, 8, 16, 32 bpp
:param[in]    x,: y  location of display frame
:param[in]    title: [optional] on frame; can be NULL;
:param[in]    dispflag: 1 to write, else disabled
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) See notes for pixDisplay().
(2) This displays the image if dispflag == 1; otherwise it punts.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayWithTitle(*args)
    
    

    try:
        leptonica.pixMakeColorSquare.argtypes = [ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixMakeColorSquare.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMakeColorSquare not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMakeColorSquare(*args):
        """
        ('l_uint32', 'color')       
('l_int32', 'size')       
('l_int32', 'addlabel')       
('l_int32', 'location')       
('l_uint32', 'textcolor')       

:param[in]    color:      in 0xrrggbb00 format
:param[in]    size:       in pixels; >= 100; use 0 for default (min size)
:param[in]    addlabel:   use 1 to display the color component values
:param[in]    location:   of text: L_ADD_ABOVE, etc; ignored if %addlabel == 0
:param[in]    textcolor:  of text label; in 0xrrggbb00 format
:returns:  32 bpp rgb pixd if OK; NULL on error

<pre>
Notes:
(1) If %addlabel == 0, %location and %textcolor are ignored.
(2) To make an array of color squares, use pixDisplayColorArray().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMakeColorSquare(*args)
    
    

    try:
        leptonica.changeFormatForMissingLib.argtypes = [ctypes.c_void_p]
        leptonica.changeFormatForMissingLib.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function changeFormatForMissingLib not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def changeFormatForMissingLib(*args):
        """
        ('l_int32', '*pformat')       

:param[in,out]    pformat:    addr of requested output image format
:returns:  void

<pre>
Notes:
(1) This is useful for testing functionality when the library for
the requested output format (jpeg, png or tiff) is not linked.
In that case, the output format is changed to bmp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.changeFormatForMissingLib(*args)
    
    

    try:
        leptonica.pixDisplayWrite.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDisplayWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayWrite(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'reduction')       

:param[in]    pix: 1, 2, 4, 8, 16, 32 bpp
:param[in]    reduction: -1 to reset/erase; 0 to disable;
otherwise this is a reduction factor
:returns:  0 if OK; 1 on error

<pre>
Notes:
(0) Deprecated.
(1) This is a simple interface for writing a set of files.
(2) This uses jpeg output for pix that are 32 bpp or 8 bpp
without a colormap; otherwise, it uses png.
(3) To erase any previously written files in the output directory:
pixDisplayWrite(NULL, -1);
(4) If reduction > 1 and depth == 1, this does a scale-to-gray
reduction.
(5) This function uses a static internal variable to number
output files written by a single process.  Behavior
with a shared library may be unpredictable.
(6) For 16 bpp, this displays the full dynamic range with log scale.
Alternative image transforms to generate 8 bpp pix are:
pix8 = pixMaxDynamicRange(pixt, L_LINEAR_SCALE);
pix8 = pixConvert16To8(pixt, L_LS_BYTE);  // low order byte
pix8 = pixConvert16To8(pixt, L_MS_BYTE);  // high order byte
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayWrite(*args)
    
    

    try:
        leptonica.pixSaveTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSaveTiled.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSaveTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSaveTiled(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_float32', 'scalefactor')       
('l_int32', 'newrow')       
('l_int32', 'space')       
('l_int32', 'dp')       

:param[in]    pixs: 1, 2, 4, 8, 32 bpp
:param[in]    pixa: the pix are accumulated here
:param[in]    scalefactor: 0.0 to disable; otherwise this is a scale factor
:param[in]    newrow: 0 if placed on the same row as previous; 1 otherwise
:param[in]    space: horizontal and vertical spacing, in pixels
:param[in]    dp: depth of pixa; 8 or 32 bpp; only used on first call
:returns:  0 if OK, 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixSaveTiled(*args)
    
    

    try:
        leptonica.pixSaveTiledOutline.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSaveTiledOutline.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSaveTiledOutline not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSaveTiledOutline(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_float32', 'scalefactor')       
('l_int32', 'newrow')       
('l_int32', 'space')       
('l_int32', 'linewidth')       
('l_int32', 'dp')       

:param[in]    pixs: 1, 2, 4, 8, 32 bpp
:param[in]    pixa: the pix are accumulated here
:param[in]    scalefactor: 0.0 to disable; otherwise this is a scale factor
:param[in]    newrow: 0 if placed on the same row as previous; 1 otherwise
:param[in]    space: horizontal and vertical spacing, in pixels
:param[in]    linewidth: width of added outline for image; 0 for no outline
:param[in]    dp: depth of pixa; 8 or 32 bpp; only used on first call
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) Before calling this function for the first time, use
pixaCreate() to make the %pixa that will accumulate the pix.
This is passed in each time pixSaveTiled() is called.
(2) %scalefactor scales the input image.  After scaling and
possible depth conversion, the image is saved in the input
pixa, along with a box that specifies the location to
place it when tiled later.  Disable saving the pix by
setting %scalefactor == 0.0.
(3) %newrow and %space specify the location of the new pix
with respect to the last one(s) that were entered.
(4) %dp specifies the depth at which all pix are saved.  It can
be only 8 or 32 bpp.  Any colormap is removed.  This is only
used at the first invocation.
(5) This function uses two variables from call to call.
If they were static, the function would not be .so or thread
safe, and furthermore, there would be interference with two or
more pixa accumulating images at a time.  Consequently,
we use the first pix in the pixa to store and obtain both
the depth and the current position of the bottom (one pixel
below the lowest image raster line when laid out using
the boxa).  The bottom variable is stored in the input format
field, which is the only field available for storing an int.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSaveTiledOutline(*args)
    
    

    try:
        leptonica.pixSaveTiledWithText.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixSaveTiledWithText.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSaveTiledWithText not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSaveTiledWithText(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixa')       
('l_int32', 'outwidth')       
('l_int32', 'newrow')       
('l_int32', 'space')       
('l_int32', 'linewidth')       
('L_BMF', '*bmf')       
('const char', '*textstr')       
('l_uint32', 'val')       
('l_int32', 'location')       

:param[in]    pixs: 1, 2, 4, 8, 32 bpp
:param[in]    pixa: the pix are accumulated here; as 32 bpp
:param[in]    outwidth: in pixels; use 0 to disable entirely
:param[in]    newrow: 1 to start a new row; 0 to go on same row as previous
:param[in]    space: horizontal and vertical spacing, in pixels
:param[in]    linewidth: width of added outline for image; 0 for no outline
:param[in]    bmf: [optional] font struct
:param[in]    textstr: [optional] text string to be added
:param[in]    val: color to set the text
:param[in]    location: L_ADD_ABOVE, L_ADD_AT_TOP, L_ADD_AT_BOT, L_ADD_BELOW
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) Before calling this function for the first time, use
pixaCreate() to make the %pixa that will accumulate the pix.
This is passed in each time pixSaveTiled() is called.
(2) %outwidth is the scaled width.  After scaling, the image is
saved in the input pixa, along with a box that specifies
the location to place it when tiled later.  Disable saving
the pix by setting %outwidth == 0.
(3) %newrow and %space specify the location of the new pix
with respect to the last one(s) that were entered.
(4) All pix are saved as 32 bpp RGB.
(5) If both %bmf and %textstr are defined, this generates a pix
with the additional text; otherwise, no text is written.
(6) The text is written before scaling, so it is properly
antialiased in the scaled pix.  However, if the pix on
different calls have different widths, the size of the
text will vary.
(7) See pixSaveTiledOutline() for other implementation details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSaveTiledWithText(*args)
    




class bmpiostub(object):
    """<pre>

Stubs for bmpio.c functions
</pre>




"""
    



class fhmtauto(object):
    """<pre>

Main function calls:
l_int32             fhmtautogen()
l_int32             fhmtautogen1()
l_int32             fhmtautogen2()

Static helpers:
static SARRAY      *sarrayMakeWplsCode()
static SARRAY      *sarrayMakeInnerLoopDWACode()
static char        *makeBarrelshiftString()

This automatically generates dwa code for the hit-miss transform.
Here's a road map for how it all works.

(1) You generate an array (a SELA) of hit-miss transform SELs.
This can be done in several ways, including
(a) calling the function selaAddHitMiss() for
pre-compiled SELs
(b) generating the SELA in code in line
(c) reading in a SELA from file, using selaRead()
or various other formats.

(2) You call fhmtautogen1() and fhmtautogen2() on this SELA.
This uses the text files hmttemplate1.txt and
hmttemplate2.txt for building up the source code.  See the file
prog/fhmtautogen.c for an example of how this is done.
The output is written to files named fhmtgen.*.c
and fhmtgenlow.*.c, where "*" is an integer that you
input to this function.  That integer labels both
the output files, as well as all the functions that
are generated.  That way, using different integers,
you can invoke fhmtautogen() any number of times
to get functions that all have different names so that
they can be linked into one program.

(3) You copy the generated source code back to your src
directory for compilation.  Put their names in the
Makefile, regnerate the prototypes, and recompile
the libraries.  Look at the Makefile to see how I've
included fhmtgen.1.c and fhmtgenlow.1.c.  These files
provide the high-level interfaces for the hmt, and
the low-level interfaces to do the actual work.

(4) In an application, you now use this interface.  Again
for the example files generated, using integer "1":

PIX   *pixHMTDwa_1(PIX *pixd, PIX *pixs, const char *selname);

or

PIX   *pixFHMTGen_1(PIX *pixd, PIX *pixs, const char *selname);

where the selname is one of the set that were defined
as the name field of sels.  This set is listed at the
beginning of the file fhmtgen.1.c.
As an example, see the file prog/fmtauto_reg.c, which
verifies the correctness of the implementation by
comparing the dwa result with that of full-image
rasterops.
</pre>




"""
    
    try:
        leptonica.fhmtautogen.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.fhmtautogen.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fhmtautogen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fhmtautogen(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       

:param[in]    sela:
:param[in]    fileindex:
:param[in]    filename: [optional]; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This function generates all the code for implementing
dwa morphological operations using all the sels in the sela.
(2) See fhmtautogen1() and fhmtautogen2() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fhmtautogen(*args)
    
    

    try:
        leptonica.fhmtautogen1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.fhmtautogen1.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fhmtautogen1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fhmtautogen1(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       

:param[in]    sela: array
:param[in]    fileindex:
:param[in]    filename: [optional]; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This function uses hmttemplate1.txt to create a
top-level file that contains two functions that carry
out the hit-miss transform for any of the sels in
the input sela.
(2) The fileindex parameter is inserted into the output
filename, as described below.
(3) If filename == NULL, the output file is fhmtgen.[n].c,
where [n] is equal to the 'fileindex' parameter.
(4) If filename != NULL, the output file is [filename].[n].c.
(5) Each sel must have at least one hit.  A sel with only misses
generates code that will abort the operation if it is called.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fhmtautogen1(*args)
    
    

    try:
        leptonica.fhmtautogen2.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.fhmtautogen2.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fhmtautogen2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fhmtautogen2(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       

:param[in]    sela: array
:param[in]    fileindex:
:param[in]    filename: [optional]; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This function uses hmttemplate2.txt to create a
low-level file that contains the low-level functions for
implementing the hit-miss transform for every sel
in the input sela.
(2) The fileindex parameter is inserted into the output
filename, as described below.
(3) If filename == NULL, the output file is fhmtgenlow.[n].c,
where [n] is equal to the %fileindex parameter.
(4) If filename != NULL, the output file is [filename]low.[n].c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fhmtautogen2(*args)
    




class list(object):
    """<pre>

Inserting and removing elements

void      listDestroy()
DLLIST   *listAddToHead()
l_int32   listAddToTail()
l_int32   listInsertBefore()
l_int32   listInsertAfter()
void     *listRemoveElement()
void     *listRemoveFromHead()
void     *listRemoveFromTail()

Other list operations

DLLIST   *listFindElement()
DLLIST   *listFindTail()
l_int32   listGetCount()
l_int32   listReverse()
DLLIST   *listJoin()

Lists are much harder to handle than arrays.  There is
more overhead for the programmer, both cognitive and
codewise, and more likelihood that an error can be made.
For that reason, lists should only be used when it is
inefficient to use arrays, such as when elements are
routinely inserted or deleted from inside arrays whose
average size is greater than about 10.

A list of data structures can be implemented in a number
of ways.  The two most popular are:

(1) The list can be composed of a linked list of
pointer cells ("cons cells"), where the data structures
are hung off the cells.  This is more difficult
to use because you have to keep track of both
your hanging data and the cell structures.
It requires 3 pointers for every data structure
that is put in a list.  There is no problem
cloning (using reference counts) for structures that
are put in such a list.  We implement lists by this
method here.

(2) The list pointers can be inserted directly into
the data structures.  This is easy to implement
and easier to use, but it adds 2 ptrs of overhead
to every data structure in which the ptrs are embedded.
It also requires special care not to put the ptrs
in any data that is cloned with a reference count;
else your lists will break.

Writing C code that uses list pointers explicitly to make
and alter lists is difficult and prone to error.
Consequently, a generic list utility that handles lists
of arbitrary objects and doesn't force the programmer to
touch the "next" and "prev" pointers, is quite useful.
Such functions are provided here.   However, the usual
situation requires traversing a list and applying some
function to one or more of the list elements.  Macros
for traversing the list are, in general, necessary, to
achieve the goal of invisibly handling all "next" and "prev"
pointers in generic lists.  We provide macros for
traversing a list in both forward and reverse directions.

Because of the typing in C, implementation of a general
list utility requires casting.  If macros are used, the
casting can be done implicitly; otherwise, using functions,
some of the casts must be explicit.  Fortunately, this
can be implemented with void* so the programmer using
the library will not have to make any casts!  (Unless you
compile with g++, in which case the rules on implicit
conversion are more strict.)

For example, to add an arbitrary data structure foo to the
tail of a list, use
listAddToTail(&head, &tail, pfoo);
where head and tail are list cell ptrs and pfoo is
a pointer to the foo object.
And to remove an arbitrary data structure foo from a
list, when you know the list cell element it is hanging from,
use
pfoo = listRemoveElement(&head, elem)
where head and elem are list cell ptrs and pfoo is a pointer
to the foo object.  No casts are required for foo in
either direction in ANSI C.  (However, casts are
required for ANSI C++).

We use lists that are composed of doubly-linked
cells with data structures hanging off the cells.
We use doubly-linked cells to simplify insertion
and deletion, and to allow operations to proceed in either
direction along the list.  With doubly-linked lists,
it is tempting to make them circular, by setting head->prev
to the tail of the list and tail->next to the head.
The circular list costs nothing extra in storage, and
allows operations to proceed from either end of the list
with equal speed.  However, the circular link adds
cognitive overhead for the application programmer in
general, and it greatly complicates list traversal when
arbitrary list elements can be added or removed as you
move through.  It can be done, but in the spirit of
simplicity, we avoid the temptation.  The price to be paid
is the extra cost to find the tail of a list -- a full
traversal -- before the tail can be used.  This is a
cheap price to pay to avoid major headaches and buggy code.

When you are only applying some function to each element
in a list, you can go either forwards or backwards.
To run through a list forwards, use:
\code
for (elem = head; elem; elem = nextelem) {
nextelem = elem->next;   (in case we destroy elem)
<do something with elem->data>
}
\endcode
To run through a list backwards, find the tail and use:

for (elem = tail; elem; elem = prevelem) {
#              prevelem = elem->prev;  (in case we destroy elem)
<do something with elem->data>
}

Even though these patterns are very simple, they are so common
that we've provided macros for them in list.h.  Using the
macros, this becomes:
\code
L_BEGIN_LIST_FORWARD(head, elem)
<do something with elem->data>
L_END_LIST

L_BEGIN_LIST_REVERSE(tail, elem)
<do something with elem->data>
L_END_LIST
\endcode
Note again that with macros, the application programmer does
not need to refer explicitly to next and prev fields.  Also,
in the reverse case, note that we do not explicitly
show the head of the list.  However, the head of the list
is always in scope, and functions can be called within the
iterator that change the head.

Some special cases are simpler.  For example, when
removing all items from the head of the list, you can use
\code
while (head) {
obj = listRemoveFromHead(&head);
<do something with obj>
}
\endcode
Removing successive elements from the tail is equally simple:
\code
while (tail) {
obj = listRemoveFromTail(&head, &tail);
<do something with obj>
}
\endcode
When removing an arbitrary element from a list, use
\code
obj = listRemoveElement(&head, elem);
\endcode
All the listRemove*() functions hand you the object,
destroy the list cell to which it was attached, and
reset the list pointers if necessary.

Several other list operations, that do not involve
inserting or removing objects, are also provided.
The function listFindElement() locates a list pointer
by matching the object hanging on it to a given
object.  The function listFindTail() gets a handle
to the tail list ptr, allowing backwards traversals of
the list.  listGetCount() gives the number of elements
in a list.  Functions that reverse a list and concatenate
two lists are also provided.

These functions can be modified for efficiency in the
situation where there is a large amount of creation and
destruction of list cells.  If millions of cells are
made and destroyed, but a relatively small number are
around at any time, the list cells can be stored for
later re-use in a stack (see the generic stack functions
in stack.c).
</pre>




"""
    
    try:
        leptonica.listDestroy.argtypes = [ctypes.c_void_p]
        leptonica.listDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function listDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listDestroy(*args):
        """
        ('DLLIST', '**phead')       

:param[in,out]   phead:   head of list; will be set to null before returning
:returns:  void

<pre>
Notes:
(1) This only destroys the cons cells.  Before destroying
the list, it is necessary to remove all data and set the
data pointers in each cons cell to NULL.
(2) listDestroy() will give a warning message for each data
ptr that is not NULL.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listDestroy(*args)
    
    

    try:
        leptonica.listAddToHead.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listAddToHead.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function listAddToHead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listAddToHead(*args):
        """
        ('DLLIST', '**phead')       
('void', '*data')       

:param[in,out]   phead:    [optional] input head
:param[in]       data:     void* ptr, to be added
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This makes a new cell, attaches %data, and adds the
cell to the head of the list.
(2) When consing from NULL, be sure to initialize head to NULL
before calling this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listAddToHead(*args)
    
    

    try:
        leptonica.listAddToTail.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listAddToTail.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function listAddToTail not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listAddToTail(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '**ptail')       
('void', '*data')       

:param[in,out]   phead:    [may be updated], can be NULL
:param[in,out]   ptail:    [updated], can be NULL
:param[in]       data:     void* ptr, to be hung on tail cons cell
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This makes a new cell, attaches %data, and adds the
cell to the tail of the list.
(2) &head is input to allow the list to be "cons'd" up from NULL.
(3) &tail is input to allow the tail to be updated
for efficient sequential operation with this function.
(4) We assume that if *phead and/or *ptail are not NULL,
then they are valid addresses.  Therefore:
(a) when consing from NULL, be sure to initialize both
head and tail to NULL.
(b) when tail == NULL for an existing list, the tail
will be found and updated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listAddToTail(*args)
    
    

    try:
        leptonica.listInsertBefore.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listInsertBefore.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function listInsertBefore not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listInsertBefore(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '*elem')       
('void', '*data')       

:param[in,out]   phead:    [optional] input head
:param[in]       elem:     list element to be inserted in front of;
must be NULL if head is NULL
:param[in]       data:     void* address, to be added
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This can be called on a null list, in which case both
head and elem must be null.
(2) If you are searching through a list, looking for a condition
to add an element, you can do something like this:
\code
L_BEGIN_LIST_FORWARD(head, elem)
<identify an elem to insert before>
listInsertBefore(&head, elem, data);
L_END_LIST
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listInsertBefore(*args)
    
    

    try:
        leptonica.listInsertAfter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listInsertAfter.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function listInsertAfter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listInsertAfter(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '*elem')       
('void', '*data')       

:param[in,out]   phead:    [optional] input head
:param[in]       elem:     list element to be inserted after;
must be NULL if head is NULL
:param[in]       data:     void* ptr, to be added
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This can be called on a null list, in which case both
head and elem must be null.  The head is included
in the call to allow "consing" up from NULL.
(2) If you are searching through a list, looking for a condition
to add an element, you can do something like this:
\code
L_BEGIN_LIST_FORWARD(head, elem)
<identify an elem to insert after>
listInsertAfter(&head, elem, data);
L_END_LIST
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listInsertAfter(*args)
    
    

    try:
        leptonica.listRemoveElement.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listRemoveElement.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function listRemoveElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listRemoveElement(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '*elem')       

:param[in,out]   phead:    input head; can be changed
:param[in]       elem:     list element to be removed
:returns:  data  void* struct on cell

<pre>
Notes:
(1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
pix = listRemoveElement(&head, elem);
but in ANSI C++, it is necessary to do the cast:
pix = (Pix *)listRemoveElement(&head, elem);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listRemoveElement(*args)
    
    

    try:
        leptonica.listRemoveFromHead.argtypes = [ctypes.c_void_p]
        leptonica.listRemoveFromHead.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function listRemoveFromHead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listRemoveFromHead(*args):
        """
        ('DLLIST', '**phead')       

:param[in,out]   phead:     head of list; updated
:returns:  data  void* struct on cell, or NULL on error

<pre>
Notes:
(1) in ANSI C, it is not necessary to cast return to actual type; e.g.,
pix = listRemoveFromHead(&head);
but in ANSI C++, it is necessary to do the cast; e.g.,
pix = (Pix *)listRemoveFromHead(&head);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listRemoveFromHead(*args)
    
    

    try:
        leptonica.listRemoveFromTail.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listRemoveFromTail.restype = ctypes.POINTER(ctypes.c_void_p)
    except AttributeError:
        sys.stderr.write("Warning - function listRemoveFromTail not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listRemoveFromTail(*args):
        """
        ('DLLIST', '**phead')       
('DLLIST', '**ptail')       

:param[in,out]   phead:    list head must NOT be NULL; may be changed
:param[in,out]   ptail:    list tail may be NULL; always updated
:returns:  data  void* struct on cell or NULL on error

<pre>
Notes:
(1) We include &head so that it can be set to NULL if
if the only element in the list is removed.
(2) The function is relying on the fact that if tail is
not NULL, then is is a valid address.  You can use
this function with tail == NULL for an existing list, in
which case  the tail is found and updated, and the
removed element is returned.
(3) In ANSI C, it is not necessary to cast return to actual type; e.g.,
pix = listRemoveFromTail(&head, &tail);
but in ANSI C++, it is necessary to do the cast; e.g.,
pix = (Pix *)listRemoveFromTail(&head, &tail);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listRemoveFromTail(*args)
    
    

    try:
        leptonica.listFindElement.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listFindElement.restype = lambda address: DLLIST(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function listFindElement not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listFindElement(*args):
        """
        ('DLLIST', '*head')       
('void', '*data')       

:param[in]    head:    list head
:param[in]    data:    void* address, to be searched for
:returns:  cell  the containing cell, or NULL if not found or on error

<pre>
Notes:
(1) This returns a ptr to the cell, which is still embedded in
the list.
(2) This handle and the attached data have not been copied or
reference counted, so they must not be destroyed.  This
violates our basic rule that every handle returned from a
function is owned by that function and must be destroyed,
but if rules aren't there to be broken, why have them?
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listFindElement(*args)
    
    

    try:
        leptonica.listFindTail.argtypes = [ctypes.c_void_p]
        leptonica.listFindTail.restype = lambda address: DLLIST(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function listFindTail not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listFindTail(*args):
        """
        ('DLLIST', '*head')       

:param[in]    head:
:returns:  tail, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.listFindTail(*args)
    
    

    try:
        leptonica.listGetCount.argtypes = [ctypes.c_void_p]
        leptonica.listGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function listGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listGetCount(*args):
        """
        ('DLLIST', '*head')       

:param[in]    head:     of list
:returns:  number of elements; 0 if no list or on error


        """
        args = _convert_params(*args)
        
        return leptonica.listGetCount(*args)
    
    

    try:
        leptonica.listReverse.argtypes = [ctypes.c_void_p]
        leptonica.listReverse.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function listReverse not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listReverse(*args):
        """
        ('DLLIST', '**phead')       

:param[in,out]   phead:    list head; may be changed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This reverses the list in-place.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listReverse(*args)
    
    

    try:
        leptonica.listJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.listJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function listJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def listJoin(*args):
        """
        ('DLLIST', '**phead1')       
('DLLIST', '**phead2')       

:param[in,out]   phead1:   head of first list; may be changed
:param[in,out]   phead2:   head of second list; to be nulled
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The concatenated list is returned with head1 as the new head.
(2) Both input ptrs must exist, though either can have the value NULL.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.listJoin(*args)
    




class pixconv(object):
    """<pre>

These functions convert between images of different types
without scaling.

Conversion from 8 bpp grayscale to 1, 2, 4 and 8 bpp
PIX        *pixThreshold8()

Conversion from colormap to full color or grayscale
PIX        *pixRemoveColormapGeneral()
PIX        *pixRemoveColormap()

Add colormap losslessly (8 to 8)
l_int32     pixAddGrayColormap8()
PIX        *pixAddMinimalGrayColormap8()

Conversion from RGB color to grayscale
PIX        *pixConvertRGBToLuminance()
PIX        *pixConvertRGBToGray()
PIX        *pixConvertRGBToGrayFast()
PIX        *pixConvertRGBToGrayMinMax()
PIX        *pixConvertRGBToGraySatBoost()
PIX        *pixConvertRGBToGrayArb()
PIX        *pixConvertRGBToBinaryArb()

Conversion from grayscale to colormap
PIX        *pixConvertGrayToColormap()  -- 2, 4, 8 bpp
PIX        *pixConvertGrayToColormap8()  -- 8 bpp only

Colorizing conversion from grayscale to color
PIX        *pixColorizeGray()  -- 8 bpp or cmapped

Conversion from RGB color to colormap
PIX        *pixConvertRGBToColormap()

Conversion from colormap to 1 bpp
PIX        *pixConvertCmapTo1()

Quantization for relatively small number of colors in source
l_int32     pixQuantizeIfFewColors()

Conversion from 16 bpp to 8 bpp
PIX        *pixConvert16To8()

Conversion from grayscale to false color
PIX        *pixConvertGrayToFalseColor()

Unpacking conversion from 1 bpp to 2, 4, 8, 16 and 32 bpp
PIX        *pixUnpackBinary()
PIX        *pixConvert1To16()
PIX        *pixConvert1To32()

Unpacking conversion from 1 bpp to 2 bpp
PIX        *pixConvert1To2Cmap()
PIX        *pixConvert1To2()

Unpacking conversion from 1 bpp to 4 bpp
PIX        *pixConvert1To4Cmap()
PIX        *pixConvert1To4()

Unpacking conversion from 1, 2 and 4 bpp to 8 bpp
PIX        *pixConvert1To8()
PIX        *pixConvert2To8()
PIX        *pixConvert4To8()

Unpacking conversion from 8 bpp to 16 bpp
PIX        *pixConvert8To16()

Top-level conversion to 1 bpp
PIX        *pixConvertTo1Adaptive()
PIX        *pixConvertTo1()
PIX        *pixConvertTo1BySampling()

Top-level conversion to 2 bpp
PIX        *pixConvertTo2()
PIX        *pixConvert8To2()

Top-level conversion to 4 bpp
PIX        *pixConvertTo4()
PIX        *pixConvert8To4()

Top-level conversion to 8 bpp
PIX        *pixConvertTo8()
PIX        *pixConvertTo8BySampling()
PIX        *pixConvertTo8Colormap()

Top-level conversion to 16 bpp
PIX        *pixConvertTo16()

Top-level conversion to 32 bpp (RGB)
PIX        *pixConvertTo32()
PIX        *pixConvertTo32BySampling()
PIX        *pixConvert8To32()

Top-level conversion to 8 or 32 bpp, without colormap
PIX        *pixConvertTo8Or32

Conversion between 24 bpp and 32 bpp rgb
PIX        *pixConvert24To32()
PIX        *pixConvert32To24()

Conversion between 32 bpp (1 spp) and 16 or 8 bpp
PIX        *pixConvert32To16()
PIX        *pixConvert32To8()

Removal of alpha component by blending with white background
PIX        *pixRemoveAlpha()

Addition of alpha component to 1 bpp
PIX        *pixAddAlphaTo1bpp()

Lossless depth conversion (unpacking)
PIX        *pixConvertLossless()

Conversion for printing in PostScript
PIX        *pixConvertForPSWrap()

Scaling conversion to subpixel RGB
PIX        *pixConvertToSubpixelRGB()
PIX        *pixConvertGrayToSubpixelRGB()
PIX        *pixConvertColorToSubpixelRGB()

Setting neutral point for min/max boost conversion to gray
void         l_setNeutralBoostVal()
</pre>




"""
    
    try:
        leptonica.pixThreshold8.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThreshold8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThreshold8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThreshold8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'd')       
('l_int32', 'nlevels')       
('l_int32', 'cmapflag')       

:param[in]    pixs:       8 bpp grayscale
:param[in]    d:          destination depth: 1, 2, 4 or 8
:param[in]    nlevels:    number of levels to be used for colormap
:param[in]    cmapflag:   1 if makes colormap; 0 otherwise
:returns:  pixd thresholded with standard dest thresholds,
or NULL on error

<pre>
Notes:
(1) This uses, by default, equally spaced "target" values
that depend on the number of levels, with thresholds
halfway between.  For N levels, with separation (N-1)/255,
there are N-1 fixed thresholds.
(2) For 1 bpp destination, the number of levels can only be 2
and if a cmap is made, black is (0,0,0) and white
is (255,255,255), which is opposite to the convention
without a colormap.
(3) For 1, 2 and 4 bpp, the nlevels arg is used if a colormap
is made; otherwise, we take the most significant bits
from the src that will fit in the dest.
(4) For 8 bpp, the input pixs is quantized to nlevels.  The
dest quantized with that mapping, either through a colormap
table or directly with 8 bit values.
(5) Typically you should not use make a colormap for 1 bpp dest.
(6) This is not dithering.  Each pixel is treated independently.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThreshold8(*args)
    
    

    try:
        leptonica.pixRemoveColormapGeneral.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveColormapGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveColormapGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveColormapGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'ifnocmap')       

:param[in]    pixs:      any depth, with or without colormap
:param[in]    type:      REMOVE_CMAP_TO_BINARY,
REMOVE_CMAP_TO_GRAYSCALE,
REMOVE_CMAP_TO_FULL_COLOR,
REMOVE_CMAP_WITH_ALPHA,
REMOVE_CMAP_BASED_ON_SRC
:param[in]    ifnocmap:  L_CLONE, L_COPY
:returns:  pixd always a new pix; without colormap, or NULL on error

<pre>
Notes:
(1) Convenience function that allows choice between returning
a clone or a copy if pixs does not have a colormap.
(2) See pixRemoveColormap().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveColormapGeneral(*args)
    
    

    try:
        leptonica.pixRemoveColormap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRemoveColormap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveColormap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:   see restrictions below
:param[in]    type:   REMOVE_CMAP_TO_BINARY,
REMOVE_CMAP_TO_GRAYSCALE,
REMOVE_CMAP_TO_FULL_COLOR,
REMOVE_CMAP_WITH_ALPHA,
REMOVE_CMAP_BASED_ON_SRC
:returns:  pixd without colormap, or NULL on error

<pre>
Notes:
(1) If pixs does not have a colormap, a clone is returned.
(2) Otherwise, the input pixs is restricted to 1, 2, 4 or 8 bpp.
(3) Use REMOVE_CMAP_TO_BINARY only on 1 bpp pix.
(4) For grayscale conversion from RGB, use a weighted average
of RGB values, and always return an 8 bpp pix, regardless
of whether the input pixs depth is 2, 4 or 8 bpp.
(5) REMOVE_CMAP_TO_FULL_COLOR ignores the alpha component and
returns a 32 bpp pix with spp == 3 and the alpha bytes are 0.
(6) For REMOVE_CMAP_BASED_ON_SRC, if there is no color, this
returns either a 1 bpp or 8 bpp grayscale pix.
If there is color, this returns a 32 bpp pix, with either:
3 spp, if the alpha values are all 255 (opaque), or
4 spp (preserving the alpha), if any alpha values are not 255.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveColormap(*args)
    
    

    try:
        leptonica.pixAddGrayColormap8.argtypes = [ctypes.c_void_p]
        leptonica.pixAddGrayColormap8.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixAddGrayColormap8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddGrayColormap8(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   8 bpp
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If pixs has a colormap, this is a no-op.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddGrayColormap8(*args)
    
    

    try:
        leptonica.pixAddMinimalGrayColormap8.argtypes = [ctypes.c_void_p]
        leptonica.pixAddMinimalGrayColormap8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddMinimalGrayColormap8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddMinimalGrayColormap8(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   8 bpp
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a colormapped version of the input image
that has the same number of colormap entries as the
input image has unique gray levels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddMinimalGrayColormap8(*args)
    
    

    try:
        leptonica.pixConvertRGBToLuminance.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToLuminance.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToLuminance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToLuminance(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   32 bpp RGB
:returns:  8 bpp pix, or NULL on error

<pre>
Notes:
(1) Use a standard luminance conversion.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToLuminance(*args)
    
    

    try:
        leptonica.pixConvertRGBToGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixConvertRGBToGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       

:param[in]    pixs:           32 bpp RGB
:param[in]    rwt,: gwt, bwt  non-negative; these should add to 1.0,
or use 0.0 for default
:returns:  8 bpp pix, or NULL on error

<pre>
Notes:
(1) Use a weighted average of the RGB values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGray(*args)
    
    

    try:
        leptonica.pixConvertRGBToGrayFast.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertRGBToGrayFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGrayFast(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp RGB
:returns:  8 bpp pix, or NULL on error

<pre>
Notes:
(1) This function should be used if speed of conversion
is paramount, and the green channel can be used as
a fair representative of the RGB intensity.  It is
several times faster than pixConvertRGBToGray().
(2) To combine RGB to gray conversion with subsampling,
use pixScaleRGBToGrayFast() instead.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGrayFast(*args)
    
    

    try:
        leptonica.pixConvertRGBToGrayMinMax.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertRGBToGrayMinMax.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToGrayMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGrayMinMax(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:   32 bpp RGB
:param[in]    type:   L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF,
L_CHOOSE_MIN_BOOST, L_CHOOSE_MAX_BOOST
:returns:  8 bpp pix, or NULL on error

<pre>
Notes:
(1) This chooses various components or combinations of them,
from the three RGB sample values.  In addition to choosing
the min, max, and maxdiff (difference between max and min),
this also allows boosting the min and max about a reference
value.
(2) The default reference value for boosting the min and max
is 200.  This can be changed with l_setNeutralBoostVal()
(3) The result with L_CHOOSE_MAXDIFF is surprisingly sensitive
to a jpeg compression/decompression cycle with quality = 75.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGrayMinMax(*args)
    
    

    try:
        leptonica.pixConvertRGBToGraySatBoost.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertRGBToGraySatBoost.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToGraySatBoost not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGraySatBoost(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'refval')       

:param[in]    pixs:    32 bpp rgb
:param[in]    refval:  between 1 and 255; typ. less than 128
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) This returns the max component value, boosted by
the saturation. The maximum boost occurs where
the maximum component value is equal to some reference value.
This particular weighting is due to Dany Qumsiyeh.
(2) For gray pixels (zero saturation), this returns
the intensity of any component.
(3) For fully saturated pixels ('fullsat'), this rises linearly
with the max value and has a slope equal to 255 divided
by the reference value; for a max value greater than
the reference value, it is clipped to 255.
(4) For saturation values in between, the output is a linear
combination of (2) and (3), weighted by saturation.
It falls between these two curves, and does not exceed 255.
(5) This can be useful for distinguishing an object that has nonzero
saturation from a gray background.  For this, the refval
should be chosen near the expected value of the background,
to achieve maximum saturation boost there.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGraySatBoost(*args)
    
    

    try:
        leptonica.pixConvertRGBToGrayArb.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixConvertRGBToGrayArb.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToGrayArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToGrayArb(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rc')       
('l_float32', 'gc')       
('l_float32', 'bc')       

:param[in]    pixs:        32 bpp RGB
:param[in]    rc,: gc, bc  arithmetic factors; can be negative
:returns:  8 bpp pix, or NULL on error

<pre>
Notes:
(1) This converts to gray using an arbitrary linear combination
of the rgb color components.  It differs from pixConvertToGray(),
which uses only positive coefficients that sum to 1.
(2) The gray output values are clipped to 0 and 255.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToGrayArb(*args)
    
    

    try:
        leptonica.pixConvertRGBToBinaryArb.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertRGBToBinaryArb.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToBinaryArb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToBinaryArb(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rc')       
('l_float32', 'gc')       
('l_float32', 'bc')       
('l_int32', 'thresh')       
('l_int32', 'relation')       

:param[in]    pixs:        32 bpp RGB
:param[in]    rc,: gc, bc  arithmetic factors; can be negative
:param[in]    thresh:      binarization threshold
:param[in]    relation:    L_SELECT_IF_LT, L_SELECT_IF_GT
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:  1 bpp pix, or NULL on error

<pre>
Notes:
(1) This makes a 1 bpp mask from an RGB image, using an arbitrary
linear combination of the rgb color components, along with
a threshold and a selection choice of the gray value relative
to %thresh.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToBinaryArb(*args)
    
    

    try:
        leptonica.pixConvertGrayToColormap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertGrayToColormap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertGrayToColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToColormap(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    2, 4 or 8 bpp grayscale
:returns:  pixd 2, 4 or 8 bpp with colormap, or NULL on error

<pre>
Notes:
(1) This is a simple interface for adding a colormap to a
2, 4 or 8 bpp grayscale image without causing any
quantization.  There is some similarity to operations
in grayquant.c, such as pixThresholdOn8bpp(), where
the emphasis is on quantization with an arbitrary number
of levels, and a colormap is an option.
(2) Returns a copy if pixs already has a colormap.
(3) For 8 bpp src, this is a lossless transformation.
(4) For 2 and 4 bpp src, this generates a colormap that
assumes full coverage of the gray space, with equally spaced
levels: 4 levels for d = 2 and 16 levels for d = 4.
(5) In all cases, the depth of the dest is the same as the src.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToColormap(*args)
    
    

    try:
        leptonica.pixConvertGrayToColormap8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertGrayToColormap8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertGrayToColormap8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToColormap8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'mindepth')       

:param[in]    pixs:       8 bpp grayscale
:param[in]    mindepth:   of pixd; valid values are 2, 4 and 8
:returns:  pixd 2, 4 or 8 bpp with colormap, or NULL on error

<pre>
Notes:
(1) Returns a copy if pixs already has a colormap.
(2) This is a lossless transformation; there is no quantization.
We compute the number of different gray values in pixs,
and construct a colormap that has exactly these values.
(3) 'mindepth' is the minimum depth of pixd.  If mindepth == 8,
pixd will always be 8 bpp.  Let the number of different
gray values in pixs be ngray.  If mindepth == 4, we attempt
to save pixd as a 4 bpp image, but if ngray > 16,
pixd must be 8 bpp.  Likewise, if mindepth == 2,
the depth of pixd will be 2 if ngray <= 4 and 4 if ngray > 4
but <= 16.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToColormap8(*args)
    
    

    try:
        leptonica.pixColorizeGray.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_int32]
        leptonica.pixColorizeGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorizeGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorizeGray(*args):
        """
        ('PIX', '*pixs')       
('l_uint32', 'color')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      8 bpp gray; 2, 4 or 8 bpp colormapped
:param[in]    color:     32 bit rgba pixel
:param[in]    cmapflag:  1 for result to have colormap; 0 for RGB
:returns:  pixd 8 bpp colormapped or 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This applies the specific color to the grayscale image.
(2) If pixs already has a colormap, it is removed to gray
before colorizing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorizeGray(*args)
    
    

    try:
        leptonica.pixConvertRGBToColormap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertRGBToColormap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertRGBToColormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertRGBToColormap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'ditherflag')       

:param[in]    pixs:       32 bpp rgb
:param[in]    ditherflag:  1 to dither, 0 otherwise
:returns:  pixd 2, 4 or 8 bpp with colormap, or NULL on error

<pre>
Notes:
(1) This function has two relatively simple modes of color
quantization:
(a) If the image is made orthographically and has not more
than 256 'colors' at the level 4 octcube leaves,
it is quantized nearly exactly.  The ditherflag
is ignored.
(b) Most natural images have more than 256 different colors;
in that case we use adaptive octree quantization,
with dithering if requested.
(2) If there are not more than 256 occupied level 4 octcubes,
the color in the colormap that represents all pixels in
one of those octcubes is given by the first pixel that
falls into that octcube.
(3) Dithering gives better visual results on images where
there is a color wash (a slow variation of color), but it
is about twice as slow and results in significantly larger
files when losslessly compressed (e.g., into png).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertRGBToColormap(*args)
    
    

    try:
        leptonica.pixConvertCmapTo1.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertCmapTo1.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertCmapTo1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertCmapTo1(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   cmapped
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This is an extreme color quantizer.  It decides which
colors map to FG (black) and which to BG (white).
(2) This uses two heuristics to make the decision:
(a) colors similar to each other are likely to be in the same class
(b) there is usually much less FG than BG.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertCmapTo1(*args)
    
    

    try:
        leptonica.pixQuantizeIfFewColors.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixQuantizeIfFewColors.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixQuantizeIfFewColors not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuantizeIfFewColors(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxcolors')       
('l_int32', 'mingraycolors')       
('l_int32', 'octlevel')       
('PIX', '**ppixd')       

:param[in]    pixs:           8 bpp gray or 32 bpp rgb
:param[in]    maxcolors:      max number of colors allowed to be returned
from pixColorsForQuantization();
use 0 for default
:param[in]    mingraycolors:  min number of gray levels that a grayscale
image is quantized to; use 0 for default
:param[in]    octlevel:       for octcube quantization: 3 or 4
:param[out]   ppixd:          2,4 or 8 bpp quantized; null if too many colors
:returns:  0 if OK, 1 on error or if pixs can't be quantized into
a small number of colors.

<pre>
Notes:
(1) This is a wrapper that tests if the pix can be quantized
with good quality using a small number of colors.  If so,
it does the quantization, defining a colormap and using
pixels whose value is an index into the colormap.
(2) If the image has color, it is quantized with 8 bpp pixels.
If the image is essentially grayscale, the pixels are
either 4 or 8 bpp, depending on the size of the required
colormap.
(3) %octlevel = 4 generates a larger colormap and larger
compressed image than %octlevel = 3.  If image quality is
important, you should use %octlevel = 4.
(4) If the image already has a colormap, it returns a clone.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuantizeIfFewColors(*args)
    
    

    try:
        leptonica.pixConvert16To8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert16To8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert16To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert16To8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:     16 bpp
:param[in]    type:     L_LS_BYTE, L_MS_BYTE, L_AUTO_BYTE, L_CLIP_TO_FF
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) With L_AUTO_BYTE, if the max pixel value is greater than 255,
use the MSB; otherwise, use the LSB.
(2) With L_CLIP_TO_FF, use min(pixel-value, 0xff) for each
16-bit src pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert16To8(*args)
    
    

    try:
        leptonica.pixConvertGrayToFalseColor.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixConvertGrayToFalseColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertGrayToFalseColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToFalseColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'gamma')       

:param[in]    pixs:    8 or 16 bpp grayscale
:param[in]    gamma:   (factor) 0.0 or 1.0 for default; > 1.0 for brighter;
2.0 is quite nice
:returns:  pixd 8 bpp with colormap, or NULL on error

<pre>
Notes:
(1) For 8 bpp input, this simply adds a colormap to the input image.
(2) For 16 bpp input, it first converts to 8 bpp, using the MSB,
and then adds the colormap.
(3) The colormap is modeled after the Matlab "jet" configuration.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToFalseColor(*args)
    
    

    try:
        leptonica.pixUnpackBinary.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUnpackBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnpackBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnpackBinary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'depth')       
('l_int32', 'invert')       

:param[in]    pixs:     1 bpp
:param[in]    depth:    of destination: 2, 4, 8, 16 or 32 bpp
:param[in]    invert:   0:  binary 0 --> grayscale 0
binary 1 --> grayscale 0xff...
1:  binary 0 --> grayscale 0xff...
binary 1 --> grayscale 0
:returns:  pixd 2, 4, 8, 16 or 32 bpp, or NULL on error

<pre>
Notes:
(1) This function calls special cases of pixConvert1To*(),
for 2, 4, 8, 16 and 32 bpp destinations.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnpackBinary(*args)
    
    

    try:
        leptonica.pixConvert1To16.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint16, ctypes.c_uint16]
        leptonica.pixConvert1To16.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To16(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint16', 'val0')       
('l_uint16', 'val1')       

:param[in]    pixd:    [optional] 16 bpp, can be null
:param[in]    pixs:    1 bpp
:param[in]    val0:    16 bit value to be used for 0s in pixs
:param[in]    val1:    16 bit value to be used for 1s in pixs
:returns:  pixd 16 bpp

<pre>
Notes:
(1) If pixd is null, a new pix is made.
(2) If pixd is not null, it must be of equal width and height
as pixs.  It is always returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To16(*args)
    
    

    try:
        leptonica.pixConvert1To32.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
        leptonica.pixConvert1To32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To32(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint32', 'val0')       
('l_uint32', 'val1')       

:param[in]    pixd:    [optional] 32 bpp, can be null
:param[in]    pixs:    1 bpp
:param[in]    val0:    32 bit value to be used for 0s in pixs
:param[in]    val1:    32 bit value to be used for 1s in pixs
:returns:  pixd 32 bpp

<pre>
Notes:
(1) If pixd is null, a new pix is made.
(2) If pixd is not null, it must be of equal width and height
as pixs.  It is always returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To32(*args)
    
    

    try:
        leptonica.pixConvert1To2Cmap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert1To2Cmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To2Cmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To2Cmap(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1 bpp
:returns:  pixd 2 bpp, cmapped

<pre>
Notes:
(1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To2Cmap(*args)
    
    

    try:
        leptonica.pixConvert1To2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvert1To2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To2(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'val0')       
('l_int32', 'val1')       

:param[in]    pixd:    [optional] 2 bpp, can be null
:param[in]    pixs:    1 bpp
:param[in]    val0:    2 bit value to be used for 0s in pixs
:param[in]    val1:    2 bit value to be used for 1s in pixs
:returns:  pixd 2 bpp

<pre>
Notes:
(1) If pixd is null, a new pix is made.
(2) If pixd is not null, it must be of equal width and height
as pixs.  It is always returned.
(3) A simple unpacking might use val0 = 0 and val1 = 3.
(4) If you want a colormapped pixd, use pixConvert1To2Cmap().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To2(*args)
    
    

    try:
        leptonica.pixConvert1To4Cmap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert1To4Cmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To4Cmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To4Cmap(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1 bpp
:returns:  pixd 4 bpp, cmapped

<pre>
Notes:
(1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To4Cmap(*args)
    
    

    try:
        leptonica.pixConvert1To4.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvert1To4.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To4(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'val0')       
('l_int32', 'val1')       

:param[in]    pixd:    [optional] 4 bpp, can be null
:param[in]    pixs:    1 bpp
:param[in]    val0:    4 bit value to be used for 0s in pixs
:param[in]    val1:    4 bit value to be used for 1s in pixs
:returns:  pixd 4 bpp

<pre>
Notes:
(1) If pixd is null, a new pix is made.
(2) If pixd is not null, it must be of equal width and height
as pixs.  It is always returned.
(3) A simple unpacking might use val0 = 0 and val1 = 15, or v.v.
(4) If you want a colormapped pixd, use pixConvert1To4Cmap().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To4(*args)
    
    

    try:
        leptonica.pixConvert1To8Cmap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert1To8Cmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To8Cmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To8Cmap(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1 bpp
:returns:  pixd 8 bpp, cmapped

<pre>
Notes:
(1) Input 0 is mapped to (255, 255, 255); 1 is mapped to (0, 0, 0)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To8Cmap(*args)
    
    

    try:
        leptonica.pixConvert1To8.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte]
        leptonica.pixConvert1To8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert1To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert1To8(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_uint8', 'val0')       
('l_uint8', 'val1')       

:param[in]    pixd:    [optional] 8 bpp, can be null
:param[in]    pixs:    1 bpp
:param[in]    val0:    8 bit value to be used for 0s in pixs
:param[in]    val1:    8 bit value to be used for 1s in pixs
:returns:  pixd 8 bpp

<pre>
Notes:
(1) If pixd is null, a new pix is made.
(2) If pixd is not null, it must be of equal width and height
as pixs.  It is always returned.
(3) A simple unpacking might use val0 = 0 and val1 = 255, or v.v.
(4) To have a colormap associated with the 8 bpp pixd,
use pixConvert1To8Cmap().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert1To8(*args)
    
    

    try:
        leptonica.pixConvert2To8.argtypes = [ctypes.c_void_p, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_ubyte, ctypes.c_int32]
        leptonica.pixConvert2To8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert2To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert2To8(*args):
        """
        ('PIX', '*pixs')       
('l_uint8', 'val0')       
('l_uint8', 'val1')       
('l_uint8', 'val2')       
('l_uint8', 'val3')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      2 bpp
:param[in]    val0:      8 bit value to be used for 00 in pixs
:param[in]    val1:      8 bit value to be used for 01 in pixs
:param[in]    val2:      8 bit value to be used for 10 in pixs
:param[in]    val3:      8 bit value to be used for 11 in pixs
:param[in]    cmapflag:  TRUE if pixd is to have a colormap; FALSE otherwise
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
~ A simple unpacking might use val0 = 0,
val1 = 85 (0x55), val2 = 170 (0xaa), val3 = 255.
~ If cmapflag is TRUE:
~ The 8 bpp image is made with a colormap.
~ If pixs has a colormap, the input values are ignored and
the 8 bpp image is made using the colormap
~ If pixs does not have a colormap, the input values are
used to build the colormap.
~ If cmapflag is FALSE:
~ The 8 bpp image is made without a colormap.
~ If pixs has a colormap, the input values are ignored,
the colormap is removed, and the values stored in the 8 bpp
image are from the colormap.
~ If pixs does not have a colormap, the input values are
used to populate the 8 bpp image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert2To8(*args)
    
    

    try:
        leptonica.pixConvert4To8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert4To8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert4To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert4To8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      4 bpp
:param[in]    cmapflag:  TRUE if pixd is to have a colormap; FALSE otherwise
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
~ If cmapflag is TRUE:
~ pixd is made with a colormap.
~ If pixs has a colormap, it is copied and the colormap
index values are placed in pixd.
~ If pixs does not have a colormap, a colormap with linear
trc is built and the pixel values in pixs are placed in
pixd as colormap index values.
~ If cmapflag is FALSE:
~ pixd is made without a colormap.
~ If pixs has a colormap, it is removed and the values stored
in pixd are from the colormap (converted to gray).
~ If pixs does not have a colormap, the pixel values in pixs
are used, with shift replication, to populate pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert4To8(*args)
    
    

    try:
        leptonica.pixConvert8To16.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert8To16.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert8To16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert8To16(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'leftshift')       

:param[in]    pixs:       8 bpp; colormap removed to gray
:param[in]    leftshift:  number of bits: 0 is no shift;
8 replicates in MSB and LSB of dest
:returns:  pixd 16 bpp, or NULL on error

<pre>
Notes:
(1) For left shift of 8, the 8 bit value is replicated in both
the MSB and the LSB of the pixels in pixd.  That way, we get
proportional mapping, with a correct map from 8 bpp white
(0xff) to 16 bpp white (0xffff).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert8To16(*args)
    
    

    try:
        leptonica.pixConvertTo2.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo2(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   1, 2, 4, 8, 32 bpp; colormap OK but will be removed
:returns:  pixd   2 bpp, or NULL on error

<pre>
Notes:
(1) This is a top-level function, with simple default values
used in pixConvertTo8() if unpacking is necessary.
(2) Any existing colormap is removed; the result is always gray.
(3) If the input image has 2 bpp and no colormap, the operation is
lossless and a copy is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo2(*args)
    
    

    try:
        leptonica.pixConvert8To2.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert8To2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert8To2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert8To2(*args):
        """
        ('PIX', '*pix')       

:param[in]     pix:     8 bpp; colormap OK
:returns:  pixd  2 bpp, or NULL on error

<pre>
Notes:
(1) Any existing colormap is removed to gray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert8To2(*args)
    
    

    try:
        leptonica.pixConvertTo4.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo4.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo4(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   1, 2, 4, 8, 32 bpp; colormap OK but will be removed
:returns:  pixd   4 bpp, or NULL on error

<pre>
Notes:
(1) This is a top-level function, with simple default values
used in pixConvertTo8() if unpacking is necessary.
(2) Any existing colormap is removed; the result is always gray.
(3) If the input image has 4 bpp and no colormap, the operation is
lossless and a copy is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo4(*args)
    
    

    try:
        leptonica.pixConvert8To4.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert8To4.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert8To4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert8To4(*args):
        """
        ('PIX', '*pix')       

:param[in]     pix:     8 bpp; colormap OK
:returns:  pixd  4 bpp, or NULL on error

<pre>
Notes:
(1) Any existing colormap is removed to gray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert8To4(*args)
    
    

    try:
        leptonica.pixConvertTo1Adaptive.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo1Adaptive.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo1Adaptive not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo1Adaptive(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:       1, 2, 4, 8, 16 or 32 bpp
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This is a top-level function, that uses default values for
adaptive thresholding, if necessary.  Otherwise, it is the same as
pixConvertTo1(), which uses a global threshold for binarization.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo1Adaptive(*args)
    
    

    try:
        leptonica.pixConvertTo1.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo1.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo1(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'threshold')       

:param[in]    pixs:       1, 2, 4, 8, 16 or 32 bpp
:param[in]    threshold:  for final binarization, relative to 8 bpp
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This is a top-level function, with simple default values
used in pixConvertTo8() if unpacking is necessary.
(2) Any existing colormap is removed.
(3) If the input image has 1 bpp and no colormap, the operation is
lossless and a copy is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo1(*args)
    
    

    try:
        leptonica.pixConvertTo1BySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertTo1BySampling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo1BySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo1BySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'threshold')       

:param[in]    pixs:       1, 2, 4, 8, 16 or 32 bpp
:param[in]    factor:     submsampling factor; integer >= 1
:param[in]    threshold:  for final binarization, relative to 8 bpp
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This is a quick and dirty, top-level converter.
(2) See pixConvertTo1() for default values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo1BySampling(*args)
    
    

    try:
        leptonica.pixConvertTo8.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      1, 2, 4, 8, 16 or 32 bpp
:param[in]    cmapflag:  TRUE if pixd is to have a colormap; FALSE otherwise
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) This is a top-level function, with simple default values
for unpacking.
(2) The result, pixd, is made with a colormap if specified.
It is always a new image -- never a clone.  For example,
if d == 8, and cmapflag matches the existence of a cmap
in pixs, the operation is lossless and it returns a copy.
(3) The default values used are:
~ 1 bpp: val0 = 255, val1 = 0
~ 2 bpp: 4 bpp:  even increments over dynamic range
~ 8 bpp: lossless if cmap matches cmapflag
~ 16 bpp: use most significant byte
(4) If 32 bpp RGB, this is converted to gray.  If you want
to do color quantization, you must specify the type
explicitly, using the color quantization code.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8(*args)
    
    

    try:
        leptonica.pixConvertTo8BySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertTo8BySampling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo8BySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8BySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'cmapflag')       

:param[in]    pixs:      1, 2, 4, 8, 16 or 32 bpp
:param[in]    factor:    submsampling factor; integer >= 1
:param[in]    cmapflag:  TRUE if pixd is to have a colormap; FALSE otherwise
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) This is a fast, quick/dirty, top-level converter.
(2) See pixConvertTo8() for default values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8BySampling(*args)
    
    

    try:
        leptonica.pixConvertTo8Colormap.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo8Colormap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo8Colormap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8Colormap(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'dither')       

:param[in]    pixs:    1, 2, 4, 8, 16 or 32 bpp
:param[in]    dither:  1 to dither if necessary; 0 otherwise
:returns:  pixd 8 bpp, cmapped, or NULL on error

<pre>
Notes:
(1) This is a top-level function, with simple default values
for unpacking.
(2) The result, pixd, is always made with a colormap.
(3) If d == 8, the operation is lossless and it returns a copy.
(4) The default values used for increasing depth are:
~ 1 bpp: val0 = 255, val1 = 0
~ 2 bpp: 4 bpp:  even increments over dynamic range
(5) For 16 bpp, use the most significant byte.
(6) For 32 bpp RGB, use octcube quantization with optional dithering.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8Colormap(*args)
    
    

    try:
        leptonica.pixConvertTo16.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo16.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo16(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1, 8 bpp
:returns:  pixd 16 bpp, or NULL on error

Usage: Top-level function, with simple default values for unpacking.
1 bpp:  val0 = 0xffff, val1 = 0
8 bpp:  replicates the 8 bit value in both the MSB and LSB
of the 16 bit pixel.


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo16(*args)
    
    

    try:
        leptonica.pixConvertTo32.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertTo32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo32(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1, 2, 4, 8, 16, 24 or 32 bpp
:returns:  pixd 32 bpp, or NULL on error

Usage: Top-level function, with simple default values for unpacking.
1 bpp:  val0 = 255, val1 = 0
and then replication into R, G and B components
2 bpp:  if colormapped, use the colormap values; otherwise,
use val0 = 0, val1 = 0x55, val2 = 0xaa, val3 = 255
and replicate gray into R, G and B components
4 bpp:  if colormapped, use the colormap values; otherwise,
replicate 2 nybs into a byte, and then into R,G,B components
8 bpp:  if colormapped, use the colormap values; otherwise,
replicate gray values into R, G and B components
16 bpp: replicate MSB into R, G and B components
24 bpp: unpack the pixels, maintaining word alignment on each scanline
32 bpp: makes a copy

<pre>
Notes:
(1) Never returns a clone of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo32(*args)
    
    

    try:
        leptonica.pixConvertTo32BySampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertTo32BySampling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo32BySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo32BySampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]    pixs:    1, 2, 4, 8, 16, 24 or 32 bpp
:param[in]    factor:  submsampling factor; integer >= 1
:returns:  pixd 32 bpp, or NULL on error

<pre>
Notes:
(1) This is a fast, quick/dirty, top-level converter.
(2) See pixConvertTo32() for default values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo32BySampling(*args)
    
    

    try:
        leptonica.pixConvert8To32.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert8To32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert8To32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert8To32(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    8 bpp
:returns:  32 bpp rgb pix, or NULL on error

<pre>
Notes:
(1) If there is no colormap, replicates the gray value
into the 3 MSB of the dest pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert8To32(*args)
    
    

    try:
        leptonica.pixConvertTo8Or32.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvertTo8Or32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertTo8Or32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertTo8Or32(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'copyflag')       
('l_int32', 'warnflag')       

:param[in]    pixs:      1, 2, 4, 8, 16, with or without colormap;
or 32 bpp rgb
:param[in]    copyflag:  L_CLONE or L_COPY
:param[in]    warnflag:  1 to issue warning if colormap is removed; else 0
:returns:  pixd 8 bpp grayscale or 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) If there is a colormap, the colormap is removed to 8 or 32 bpp,
depending on whether the colors in the colormap are all gray.
(2) If the input is either rgb or 8 bpp without a colormap,
this returns either a clone or a copy, depending on %copyflag.
(3) Otherwise, the pix is converted to 8 bpp grayscale.
In all cases, pixd does not have a colormap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertTo8Or32(*args)
    
    

    try:
        leptonica.pixConvert24To32.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert24To32.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert24To32 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert24To32(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    24 bpp rgb
:returns:  pixd 32 bpp rgb, or NULL on error

<pre>
Notes:
(1) 24 bpp rgb pix are not supported in leptonica, except for a small
number of formatted write operations.  The data is a byte array,
with pixels in order r,g,b, and padded to 32 bit boundaries
in each line.
(2) Because 24 bpp rgb pix are conveniently generated by programs
such as xpdf (which has SplashBitmaps that store the raster
data in consecutive 24-bit rgb pixels), it is useful to provide
24 bpp pix that simply incorporate that data.  The only things
we can do with these are:
(a) write them to file in png, jpeg, tiff and pnm
(b) interconvert between 24 and 32 bpp in memory (for testing).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert24To32(*args)
    
    

    try:
        leptonica.pixConvert32To24.argtypes = [ctypes.c_void_p]
        leptonica.pixConvert32To24.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert32To24 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert32To24(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp rgb
:returns:  pixd 24 bpp rgb, or NULL on error

<pre>
Notes:
(1) See pixconvert24To32().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert32To24(*args)
    
    

    try:
        leptonica.pixConvert32To16.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvert32To16.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert32To16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert32To16(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:   32 bpp, single component
:param[in]    type:   L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF
:returns:  pixd 16 bpp , or NULL on error

<pre>
Notes:
(1) The data in pixs is typically used for labelling.
It is an array of l_uint32 values, not rgb or rgba.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert32To16(*args)
    
    

    try:
        leptonica.pixConvert32To8.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConvert32To8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvert32To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvert32To8(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type16')       
('l_int32', 'type8')       

:param[in]    pixs:    32 bpp, single component
:param[in]    type16:  L_LS_TWO_BYTES, L_MS_TWO_BYTES, L_CLIP_TO_FFFF
:param[in]    type8:   L_LS_BYTE, L_MS_BYTE, L_CLIP_TO_FF
:returns:  pixd 8 bpp, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvert32To8(*args)
    
    

    try:
        leptonica.pixRemoveAlpha.argtypes = [ctypes.c_void_p]
        leptonica.pixRemoveAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveAlpha(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:   any depth
:returns:  pixd        if 32 bpp rgba, pixs blended over a white background;
a clone of pixs otherwise, and NULL on error

<pre>
Notes:
(1) This is a wrapper on pixAlphaBlendUniform()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveAlpha(*args)
    
    

    try:
        leptonica.pixAddAlphaTo1bpp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixAddAlphaTo1bpp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixAddAlphaTo1bpp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixAddAlphaTo1bpp(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       

:param[in]    pixd:    [optional] 1 bpp, can be null or equal to pixs
:param[in]    pixs:    1 bpp
:returns:  pixd 1 bpp with colormap and non-opaque alpha,
or NULL on error

<pre>
Notes:
(1) We don't use 1 bpp colormapped images with alpha in leptonica,
but we support generating them (here), writing to png, and reading
the png.  On reading, they are converted to 32 bpp RGBA.
(2) The background (0) pixels in pixs become fully transparent, and the
foreground (1) pixels are fully opaque.  Thus, pixd is a 1 bpp
representation of a stencil, that can be used to paint over pixels
of a backing image that are masked by the foreground in pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixAddAlphaTo1bpp(*args)
    
    

    try:
        leptonica.pixConvertLossless.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertLossless.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertLossless not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertLossless(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'd')       

:param[in]    pixs:    1, 2, 4, 8 bpp, not cmapped
:param[in]    d:       destination depth: 2, 4 or 8
:returns:  pixd 2, 4 or 8 bpp, or NULL on error

<pre>
Notes:
(1) This is a lossless unpacking (depth-increasing)
conversion.  If ds is the depth of pixs, then
~ if d < ds, returns NULL
~ if d == ds, returns a copy
~ if d > ds, does the unpacking conversion
(2) If pixs has a colormap, this is an error.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertLossless(*args)
    
    

    try:
        leptonica.pixConvertForPSWrap.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertForPSWrap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertForPSWrap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertForPSWrap(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1, 2, 4, 8, 16, 32 bpp
:returns:  pixd    1, 8, or 32 bpp, or NULL on error

<pre>
Notes:
(1) For wrapping in PostScript, we convert pixs to
1 bpp, 8 bpp (gray) and 32 bpp (RGB color).
(2) Colormaps are removed.  For pixs with colormaps, the
images are converted to either 8 bpp gray or 32 bpp
RGB, depending on whether the colormap has color content.
(3) Images without colormaps, that are not 1 bpp or 32 bpp,
are converted to 8 bpp gray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertForPSWrap(*args)
    
    

    try:
        leptonica.pixConvertToSubpixelRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConvertToSubpixelRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToSubpixelRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToSubpixelRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'order')       

:param[in]    pixs:            8 bpp grayscale, 32 bpp rgb, or colormapped
:param[in]    scalex,: scaley  anisotropic scaling permitted between
source and destination
:param[in]    order:           of subpixel rgb color components in
composition of pixd:
L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,
L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR
:returns:  pixd 32 bpp, or NULL on error

<pre>
Notes:
(1) If pixs has a colormap, it is removed based on its contents
to either 8 bpp gray or rgb.
(2) For horizontal subpixel splitting, the input image
is rescaled by %scaley vertically and by 3.0 times
%scalex horizontally.  Then each horizontal triplet
of pixels is mapped back to a single rgb pixel, with the
r, g and b values being assigned based on the pixel triplet.
For gray triplets, the r, g, and b values are set equal to
the three gray values.  For color triplets, the r, g and b
values are set equal to the components from the appropriate
subpixel.  Vertical subpixel splitting is handled similarly.
(3) See pixConvertGrayToSubpixelRGB() and
pixConvertColorToSubpixelRGB() for further details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToSubpixelRGB(*args)
    
    

    try:
        leptonica.pixConvertGrayToSubpixelRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConvertGrayToSubpixelRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertGrayToSubpixelRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertGrayToSubpixelRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'order')       

:param[in]    pixs:            8 bpp or colormapped
:param[in]    scalex,: scaley
:param[in]    order:           of subpixel rgb color components in
composition of pixd:
L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,
L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR
:returns:  pixd 32 bpp, or NULL on error

<pre>
Notes:
(1) If pixs has a colormap, it is removed to 8 bpp.
(2) For horizontal subpixel splitting, the input gray image
is rescaled by %scaley vertically and by 3.0 times
%scalex horizontally.  Then each horizontal triplet
of pixels is mapped back to a single rgb pixel, with the
r, g and b values being assigned from the triplet of gray values.
Similar operations are used for vertical subpixel splitting.
(3) This is a form of subpixel rendering that tends to give the
resulting text a sharper and somewhat chromatic display.
For horizontal subpixel splitting, the observable difference
between %order=L_SUBPIXEL_ORDER_RGB and
%order=L_SUBPIXEL_ORDER_BGR is reduced by optical diffusers
in the display that make the pixel color appear to emerge
from the entire pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertGrayToSubpixelRGB(*args)
    
    

    try:
        leptonica.pixConvertColorToSubpixelRGB.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConvertColorToSubpixelRGB.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertColorToSubpixelRGB not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertColorToSubpixelRGB(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'order')       

:param[in]    pixs:            32 bpp or colormapped
:param[in]    scalex,: scaley
:param[in]    order:           of subpixel rgb color components in
composition of pixd:
L_SUBPIXEL_ORDER_RGB, L_SUBPIXEL_ORDER_BGR,
L_SUBPIXEL_ORDER_VRGB, L_SUBPIXEL_ORDER_VBGR
:returns:  pixd 32 bpp, or NULL on error

<pre>
Notes:
(1) If pixs has a colormap, it is removed to 32 bpp rgb.
If the colormap has no color, pixConvertGrayToSubpixelRGB()
should be called instead, because it will give the same result
more efficiently.  The function pixConvertToSubpixelRGB()
will do the best thing for all cases.
(2) For horizontal subpixel splitting, the input rgb image
is rescaled by %scaley vertically and by 3.0 times
%scalex horizontally.  Then for each horizontal triplet
of pixels, the r component of the final pixel is selected
from the r component of the appropriate pixel in the triplet,
and likewise for g and b.  Vertical subpixel splitting is
handled similarly.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertColorToSubpixelRGB(*args)
    
    

    try:
        leptonica.l_setNeutralBoostVal.argtypes = [ctypes.c_int32]
        leptonica.l_setNeutralBoostVal.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_setNeutralBoostVal not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_setNeutralBoostVal(*args):
        """
        ('l_int32', 'val')       

:param[in]    val:    between 1 and 255; typical value is 180
:returns:  void

<pre>
Notes:
(1) This raises or lowers the selected min or max RGB component value,
depending on if that component is above or below this value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_setNeutralBoostVal(*args)
    




class boxbasic(object):
    """<pre>

Basic 'class' functions for box, boxa and boxaa,
including accessors and serialization.

Box creation, copy, clone, destruction
BOX      *boxCreate()
BOX      *boxCreateValid()
BOX      *boxCopy()
BOX      *boxClone()
void      boxDestroy()

Box accessors
l_int32   boxGetGeometry()
l_int32   boxSetGeometry()
l_int32   boxGetSideLocations()
l_int32   boxSetSideLocations()
l_int32   boxGetRefcount()
l_int32   boxChangeRefcount()
l_int32   boxIsValid()

Boxa creation, copy, destruction
BOXA     *boxaCreate()
BOXA     *boxaCopy()
void      boxaDestroy()

Boxa array extension
l_int32   boxaAddBox()
l_int32   boxaExtendArray()
l_int32   boxaExtendArrayToSize()

Boxa accessors
l_int32   boxaGetCount()
l_int32   boxaGetValidCount()
BOX      *boxaGetBox()
BOX      *boxaGetValidBox()
NUMA     *boxaFindInvalidBoxes()
l_int32   boxaGetBoxGeometry()
l_int32   boxaIsFull()

Boxa array modifiers
l_int32   boxaReplaceBox()
l_int32   boxaInsertBox()
l_int32   boxaRemoveBox()
l_int32   boxaRemoveBoxAndSave()
BOXA     *boxaSaveValid()
l_int32   boxaInitFull()
l_int32   boxaClear()

Boxaa creation, copy, destruction
BOXAA    *boxaaCreate()
BOXAA    *boxaaCopy()
void      boxaaDestroy()

Boxaa array extension
l_int32   boxaaAddBoxa()
l_int32   boxaaExtendArray()
l_int32   boxaaExtendArrayToSize()

Boxaa accessors
l_int32   boxaaGetCount()
l_int32   boxaaGetBoxCount()
BOXA     *boxaaGetBoxa()
BOX      *boxaaGetBox()

Boxaa array modifiers
l_int32   boxaaInitFull()
l_int32   boxaaExtendWithInit()
l_int32   boxaaReplaceBoxa()
l_int32   boxaaInsertBoxa()
l_int32   boxaaRemoveBoxa()
l_int32   boxaaAddBox()

Boxaa serialized I/O
BOXAA    *boxaaReadFromFiles()
BOXAA    *boxaaRead()
BOXAA    *boxaaReadStream()
BOXAA    *boxaaReadMem()
l_int32   boxaaWrite()
l_int32   boxaaWriteStream()
l_int32   boxaaWriteMem()

Boxa serialized I/O
BOXA     *boxaRead()
BOXA     *boxaReadStream()
BOXA     *boxaReadMem()
l_int32   boxaWriteDebug()
l_int32   boxaWrite()
l_int32   boxaWriteStream()
l_int32   boxaWriteStderr()
l_int32   boxaWriteMem()

Box print (for debug)
l_int32   boxPrintStreamInfo()

Most functions use only valid boxes, which are boxes that have both
width and height > 0.  However, a few functions, such as
boxaGetMedianVals() do not assume that all boxes are valid.  For any
function that can use a boxa with invalid boxes, it is convenient
to use these accessors:
boxaGetValidCount()   :  count of valid boxes
boxaGetValidBox()     :  returns NULL for invalid boxes
</pre>




"""
    
    try:
        leptonica.boxCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxCreate.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCreate(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    x,: y, w, h
:returns:  box, or NULL on error

<pre>
Notes:
(1) This clips the box to the +quad.  If no part of the
box is in the +quad, this returns NULL.
(2) We allow you to make a box with w = 0 and/or h = 0.
This does not represent a valid region, but it is useful
as a placeholder in a boxa for which the index of the
box in the boxa is important.  This is an atypical
situation; usually you want to put only valid boxes with
nonzero width and height in a boxa.  If you have a boxa
with invalid boxes, the accessor boxaGetValidBox()
will return NULL on each invalid box.
(3) If you want to create only valid boxes, use boxCreateValid(),
which returns NULL if either w or h is 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxCreate(*args)
    
    

    try:
        leptonica.boxCreateValid.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxCreateValid.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxCreateValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCreateValid(*args):
        """
        ('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    x,: y, w, h
:returns:  box, or NULL on error

<pre>
Notes:
(1) This returns NULL if either w = 0 or h = 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxCreateValid(*args)
    
    

    try:
        leptonica.boxCopy.argtypes = [ctypes.c_void_p]
        leptonica.boxCopy.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCopy(*args):
        """
        ('BOX', '*box')       

:param[in]    box:
:returns:  copy of box, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxCopy(*args)
    
    

    try:
        leptonica.boxClone.argtypes = [ctypes.c_void_p]
        leptonica.boxClone.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxClone(*args):
        """
        ('BOX', '*box')       

:param[in]    box:
:returns:  ptr to same box, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxClone(*args)
    
    

    try:
        leptonica.boxDestroy.argtypes = [ctypes.c_void_p]
        leptonica.boxDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function boxDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxDestroy(*args):
        """
        ('BOX', '**pbox')       

:param[in,out]   pbox:     will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the box.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxDestroy(*args)
    
    

    try:
        leptonica.boxGetGeometry.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxGetGeometry.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxGetGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetGeometry(*args):
        """
        ('BOX', '*box')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    box:
:param[out]   px,: py, pw, ph [optional]  each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetGeometry(*args)
    
    

    try:
        leptonica.boxSetGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxSetGeometry.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxSetGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSetGeometry(*args):
        """
        ('BOX', '*box')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    box:
:param[in]    x,: y, w, h     [optional] use -1 to leave unchanged
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxSetGeometry(*args)
    
    

    try:
        leptonica.boxGetSideLocations.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxGetSideLocations.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxGetSideLocations not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetSideLocations(*args):
        """
        ('BOX', '*box')       
('l_int32', '*pl')       
('l_int32', '*pr')       
('l_int32', '*pt')       
('l_int32', '*pb')       

:param[in]    box:
:param[out]   pl,: pt, pr, pb     [optional] each can be null
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) All returned values are within the box.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetSideLocations(*args)
    
    

    try:
        leptonica.boxSetSideLocations.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxSetSideLocations.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxSetSideLocations not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSetSideLocations(*args):
        """
        ('BOX', '*box')       
('l_int32', 'l')       
('l_int32', 'r')       
('l_int32', 't')       
('l_int32', 'b')       

:param[in]    box:
:param[in]    l,: r, t, b     [optional] use -1 to leave unchanged
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxSetSideLocations(*args)
    
    

    try:
        leptonica.boxGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.boxGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function boxGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetRefcount(*args):
        """
        ('BOX', '*box')       

:param[in]     box:
:returns:   refcount


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetRefcount(*args)
    
    

    try:
        leptonica.boxChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxChangeRefcount(*args):
        """
        ('BOX', '*box')       
('l_int32', 'delta')       

:param[in]     box: ptr to box
:param[in]     delta: adjustment, usually -1 or 1
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxChangeRefcount(*args)
    
    

    try:
        leptonica.boxIsValid.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxIsValid.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxIsValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxIsValid(*args):
        """
        ('BOX', '*box')       
('l_int32', '*pvalid')       

:param[in]    box:
:param[out]   pvalid:    1 if valid; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxIsValid(*args)
    
    

    try:
        leptonica.boxaCreate.argtypes = [ctypes.c_int32]
        leptonica.boxaCreate.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    initial number of ptrs; 0 for default
:returns:  boxa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCreate(*args)
    
    

    try:
        leptonica.boxaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaCopy.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCopy(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'copyflag')       

:param[in]    boxa:
:param[in]    copyflag:    L_COPY, L_CLONE, L_COPY_CLONE
:returns:  new boxa, or NULL on error

<pre>
Notes:
(1) See pix.h for description of the copyflag.
(2) The copy-clone makes a new boxa that holds clones of each box.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCopy(*args)
    
    

    try:
        leptonica.boxaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.boxaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function boxaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaDestroy(*args):
        """
        ('BOXA', '**pboxa')       

:param[in,out]   pboxa:    will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the boxa.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaDestroy(*args)
    
    

    try:
        leptonica.boxaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaAddBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAddBox(*args):
        """
        ('BOXA', '*boxa')       
('BOX', '*box')       
('l_int32', 'copyflag')       

:param[in]    boxa:
:param[in]    box:         to be added
:param[in]    copyflag:    L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAddBox(*args)
    
    

    try:
        leptonica.boxaExtendArray.argtypes = [ctypes.c_void_p]
        leptonica.boxaExtendArray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtendArray(*args):
        """
        ('BOXA', '*boxa')       

:param[in]    boxa:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Reallocs with doubled size of ptr array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtendArray(*args)
    
    

    try:
        leptonica.boxaExtendArrayToSize.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.boxaExtendArrayToSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaExtendArrayToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtendArrayToSize(*args):
        """
        ('BOXA', '*boxa')       
('size_t', 'size')       

:param[in]    boxa:
:param[in]    size:     new size of boxa ptr array
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If necessary, reallocs new boxa ptr array to %size.
(2) The max number of box ptrs is 10M.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtendArrayToSize(*args)
    
    

    try:
        leptonica.boxaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetCount(*args):
        """
        ('BOXA', '*boxa')       

:param[in]    boxa:
:returns:  count of all boxes; 0 if no boxes or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetCount(*args)
    
    

    try:
        leptonica.boxaGetValidCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaGetValidCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetValidCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetValidCount(*args):
        """
        ('BOXA', '*boxa')       

:param[in]    boxa:
:returns:  count of valid boxes; 0 if no valid boxes or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetValidCount(*args)
    
    

    try:
        leptonica.boxaGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    boxa:
:param[in]    index:        to the index-th box
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  box, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetBox(*args)
    
    

    try:
        leptonica.boxaGetValidBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetValidBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetValidBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetValidBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    boxa:
:param[in]    index:        to the index-th box
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  box, or NULL if box is not valid or on error

<pre>
Notes:
(1) This returns NULL for an invalid box in a boxa.
For a box to be valid, both the width and height must be > 0.
(2) We allow invalid boxes, with w = 0 or h = 0, as placeholders
in boxa for which the index of the box in the boxa is important.
This is an atypical situation; usually you want to put only
valid boxes in a boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetValidBox(*args)
    
    

    try:
        leptonica.boxaFindInvalidBoxes.argtypes = [ctypes.c_void_p]
        leptonica.boxaFindInvalidBoxes.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaFindInvalidBoxes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaFindInvalidBoxes(*args):
        """
        ('BOXA', '*boxa')       

:param[in]    boxa:
:returns:  na   numa of invalid boxes; NULL if there are none or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaFindInvalidBoxes(*args)
    
    

    try:
        leptonica.boxaGetBoxGeometry.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetBoxGeometry.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetBoxGeometry not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetBoxGeometry(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    boxa:
:param[in]    index:            to the index-th box
:param[out]   px,: py, pw, ph   [optional] each can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetBoxGeometry(*args)
    
    

    try:
        leptonica.boxaIsFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaIsFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaIsFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaIsFull(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*pfull')       

:param[in]    boxa:
:param[out]   pfull:    1 if boxa is full; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaIsFull(*args)
    
    

    try:
        leptonica.boxaReplaceBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaReplaceBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaReplaceBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReplaceBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('BOX', '*box')       

:param[in]    boxa:
:param[in]    index:     to the index-th box
:param[in]    box:       insert this box to replace existing one
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place replacement of one box; the input %box is now
owned by the boxa.
(2) The previous box at that location, if any, is destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReplaceBox(*args)
    
    

    try:
        leptonica.boxaInsertBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaInsertBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaInsertBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaInsertBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('BOX', '*box')       

:param[in]    boxa:
:param[in]    index:    location in boxa to insert new value
:param[in]    box:      new box to be inserted; the boxa now owns it
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts box[i] --> box[i + 1] for all i >= index,
and then inserts box as box[index].
(2) To insert at the beginning of the array, set index = 0.
(3) To append to the array, it's easier to use boxaAddBox().
(4) This should not be used repeatedly to insert into large arrays,
because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaInsertBox(*args)
    
    

    try:
        leptonica.boxaRemoveBox.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaRemoveBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaRemoveBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRemoveBox(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       

:param[in]    boxa:
:param[in]    index:    of box to be removed and destroyed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes box[index] and then shifts
box[i] --> box[i - 1] for all i > index.
(2) It should not be used repeatedly to remove boxes from
large arrays, because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRemoveBox(*args)
    
    

    try:
        leptonica.boxaRemoveBoxAndSave.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaRemoveBoxAndSave.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaRemoveBoxAndSave not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRemoveBoxAndSave(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('BOX', '**pbox')       

:param[in]    boxa:
:param[in]    index:     of box to be removed
:param[out]   pbox:      [optional] removed box
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes box[index] and then shifts
box[i] --> box[i - 1] for all i > index.
(2) It should not be used repeatedly to remove boxes from
large arrays, because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRemoveBoxAndSave(*args)
    
    

    try:
        leptonica.boxaSaveValid.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaSaveValid.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSaveValid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSaveValid(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'copyflag')       

:param[in]    boxas:
:param[in]    copyflag:    L_COPY or L_CLONE
:returns:  boxad if OK, NULL on error

<pre>
Notes:
(1) This makes a copy/clone of each valid box.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSaveValid(*args)
    
    

    try:
        leptonica.boxaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaInitFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaInitFull(*args):
        """
        ('BOXA', '*boxa')       
('BOX', '*box')       

:param[in]    boxa:    typically empty
:param[in]    box:     [optional] to be replicated into the entire ptr array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This initializes a boxa by filling up the entire box ptr array
with copies of %box.  If %box == NULL, use a placeholder box
of zero size.  Any existing boxes are destroyed.
After this opepration, the number of boxes is equal to
the number of allocated ptrs.
(2) Note that we use boxaReplaceBox() instead of boxaInsertBox().
They both have the same effect when inserting into a NULL ptr
in the boxa ptr array:
(3) Example usage.  This function is useful to prepare for a
random insertion (or replacement) of boxes into a boxa.
To randomly insert boxes into a boxa, up to some index "max":
Boxa *boxa = boxaCreate(max);
boxaInitFull(boxa, NULL);
If you want placeholder boxes of non-zero size:
Boxa *boxa = boxaCreate(max);
Box *box = boxCreate(...);
boxaInitFull(boxa, box);
boxDestroy(&box);
If we have an existing boxa with a smaller ptr array, it can
be reused for up to max boxes:
boxaExtendArrayToSize(boxa, max);
boxaInitFull(boxa, NULL);
The initialization allows the boxa to always be properly
filled, even if all the boxes are not later replaced.
If you want to know which boxes have been replaced,
and you initialized with invalid zero-sized boxes,
use boxaGetValidBox() to return NULL for the invalid boxes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaInitFull(*args)
    
    

    try:
        leptonica.boxaClear.argtypes = [ctypes.c_void_p]
        leptonica.boxaClear.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaClear(*args):
        """
        ('BOXA', '*boxa')       

:param[in]    boxa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys all boxes in the boxa, setting the ptrs
to null.  The number of allocated boxes, n, is set to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaClear(*args)
    
    

    try:
        leptonica.boxaaCreate.argtypes = [ctypes.c_int32]
        leptonica.boxaaCreate.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:     size of boxa ptr array to be alloc'd; 0 for default
:returns:  baa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaCreate(*args)
    
    

    try:
        leptonica.boxaaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaCopy.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaCopy(*args):
        """
        ('BOXAA', '*baas')       
('l_int32', 'copyflag')       

:param[in]    baas:       input boxaa to be copied
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  baad new boxaa, composed of copies or clones of the boxa
in baas, or NULL on error

<pre>
Notes:
(1) L_COPY makes a copy of each boxa in baas.
L_CLONE makes a clone of each boxa in baas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaCopy(*args)
    
    

    try:
        leptonica.boxaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.boxaaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaDestroy(*args):
        """
        ('BOXAA', '**pbaa')       

:param[in,out]   pbaa:     will be set to null before returning


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaDestroy(*args)
    
    

    try:
        leptonica.boxaaAddBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaAddBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaAddBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaAddBoxa(*args):
        """
        ('BOXAA', '*baa')       
('BOXA', '*ba')       
('l_int32', 'copyflag')       

:param[in]    baa:
:param[in]    ba:         to be added
:param[in]    copyflag:   L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaAddBoxa(*args)
    
    

    try:
        leptonica.boxaaExtendArray.argtypes = [ctypes.c_void_p]
        leptonica.boxaaExtendArray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaExtendArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaExtendArray(*args):
        """
        ('BOXAA', '*baa')       

:param[in]    baa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Doubles the size of the boxa ptr array.
(2) The max number of boxa ptrs is 1 million.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaExtendArray(*args)
    
    

    try:
        leptonica.boxaaExtendArrayToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaExtendArrayToSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaExtendArrayToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaExtendArrayToSize(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'size')       

:param[in]    baa:
:param[in]    size:     new size of boxa array
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If necessary, reallocs the boxa ptr array to %size.
(2) %size limited to 1M boxa ptrs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaExtendArrayToSize(*args)
    
    

    try:
        leptonica.boxaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function boxaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetCount(*args):
        """
        ('BOXAA', '*baa')       

:param[in]    baa:
:returns:  count number of boxa, or 0 if no boxa or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetCount(*args)
    
    

    try:
        leptonica.boxaaGetBoxCount.argtypes = [ctypes.c_void_p]
        leptonica.boxaaGetBoxCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function boxaaGetBoxCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetBoxCount(*args):
        """
        ('BOXAA', '*baa')       

:param[in]    baa:
:returns:  count number of boxes, or 0 if no boxes or on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetBoxCount(*args)
    
    

    try:
        leptonica.boxaaGetBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaGetBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaGetBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    baa:
:param[in]    index:        to the index-th boxa
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  boxa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetBoxa(*args)
    
    

    try:
        leptonica.boxaaGetBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaGetBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaGetBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetBox(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'iboxa')       
('l_int32', 'ibox')       
('l_int32', 'accessflag')       

:param[in]    baa:
:param[in]    iboxa:        index into the boxa array in the boxaa
:param[in]    ibox:         index into the box array in the boxa
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  box, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetBox(*args)
    
    

    try:
        leptonica.boxaaInitFull.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaInitFull.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaInitFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaInitFull(*args):
        """
        ('BOXAA', '*baa')       
('BOXA', '*boxa')       

:param[in]    baa:      typically empty
:param[in]    boxa:     to be replicated into the entire ptr array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This initializes a boxaa by filling up the entire boxa ptr array
with copies of %boxa.  Any existing boxa are destroyed.
After this operation, the number of boxa is equal to
the number of allocated ptrs.
(2) Note that we use boxaaReplaceBox() instead of boxaInsertBox().
They both have the same effect when inserting into a NULL ptr
in the boxa ptr array
(3) Example usage.  This function is useful to prepare for a
random insertion (or replacement) of boxa into a boxaa.
To randomly insert boxa into a boxaa, up to some index "max":
Boxaa *baa = boxaaCreate(max);
// initialize the boxa
Boxa *boxa = boxaCreate(...);
...  [optionally fix with boxes]
boxaaInitFull(baa, boxa);
A typical use is to initialize the array with empty boxa,
and to replace only a subset that must be aligned with
something else, such as a pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaInitFull(*args)
    
    

    try:
        leptonica.boxaaExtendWithInit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaExtendWithInit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaExtendWithInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaExtendWithInit(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'maxindex')       
('BOXA', '*boxa')       

:param[in]    baa:
:param[in]    maxindex:
:param[in]    boxa:       to be replicated into the extended ptr array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This should be used on an existing boxaa that has been
fully loaded with boxa.  It then extends the boxaa,
loading all the additional ptrs with copies of boxa.
Typically, boxa will be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaExtendWithInit(*args)
    
    

    try:
        leptonica.boxaaReplaceBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaReplaceBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaReplaceBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReplaceBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('BOXA', '*boxa')       

:param[in]    baa:
:param[in]    index:    to the index-th boxa
:param[in]    boxa:     insert and replace any existing one
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Any existing boxa is destroyed, and the input one
is inserted in its place.
(2) If the index is invalid, return 1 (error)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReplaceBoxa(*args)
    
    

    try:
        leptonica.boxaaInsertBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaInsertBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaInsertBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaInsertBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('BOXA', '*boxa')       

:param[in]    baa:
:param[in]    index:    location in boxaa to insert new boxa
:param[in]    boxa:     new boxa to be inserted
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts boxa[i] --> boxa[i + 1] for all i >= index,
and then inserts boxa as boxa[index].
(2) To insert at the beginning of the array, set index = 0.
(3) To append to the array, it's easier to use boxaaAddBoxa().
(4) This should not be used repeatedly to insert into large arrays,
because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaInsertBoxa(*args)
    
    

    try:
        leptonica.boxaaRemoveBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaRemoveBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaRemoveBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaRemoveBoxa(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       

:param[in]    baa:
:param[in]    index:   of the boxa to be removed and destroyed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes boxa[index] and then shifts
boxa[i] --> boxa[i - 1] for all i > index.
(2) The removed boxaa is destroyed.
(2) This should not be used repeatedly on large arrays,
because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaRemoveBoxa(*args)
    
    

    try:
        leptonica.boxaaAddBox.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaAddBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaAddBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaAddBox(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'index')       
('BOX', '*box')       
('l_int32', 'accessflag')       

:param[in]    baa:
:param[in]    index:       of boxa with boxaa
:param[in]    box:         to be added
:param[in]    accessflag:  L_INSERT, L_COPY or L_CLONE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Adds to an existing boxa only.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaAddBox(*args)
    
    

    try:
        leptonica.boxaaReadFromFiles.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaReadFromFiles.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaReadFromFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReadFromFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'first')       
('l_int32', 'nfiles')       

:param[in]    dirname:   directory
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    first:     0-based
:param[in]    nfiles:    use 0 for everything from %first to the end
:returns:  baa, or NULL on error or if no boxa files are found.

<pre>
Notes:
(1) The files must be serialized boxa files (e.g., *.ba).
If some files cannot be read, warnings are issued.
(2) Use %substr to filter filenames in the directory.  If
%substr == NULL, this takes all files.
(3) After filtering, use %first and %nfiles to select
a contiguous set of files, that have been lexically
sorted in increasing order.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReadFromFiles(*args)
    
    

    try:
        leptonica.boxaaRead.argtypes = [ctypes.c_char_p]
        leptonica.boxaaRead.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  boxaa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaRead(*args)
    
    

    try:
        leptonica.boxaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.boxaaReadStream.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    input file stream
:returns:  boxaa, or NULL on error

<pre>
Notes:
(1) It is OK for the boxaa to be empty (n == 0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReadStream(*args)
    
    

    try:
        leptonica.boxaaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.boxaaReadMem.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:     serialization of boxaa; in ascii
:param[in]    size:     of data in bytes; can use strlen to get it
:returns:  baa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaReadMem(*args)
    
    

    try:
        leptonica.boxaaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.boxaaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaWrite(*args):
        """
        ('const char', '*filename')       
('BOXAA', '*baa')       

:param[in]    filename:
:param[in]    baa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaWrite(*args)
    
    

    try:
        leptonica.boxaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('BOXAA', '*baa')       

:param[in]   fp:    output file stream
:param[in]   baa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaWriteStream(*args)
    
    

    try:
        leptonica.boxaaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('BOXAA', '*baa')       

:param[out]   pdata:    data of serialized boxaa; ascii
:param[out]   psize:    size of returned data
:param[in]    baa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a boxaa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaWriteMem(*args)
    
    

    try:
        leptonica.boxaRead.argtypes = [ctypes.c_char_p]
        leptonica.boxaRead.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  boxa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRead(*args)
    
    

    try:
        leptonica.boxaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.boxaReadStream.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:   input file stream
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) It is OK for the boxa to be empty (n == 0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReadStream(*args)
    
    

    try:
        leptonica.boxaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.boxaReadMem.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    serialization of boxa; in ascii
:param[in]    size:    of data in bytes; can use strlen to get it
:returns:  boxa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReadMem(*args)
    
    

    try:
        leptonica.boxaWriteDebug.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.boxaWriteDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaWriteDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWriteDebug(*args):
        """
        ('const char', '*filename')       
('BOXA', '*boxa')       

:param[in]    filename:
:param[in]    boxa:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Debug version, intended for use in the library when writing
to files in a temp directory with names that are compiled in.
This is used instead of boxaWrite() for all such library calls.
(2) The global variable LeptDebugOK defaults to 0, and can be set
or cleared by the function setLeptDebugOK().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWriteDebug(*args)
    
    

    try:
        leptonica.boxaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.boxaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWrite(*args):
        """
        ('const char', '*filename')       
('BOXA', '*boxa')       

:param[in]    filename:
:param[in]    boxa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWrite(*args)
    
    

    try:
        leptonica.boxaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWriteStream(*args):
        """
        ('FILE', '*fp')       
('BOXA', '*boxa')       

:param[in]   fp:     file stream; use NULL for stderr
:param[in]   boxa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWriteStream(*args)
    
    

    try:
        leptonica.boxaWriteStderr.argtypes = [ctypes.c_void_p]
        leptonica.boxaWriteStderr.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaWriteStderr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWriteStderr(*args):
        """
        ('BOXA', '*boxa')       

:param[in]   boxa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWriteStderr(*args)
    
    

    try:
        leptonica.boxaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('BOXA', '*boxa')       

:param[out]   pdata:   data of serialized boxa; ascii
:param[out]   psize:   size of returned data
:param[in]    boxa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a boxa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWriteMem(*args)
    
    

    try:
        leptonica.boxPrintStreamInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxPrintStreamInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxPrintStreamInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxPrintStreamInfo(*args):
        """
        ('FILE', '*fp')       
('BOX', '*box')       

:param[in]    fp:    file stream; use NULL for stderr
:param[in]    box:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This outputs debug info.  Use serialization functions to
write to file if you want to read the data back.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxPrintStreamInfo(*args)
    




class makefile(object):
    """"""
    



class pixtiling(object):
    """<pre>

PIXTILING       *pixTilingCreate()
void            *pixTilingDestroy()
l_int32          pixTilingGetCount()
l_int32          pixTilingGetSize()
PIX             *pixTilingGetTile()
l_int32          pixTilingNoStripOnPaint()
l_int32          pixTilingPaintTile()

This provides a simple way to split an image into tiles
and to perform operations independently on each tile.

The tile created with pixTilingGetTile() can have pixels in
adjacent tiles for computation.  The number of extra pixels
on each side of the tile is given by an 'overlap' parameter
to pixTilingCreate().  For tiles at the boundary of
the input image, quasi-overlap pixels are created by reflection
symmetry into the tile.

Here's a typical intended usage.  Suppose you want to parallelize
the operation on an image, by operating on tiles.  For each
tile, you want to generate an in-place image result at the same
resolution.  Suppose you choose a one-dimensional vertical tiling,
where the desired tile width is 256 pixels and the overlap is
30 pixels on left and right sides:

PIX *pixd = pixCreateTemplate(pixs);  // output
PIXTILING  *pt = pixTilingCreate(pixs, 0, 1, 256, 30, 0);
pixTilingGetCount(pt, &nx, NULL);
for (j = 0; j < nx; j++) {
PIX *pixt = pixTilingGetTile(pt, 0, j);
SomeInPlaceOperation(pixt, 30, 0, ...);
pixTilingPaintTile(pixd, 0, j, pixt, pt);
pixDestroy(&pixt);
}

In this example, note the following:
~ The unspecfified in-place operation could instead generate
a new pix.  If this is done, the resulting pix must be the
same size as pixt, because pixTilingPaintTile() makes that
assumption, removing the overlap pixels before painting
into the destination.
~ The 'overlap' parameters have been included in your function,
to indicate which pixels are not in the exterior overlap region.
You will need to change only pixels that are not in the overlap
region, because those are the pixels that will be painted
into the destination.
~ For tiles on the outside of the image, mirrored pixels are
added to substitute for the overlap that is added to interior
tiles.  This allows you to implement your function without
reference to which tile it is; no special coding is necessary
for pixels that are near the image boundary.
~ The tiles are labeled by (i, j) = (row, column),
and in this example there is one row and nx columns.
</pre>




"""
    
    try:
        leptonica.pixTilingCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTilingCreate.restype = lambda address: PIXTILING(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingCreate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nx')       
('l_int32', 'ny')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'xoverlap')       
('l_int32', 'yoverlap')       

:param[in]    pixs:       pix to be tiled; any depth; colormap OK
:param[in]    nx:         number of tiles across image
:param[in]    ny:         number of tiles down image
:param[in]    w:          desired width of each tile
:param[in]    h:          desired height of each tile
:param[in]    xoverlap:   overlap into neighboring tiles on each side
:param[in]    yoverlap:   overlap into neighboring tiles above and below
:returns:  pixtiling, or NULL on error

<pre>
Notes:
(1) We put a clone of pixs in the PixTiling.
(2) The input to pixTilingCreate() for horizontal tiling can be
either the number of tiles across the image or the approximate
width of the tiles.  If the latter, the actual width will be
determined by making all tiles but the last of equal width, and
making the last as close to the others as possible.  The same
consideration is applied independently to the vertical tiling.
To specify tile width, set nx = 0; to specify the number of
tiles horizontally across the image, set w = 0.
(3) If pixs is to be tiled in one-dimensional strips, use ny = 1 for
vertical strips and nx = 1 for horizontal strips.
(4) The overlap must not be larger than the width or height of
the leftmost or topmost tile(s).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingCreate(*args)
    
    

    try:
        leptonica.pixTilingDestroy.argtypes = [ctypes.c_void_p]
        leptonica.pixTilingDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingDestroy(*args):
        """
        ('PIXTILING', '**ppt')       

:param[in,out]   ppt:   will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingDestroy(*args)
    
    

    try:
        leptonica.pixTilingGetCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTilingGetCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingGetCount(*args):
        """
        ('PIXTILING', '*pt')       
('l_int32', '*pnx')       
('l_int32', '*pny')       

:param[in]    pt:     pixtiling
:param[out]   pnx:    [optional] nx; can be null
:param[out]   pny:    [optional] ny; can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingGetCount(*args)
    
    

    try:
        leptonica.pixTilingGetSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTilingGetSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingGetSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingGetSize(*args):
        """
        ('PIXTILING', '*pt')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    pt:    pixtiling
:param[out]   pw:    [optional] tile width; can be null
:param[out]   ph:    [optional] tile height; can be null
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingGetSize(*args)
    
    

    try:
        leptonica.pixTilingGetTile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTilingGetTile.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingGetTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingGetTile(*args):
        """
        ('PIXTILING', '*pt')       
('l_int32', 'i')       
('l_int32', 'j')       

:param[in]    pt:    pixtiling
:param[in]    i:     tile row index
:param[in]    j:     tile column index
:returns:  pixd   tile with appropriate boundary (overlap) pixels added,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingGetTile(*args)
    
    

    try:
        leptonica.pixTilingNoStripOnPaint.argtypes = [ctypes.c_void_p]
        leptonica.pixTilingNoStripOnPaint.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingNoStripOnPaint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingNoStripOnPaint(*args):
        """
        ('PIXTILING', '*pt')       

:param[in]    pt:    pixtiling
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The default for paint is to strip out the overlap pixels
that are added by pixTilingGetTile().  However, some
operations will generate an image with these pixels
stripped off.  This tells the paint operation not
to strip the added boundary pixels when painting.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingNoStripOnPaint(*args)
    
    

    try:
        leptonica.pixTilingPaintTile.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixTilingPaintTile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixTilingPaintTile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTilingPaintTile(*args):
        """
        ('PIX', '*pixd')       
('l_int32', 'i')       
('l_int32', 'j')       
('PIX', '*pixs')       
('PIXTILING', '*pt')       

:param[in]    pixd:    dest: paint tile onto this, without overlap
:param[in]    i:       tile row index
:param[in]    j:       tile column index
:param[in]    pixs:    source: tile to be painted from
:param[in]    pt:      pixtiling struct
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixTilingPaintTile(*args)
    




class rotateshear(object):
    """<pre>

Shear rotation about arbitrary point using 2 and 3 shears

PIX      *pixRotateShear()
PIX      *pixRotate2Shear()
PIX      *pixRotate3Shear()

Shear rotation in-place about arbitrary point using 3 shears
l_int32   pixRotateShearIP()

Shear rotation around the image center
PIX      *pixRotateShearCenter()    (2 or 3 shears)
l_int32   pixRotateShearCenterIP()  (3 shears)

Rotation is measured in radians; clockwise rotations are positive.

Rotation by shear works on images of any depth,
including 8 bpp color paletted images and 32 bpp
rgb images.  It works by translating each src pixel
value to the appropriate pixel in the rotated dest.
For 8 bpp grayscale images, it is about 10-15x faster
than rotation by area-mapping.

This speed and flexibility comes at the following cost,
relative to area-mapped rotation:

~  Jaggies are created on edges of straight lines

~  For large angles, where you must use 3 shears,
there is some extra clipping from the shears.

For small angles, typically less than 0.05 radians,
rotation can be done with 2 orthogonal shears.
Two such continuous shears (as opposed to the discrete
shears on a pixel lattice that we have here) give
a rotated image that has a distortion in the lengths
of the two rotated and still-perpendicular axes.  The
length/width ratio changes by a fraction

0.5 * (angle)**2

For an angle of 0.05 radians, this is about 1 part in
a thousand.  This distortion is absent when you use
3 continuous shears with the correct angles (see below).

Of course, the image is on a discrete pixel lattice.
Rotation by shear gives an approximation to a continuous
rotation, leaving pixel jaggies at sharp boundaries.
For very small rotations, rotating from a corner gives
better sensitivity than rotating from the image center.
Here's why.  Define the shear "center" to be the line such
that the image is sheared in opposite directions on
each side of and parallel to the line.  For small
rotations there is a "dead space" on each side of the
shear center of width equal to half the shear angle,
in radians.  Thus, when the image is sheared about the center,
the dead space width equals the shear angle, but when
the image is sheared from a corner, the dead space
width is only half the shear angle.

All horizontal and vertical shears are implemented by
rasterop.  The in-place rotation uses special in-place
shears that copy rows sideways or columns vertically
without buffering, and then rewrite old pixels that are
no longer covered by sheared pixels.  For that rewriting,
you have the choice of using white or black pixels.
When not in-place, the new pix is initialized with white or black
pixels by pixSetBlackOrWhite(), which also works for cmapped pix.
But for in-place, this initialization is not possible, so
in-place shear operations on cmapped pix are not allowed.

Rotation by shear is fast and depth-independent.  However, it
does not work well for large rotation angles.  In fact, for
rotation angles greater than about 7 degrees, more pixels are
lost at the edges than when using pixRotationBySampling(), which
only loses pixels because they are rotated out of the image.
For larger rotations, use pixRotationBySampling() or, for
more accuracy when d > 1 bpp, pixRotateAM().

For small angles, when comparing the quality of rotation by
sampling and by shear, you can see that rotation by sampling
is slightly more accurate.  However, the difference in
accuracy of rotation by sampling when compared to 3-shear and
(for angles less than 2 degrees, when compared to 2-shear) is
less than 1 pixel at any point.  For very small angles, rotation by
sampling is much slower than rotation by shear.  The speed difference
depends on the pixel depth and the rotation angle.  Rotation
by shear is very fast for small angles and for small depth (esp. 1 bpp).
Rotation by sampling speed is independent of angle and relatively
more efficient for 8 and 32 bpp images.  Here are some timings
for the ratio of rotation times: (time for sampling)/ (time for shear)

depth (bpp)       ratio (2 deg)       ratio (10 deg)
-----------------------------------------------------
1                  25                  6
8                   5                  2.6
32                  1.6                1.0

In summary:
For d == 1 and small angles, use rotation by shear.  By default
this will use 2-shear rotations, because 3-shears cause more
visible artifacts in straight lines and, for small angles, the
distortion in asperity ratio is small.
For d > 1, shear is faster than sampling, which is faster than
area mapping.  However, area mapping gives the best results.
These results are used in selecting the rotation methods in
pixRotateShear().

There has been some work on what is called a "quasishear
rotation" ("The Quasi-Shear Rotation, Eric Andres,
DGCI 1996, pp. 307-314).  I believe they use a 3-shear
approximation to the continuous rotation, exactly as
we do here.  The approximation is due to being on
a square pixel lattice.  They also use integers to specify
the rotation angle and center offset, but that makes
little sense on a machine where you have a few GFLOPS
and only a few hundred floating point operations to do (!)
They also allow subpixel specification of the center of
rotation, which I haven't bothered with, and claim that
better results are possible if each of the 4 quadrants is
handled separately.

But the bottom line is that you are going to see shear lines when
you rotate 1 bpp images.  Although the 3-shear rotation is
mathematically exact in the limit of infinitesimal pixels, artifacts
will be evident in real images.  One might imagine using dithering
to break up the horizontal and vertical shear lines, but this
is hard with block shears, where you need to dither on the block
boundaries.  Dithering (by accumulation of 'error') with sampling
makes more sense, but I haven't tried to do this.  There is only
so much you can do with 1 bpp images!
</pre>




"""
    
    try:
        leptonica.pixRotateShear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateShear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:     any depth; cmap ok
:param[in]    xcen:     x value for which there is no horizontal shear
:param[in]    ycen:     y value for which there is no vertical shear
:param[in]    angle:    radians
:param[in]    incolor:  L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) This rotates an image about the given point, using
either 2 or 3 shears.
(2) A positive angle gives a clockwise rotation.
(3) This brings in 'incolor' pixels from outside the image.
(4) For rotation angles larger than about 0.35 radians, we issue
a warning because you should probably be using another method
(either sampling or area mapping)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShear(*args)
    
    

    try:
        leptonica.pixRotate2Shear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotate2Shear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotate2Shear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate2Shear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:         any depth; cmap ok
:param[in]    xcen,: ycen   center of rotation
:param[in]    angle:        radians
:param[in]    incolor:      L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) This rotates the image about the given point, using the 2-shear
method.  It should only be used for angles no larger than
MaxTwoShearAngle.  For larger angles, a warning is issued.
(2) A positive angle gives a clockwise rotation.
(3) 2-shear rotation by a specified angle is equivalent
to the sequential transformations
x' = x + tan(angle) * (y - ycen)     for x-shear
y' = y + tan(angle) * (x - xcen)     for y-shear
(4) Computation of tan(angle) is performed within the shear operation.
(5) This brings in 'incolor' pixels from outside the image.
(6) If the image has an alpha layer, it is rotated separately by
two shears.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate2Shear(*args)
    
    

    try:
        leptonica.pixRotate3Shear.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotate3Shear.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotate3Shear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotate3Shear(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:         any depth; cmap ok
:param[in]    xcen,: ycen   center of rotation
:param[in]    angle:        radians
:param[in]    incolor:      L_BRING_IN_WHITE, L_BRING_IN_BLACK;
:returns:  pixd, or NULL on error.

<pre>
Notes:
(1) This rotates the image about the given point, using the 3-shear
method.  It should only be used for angles smaller than
MaxThreeShearAngle.  For larger angles, a warning is issued.
(2) A positive angle gives a clockwise rotation.
(3) 3-shear rotation by a specified angle is equivalent
to the sequential transformations
y' = y + tan(angle/2) * (x - xcen)     for first y-shear
x' = x + sin(angle) * (y - ycen)       for x-shear
y' = y + tan(angle/2) * (x - xcen)     for second y-shear
(4) Computation of tan(angle) is performed in the shear operations.
(5) This brings in 'incolor' pixels from outside the image.
(6) If the image has an alpha layer, it is rotated separately by
two shears.
(7) The algorithm was published by Alan Paeth: "A Fast Algorithm
for General Raster Rotation," Graphics Interface '86,
pp. 77-81, May 1986.  A description of the method, along with
an implementation, can be found in Graphics Gems, p. 179,
edited by Andrew Glassner, published by Academic Press, 1990.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotate3Shear(*args)
    
    

    try:
        leptonica.pixRotateShearIP.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShearIP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateShearIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShearIP(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:         any depth; no cmap
:param[in]    xcen,: ycen   center of rotation
:param[in]    angle:        radians
:param[in]    incolor:      L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This does an in-place rotation of the image about the
specified point, using the 3-shear method.  It should only
be used for angles smaller than MaxThreeShearAngle.
For larger angles, a warning is issued.
(2) A positive angle gives a clockwise rotation.
(3) 3-shear rotation by a specified angle is equivalent
to the sequential transformations
y' = y + tan(angle/2) * (x - xcen)      for first y-shear
x' = x + sin(angle) * (y - ycen)        for x-shear
y' = y + tan(angle/2) * (x - xcen)      for second y-shear
(4) Computation of tan(angle) is performed in the shear operations.
(5) This brings in 'incolor' pixels from outside the image.
(6) The pix cannot be colormapped, because the in-place operation
only blits in 0 or 1 bits, not an arbitrary colormap index.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShearIP(*args)
    
    

    try:
        leptonica.pixRotateShearCenter.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShearCenter.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateShearCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShearCenter(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:      any depth; cmap ok
:param[in]    angle:     radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShearCenter(*args)
    
    

    try:
        leptonica.pixRotateShearCenterIP.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixRotateShearCenterIP.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRotateShearCenterIP not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRotateShearCenterIP(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'angle')       
('l_int32', 'incolor')       

:param[in]    pixs:      any depth; no cmap
:param[in]    angle:     radians
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixRotateShearCenterIP(*args)
    




class zlibmem(object):
    """<pre>

zlib operations in memory, using bbuffer
l_uint8   *zlibCompress()
l_uint8   *zlibUncompress()


This provides an example use of the byte buffer utility
(see bbuffer.c for details of how the bbuffer works internally).
We use zlib to compress and decompress a byte array from
one memory buffer to another.  The standard method uses streams,
but here we use the bbuffer as an expandable queue of pixels
for both the reading and writing sides of each operation.

With memory mapping, one should be able to compress between
memory buffers by using the file system to buffer everything in
the background, but the bbuffer implementation is more portable.
</pre>




"""
    
    try:
        leptonica.zlibCompress.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.zlibCompress.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function zlibCompress not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def zlibCompress(*args):
        """
        ('l_uint8', '*datain')       
('size_t', 'nin')       
('size_t', '*pnout')       

:param[in]    datain:    byte buffer with input data
:param[in]    nin:       number of bytes of input data
:param[out]   pnout:     number of bytes of output data
:returns:  dataout compressed data, or NULL on error

<pre>
Notes:
(1) We repeatedly read in and fill up an input buffer,
compress the data, and read it back out.  zlib
uses two byte buffers internally in the z_stream
data structure.  We use the bbuffers to feed data
into the fixed bufferin, and feed it out of bufferout,
in the same way that a pair of streams would normally
be used if the data were being read from one file
and written to another.  This is done iteratively,
compressing L_BUF_SIZE bytes of input data at a time.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.zlibCompress(*args)
    
    

    try:
        leptonica.zlibUncompress.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.zlibUncompress.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function zlibUncompress not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def zlibUncompress(*args):
        """
        ('l_uint8', '*datain')       
('size_t', 'nin')       
('size_t', '*pnout')       

:param[in]    datain:    byte buffer with compressed input data
:param[in]    nin:       number of bytes of input data
:param[out]   pnout:     number of bytes of output data
:returns:  dataout uncompressed data, or NULL on error

<pre>
Notes:
(1) See zlibCompress().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.zlibUncompress(*args)
    




class boxfunc1(object):
    """<pre>

Box geometry
l_int32   boxContains()
l_int32   boxIntersects()
BOXA     *boxaContainedInBox()
l_int32   boxaContainedInBoxCount()
l_int32   boxaContainedInBoxa()
BOXA     *boxaIntersectsBox()
l_int32   boxaIntersectsBoxCount()
BOXA     *boxaClipToBox()
BOXA     *boxaCombineOverlaps()
l_int32   boxaCombineOverlapsInPair()
BOX      *boxOverlapRegion()
BOX      *boxBoundingRegion()
l_int32   boxOverlapFraction()
l_int32   boxOverlapArea()
BOXA     *boxaHandleOverlaps()
l_int32   boxOverlapDistance()
l_int32   boxSeparationDistance()
l_int32   boxCompareSize()
l_int32   boxContainsPt()
BOX      *boxaGetNearestToPt()
BOX      *boxaGetNearestToLine()
l_int32   boxaFindNearestBoxes()
l_int32   boxaGetNearestByDirection()
static l_int32   boxHasOverlapInXorY()
static l_int32   boxGetDistanceInXorY()
l_int32   boxIntersectByLine()
l_int32   boxGetCenter()
BOX      *boxClipToRectangle()
l_int32   boxClipToRectangleParams()
BOX      *boxRelocateOneSide()
BOXA     *boxaAdjustSides()
BOXA     *boxaAdjustBoxSides()
BOX      *boxAdjustSides()
BOXA     *boxaSetSide()
l_int32   boxSetSide()
BOXA     *boxaAdjustWidthToTarget()
BOXA     *boxaAdjustHeightToTarget()
l_int32   boxEqual()
l_int32   boxaEqual()
l_int32   boxSimilar()
l_int32   boxaSimilar()

Boxa combine and split
l_int32   boxaJoin()
l_int32   boxaaJoin()
l_int32   boxaSplitEvenOdd()
BOXA     *boxaMergeEvenOdd()
</pre>




"""
    
    try:
        leptonica.boxContains.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxContains.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxContains not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxContains(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*presult')       

:param[in]    box1,: box2
:param[out]   presult:     1 if box2 is entirely contained within box1;
0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxContains(*args)
    
    

    try:
        leptonica.boxIntersects.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxIntersects.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxIntersects not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxIntersects(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*presult')       

:param[in]    box1,: box2
:param[out]   presult:    1 if any part of box2 is contained in box1;
0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxIntersects(*args)
    
    

    try:
        leptonica.boxaContainedInBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaContainedInBox.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaContainedInBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaContainedInBox(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       

:param[in]    boxas:
:param[in]    box:     for containment
:returns:  boxad  boxa with all boxes in boxas that are entirely
contained in box, or NULL on error

<pre>
Notes:
(1) All boxes in %boxas that are entirely outside box are removed.
(2) If %box is not valid, returns an empty boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaContainedInBox(*args)
    
    

    try:
        leptonica.boxaContainedInBoxCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaContainedInBoxCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaContainedInBoxCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaContainedInBoxCount(*args):
        """
        ('BOXA', '*boxa')       
('BOX', '*box')       
('l_int32', '*pcount')       

:param[in]    boxa:
:param[in]    box:      for selecting contained boxes in %boxa
:param[out]   pcount:   number of boxes intersecting the box
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %box is not valid, returns a zero count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaContainedInBoxCount(*args)
    
    

    try:
        leptonica.boxaContainedInBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaContainedInBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaContainedInBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaContainedInBoxa(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', '*pcontained')       

:param[in]     boxa1,: boxa2
:param[out]    pcontained:    1 if every box in boxa2 is contained in
some box in boxa1; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaContainedInBoxa(*args)
    
    

    try:
        leptonica.boxaIntersectsBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaIntersectsBox.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaIntersectsBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaIntersectsBox(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       

:param[in]    boxas:
:param[in]    box:     for intersecting
:returns:  boxad    boxa with all boxes in boxas that intersect box,
or NULL on error

<pre>
Notes:
(1) All boxes in boxa that intersect with box (i.e., are completely
or partially contained in box) are retained.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaIntersectsBox(*args)
    
    

    try:
        leptonica.boxaIntersectsBoxCount.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaIntersectsBoxCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaIntersectsBoxCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaIntersectsBoxCount(*args):
        """
        ('BOXA', '*boxa')       
('BOX', '*box')       
('l_int32', '*pcount')       

:param[in]    boxa:
:param[in]    box:      for selecting intersecting boxes in %boxa
:param[out]   pcount:   number of boxes intersecting the box
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaIntersectsBoxCount(*args)
    
    

    try:
        leptonica.boxaClipToBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaClipToBox.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaClipToBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaClipToBox(*args):
        """
        ('BOXA', '*boxas')       
('BOX', '*box')       

:param[in]    boxas:
:param[in]    box:     for clipping
:returns:  boxad     boxa with boxes in boxas clipped to box, or NULL on error

<pre>
Notes:
(1) All boxes in boxa not intersecting with box are removed, and
the remaining boxes are clipped to box.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaClipToBox(*args)
    
    

    try:
        leptonica.boxaCombineOverlaps.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaCombineOverlaps.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaCombineOverlaps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCombineOverlaps(*args):
        """
        ('BOXA', '*boxas')       
('PIXA', '*pixadb')       

:param[in]       boxas:
:param[in,out]   pixadb:     debug output
:returns:  boxad   where each set of boxes in boxas that overlap are combined
into a single bounding box in boxad, or NULL on error.

<pre>
Notes:
(1) If there are no overlapping boxes, it simply returns a copy
of %boxas.
(2) Input an empty %pixadb, using pixaCreate(0), for debug output.
The output gives 2 visualizations of the boxes per iteration;
boxes in red before, and added boxes in green after. Note that
all pixels in the red boxes are contained in the green ones.
(3) The alternative method of painting each rectangle and finding
the 4-connected components gives a different result in
general, because two non-overlapping (but touching)
rectangles, when rendered, are 4-connected and will be joined.
(4) A bad case computationally is to have n boxes, none of which
overlap.  Then you have one iteration with O(n^2) compares.
This is still faster than painting each rectangle and finding
the bounding boxes of the connected components, even for
thousands of rectangles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCombineOverlaps(*args)
    
    

    try:
        leptonica.boxaCombineOverlapsInPair.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaCombineOverlapsInPair.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaCombineOverlapsInPair not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCombineOverlapsInPair(*args):
        """
        ('BOXA', '*boxas1')       
('BOXA', '*boxas2')       
('BOXA', '**pboxad1')       
('BOXA', '**pboxad2')       
('PIXA', '*pixadb')       

:param[in]       boxas1:     input boxa1
:param[in]       boxas2:     input boxa2
:param[out]      pboxad1:    output boxa1
:param[out]      pboxad2:    output boxa2
:param[in,out]   pixadb:     debug output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) One of three things happens to each box in %boxa1 and %boxa2:
it gets absorbed into a larger box that it overlaps with
it absorbs a smaller (by area) box that it overlaps with
and gets larger, using the bounding region of the 2 boxes
it is unchanged (including absorbing smaller boxes that
are contained within it).
(2) If all the boxes from one of the input boxa are absorbed, this
returns an empty boxa.
(3) Input an empty %pixadb, using pixaCreate(0), for debug output
(4) This is useful if different operations are to be carried out
on possibly overlapping rectangular regions, and it is desired
to have only one operation on any rectangular region.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCombineOverlapsInPair(*args)
    
    

    try:
        leptonica.boxOverlapRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapRegion.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxOverlapRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapRegion(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       

:param[in]    box1,: box2
:returns:  box     of overlap region between input boxes;
NULL if no overlap or on error

<pre>
Notes:
(1) This is the geometric intersection of the two rectangles.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapRegion(*args)
    
    

    try:
        leptonica.boxBoundingRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxBoundingRegion.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxBoundingRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxBoundingRegion(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       

:param[in]    box1,: box2
:returns:  box  of bounding region containing the input boxes;
NULL on error

<pre>
Notes:
(1) This is the geometric union of the two rectangles.
(2) Invalid boxes are ignored.  This returns an invalid box
if both input boxes are invalid.
(3) For the geometric union of a boxa, use boxaGetExtent().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxBoundingRegion(*args)
    
    

    try:
        leptonica.boxOverlapFraction.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapFraction.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxOverlapFraction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapFraction(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_float32', '*pfract')       

:param[in]    box1,: box2
:param[out]   pfract:      the fraction of box2 overlapped by box1
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) The result depends on the order of the input boxes,
because the overlap is taken as a fraction of box2.
(2) If at least one box is not valid, there is no overlap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapFraction(*args)
    
    

    try:
        leptonica.boxOverlapArea.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapArea.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxOverlapArea not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapArea(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*parea')       

:param[in]    box1,: box2
:param[out]   parea:       the number of pixels in the overlap
:returns:  0 if OK, 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapArea(*args)
    
    

    try:
        leptonica.boxaHandleOverlaps.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.boxaHandleOverlaps.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaHandleOverlaps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaHandleOverlaps(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'op')       
('l_int32', 'range')       
('l_float32', 'min_overlap')       
('l_float32', 'max_ratio')       
('NUMA', '**pnamap')       

:param[in]    boxas:
:param[in]    op:            L_COMBINE, L_REMOVE_SMALL
:param[in]    range:         forward distance over which overlaps
are checked; > 0
:param[in]    min_overlap:   minimum fraction of smaller box required for
overlap to count; 0.0 to ignore
:param[in]    max_ratio:     maximum fraction of small/large areas for
overlap to count; 1.0 to ignore
:param[out]   pnamap:        [optional] combining map
:returns:  boxad, or NULL on error.

<pre>
Notes:
(1) For all n(n-1)/2 box pairings, if two boxes overlap, either:
(a) op == L_COMBINE: get the bounding region for the two,
replace the larger with the bounding region, and remove
the smaller of the two, or
(b) op == L_REMOVE_SMALL: just remove the smaller.
(2) If boxas is 2D sorted, range can be small, but if it is
not spatially sorted, range should be large to allow all
pairwise comparisons to be made.
(3) The %min_overlap parameter allows ignoring small overlaps.
If %min_overlap == 1.0, only boxes fully contained in larger
boxes can be considered for removal; if %min_overlap == 0.0,
this constraint is ignored.
(4) The %max_ratio parameter allows ignoring overlaps between
boxes that are not too different in size.  If %max_ratio == 0.0,
no boxes can be removed; if %max_ratio == 1.0, this constraint
is ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaHandleOverlaps(*args)
    
    

    try:
        leptonica.boxOverlapDistance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxOverlapDistance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxOverlapDistance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxOverlapDistance(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*ph_ovl')       
('l_int32', '*pv_ovl')       

:param[in]    box1,: box2    two boxes, in any order
:param[out]   ph_ovl:        [optional] horizontal overlap
:param[out]   pv_ovl:        [optional] vertical overlap
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This measures horizontal and vertical overlap of the
two boxes.  Horizontal and vertical overlap are measured
independently.  We need to consider several cases to clarify.
(2) A positive horizontal overlap means that there is at least
one point on the the %box1 boundary with the same x-component
as some point on the %box2 boundary.  Conversely, with a zero
or negative horizontal overlap, there are no boundary pixels
in %box1 that share an x-component with a boundary pixel in %box2.
(3) For a zero or negative horizontal overlap, o <= 0, the minimum
difference in the x-component between pixels on the boundaries
of the two boxes is d = -o + 1.
(4) Likewise for vertical overlaps.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxOverlapDistance(*args)
    
    

    try:
        leptonica.boxSeparationDistance.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxSeparationDistance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxSeparationDistance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSeparationDistance(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*ph_sep')       
('l_int32', '*pv_sep')       

:param[in]    box1,: box2    two boxes, in any order
:param[out]   ph_sep:        horizontal separation
:param[out]   pv_sep:        vertical separation
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This measures the Manhattan distance between the closest points
on the boundaries of the two boxes.  When the boxes overlap
(including touching along a line or at a corner), the
horizontal and vertical distances are 0.
(2) The distances represent the horizontal and vertical separation
of the two boxes.  The boxes have a nonzero intersection when
both the horizontal and vertical overlaps are positive, and
for that case both horizontal and vertical separation
distances are 0.
(3) If the horizontal overlap of the boxes is positive, the
horizontal separation between nearest points on respective
boundaries is 0, and likewise for the vertical overlap.
(4) If the horizontal overlap ho <= 0, the horizontal
separation between nearest points is d = -ho + 1.
Likewise, if the vertical overlap vo <= 0, the vertical
separation between nearest points is d = -vo + 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxSeparationDistance(*args)
    
    

    try:
        leptonica.boxCompareSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxCompareSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxCompareSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxCompareSize(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', 'type')       
('l_int32', '*prel')       

:param[in]    box1,: box2
:param[in]    type:     L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,
L_SORT_BY_MAX_DIMENSION, L_SORT_BY_PERIMETER,
L_SORT_BY_AREA,
:param[out]   prel:     1 if box1 > box2, 0 if the same, -1 if box1 < box2
:returns:   0 if OK, 1 on error

<pre>
Notes:
(1) We're re-using the SORT enum for these comparisons.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxCompareSize(*args)
    
    

    try:
        leptonica.boxContainsPt.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.boxContainsPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxContainsPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxContainsPt(*args):
        """
        ('BOX', '*box')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', '*pcontains')       

:param[in]    box:
:param[in]    x,: y        a point
:param[out]   pcontains:   1 if box contains point; 0 otherwise
:returns:  0 if OK, 1 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.boxContainsPt(*args)
    
    

    try:
        leptonica.boxaGetNearestToPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetNearestToPt.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetNearestToPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetNearestToPt(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    boxa:
:param[in]    x,: y    point
:returns:  box   with centroid closest to the given point [x,y],
or NULL if no boxes in boxa

<pre>
Notes:
(1) Uses euclidean distance between centroid and point.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetNearestToPt(*args)
    
    

    try:
        leptonica.boxaGetNearestToLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaGetNearestToLine.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetNearestToLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetNearestToLine(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    boxa:
:param[in]    x,: y   (y = -1 for vertical line; x = -1 for horiz line)
:returns:  box  with centroid closest to the given line,
or NULL if no boxes in boxa

<pre>
Notes:
(1) For a horizontal line at some value y, get the minimum of the
distance |yc - y| from the box centroid yc value to y;
likewise minimize |xc - x| for a vertical line at x.
(2) Input y < 0, x >= 0 to indicate a vertical line at x, and
x < 0, y >= 0 for a horizontal line at y.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetNearestToLine(*args)
    
    

    try:
        leptonica.boxaFindNearestBoxes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaFindNearestBoxes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaFindNearestBoxes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaFindNearestBoxes(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'dist_select')       
('l_int32', 'range')       
('NUMAA', '**pnaaindex')       
('NUMAA', '**pnaadist')       

:param[in]    boxa:         either unsorted, or 2D sorted in LR/TB scan order
:param[in]    dist_select:  L_NON_NEGATIVE, L_ALL
:param[in]    range:        search distance from box i; use 0 to search
entire boxa (e.g., if it's not 2D sorted)
:param[out]   pnaaindex:    for each box in %boxa, contains a numa of 4
box indices (per direction) of the nearest box
:param[out]   pnaadist:     for each box in %boxa, this contains a numa
:returns:  0 if OK, 1 on error
<pre>
Notes:
(1) See boxaGetNearestByDirection() for usage of %dist_select
and %range.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaFindNearestBoxes(*args)
    
    

    try:
        leptonica.boxaGetNearestByDirection.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetNearestByDirection.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetNearestByDirection not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetNearestByDirection(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'i')       
('l_int32', 'dir')       
('l_int32', 'dist_select')       
('l_int32', 'range')       
('l_int32', '*pindex')       
('l_int32', '*pdist')       

:param[in]    boxa:         either unsorted, or 2D sorted in LR/TB scan order
:param[in]    i:            box we test against
:param[in]    dir:          direction to look: L_FROM_LEFT, L_FROM_RIGHT,
L_FROM_TOP, L_FROM_BOT
:param[in]    dist_select:  L_NON_NEGATIVE, L_ALL
:param[in]    range:        search distance from box i; use 0 to search
entire boxa (e.g., if it's not 2D sorted)
:param[out]   pindex:       index in boxa of nearest box with overlapping
coordinates in the indicated direction;
-1 if there is no box
:param[out]   pdist:        distance of the nearest box in the indicated
direction; 100000 if no box
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For efficiency, use a LR/TD sorted %boxa, which can be
made by flattening a 2D sorted boxaa.  In that case,
%range can be some positive integer like 50.
(2) If boxes overlap, the distance will be < 0.  Use %dist_select
to determine if these should count or not.  If L_ALL, then
one box will match as the nearest to another in 2 or more
directions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetNearestByDirection(*args)
    
    

    try:
        leptonica.boxGetCenter.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxGetCenter.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxGetCenter not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxGetCenter(*args):
        """
        ('BOX', '*box')       
('l_float32', '*pcx')       
('l_float32', '*pcy')       

:param[in]    box:
:param[out]   pcx,: pcy location of center of box
:returns:  0 if OK, 1 on error or if box is not valid


        """
        args = _convert_params(*args)
        
        return leptonica.boxGetCenter(*args)
    
    

    try:
        leptonica.boxIntersectByLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxIntersectByLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxIntersectByLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxIntersectByLine(*args):
        """
        ('BOX', '*box')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', 'slope')       
('l_int32', '*px1')       
('l_int32', '*py1')       
('l_int32', '*px2')       
('l_int32', '*py2')       
('l_int32', '*pn')       

:param[in]    box:
:param[in]    x,: y point that line goes through
:param[in]    slope: of line
:param[out]   px1,: py1 1st point of intersection with box
:param[out]   px2,: py2 2nd point of intersection with box
:param[out]   pn: number of points of intersection
:returns:  0 if OK, 1 on error or if box is not valid

<pre>
Notes:
(1) If the intersection is at only one point (a corner), the
coordinates are returned in (x1, y1).
(2) Represent a vertical line by one with a large but finite slope.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxIntersectByLine(*args)
    
    

    try:
        leptonica.boxClipToRectangle.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxClipToRectangle.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxClipToRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxClipToRectangle(*args):
        """
        ('BOX', '*box')       
('l_int32', 'wi')       
('l_int32', 'hi')       

:param[in]    box:
:param[in]    wi,: hi rectangle representing image
:returns:  part of box within given rectangle, or NULL on error
or if box is entirely outside the rectangle

<pre>
Notes:
(1) This can be used to clip a rectangle to an image.
The clipping rectangle is assumed to have a UL corner at (0, 0),
and a LR corner at (wi - 1, hi - 1).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxClipToRectangle(*args)
    
    

    try:
        leptonica.boxClipToRectangleParams.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxClipToRectangleParams.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxClipToRectangleParams not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxClipToRectangleParams(*args):
        """
        ('BOX', '*box')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', '*pxstart')       
('l_int32', '*pystart')       
('l_int32', '*pxend')       
('l_int32', '*pyend')       
('l_int32', '*pbw')       
('l_int32', '*pbh')       

:param[in]    box: [optional] requested box; can be null
:param[in]    w,: h clipping box size; typ. the size of an image
:param[out]   pxstart: start x coordinate
:param[out]   pystart: start y coordinate
:param[out]   pxend: one pixel beyond clipping box
:param[out]   pyend: one pixel beyond clipping box
:param[out]   pbw: [optional] clipped width
:param[out]   pbh: [optional] clipped height
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The return value should be checked.  If it is 1, the
returned parameter values are bogus.
(2) This simplifies the selection of pixel locations within
a given rectangle:
for (i = ystart; i < yend; i++ {
...
for (j = xstart; j < xend; j++ {
....
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxClipToRectangleParams(*args)
    
    

    try:
        leptonica.boxRelocateOneSide.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxRelocateOneSide.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxRelocateOneSide not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxRelocateOneSide(*args):
        """
        ('BOX', '*boxd')       
('BOX', '*boxs')       
('l_int32', 'loc')       
('l_int32', 'sideflag')       

:param[in]    boxd: [optional]; this can be null, equal to boxs,
or different from boxs;
:param[in]    boxs: starting box; to have one side relocated
:param[in]    loc: new location of the side that is changing
:param[in]    sideflag: L_FROM_LEFT, etc., indicating the side that moves
:returns:  boxd, or NULL on error or if the computed boxd has
width or height <= 0.

<pre>
Notes:
(1) Set boxd == NULL to get new box; boxd == boxs for in-place;
or otherwise to resize existing boxd.
(2) For usage, suggest one of these:
boxd = boxRelocateOneSide(NULL, boxs, ...);   // new
boxRelocateOneSide(boxs, boxs, ...);          // in-place
boxRelocateOneSide(boxd, boxs, ...);          // other
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxRelocateOneSide(*args)
    
    

    try:
        leptonica.boxaAdjustSides.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaAdjustSides.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaAdjustSides not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAdjustSides(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'delleft')       
('l_int32', 'delright')       
('l_int32', 'deltop')       
('l_int32', 'delbot')       

:param[in]    boxas:
:param[in]    delleft,: delright, deltop, delbot   changes in location of
each side for each box
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) New box dimensions are cropped at left and top to x >= 0 and y >= 0.
(2) If the width or height of a box goes to 0, we generate a box with
w == 1 and h == 1, as a placeholder.
(3) See boxAdjustSides().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAdjustSides(*args)
    
    

    try:
        leptonica.boxaAdjustBoxSides.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaAdjustBoxSides.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaAdjustBoxSides not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAdjustBoxSides(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'index')       
('l_int32', 'delleft')       
('l_int32', 'delright')       
('l_int32', 'deltop')       
('l_int32', 'delbot')       

:param[in]    boxas:
:param[in]    index:
:param[in]    delleft,: delright, deltop, delbot   changes to box side locs
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place operation on a box in a boxa.
(2) New box dimensions are cropped at left and top to x >= 0 and y >= 0.
(3) If a box ends up with no area, an error message is emitted,
but the box dimensions are not changed.
(4) See boxaAdjustSides().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAdjustBoxSides(*args)
    
    

    try:
        leptonica.boxAdjustSides.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxAdjustSides.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxAdjustSides not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxAdjustSides(*args):
        """
        ('BOX', '*boxd')       
('BOX', '*boxs')       
('l_int32', 'delleft')       
('l_int32', 'delright')       
('l_int32', 'deltop')       
('l_int32', 'delbot')       

:param[in]    boxd:     [optional]; this can be null, equal to boxs,
or different from boxs
:param[in]    boxs:     starting box; to have sides adjusted
:param[in]    delleft,: delright, deltop, delbot    changes in location
of each side
:returns:  boxd, or NULL on error or if the computed boxd has
width or height <= 0.

<pre>
Notes:
(1) Set boxd == NULL to get new box; boxd == boxs for in-place;
or otherwise to resize existing boxd.
(2) For usage, suggest one of these:
boxd = boxAdjustSides(NULL, boxs, ...);   // new
boxAdjustSides(boxs, boxs, ...);          // in-place
boxAdjustSides(boxd, boxs, ...);          // other
(3) New box dimensions are cropped at left and top to x >= 0 and y >= 0.
(4) For example, to expand in-place by 20 pixels on each side, use
boxAdjustSides(box, box, -20, 20, -20, 20);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxAdjustSides(*args)
    
    

    try:
        leptonica.boxaSetSide.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSetSide.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSetSide not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSetSide(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'side')       
('l_int32', 'val')       
('l_int32', 'thresh')       

:param[in]    boxad:    use NULL to get a new one; same as boxas for in-place
:param[in]    boxas:
:param[in]    side:     L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT
:param[in]    val:      location to set for given side, for each box
:param[in]    thresh:   min abs difference to cause resetting to %val
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) Sets the given side of each box.  Use boxad == NULL for a new
boxa, and boxad == boxas for in-place.
(2) Use one of these:
boxad = boxaSetSide(NULL, boxas, ...);   // new
boxaSetSide(boxas, boxas, ...);  // in-place
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSetSide(*args)
    
    

    try:
        leptonica.boxSetSide.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxSetSide.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxSetSide not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSetSide(*args):
        """
        ('BOX', '*boxs')       
('l_int32', 'side')       
('l_int32', 'val')       
('l_int32', 'thresh')       

:param[in]    boxs:
:param[in]    side:     L_SET_LEFT, L_SET_RIGHT, L_SET_TOP, L_SET_BOT
:param[in]    val:      location to set for given side, for each box
:param[in]    thresh:   min abs difference to cause resetting to %val
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) In-place operation.
(2) Use %thresh = 0 to definitely set the side to %val.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxSetSide(*args)
    
    

    try:
        leptonica.boxaAdjustWidthToTarget.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaAdjustWidthToTarget.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaAdjustWidthToTarget not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAdjustWidthToTarget(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'sides')       
('l_int32', 'target')       
('l_int32', 'thresh')       

:param[in]    boxad:    use NULL to get a new one; same as boxas for in-place
:param[in]    boxas:
:param[in]    sides:    L_ADJUST_LEFT, L_ADJUST_RIGHT, L_ADJUST_LEFT_AND_RIGHT
:param[in]    target:   target width if differs by more than thresh
:param[in]    thresh:   min abs difference in width to cause adjustment
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) Conditionally adjusts the width of each box, by moving
the indicated edges (left and/or right) if the width differs
by %thresh or more from %target.
(2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
Use one of these:
boxad = boxaAdjustWidthToTarget(NULL, boxas, ...);   // new
boxaAdjustWidthToTarget(boxas, boxas, ...);  // in-place
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAdjustWidthToTarget(*args)
    
    

    try:
        leptonica.boxaAdjustHeightToTarget.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaAdjustHeightToTarget.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaAdjustHeightToTarget not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaAdjustHeightToTarget(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'sides')       
('l_int32', 'target')       
('l_int32', 'thresh')       

:param[in]    boxad:    use NULL to get a new one
:param[in]    boxas:
:param[in]    sides:    L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT
:param[in]    target:   target height if differs by more than thresh
:param[in]    thresh:   min abs difference in height to cause adjustment
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) Conditionally adjusts the height of each box, by moving
the indicated edges (top and/or bot) if the height differs
by %thresh or more from %target.
(2) Use boxad == NULL for a new boxa, and boxad == boxas for in-place.
Use one of these:
boxad = boxaAdjustHeightToTarget(NULL, boxas, ...);   // new
boxaAdjustHeightToTarget(boxas, boxas, ...);  // in-place
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaAdjustHeightToTarget(*args)
    
    

    try:
        leptonica.boxEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxEqual.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxEqual(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', '*psame')       

:param[in]    box1:
:param[in]    box2:
:param[out]   psame:    1 if equal; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxEqual(*args)
    
    

    try:
        leptonica.boxaEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaEqual.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaEqual(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', 'maxdist')       
('NUMA', '**pnaindex')       
('l_int32', '*psame')       

:param[in]    boxa1:
:param[in]    boxa2:
:param[in]    maxdist:
:param[out]   pnaindex:     [optional] index array of correspondences
:param[out]   psame:        1 if equal; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The two boxa are the "same" if they contain the same
boxes and each box is within %maxdist of its counterpart
in their positions within the boxa.  This allows for
small rearrangements.  Use 0 for maxdist if the boxa
must be identical.
(2) This applies only to geometry and ordering; refcounts
are not considered.
(3) %maxdist allows some latitude in the ordering of the boxes.
For the boxa to be the "same", corresponding boxes must
be within %maxdist of each other.  Note that for large
%maxdist, we should use a hash function for efficiency.
(4) naindex[i] gives the position of the box in boxa2 that
corresponds to box i in boxa1.  It is only returned if the
boxa are equal.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaEqual(*args)
    
    

    try:
        leptonica.boxSimilar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxSimilar.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxSimilar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxSimilar(*args):
        """
        ('BOX', '*box1')       
('BOX', '*box2')       
('l_int32', 'leftdiff')       
('l_int32', 'rightdiff')       
('l_int32', 'topdiff')       
('l_int32', 'botdiff')       
('l_int32', '*psimilar')       

:param[in]    box1:
:param[in]    box2:
:param[in]    leftdiff,: rightdiff, topdiff, botdiff
:param[out]   psimilar:   1 if similar; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The values of leftdiff (etc) are the maximum allowed deviations
between the locations of the left (etc) sides.  If any side
pairs differ by more than this amount, the boxes are not similar.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxSimilar(*args)
    
    

    try:
        leptonica.boxaSimilar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSimilar.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSimilar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSimilar(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', 'leftdiff')       
('l_int32', 'rightdiff')       
('l_int32', 'topdiff')       
('l_int32', 'botdiff')       
('l_int32', 'debug')       
('l_int32', '*psimilar')       
('NUMA', '**pnasim')       

:param[in]    boxa1:
:param[in]    boxa2:
:param[in]    leftdiff,: rightdiff, topdiff, botdiff
:param[in]    debug:      output details of non-similar boxes
:param[out]   psimilar:   1 if similar; 0 otherwise
:param[out]   pnasim:     [optional] na containing 1 if similar; else 0
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See boxSimilar() for parameter usage.
(2) Corresponding boxes are taken in order in the two boxa.
(3) %nasim is an indicator array with a (0/1) for each box pair.
(4) With %nasim or debug == 1, boxes continue to be tested
after failure.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSimilar(*args)
    
    

    try:
        leptonica.boxaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaJoin(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    boxad:     dest boxa; add to this one
:param[in]    boxas:     source boxa; add from this one
:param[in]    istart:    starting index in boxas
:param[in]    iend:      ending index in boxas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This appends a clone of each indicated box in boxas to boxad
(2) istart < 0 is taken to mean 'read from the start' (istart = 0)
(3) iend < 0 means 'read to the end'
(4) if boxas == NULL or has no boxes, this is a no-op.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaJoin(*args)
    
    

    try:
        leptonica.boxaaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaJoin(*args):
        """
        ('BOXAA', '*baad')       
('BOXAA', '*baas')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    baad:     dest boxaa; add to this one
:param[in]    baas:     source boxaa; add from this one
:param[in]    istart:   starting index in baas
:param[in]    iend:     ending index in baas; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This appends a clone of each indicated boxa in baas to baad
(2) istart < 0 is taken to mean 'read from the start' (istart = 0)
(3) iend < 0 means 'read to the end'
(4) if baas == NULL, this is a no-op.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaJoin(*args)
    
    

    try:
        leptonica.boxaSplitEvenOdd.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSplitEvenOdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSplitEvenOdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSplitEvenOdd(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'fillflag')       
('BOXA', '**pboxae')       
('BOXA', '**pboxao')       

:param[in]    boxa:
:param[in]    fillflag:         1 to put invalid boxes in place; 0 to omit
:param[out]   pboxae,: pboxao   save even and odd boxes in their separate
boxa, setting the other type to invalid boxes.
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %fillflag == 1, boxae has copies of the even boxes
in their original location, and nvalid boxes are placed
in the odd array locations.  And v.v.
(2) If %fillflag == 0, boxae has only copies of the even boxes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSplitEvenOdd(*args)
    
    

    try:
        leptonica.boxaMergeEvenOdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaMergeEvenOdd.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaMergeEvenOdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaMergeEvenOdd(*args):
        """
        ('BOXA', '*boxae')       
('BOXA', '*boxao')       
('l_int32', 'fillflag')       

:param[in]    boxae:       boxes to go in even positions in merged boxa
:param[in]    boxao:       boxes to go in odd positions in merged boxa
:param[in]    fillflag:    1 if there are invalid boxes in placeholders
:returns:  boxad merged, or NULL on error

<pre>
Notes:
(1) This is essentially the inverse of boxaSplitEvenOdd().
Typically, boxae and boxao were generated by boxaSplitEvenOdd(),
and the value of %fillflag needs to be the same in both calls.
(2) If %fillflag == 1, both boxae and boxao are of the same size;
otherwise boxae may have one more box than boxao.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaMergeEvenOdd(*args)
    




class maze(object):
    """<pre>

This is a game with a pedagogical slant.  A maze is represented
by a binary image.  The ON pixels (fg) are walls.  The goal is
to navigate on OFF pixels (bg), using Manhattan steps
(N, S, E, W), between arbitrary start and end positions.
The problem is thus to find the shortest route between two points
in a binary image that are 4-connected in the bg.  This is done
with a breadth-first search, implemented with a queue.
We also use a queue of pointers to generate the maze (image).

PIX             *generateBinaryMaze()
static MAZEEL   *mazeelCreate()

PIX             *pixSearchBinaryMaze()
static l_int32   localSearchForBackground()

Generalizing a maze to a grayscale image, the search is
now for the "shortest" or least cost path, for some given
cost function.

PIX             *pixSearchGrayMaze()
</pre>




"""
    
    try:
        leptonica.generateBinaryMaze.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.generateBinaryMaze.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function generateBinaryMaze not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def generateBinaryMaze(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'xi')       
('l_int32', 'yi')       
('l_float32', 'wallps')       
('l_float32', 'ranis')       

:param[in]    w,: h  size of maze
:param[in]    xi,: yi  initial location
:param[in]    wallps: probability that a pixel to the side is ON
:param[in]    ranis: ratio of prob that pixel in forward direction
is a wall to the probability that pixel in
side directions is a wall
:returns:  pix, or NULL on error

<pre>
Notes:
(1) We have two input probability factors that determine the
density of walls and average length of straight passages.
When ranis < 1.0, you are more likely to generate a wall
to the side than going forward.  Enter 0.0 for either if
you want to use the default values.
(2) This is a type of percolation problem, and exhibits
different phases for different parameters wallps and ranis.
For larger values of these parameters, regions in the maze
are not explored because the maze generator walls them
off and cannot get through.  The boundary between the
two phases in this two-dimensional parameter space goes
near these values:
wallps       ranis
0.35         1.00
0.40         0.85
0.45         0.70
0.50         0.50
0.55         0.40
0.60         0.30
0.65         0.25
0.70         0.19
0.75         0.15
0.80         0.11
(3) Because there is a considerable amount of overhead in calling
pixGetPixel() and pixSetPixel(), this function can be sped
up with little effort using raster line pointers and the
GET_DATA* and SET_DATA* macros.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.generateBinaryMaze(*args)
    
    

    try:
        leptonica.pixSearchBinaryMaze.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSearchBinaryMaze.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSearchBinaryMaze not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSearchBinaryMaze(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xi')       
('l_int32', 'yi')       
('l_int32', 'xf')       
('l_int32', 'yf')       
('PIX', '**ppixd')       

:param[in]    pixs: 1 bpp, maze
:param[in]    xi,: yi  beginning point; use same initial point
that was used to generate the maze
:param[in]    xf,: yf  end point, or close to it
:param[out]   ppixd: [optional] maze with path illustrated, or
if no path possible, the part of the maze
that was searched
:returns:  pta shortest path, or NULL if either no path
exists or on error

<pre>
Notes:
(1) Because of the overhead in calling pixGetPixel() and
pixSetPixel(), we have used raster line pointers and the
GET_DATA* and SET_DATA* macros for many of the pix accesses.
(2) Commentary:
The goal is to find the shortest path between beginning and
end points, without going through walls, and there are many
ways to solve this problem.
We use a queue to implement a breadth-first search.  Two auxiliary
"image" data structures can be used: one to mark the visited
pixels and one to give the direction to the parent for each
visited pixel.  The first structure is used to avoid putting
pixels on the queue more than once, and the second is used
for retracing back to the origin, like the breadcrumbs in
Hansel and Gretel.  Each pixel taken off the queue is destroyed
after it is used to locate the allowed neighbors.  In fact,
only one distance image is required, if you initialize it
to some value that signifies "not yet visited."  (We use
a binary image for marking visited pixels because it is clearer.)
This method for a simple search of a binary maze is implemented in
pixSearchBinaryMaze().
An alternative method would store the (manhattan) distance
from the start point with each pixel on the queue.  The children
of each pixel get a distance one larger than the parent.  These
values can be stored in an auxiliary distance map image
that is constructed simultaneously with the search.  Once the
end point is reached, the distance map is used to backtrack
along a minimum path.  There may be several equal length
minimum paths, any one of which can be chosen this way.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSearchBinaryMaze(*args)
    
    

    try:
        leptonica.pixSearchGrayMaze.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixSearchGrayMaze.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSearchGrayMaze not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSearchGrayMaze(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xi')       
('l_int32', 'yi')       
('l_int32', 'xf')       
('l_int32', 'yf')       
('PIX', '**ppixd')       

:param[in]    pixs: 1 bpp, maze
:param[in]    xi,: yi  beginning point; use same initial point
that was used to generate the maze
:param[in]    xf,: yf  end point, or close to it
:param[out]   ppixd: [optional] maze with path illustrated, or
if no path possible, the part of the maze
that was searched
:returns:  pta shortest path, or NULL if either no path
exists or on error

Commentary:
Consider first a slight generalization of the binary maze
search problem.  Suppose that you can go through walls,
but the cost is higher say, an increment of 3 to go into
a wall pixel rather than 1?  You're still trying to find
the shortest path.  One way to do this is with an ordered
queue, and a simple way to visualize an ordered queue is as
a set of stacks, each stack being marked with the distance
of each pixel in the stack from the start.  We place the
start pixel in stack 0, pop it, and process its 4 children.
Each pixel is given a distance that is incremented from that
of its parent 0 in this case, depending on if it is a wall
pixel or not.  That value may be recorded on a distance map,
according to the algorithm below.  For children of the first
pixel, those not on a wall go in stack 1, and wall
children go in stack 3.  Stack 0 being emptied, the process
then continues with pixels being popped from stack 1.
Here is the algorithm for each child pixel.  The pixel's
distance value, were it to be placed on a stack, is compared
with the value for it that is on the distance map.  There
are three possible cases:
1 If the pixel has not yet been registered, it is pushed
on its stack and the distance is written to the map.
2 If it has previously been registered with a higher distance,
the distance on the map is relaxed to that of the
current pixel, which is then placed on its stack.
3 If it has previously been registered with an equal
or lower value, the pixel is discarded.
The pixels are popped and processed successively from
stack 1, and when stack 1 is empty, popping starts on stack 2.
This continues until the destination pixel is popped off
a stack.   The minimum path is then derived from the distance map,
going back from the end point as before.  This is just Dijkstra's
algorithm for a directed graph; here, the underlying graph
consisting of the pixels and four edges connecting each pixel
to its 4-neighbor is a special case of a directed graph, where
each edge is bi-directional.  The implementation of this generalized
maze search is left as an exercise to the reader.

Let's generalize a bit further.  Suppose the "maze" is just
a grayscale image -- think of it as an elevation map.  The cost
of moving on this surface depends on the height, or the gradient,
or whatever you want.  All that is required is that the cost
is specified and non-negative on each link between adjacent
pixels.  Now the problem becomes: find the least cost path
moving on this surface between two specified end points.
For example, if the cost across an edge between two pixels
depends on the "gradient", you can use:
cost = 1 + L_ABSdeltaV
where deltaV is the difference in value between two adjacent
pixels.  If the costs are all integers, we can still use an array
of stacks to avoid ordering the queue e.g., by using a heap sort.
This is a neat problem, because you don't even have to build a
maze -- you can can use it on any grayscale image!

Rather than using an array of stacks, a more practical
approach is to implement with a priority queue, which is
a queue that is sorted so that the elements with the largest
or smallest key values always come off first.  The
priority queue is efficiently implemented as a heap, and
this is how we do it.  Suppose you run the algorithm
using a priority queue, doing the bookkeeping with an
auxiliary image data structure that saves the distance of
each pixel put on the queue as before, according to the method
described above.  We implement it as a 2-way choice by
initializing the distance array to a large value and putting
a pixel on the queue if its distance is less than the value
found on the array.  When you finally pop the end pixel from
the queue, you're done, and you can trace the path backward,
either always going downhill or using an auxiliary image to
give you the direction to go at each step.  This is implemented
here in searchGrayMaze.

Do we really have to use a sorted queue?  Can we solve this
generalized maze with an unsorted queue of pixels?  Or even
an unsorted stack, doing a depth-first search (DFS)?
Consider a different algorithm for this generalized maze, where
we travel again breadth first, but this time use a single,
unsorted queue.  An auxiliary image is used as before to
store the distances and to determine if pixels get pushed
on the stack or dropped.  As before, we must allow pixels
to be revisited, with relaxation of the distance if a shorter
path arrives later.  As a result, we will in general have
multiple instances of the same pixel on the stack with different
distances.  However, because the queue is not ordered, some of
these pixels will be popped when another instance with a lower
distance is still on the stack.  Here, we're just popping them
in the order they go on, rather than setting up a priority
based on minimum distance.  Thus, unlike the priority queue,
when a pixel is popped we have to check the distance map to
see if a pixel with a lower distance has been put on the queue,
and, if so, we discard the pixel we just popped.  So the
"while" loop looks like this:
~ pop a pixel from the queue
~ check its distance against the distance stored in the
distance map; if larger, discard
~ otherwise, for each of its neighbors:
~ compute its distance from the start pixel
~ compare this distance with that on the distance map:
~ if the distance map value higher, relax the distance
and push the pixel on the queue
~ if the distance map value is lower, discard the pixel

How does this loop terminate?  Before, with an ordered queue,
it terminates when you pop the end pixel.  But with an unordered
queue or stack, the first time you hit the end pixel, the
distance is not guaranteed to be correct, because the pixels
along the shortest path may not have yet been visited and relaxed.
Because the shortest path can theoretically go anywhere,
we must keep going.  How do we know when to stop?   Dijkstra
uses an ordered queue to systematically remove nodes from
further consideration.  Each time a pixel is popped, we're
done with it; it's "finalized" in the Dijkstra sense because
we know the shortest path to it.  However, with an unordered
queue, the brute force answer is: stop when the queue
or stack is empty, because then every pixel in the image
has been assigned its minimum "distance" from the start pixel.

This is similar to the situation when you use a stack for the
simpler uniform-step problem: with breadth-first search BFS
the pixels on the queue are automatically ordered, so you are
done when you locate the end pixel as a neighbor of a popped pixel;
whereas depth-first search DFS, using a stack, requires,
in general, a search of every accessible pixel.  Further, if
a pixel is revisited with a smaller distance, that distance is
recorded and the pixel is put on the stack again.

But surely, you ask, can't we stop sooner?  What if the
start and end pixels are very close to each other?
OK, suppose they are, and you have very high walls and a
long snaking level path that is actually the minimum cost.
That long path can wind back and forth across the entire
maze many times before ending up at the end point, which
could be just over a wall from the start.  With the unordered
queue, you very quickly get a high distance for the end
pixel, which will be relaxed to the minimum distance only
after all the pixels of the path have been visited and placed
on the queue, multiple times for many of them.  So that's the
price for not ordering the queue!


        """
        args = _convert_params(*args)
        
        return leptonica.pixSearchGrayMaze(*args)
    




class pngio(object):
    """<pre>

Reading png through stream
PIX        *pixReadStreamPng()

Reading png header
l_int32     readHeaderPng()
l_int32     freadHeaderPng()
l_int32     readHeaderMemPng()

Reading png metadata
l_int32     fgetPngResolution()
l_int32     isPngInterlaced()
l_int32     fgetPngColormapInfo()

Writing png through stream
l_int32     pixWritePng()  [ special top level ]
l_int32     pixWriteStreamPng()
l_int32     pixSetZlibCompression()

Set flag for special read mode
void        l_pngSetReadStrip16To8()

Low-level memio utility (thanks to T. D. Hintz)
static void memio_png_write_data()
static void memio_png_flush()
static void memio_png_read_data()
static void memio_free()

Reading png from memory
PIX        *pixReadMemPng()

Writing png to memory
l_int32     pixWriteMemPng()

Documentation: libpng.txt and example.c

On input (decompression from file), palette color images
are read into an 8 bpp Pix with a colormap, and 24 bpp
3 component color images are read into a 32 bpp Pix with
rgb samples.  On output (compression to file), palette color
images are written as 8 bpp with the colormap, and 32 bpp
full color images are written compressed as a 24 bpp,
3 component color image.

In the following, we use these abbreviations:
bps == bit/sample
spp == samples/pixel
bpp == bits/pixel of image in Pix (memory)
where each component is referred to as a "sample".

For reading and writing rgb and rgba images, we read and write
alpha if it exists (spp == 4) and do not read or write if
it doesn't (spp == 3).  The alpha component can be 'removed'
simply by setting spp to 3.  In leptonica, we make relatively
little explicit use of the alpha sample.  Note that the alpha
sample in the image is also called "alpha transparency",
"alpha component" and "alpha layer."

To change the zlib compression level, use pixSetZlibCompression()
before writing the file.  The default is for standard png compression.
The zlib compression value can be set [0 ... 9], with
0     no compression (huge files)
1     fastest compression
-1    default compression  (equivalent to 6 in latest version)
9     best compression
Note that if you are using the defined constants in zlib instead
of the compression integers given above, you must include zlib.h.

There is global for determining the size of retained samples:
var_PNG_STRIP_16_to_8
and a function l_pngSetReadStrip16To8() for setting it.
The default is TRUE, which causes pixRead() to strip each 16 bit
sample down to 8 bps:
~ For 16 bps rgb (16 bps, 3 spp) --> 32 bpp rgb Pix
~ For 16 bps gray (16 bps, 1 spp) --> 8 bpp grayscale Pix
If the variable is set to FALSE, the 16 bit gray samples
are saved when read; the 16 bit rgb samples return an error.
Note: results can be non-deterministic if used with
multi-threaded applications.

Thanks to a memory buffering utility contributed by T. D. Hintz,
encoding png directly into memory (and decoding from memory)
is now enabled without the use of any temp files.  Unlike with webp,
it is necessary to preserve the stream interface to enable writing
pixa to memory.  So there are two independent but very similar
implementations of png reading and writing.
</pre>




"""
    
    try:
        leptonica.pixReadStreamPng.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamPng.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamPng(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp: file stream
:returns:  pix, or NULL on error

<pre>
Notes:
(1) If called from pixReadStream(), the stream is positioned
at the beginning of the file.
(2) To do sequential reads of png format images from a stream,
use pixReadStreamPng()
(3) Any image with alpha is converted to RGBA (spp = 4, with
equal red, green and blue channels) on reading.
There are three important cases with alpha:
(a) grayscale-with-alpha (spp = 2), where bpp = 8, and each
pixel has an associated alpha (transparency) value
in the second component of the image data.
(b) spp = 1, d = 1 with colormap and alpha in the trans array.
Transparency is usually associated with the white background.
(c) spp = 1, d = 8 with colormap and alpha in the trans array.
Each color in the colormap has a separate transparency value.
(4) We use the high level png interface, where the transforms are set
up in advance and the header and image are read with a single
call.  The more complicated interface, where the header is
read first and the buffers for the raster image are user-
allocated before reading the image, works for single images,
but I could not get it to work properly for the successive
png reads that are required by pixaReadStream().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamPng(*args)
    
    

    try:
        leptonica.readHeaderPng.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderPng.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderPng(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    filename:
:param[out]   pw:      [optional]
:param[out]   ph:      [optional]
:param[out]   pbps:    [optional]  bits/sample
:param[out]   pspp:    [optional]  samples/pixel
:param[out]   piscmap: [optional]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there is a colormap, iscmap is returned as 1; else 0.
(2) For gray+alpha, although the png records bps = 16, we
consider this as two 8 bpp samples (gray and alpha).
When a gray+alpha is read, it is converted to 32 bpp RGBA.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderPng(*args)
    
    

    try:
        leptonica.freadHeaderPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderPng.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function freadHeaderPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderPng(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    fp:       file stream
:param[out]   pw:       [optional]
:param[out]   ph:       [optional]
:param[out]   pbps:     [optional]  bits/sample
:param[out]   pspp:     [optional]  samples/pixel
:param[out]   piscmap:  [optional]
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See readHeaderPng().  We only need the first 40 bytes in the file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderPng(*args)
    
    

    try:
        leptonica.readHeaderMemPng.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemPng.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderMemPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemPng(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       
('l_int32', '*piscmap')       

:param[in]    data:
:param[in]    size:    40 bytes is sufficient
:param[out]   pw:      [optional]
:param[out]   ph:      [optional]
:param[out]   pbps:    [optional]  bits/sample
:param[out]   pspp:    [optional]  samples/pixel
:param[out]   piscmap: [optional]  input NULL to ignore
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See readHeaderPng().
(2) png colortypes (see png.h: PNG_COLOR_TYPE_*):
0:  gray; fully transparent (with tRNS) (1 spp)
2:  RGB (3 spp)
3:  colormap; colormap+alpha (with tRNS) (1 spp)
4:  gray + alpha (2 spp)
6:  RGBA (4 spp)
Note:
0 and 3 have the alpha information in a tRNS chunk
4 and 6 have separate alpha samples with each pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemPng(*args)
    
    

    try:
        leptonica.isPngInterlaced.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.isPngInterlaced.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function isPngInterlaced not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def isPngInterlaced(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pinterlaced')       

:param[in]    filename:
:param[out]   pinterlaced: 1 if interlaced png; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.isPngInterlaced(*args)
    
    

    try:
        leptonica.pixWritePng.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixWritePng.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWritePng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWritePng(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_float32', 'gamma')       

:param[in]    filename:
:param[in]    pix:
:param[in]    gamma:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Special version for writing png with a specified gamma.
When using pixWrite(), no field is given for gamma.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWritePng(*args)
    
    

    try:
        leptonica.pixWriteStreamPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixWriteStreamPng.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPng(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_float32', 'gamma')       

:param[in]    fp: file stream
:param[in]    pix:
:param[in]    gamma: use 0.0 if gamma is not defined
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) If called from pixWriteStream(), the stream is positioned
at the beginning of the file.
(2) To do sequential writes of png format images to a stream,
use pixWriteStreamPng() directly.
(3) gamma is an optional png chunk.  If no gamma value is to be
placed into the file, use gamma = 0.0.  Otherwise, if
gamma > 0.0, its value is written into the header.
(4) The use of gamma in png is highly problematic.  For an illuminating
discussion, see:  http://hsivonen.iki.fi/png-gamma/
(5) What is the effect/meaning of gamma in the png file?  This
gamma, which we can call the 'source' gamma, is the
inverse of the gamma that was used in enhance.c to brighten
or darken images.  The 'source' gamma is supposed to indicate
the intensity mapping that was done at the time the
image was captured.  Display programs typically apply a
'display' gamma of 2.2 to the output, which is intended
to linearize the intensity based on the response of
thermionic tubes (CRTs).  Flat panel LCDs have typically
been designed to give a similar response as CRTs (call it
"backward compatibility").  The 'display' gamma is
in some sense the inverse of the 'source' gamma.
jpeg encoders attached to scanners and cameras will lighten
the pixels, applying a gamma corresponding to approximately
a square-root relation of output vs input:
output = input^(gamma)
where gamma is often set near 0.4545  (1/gamma is 2.2).
This is stored in the image file.  Then if the display
program reads the gamma, it will apply a display gamma,
typically about 2.2; the product is 1.0, and the
display program produces a linear output.  This works because
the dark colors were appropriately boosted by the scanner,
as described by the 'source' gamma, so they should not
be further boosted by the display program.
(6) As an example, with xv and display, if no gamma is stored,
the program acts as if gamma were 0.4545, multiplies this by 2.2,
and does a linear rendering.  Taking this as a baseline
brightness, if the stored gamma is:
> 0.4545, the image is rendered lighter than baseline
< 0.4545, the image is rendered darker than baseline
In contrast, gqview seems to ignore the gamma chunk in png.
(7) The only valid pixel depths in leptonica are 1, 2, 4, 8, 16
and 32.  However, it is possible, and in some cases desirable,
to write out a png file using an rgb pix that has 24 bpp.
For example, the open source xpdf SplashBitmap class generates
24 bpp rgb images.  Consequently, we enable writing 24 bpp pix.
To generate such a pix, you can make a 24 bpp pix without data
and assign the data array to the pix; e.g.,
pix = pixCreateHeader(w, h, 24);
pixSetData(pix, rgbdata);
See pixConvert32To24() for an example, where we get rgbdata
from the 32 bpp pix.  Caution: do not call pixSetPadBits(),
because the alignment is wrong and you may erase part of the
last pixel on each line.
(8) If the pix has a colormap, it is written to file.  In most
situations, the alpha component is 255 for each colormap entry,
which is opaque and indicates that it should be ignored.
However, if any alpha component is not 255, it is assumed that
the alpha values are valid, and they are written to the png
file in a tRNS segment.  On readback, the tRNS segment is
identified, and the colormapped image with alpha is converted
to a 4 spp rgba image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPng(*args)
    
    

    try:
        leptonica.pixSetZlibCompression.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetZlibCompression.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSetZlibCompression not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetZlibCompression(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'compval')       

:param[in]    pix:
:param[in]    compval: zlib compression value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Valid zlib compression values are in the interval [0 ... 9],
where, as defined in zlib.h:
0         Z_NO_COMPRESSION
1         Z_BEST_SPEED    (poorest compression)
9         Z_BEST_COMPRESSION
For the default value, use either of these:
6         Z_DEFAULT_COMPRESSION
-1         (resolves to Z_DEFAULT_COMPRESSION)
(2) If you use the defined constants in zlib.h instead of the
compression integers given above, you must include zlib.h.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetZlibCompression(*args)
    
    

    try:
        leptonica.l_pngSetReadStrip16To8.argtypes = [ctypes.c_int32]
        leptonica.l_pngSetReadStrip16To8.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_pngSetReadStrip16To8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_pngSetReadStrip16To8(*args):
        """
        ('l_int32', 'flag')       

:param[in]    flag: 1 for stripping 16 bpp to 8 bpp on reading;
0 for leaving 16 bpp
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_pngSetReadStrip16To8(*args)
    
    

    try:
        leptonica.pixReadMemPng.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemPng.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemPng(*args):
        """
        ('const l_uint8', '*filedata')       
('size_t', 'filesize')       

:param[in]    filedata:   png compressed data in memory
:param[in]    filesize:   number of bytes in data
:returns:  pix, or NULL on error

<pre>
Notes:
(1) See pixReastreamPng().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemPng(*args)
    
    

    try:
        leptonica.pixWriteMemPng.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixWriteMemPng.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemPng not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPng(*args):
        """
        ('l_uint8', '**pfiledata')       
('size_t', '*pfilesize')       
('PIX', '*pix')       
('l_float32', 'gamma')       

:param[out]   pfiledata:     png encoded data of pix
:param[out]   pfilesize:     size of png encoded data
:param[in]    pix:
:param[in]    gamma:         use 0.0 if gamma is not defined
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) See pixWriteStreamPng()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPng(*args)
    




class runlength(object):
    """<pre>

Label pixels by membership in runs
PIX         *pixStrokeWidthTransform()
static PIX  *pixFindMinRunsOrthogonal()
PIX         *pixRunlengthTransform()

Find runs along horizontal and vertical lines
l_int32      pixFindHorizontalRuns()
l_int32      pixFindVerticalRuns()

Find max runs along horizontal and vertical lines
l_int32      pixFindMaxRuns()
l_int32      pixFindMaxHorizontalRunOnLine()
l_int32      pixFindMaxVerticalRunOnLine()

Compute runlength-to-membership transform on a line
l_int32      runlengthMembershipOnLine()

Make byte position LUT
l_int32      makeMSBitLocTab()

Here we're handling runs of either black or white pixels on 1 bpp
images.  The directions of the runs in the stroke width transform
are selectable from given sets of angles.  Most of the other runs
are oriented either horizontally along the raster lines or
vertically along pixel columns.
</pre>




"""
    
    try:
        leptonica.pixStrokeWidthTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixStrokeWidthTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixStrokeWidthTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixStrokeWidthTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'color')       
('l_int32', 'depth')       
('l_int32', 'nangles')       

:param[in]     pixs:      1 bpp
:param[in]     color:     0 for white runs, 1 for black runs
:param[in]     depth:     of pixd: 8 or 16 bpp
:param[in]     nangles:   2, 4, 6 or 8
:returns:   pixd   8 or 16 bpp, or NULL on error

<pre>
Notes:
(1) The dest Pix is 8 or 16 bpp, with the pixel values
equal to the stroke width in which it is a member.
The values are clipped to the max pixel value if necessary.
(2) %color determines if we're labelling white or black strokes.
(3) A pixel that is not a member of the chosen color gets
value 0; it belongs to a width of length 0 of the
chosen color.
(4) This chooses, for each dest pixel, the minimum of sets
of runlengths through each pixel.  Here are the sets:
nangles    increment          set
-------    ---------    --------------------------------
2          90       {0, 90}
4          45       {0, 45, 90, 135}
6          30       {0, 30, 60, 90, 120, 150}
8          22.5     {0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5}
(5) Runtime scales linearly with (%nangles - 2).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixStrokeWidthTransform(*args)
    
    

    try:
        leptonica.pixRunlengthTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRunlengthTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRunlengthTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRunlengthTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'color')       
('l_int32', 'direction')       
('l_int32', 'depth')       

:param[in]     pixs:        1 bpp
:param[in]     color:       0 for white runs, 1 for black runs
:param[in]     direction:   L_HORIZONTAL_RUNS, L_VERTICAL_RUNS
:param[in]     depth:       8 or 16 bpp
:returns:   pixd   8 or 16 bpp, or NULL on error

<pre>
Notes:
(1) The dest Pix is 8 or 16 bpp, with the pixel values
equal to the runlength in which it is a member.
The length is clipped to the max pixel value if necessary.
(2) %color determines if we're labelling white or black runs.
(3) A pixel that is not a member of the chosen color gets
value 0; it belongs to a run of length 0 of the
chosen color.
(4) To convert for maximum dynamic range, either linear or
log, use pixMaxDynamicRange().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRunlengthTransform(*args)
    
    

    try:
        leptonica.pixFindHorizontalRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindHorizontalRuns.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindHorizontalRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindHorizontalRuns(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'y')       
('l_int32', '*xstart')       
('l_int32', '*xend')       
('l_int32', '*pn')       

:param[in]    pix:      1 bpp
:param[in]    y:        line to traverse
:param[in]    xstart:   returns array of start positions for fg runs
:param[in]    xend:     returns array of end positions for fg runs
:param[out]   pn:       the number of runs found
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds foreground horizontal runs on a single scanline.
(2) To find background runs, use pixInvert() before applying
this function.
(3) %xstart and %xend arrays are input.  They should be
of size w/2 + 1 to insure that they can hold
the maximum number of runs in the raster line.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindHorizontalRuns(*args)
    
    

    try:
        leptonica.pixFindVerticalRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindVerticalRuns.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindVerticalRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindVerticalRuns(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', '*ystart')       
('l_int32', '*yend')       
('l_int32', '*pn')       

:param[in]    pix:      1 bpp
:param[in]    x:        line to traverse
:param[in]    ystart:   returns array of start positions for fg runs
:param[in]    yend:     returns array of end positions for fg runs
:param[out]   pn:       the number of runs found
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds foreground vertical runs on a single scanline.
(2) To find background runs, use pixInvert() before applying
this function.
(3) %ystart and %yend arrays are input.  They should be
of size h/2 + 1 to insure that they can hold
the maximum number of runs in the raster line.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindVerticalRuns(*args)
    
    

    try:
        leptonica.pixFindMaxRuns.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixFindMaxRuns.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindMaxRuns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindMaxRuns(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'direction')       
('NUMA', '**pnastart')       

:param[in]    pix:         1 bpp
:param[in]    direction:   L_HORIZONTAL_RUNS or L_VERTICAL_RUNS
:param[out]   pnastart:    [optional] start locations of longest runs
:returns:  na of lengths of runs, or NULL on error

<pre>
Notes:
(1) This finds the longest foreground runs by row or column
(2) To find background runs, use pixInvert() before applying
this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindMaxRuns(*args)
    
    

    try:
        leptonica.pixFindMaxHorizontalRunOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindMaxHorizontalRunOnLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindMaxHorizontalRunOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindMaxHorizontalRunOnLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'y')       
('l_int32', '*pxstart')       
('l_int32', '*psize')       

:param[in]    pix:       1 bpp
:param[in]    y:         line to traverse
:param[out]   pxstart:   [optional] start position
:param[out]   psize:     the size of the run
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds the longest foreground horizontal run on a scanline.
(2) To find background runs, use pixInvert() before applying
this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindMaxHorizontalRunOnLine(*args)
    
    

    try:
        leptonica.pixFindMaxVerticalRunOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindMaxVerticalRunOnLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindMaxVerticalRunOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindMaxVerticalRunOnLine(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', '*pystart')       
('l_int32', '*psize')       

:param[in]    pix:       1 bpp
:param[in]    x:         column to traverse
:param[out]   pystart:   [optional] start position
:param[out]   psize:     the size of the run
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds the longest foreground vertical run on a scanline.
(2) To find background runs, use pixInvert() before applying
this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindMaxVerticalRunOnLine(*args)
    
    

    try:
        leptonica.runlengthMembershipOnLine.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.runlengthMembershipOnLine.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function runlengthMembershipOnLine not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def runlengthMembershipOnLine(*args):
        """
        ('l_int32', '*buffer')       
('l_int32', 'size')       
('l_int32', 'depth')       
('l_int32', '*start')       
('l_int32', '*end')       
('l_int32', 'n')       

:param[in]     buffer:   into which full line of data is placed
:param[in]     size:     full size of line; w or h
:param[in]     depth:    8 or 16 bpp
:param[in]     start:    array of start positions for fg runs
:param[in]     end:      array of end positions for fg runs
:param[in]     n:        the number of runs
:returns:   0 if OK; 1 on error

<pre>
Notes:
(1) Converts a set of runlengths into a buffer of
runlength membership values.
(2) Initialization of the array gives pixels that are
not within a run the value 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.runlengthMembershipOnLine(*args)
    
    

    try:
        leptonica.makeMSBitLocTab.argtypes = [ctypes.c_int32]
        leptonica.makeMSBitLocTab.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function makeMSBitLocTab not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeMSBitLocTab(*args):
        """
        ('l_int32', 'bitval')       

:param[in]    bitval:   either 0 or 1
:returns:  table:  for an input byte, the MS bit location, starting at 0
with the MSBit in the byte, or NULL on error.

<pre>
Notes:
(1) If %bitval == 1, it finds the leftmost ON pixel in a byte;
otherwise if %bitval == 0, it finds the leftmost OFF pixel.
(2) If there are no pixels of the indicated color in the byte,
this returns 8.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeMSBitLocTab(*args)
    




class zlibmemstub(object):
    """<pre>

Stubs for zlibmem.c functions
</pre>




"""
    



class boxfunc2(object):
    """<pre>

Boxa/Box transform (shift, scale) and orthogonal rotation
BOXA            *boxaTransform()
BOX             *boxTransform()
BOXA            *boxaTransformOrdered()
BOX             *boxTransformOrdered()
BOXA            *boxaRotateOrth()
BOX             *boxRotateOrth()
BOXA            *boxaShiftWithPta()

Boxa sort
BOXA            *boxaSort()
BOXA            *boxaBinSort()
BOXA            *boxaSortByIndex()
BOXAA           *boxaSort2d()
BOXAA           *boxaSort2dByIndex()

Boxa statistics
l_int32          boxaGetRankVals()
l_int32          boxaGetMedianVals()
l_int32          boxaGetAverageSize()

Boxa array extraction
l_int32          boxaExtractAsNuma()
l_int32          boxaExtractAsPta()
PTA             *boxaExtractCorners()

Other Boxaa functions
l_int32          boxaaGetExtent()
BOXA            *boxaaFlattenToBoxa()
BOXA            *boxaaFlattenAligned()
BOXAA           *boxaEncapsulateAligned()
BOXAA           *boxaaTranspose()
l_int32          boxaaAlignBox()
</pre>




"""
    
    try:
        leptonica.boxaTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.boxaTransform.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaTransform(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    boxas:
:param[in]    shiftx:
:param[in]    shifty:
:param[in]    scalex:
:param[in]    scaley:
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) This is a very simple function that first shifts, then scales.
(2) The UL corner coordinates of all boxes in the output %boxad
(3) For the boxes in the output %boxad, the UL corner coordinates
must be non-negative, and the width and height of valid
boxes must be at least 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaTransform(*args)
    
    

    try:
        leptonica.boxTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.boxTransform.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxTransform(*args):
        """
        ('BOX', '*box')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    box:
:param[in]    shiftx:
:param[in]    shifty:
:param[in]    scalex:
:param[in]    scaley:
:returns:  boxd, or NULL on error

<pre>
Notes:
(1) This is a very simple function that first shifts, then scales.
(2) If the box is invalid, a new invalid box is returned.
(3) The UL corner coordinates must be non-negative, and the
width and height of valid boxes must be at least 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxTransform(*args)
    
    

    try:
        leptonica.boxaTransformOrdered.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaTransformOrdered.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaTransformOrdered not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaTransformOrdered(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'order')       

:param[in]    boxas:
:param[in]    shiftx:
:param[in]    shifty:
:param[in]    scalex:
:param[in]    scaley:
:param[in]    xcen,: ycen    center of rotation
:param[in]    angle:         in radians; clockwise is positive
:param[in]    order:         one of 6 combinations: L_TR_SC_RO, ...
:returns:  boxd, or NULL on error

<pre>
shift, scaling and rotation, and the order of the
transforms is specified.
(2) Although these operations appear to be on an infinite
2D plane, in practice the region of interest is clipped
to a finite image.  The center of rotation is usually taken
with respect to the image (either the UL corner or the
center).  A translation can have two very different effects:
(a) Moves the boxes across the fixed image region.
(b) Moves the image origin, causing a change in the image
region and an opposite effective translation of the boxes.
This function should only be used for (a), where the image
region is fixed on translation.  If the image region is
changed by the translation, use instead the functions
in affinecompose.c, where the image region and rotation
center can be computed from the actual clipping due to
translation of the image origin.
(3) See boxTransformOrdered() for usage and implementation details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaTransformOrdered(*args)
    
    

    try:
        leptonica.boxTransformOrdered.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxTransformOrdered.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxTransformOrdered not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxTransformOrdered(*args):
        """
        ('BOX', '*boxs')       
('l_int32', 'shiftx')       
('l_int32', 'shifty')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_int32', 'xcen')       
('l_int32', 'ycen')       
('l_float32', 'angle')       
('l_int32', 'order')       

:param[in]    boxs:
:param[in]    shiftx:
:param[in]    shifty:
:param[in]    scalex:
:param[in]    scaley:
:param[in]    xcen,: ycen   center of rotation
:param[in]    angle:        in radians; clockwise is positive
:param[in]    order:        one of 6 combinations: L_TR_SC_RO, ...
:returns:  boxd, or NULL on error

<pre>
Notes:
(1) This allows a sequence of linear transforms, composed of
shift, scaling and rotation, where the order of the
transforms is specified.
(2) The rotation is taken about a point specified by (xcen, ycen).
Let the components of the vector from the center of rotation
to the box center be (xdif, ydif):
xdif = (bx + 0.5 * bw) - xcen
ydif = (by + 0.5 * bh) - ycen
Then the box center after rotation has new components:
bxcen = xcen + xdif * cosa + ydif * sina
bycen = ycen + ydif * cosa - xdif * sina
where cosa and sina are the cos and sin of the angle,
and the enclosing box for the rotated box has size:
rw = |bw * cosa| + |bh * sina|
rh = |bh * cosa| + |bw * sina|
where bw and bh are the unrotated width and height.
Then the box UL corner (rx, ry) is
rx = bxcen - 0.5 * rw
ry = bycen - 0.5 * rh
(3) The center of rotation specified by args %xcen and %ycen
is the point BEFORE any translation or scaling.  If the
rotation is not the first operation, this function finds
the actual center at the time of rotation.  It does this
by making the following assumptions:
(1) Any scaling is with respect to the UL corner, so
that the center location scales accordingly.
(2) A translation does not affect the center of
the image; it just moves the boxes.
We always use assumption (1).  However, assumption (2)
will be incorrect if the apparent translation is due
to a clipping operation that, in effect, moves the
origin of the image.  In that case, you should NOT use
these simple functions.  Instead, use the functions
in affinecompose.c, where the rotation center can be
computed from the actual clipping due to translation
of the image origin.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxTransformOrdered(*args)
    
    

    try:
        leptonica.boxaRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaRotateOrth.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaRotateOrth(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'rotation')       

:param[in]    boxas:
:param[in]    w,: h       of image in which the boxa is embedded
:param[in]    rotation:   0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;
all rotations are clockwise
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) See boxRotateOrth() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaRotateOrth(*args)
    
    

    try:
        leptonica.boxRotateOrth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxRotateOrth.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxRotateOrth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxRotateOrth(*args):
        """
        ('BOX', '*box')       
('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'rotation')       

:param[in]    box:
:param[in]    w,: h       of image in which the box is embedded
:param[in]    rotation:   0 = noop, 1 = 90 deg, 2 = 180 deg, 3 = 270 deg;
all rotations are clockwise
:returns:  boxd, or NULL on error

<pre>
Notes:
(1) Rotate the image with the embedded box by the specified amount.
(2) After rotation, the rotated box is always measured with
respect to the UL corner of the image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxRotateOrth(*args)
    
    

    try:
        leptonica.boxaShiftWithPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaShiftWithPta.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaShiftWithPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaShiftWithPta(*args):
        """
        ('BOXA', '*boxas')       
('PTA', '*pta')       
('l_int32', 'dir')       

:param[in]    boxas:
:param[in]    pta:       aligned with the boxes; determines shift amount
:param[in]    dir:       +1 to shift by the values in pta; -1 to shift
by the negative of the values in the pta.
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) In use, %pta may come from the UL corners of of a boxa, each
of whose boxes contains the corresponding box of %boxas
within it.  The output %boxad is then a boxa in the (global)
coordinates of the containing boxa.  So the input %pta
could come from boxaExtractCorners().
(2) The operations with %dir == 1 and %dir == -1 are inverses if
called in order (1, -1).  Starting with an input boxa and
calling twice with these values of %dir results in a boxa
identical to the input.  However, because box parameters can
never be negative, calling in the order (-1, 1) may result
in clipping at the left side and the top.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaShiftWithPta(*args)
    
    

    try:
        leptonica.boxaSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaSort.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSort(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       

:param[in]    boxas:
:param[in]    sorttype:   L_SORT_BY_X, L_SORT_BY_Y,
L_SORT_BY_RIGHT, L_SORT_BY_BOT,
L_SORT_BY_WIDTH, L_SORT_BY_HEIGHT,
L_SORT_BY_MIN_DIMENSION, L_SORT_BY_MAX_DIMENSION,
L_SORT_BY_PERIMETER, L_SORT_BY_AREA,
L_SORT_BY_ASPECT_RATIO
:param[in]    sortorder:  L_SORT_INCREASING, L_SORT_DECREASING
:param[out]   pnaindex:   [optional] index of sorted order into
original array
:returns:  boxad sorted version of boxas, or NULL on error

<pre>
Notes:
(1) An empty boxa returns a copy, with a warning.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSort(*args)
    
    

    try:
        leptonica.boxaBinSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaBinSort.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaBinSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaBinSort(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       

:param[in]    boxas:
:param[in]    sorttype:    L_SORT_BY_X, L_SORT_BY_Y, L_SORT_BY_WIDTH,
L_SORT_BY_HEIGHT, L_SORT_BY_PERIMETER
:param[in]    sortorder:   L_SORT_INCREASING, L_SORT_DECREASING
:param[out]   pnaindex:    [optional] index of sorted order into
original array
:returns:  boxad sorted version of boxas, or NULL on error

<pre>
Notes:
(1) For a large number of boxes (say, greater than 1000), this
O(n) binsort is much faster than the O(nlogn) shellsort.
For 5000 components, this is over 20x faster than boxaSort().
(2) Consequently, boxaSort() calls this function if it will
likely go much faster.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaBinSort(*args)
    
    

    try:
        leptonica.boxaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSortByIndex.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSortByIndex(*args):
        """
        ('BOXA', '*boxas')       
('NUMA', '*naindex')       

:param[in]    boxas:
:param[in]    naindex:    na that maps from the new boxa to the input boxa
:returns:  boxad sorted, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSortByIndex(*args)
    
    

    try:
        leptonica.boxaSort2d.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSort2d.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSort2d not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSort2d(*args):
        """
        ('BOXA', '*boxas')       
('NUMAA', '**pnaad')       
('l_int32', 'delta1')       
('l_int32', 'delta2')       
('l_int32', 'minh1')       

:param[in]    boxas:
:param[out]   pnaad:    [optional] numaa with sorted indices
whose values are the indices of the input array
:param[in]    delta1:   min separation that permits aggregation of a box
onto a boxa of horizontally-aligned boxes; pass 1
:param[in]    delta2:   min separation that permits aggregation of a box
onto a boxa of horizontally-aligned boxes; pass 2
:param[in]    minh1:    components less than this height either join an
existing boxa or are set aside for pass 2
:returns:  baa 2d sorted version of boxa, or NULL on error

<pre>
Notes:
(1) The final result is a sort where the 'fast scan' direction is
left to right, and the 'slow scan' direction is from top
to bottom.  Each boxa in the baa represents a sorted set
of boxes from left to right.
(2) Three passes are used to aggregate the boxas, which can correspond
to characters or words in a line of text.  In pass 1, only
taller components, which correspond to xheight or larger,
are permitted to start a new boxa.  In pass 2, the remaining
vertically-challenged components are allowed to join an
existing boxa or start a new one.  In pass 3, boxa whose extent
is overlapping are joined.  After that, the boxes in each
boxa are sorted horizontally, and finally the boxa are
sorted vertically.
(3) If %delta1 > 0, the first pass allows aggregation when
boxes in the same boxa do not overlap vertically.  In fact,
%delta1 is the max distance by which they can miss and still
be aggregated.  If %delta1 < 0, the box must have vertical
overlap of at least abs(%delta1) with the boxa before it
can be merged.  Similar for delta2 on the second pass.
(4) On the first pass, any component of height less than minh1
cannot start a new boxa; it's put aside for later insertion.
(5) On the second pass, any small component that doesn't align
with an existing boxa can start a new one.
(6) This can be used to identify lines of text from
character or word bounding boxes.
(7) Typical values for the input parameters on 300 ppi text are:
delta1 ~ 0
delta2 ~ 0
minh1 ~ 5
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSort2d(*args)
    
    

    try:
        leptonica.boxaSort2dByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSort2dByIndex.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSort2dByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSort2dByIndex(*args):
        """
        ('BOXA', '*boxas')       
('NUMAA', '*naa')       

:param[in]    boxas:
:param[in]    naa:     numaa that maps from the new baa to the input boxa
:returns:  baa sorted boxaa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSort2dByIndex(*args)
    
    

    try:
        leptonica.boxaExtractAsNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaExtractAsNuma.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaExtractAsNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractAsNuma(*args):
        """
        ('BOXA', '*boxa')       
('NUMA', '**pnal')       
('NUMA', '**pnat')       
('NUMA', '**pnar')       
('NUMA', '**pnab')       
('NUMA', '**pnaw')       
('NUMA', '**pnah')       
('l_int32', 'keepinvalid')       

:param[in]    boxa:
:param[out]   pnal:          [optional] array of left locations
:param[out]   pnat:          [optional] array of top locations
:param[out]   pnar:          [optional] array of right locations
:param[out]   pnab:          [optional] array of bottom locations
:param[out]   pnaw:          [optional] array of widths
:param[out]   pnah:          [optional] array of heights
:param[in]    keepinvalid:   1 to keep invalid boxes; 0 to remove them
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If you are counting or sorting values, such as determining
rank order, you must remove invalid boxes.
(2) If you are parametrizing the values, or doing an evaluation
where the position in the boxa sequence is important, you
must replace the invalid boxes with valid ones before
doing the extraction. This is easily done with boxaFillSequence().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractAsNuma(*args)
    
    

    try:
        leptonica.boxaExtractAsPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaExtractAsPta.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaExtractAsPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractAsPta(*args):
        """
        ('BOXA', '*boxa')       
('PTA', '**pptal')       
('PTA', '**pptat')       
('PTA', '**pptar')       
('PTA', '**pptab')       
('PTA', '**pptaw')       
('PTA', '**pptah')       
('l_int32', 'keepinvalid')       

:param[in]    boxa:
:param[out]   pptal:         [optional] array of left locations vs. index
:param[out]   pptat:         [optional] array of top locations vs. index
:param[out]   pptar:         [optional] array of right locations vs. index
:param[out]   pptab:         [optional] array of bottom locations vs. index
:param[out]   pptaw:         [optional] array of widths vs. index
:param[out]   pptah:         [optional] array of heights vs. index
:param[in]    keepinvalid:   1 to keep invalid boxes; 0 to remove them
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For most applications, such as counting, sorting, fitting
to some parametrized form, plotting or filtering in general,
you should remove the invalid boxes.  Each pta saves the
box index in the x array, so replacing invalid boxes by
filling with boxaFillSequence(), which is required for
boxaExtractAsNuma(), is not necessary.
(2) If invalid boxes are retained, each one will result in
entries (typically 0) in all selected output pta.
(3) Other boxa --> pta functions are:
boxaExtractCorners(): extracts any of the four corners as a pta.
boxaConvertToPta(): extracts sufficient number of corners
to allow reconstruction of the original boxa from the pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractAsPta(*args)
    
    

    try:
        leptonica.boxaExtractCorners.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaExtractCorners.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaExtractCorners not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractCorners(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'loc')       

:param[in]    boxa:
:param[in]    loc:       L_UPPER_LEFT, L_UPPER_RIGHT, L_LOWER_LEFT,
L_LOWER_RIGHT, L_BOX_CENTER
:returns:  pta of requested coordinates, or NULL on error

<pre>
Notes:
(1) Extracts (0,0) for invalid boxes.
(2) Other boxa --> pta functions are:
boxaExtractAsPta(): allows extraction of any dimension
and/or side location, with each in a separate pta.
boxaConvertToPta(): extracts sufficient number of corners
to allow reconstruction of the original boxa from the pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractCorners(*args)
    
    

    try:
        leptonica.boxaGetRankVals.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetRankVals.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetRankVals not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetRankVals(*args):
        """
        ('BOXA', '*boxa')       
('l_float32', 'fract')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pr')       
('l_int32', '*pb')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    boxa:
:param[in]    fract:   use 0.0 for smallest, 1.0 for largest width and height
:param[out]   px:      [optional] rank value of x (left side)
:param[out]   py:      [optional] rank value of y (top side)
:param[out]   pr:      [optional] rank value of right side
:param[out]   pb:      [optional] rank value of bottom side
:param[out]   pw:      [optional] rank value of width
:param[out]   ph:      [optional] rank value of height
:returns:  0 if OK, 1 on error or if the boxa is empty or has no valid boxes

<pre>
Notes:
(1) This function does not assume that all boxes in the boxa are valid
(2) The six box parameters are sorted independently.
For rank order, the width and height are sorted in increasing
order.  But what does it mean to sort x and y in "rank order"?
If the boxes are of comparable size and somewhat
aligned (e.g., from multiple images), it makes some sense
to give a "rank order" for x and y by sorting them in
decreasing order.  (By the same argument, we choose to sort
the r and b sides in increasing order.)  In general, the
interpretation of a rank order on x and y (or on r and b)
is highly application dependent.  In summary:
~ x and y are sorted in decreasing order
~ r and b are sorted in increasing order
~ w and h are sorted in increasing order
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetRankVals(*args)
    
    

    try:
        leptonica.boxaGetMedianVals.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetMedianVals.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetMedianVals not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetMedianVals(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*px')       
('l_int32', '*py')       
('l_int32', '*pr')       
('l_int32', '*pb')       
('l_int32', '*pw')       
('l_int32', '*ph')       

:param[in]    boxa:
:param[out]   px:     [optional] median value of x (left side)
:param[out]   py:     [optional] median value of y (top side)
:param[out]   pr:     [optional] median value of right side
:param[out]   pb:     [optional] median value of bottom side
:param[out]   pw:     [optional] median value of width
:param[out]   ph:     [optional] median value of height
:returns:  0 if OK, 1 on error or if the boxa is empty or has no valid boxes

<pre>
Notes:
(1) See boxaGetRankVals()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetMedianVals(*args)
    
    

    try:
        leptonica.boxaGetAverageSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetAverageSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetAverageSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetAverageSize(*args):
        """
        ('BOXA', '*boxa')       
('l_float32', '*pw')       
('l_float32', '*ph')       

:param[in]    boxa:
:param[out]   pw:     [optional] average width
:param[out]   ph:     [optional] average height
:returns:  0 if OK, 1 on error or if the boxa is empty


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetAverageSize(*args)
    
    

    try:
        leptonica.boxaaGetExtent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaGetExtent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaGetExtent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaGetExtent(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('BOX', '**pbox')       
('BOXA', '**pboxa')       

:param[in]    baa:
:param[out]   pw:      [optional] width
:param[out]   ph:      [optional] height
:param[out]   pbox:    [optional]  minimum box containing all boxa
in boxaa
:param[out]   pboxa:   [optional]  boxa containing all boxes in each
boxa in the boxaa
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The returned w and h are the minimum size image
that would contain all boxes untranslated.
(2) Each box in the returned boxa is the minimum box required to
hold all the boxes in the respective boxa of baa.
(3) If there are no valid boxes in a boxa, the box corresponding
to its extent has all fields set to 0 (an invalid box).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaGetExtent(*args)
    
    

    try:
        leptonica.boxaaFlattenToBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaFlattenToBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaFlattenToBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaFlattenToBoxa(*args):
        """
        ('BOXAA', '*baa')       
('NUMA', '**pnaindex')       
('l_int32', 'copyflag')       

:param[in]    baa:
:param[out]   pnaindex:   [optional] the boxa index in the baa
:param[in]    copyflag:   L_COPY or L_CLONE
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) This 'flattens' the baa to a boxa, taking the boxes in
order in the first boxa, then the second, etc.
(2) If a boxa is empty, we generate an invalid, placeholder box
of zero size.  This is useful when converting from a baa
where each boxa has either 0 or 1 boxes, and it is necessary
to maintain a 1:1 correspondence between the initial
boxa array and the resulting box array.
(3) If &naindex is defined, we generate a Numa that gives, for
each box in the baa, the index of the boxa to which it belongs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaFlattenToBoxa(*args)
    
    

    try:
        leptonica.boxaaFlattenAligned.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaaFlattenAligned.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaFlattenAligned not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaFlattenAligned(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', 'num')       
('BOX', '*fillerbox')       
('l_int32', 'copyflag')       

:param[in]    baa:
:param[in]    num:         number extracted from each
:param[in]    fillerbox:   [optional] that fills if necessary
:param[in]    copyflag:    L_COPY or L_CLONE
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) This 'flattens' the baa to a boxa, taking the first %num
boxes from each boxa.
(2) In each boxa, if there are less than %num boxes, we preserve
the alignment between the input baa and the output boxa
by inserting one or more fillerbox(es) or, if %fillerbox == NULL,
one or more invalid placeholder boxes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaFlattenAligned(*args)
    
    

    try:
        leptonica.boxaEncapsulateAligned.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaEncapsulateAligned.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaEncapsulateAligned not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaEncapsulateAligned(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'num')       
('l_int32', 'copyflag')       

:param[in]    boxa:
:param[in]    num:        number put into each boxa in the baa
:param[in]    copyflag:   L_COPY or L_CLONE
:returns:  baa, or NULL on error

<pre>
Notes:
(1) This puts %num boxes from the input %boxa into each of a
set of boxa within an output baa.
(2) This assumes that the boxes in %boxa are in sets of %num each.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaEncapsulateAligned(*args)
    
    

    try:
        leptonica.boxaaTranspose.argtypes = [ctypes.c_void_p]
        leptonica.boxaaTranspose.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaTranspose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaTranspose(*args):
        """
        ('BOXAA', '*baas')       

:param[in]    baas:
:returns:  baad, or NULL on error

<pre>
Notes:
(1) If you think of a boxaa as a 2D array of boxes that is accessed
row major, then each row is represented by one of the boxa.
This function creates a new boxaa related to the input boxaa
as a column major traversal of the input boxaa.
(2) For example, if %baas has 2 boxa, each with 10 boxes, then
%baad will have 10 boxa, each with 2 boxes.
(3) Require for this transpose operation that each boxa in
%baas has the same number of boxes.  This operation is useful
when the i-th boxes in each boxa are meaningfully related.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaTranspose(*args)
    
    

    try:
        leptonica.boxaaAlignBox.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaaAlignBox.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaAlignBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaAlignBox(*args):
        """
        ('BOXAA', '*baa')       
('BOX', '*box')       
('l_int32', 'delta')       
('l_int32', '*pindex')       

:param[in]    baa:
:param[in]    box:      to be aligned with bext boxa in the baa, if possible
:param[in]    delta:    amount by which consecutive components can miss
in overlap and still be included in the array
:param[out]   pindex:   index of boxa with best overlap, or if none match,
this is the index of the next boxa to be generated
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is not greedy.  It finds the boxa whose vertical
extent has the closest overlap with the input box.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaAlignBox(*args)
    




class finditalic(object):
    """"""
    
    try:
        leptonica.pixItalicWords.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixItalicWords.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixItalicWords not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixItalicWords(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxaw')       
('PIX', '*pixw')       
('BOXA', '**pboxa')       
('l_int32', 'debugflag')       

:param[in]    pixs:       1 bpp
:param[in]    boxaw:      [optional] word bounding boxes; can be NULL
:param[in]    pixw:       [optional] word box mask; can be NULL
:param[out]   pboxa:      boxa of italic words
:param[in]    debugflag:  1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) You can input the bounding boxes for the words in one of
two forms: as bounding boxes (%boxaw) or as a word mask with
the word bounding boxes filled (%pixw).  For example,
to compute %pixw, you can use pixWordMaskByDilation().
(2) Alternatively, you can set both of these inputs to NULL,
in which case the word mask is generated here.  This is
done by dilating and closing the input image to connect
letters within a word, while leaving the words separated.
The parameters are chosen under the assumption that the
input is 10 to 12 pt text, scanned at about 300 ppi.
(3) sel_ital1 and sel_ital2 detect the right edges that are
nearly vertical, at approximately the angle of italic
strokes.  We use the right edge to avoid getting seeds
from lower-case 'y'.  The typical italic slant has a smaller
angle with the vertical than the 'W', so in most cases we
will not trigger on the slanted lines in the 'W'.
(4) Note that sel_ital2 is shorter than sel_ital1.  It is
more appropriate for a typical font scanned at 200 ppi.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixItalicWords(*args)
    




class morphapp(object):
    """<pre>

These are some useful and/or interesting composite
image processing operations, of the type that are often
useful in applications.  Most are morphological in
nature.

Extraction of boundary pixels
PIX       *pixExtractBoundary()

Selective morph sequence operation under mask
PIX       *pixMorphSequenceMasked()

Selective morph sequence operation on each component
PIX       *pixMorphSequenceByComponent()
PIXA      *pixaMorphSequenceByComponent()

Selective morph sequence operation on each region
PIX       *pixMorphSequenceByRegion()
PIXA      *pixaMorphSequenceByRegion()

Union and intersection of parallel composite operations
PIX       *pixUnionOfMorphOps()
PIX       *pixIntersectionOfMorphOps()

Selective connected component filling
PIX       *pixSelectiveConnCompFill()

Removal of matched patterns
PIX       *pixRemoveMatchedPattern()

Display of matched patterns
PIX       *pixDisplayMatchedPattern()

Extension of pixa by iterative erosion or dilation (and by scaling)
PIXA      *pixaExtendByMorph()
PIXA      *pixaExtendByScaling()

Iterative morphological seed filling (don't use for real work)
PIX       *pixSeedfillMorph()

Granulometry on binary images
NUMA      *pixRunHistogramMorph()

Composite operations on grayscale images
PIX       *pixTophat()
PIX       *pixHDome()
PIX       *pixFastTophat()
PIX       *pixMorphGradient()

Centroid of component
PTA       *pixaCentroids()
l_int32    pixCentroid()
</pre>




"""
    
    try:
        leptonica.pixExtractBoundary.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBoundary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractBoundary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBoundary(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:    1 bpp
:param[in]    type:    0 for background pixels; 1 for foreground pixels
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Extracts the fg or bg boundary pixels for each component.
Components are assumed to end at the boundary of pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBoundary(*args)
    
    

    try:
        leptonica.pixMorphSequenceMasked.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixMorphSequenceMasked.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphSequenceMasked not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceMasked(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('const char', '*sequence')       
('l_int32', 'dispsep')       

:param[in]    pixs:       1 bpp
:param[in]    pixm:       [optional] 1 bpp mask
:param[in]    sequence:   string specifying sequence of operations
:param[in]    dispsep:    horizontal separation in pixels between
successive displays; use zero to suppress display
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This applies the morph sequence to the image, but only allows
changes in pixs for pixels under the background of pixm.
(5) If pixm is NULL, this is just pixMorphSequence().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceMasked(*args)
    
    

    try:
        leptonica.pixMorphSequenceByComponent.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMorphSequenceByComponent.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphSequenceByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceByComponent(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'connectivity')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('BOXA', '**pboxa')       

:param[in]    pixs:          1 bpp
:param[in]    sequence:      string specifying sequence
:param[in]    connectivity:  4 or 8
:param[in]    minw:          min width to consider; use 0 or 1 for any width
:param[in]    minh:          min height to consider; use 0 or 1 for any height
:param[out]   pboxa:         [optional] return boxa of c.c. in pixs
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See pixMorphSequence() for composing operation sequences.
(2) This operates separately on each c.c. in the input pix.
(3) The dilation does NOT increase the c.c. size; it is clipped
to the size of the original c.c.   This is necessary to
keep the c.c. independent after the operation.
(4) You can specify that the width and/or height must equal
or exceed a minimum size for the operation to take place.
(5) Use NULL for boxa to avoid returning the boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceByComponent(*args)
    
    

    try:
        leptonica.pixaMorphSequenceByComponent.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMorphSequenceByComponent.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaMorphSequenceByComponent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMorphSequenceByComponent(*args):
        """
        ('PIXA', '*pixas')       
('const char', '*sequence')       
('l_int32', 'minw')       
('l_int32', 'minh')       

:param[in]    pixas:       of 1 bpp pix
:param[in]    sequence:    string specifying sequence
:param[in]    minw:        min width to consider; use 0 or 1 for any width
:param[in]    minh:        min height to consider; use 0 or 1 for any height
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) See pixMorphSequence() for composing operation sequences.
(2) This operates separately on each c.c. in the input pixa.
(3) You can specify that the width and/or height must equal
or exceed a minimum size for the operation to take place.
(4) The input pixa should have a boxa giving the locations
of the pix components.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMorphSequenceByComponent(*args)
    
    

    try:
        leptonica.pixMorphSequenceByRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMorphSequenceByRegion.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphSequenceByRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceByRegion(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('const char', '*sequence')       
('l_int32', 'connectivity')       
('l_int32', 'minw')       
('l_int32', 'minh')       
('BOXA', '**pboxa')       

:param[in]    pixs:          1 bpp
:param[in]    pixm:          mask specifying regions
:param[in]    sequence:      string specifying sequence
:param[in]    connectivity:  4 or 8, used on mask
:param[in]    minw:          min width to consider; use 0 or 1 for any width
:param[in]    minh:          min height to consider; use 0 or 1 for any height
:param[out]   pboxa:         [optional] return boxa of c.c. in pixm
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See pixMorphCompSequence() for composing operation sequences.
(2) This operates separately on the region in pixs corresponding
to each c.c. in the mask pixm.  It differs from
pixMorphSequenceByComponent() in that the latter does not have
a pixm (mask), but instead operates independently on each
component in pixs.
(3) Dilation will NOT increase the region size; the result
is clipped to the size of the mask region.  This is necessary
to make regions independent after the operation.
(4) You can specify that the width and/or height of a region must
equal or exceed a minimum size for the operation to take place.
(5) Use NULL for %pboxa to avoid returning the boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceByRegion(*args)
    
    

    try:
        leptonica.pixaMorphSequenceByRegion.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaMorphSequenceByRegion.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaMorphSequenceByRegion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaMorphSequenceByRegion(*args):
        """
        ('PIX', '*pixs')       
('PIXA', '*pixam')       
('const char', '*sequence')       
('l_int32', 'minw')       
('l_int32', 'minh')       

:param[in]    pixs:       1 bpp
:param[in]    pixam:      of 1 bpp mask elements
:param[in]    sequence:   string specifying sequence
:param[in]    minw:       min width to consider; use 0 or 1 for any width
:param[in]    minh:       min height to consider; use 0 or 1 for any height
:returns:  pixad, or NULL on error

<pre>
Notes:
(1) See pixMorphSequence() for composing operation sequences.
(2) This operates separately on each region in the input pixs
defined by the components in pixam.
(3) You can specify that the width and/or height of a mask
component must equal or exceed a minimum size for the
operation to take place.
(4) The input pixam should have a boxa giving the locations
of the regions in pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaMorphSequenceByRegion(*args)
    
    

    try:
        leptonica.pixUnionOfMorphOps.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixUnionOfMorphOps.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixUnionOfMorphOps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUnionOfMorphOps(*args):
        """
        ('PIX', '*pixs')       
('SELA', '*sela')       
('l_int32', 'type')       

:param[in]    pixs:    1 bpp
:param[in]    sela:
:param[in]    type:    L_MORPH_DILATE, etc.
:returns:  pixd union of the specified morphological operation
on pixs for each Sel in the Sela, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixUnionOfMorphOps(*args)
    
    

    try:
        leptonica.pixIntersectionOfMorphOps.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixIntersectionOfMorphOps.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixIntersectionOfMorphOps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixIntersectionOfMorphOps(*args):
        """
        ('PIX', '*pixs')       
('SELA', '*sela')       
('l_int32', 'type')       

:param[in]    pixs:    1 bpp
:param[in]    sela:
:param[in]    type:    L_MORPH_DILATE, etc.
:returns:  pixd intersection of the specified morphological operation
on pixs for each Sel in the Sela, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixIntersectionOfMorphOps(*args)
    
    

    try:
        leptonica.pixSelectiveConnCompFill.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSelectiveConnCompFill.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectiveConnCompFill not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectiveConnCompFill(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('l_int32', 'minw')       
('l_int32', 'minh')       

:param[in]    pixs:          1 bpp
:param[in]    connectivity:  4 or 8
:param[in]    minw:          min width to consider; use 0 or 1 for any width
:param[in]    minh:          min height to consider; use 0 or 1 for any height
:returns:  pix with holes filled in selected c.c., or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectiveConnCompFill(*args)
    
    

    try:
        leptonica.pixRemoveMatchedPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveMatchedPattern.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveMatchedPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveMatchedPattern(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixp')       
('PIX', '*pixe')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_int32', 'dsize')       

:param[in]    pixs:     input image, 1 bpp
:param[in]    pixp:     pattern to be removed from image, 1 bpp
:param[in]    pixe:     image after erosion by Sel that approximates pixp
:param[in]    x0,: y0   center of Sel
:param[in]    dsize:    number of pixels on each side by which pixp is
dilated before being subtracted from pixs;
valid values are {0, 1, 2, 3, 4}
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is in-place.
(2) You can use various functions in selgen to create a Sel
that is used to generate pixe from pixs.
(3) This function is applied after pixe has been computed.
It finds the centroid of each c.c., and subtracts
(the appropriately dilated version of) pixp, with the center
of the Sel used to align pixp with pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveMatchedPattern(*args)
    
    

    try:
        leptonica.pixDisplayMatchedPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_float, ctypes.c_int32]
        leptonica.pixDisplayMatchedPattern.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDisplayMatchedPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDisplayMatchedPattern(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixp')       
('PIX', '*pixe')       
('l_int32', 'x0')       
('l_int32', 'y0')       
('l_uint32', 'color')       
('l_float32', 'scale')       
('l_int32', 'nlevels')       

:param[in]    pixs:      input image, 1 bpp
:param[in]    pixp:      pattern to be removed from image, 1 bpp
:param[in]    pixe:      image after erosion by Sel that approximates pixp
:param[in]    x0,: y0    center of Sel
:param[in]    color:     to paint the matched patterns; 0xrrggbb00
:param[in]    scale:     reduction factor for output pixd
:param[in]    nlevels:   if scale < 1.0, threshold to this number of levels
:returns:  pixd 8 bpp, colormapped, or NULL on error

<pre>
Notes:
(1) A 4 bpp colormapped image is generated.
(2) If scale <= 1.0, do scale to gray for the output, and threshold
to nlevels of gray.
(3) You can use various functions in selgen to create a Sel
that will generate pixe from pixs.
(4) This function is applied after pixe has been computed.
It finds the centroid of each c.c., and colors the output
pixels using pixp (appropriately aligned) as a stencil.
Alignment is done using the origin of the Sel and the
centroid of the eroded image to place the stencil pixp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDisplayMatchedPattern(*args)
    
    

    try:
        leptonica.pixaExtendByMorph.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaExtendByMorph.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaExtendByMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaExtendByMorph(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'type')       
('l_int32', 'niters')       
('SEL', '*sel')       
('l_int32', 'include')       

:param[in]    pixas:
:param[in]    type:       L_MORPH_DILATE, L_MORPH_ERODE
:param[in]    niters:
:param[in]    sel:        used for dilation, erosion; uses 2x2 if null
:param[in]    include:    1 to include a copy of the input pixas in pixad;
0 to omit
:returns:  pixad   with derived pix, using all iterations, or NULL on error

<pre>
Notes:
(1) This dilates or erodes every pix in %pixas, iteratively,
using the input Sel (or, if null, a 2x2 Sel by default),
and puts the results in %pixad.
(2) If %niters <= 0, this is a no-op; it returns a clone of pixas.
(3) If %include == 1, the output %pixad contains all the pix
in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
used later to join pixas with pixad.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaExtendByMorph(*args)
    
    

    try:
        leptonica.pixaExtendByScaling.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaExtendByScaling.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaExtendByScaling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaExtendByScaling(*args):
        """
        ('PIXA', '*pixas')       
('NUMA', '*nasc')       
('l_int32', 'type')       
('l_int32', 'include')       

:param[in]    pixas:
:param[in]    nasc:     numa of scaling factors
:param[in]    type:     L_HORIZ, L_VERT, L_BOTH_DIRECTIONS
:param[in]    include:  1 to include a copy of the input pixas in pixad;
0 to omit
:returns:  pixad   with derived pix, using all scalings, or NULL on error

<pre>
Notes:
(1) This scales every pix in %pixas by each factor in %nasc.
and puts the results in %pixad.
(2) If %include == 1, the output %pixad contains all the pix
in %pixas.  Otherwise, it doesn't, but pixaJoin() can be
used later to join pixas with pixad.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaExtendByScaling(*args)
    
    

    try:
        leptonica.pixSeedfillMorph.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillMorph.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillMorph(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'maxiters')       
('l_int32', 'connectivity')       

:param[in]    pixs: seed
:param[in]    pixm: mask
:param[in]    maxiters:      use 0 to go to completion
:param[in]    connectivity:  4 or 8
:returns:  pixd after filling into the mask or NULL on error

<pre>
Notes:
(1) This is in general a very inefficient method for filling
from a seed into a mask.  Use it for a small number of iterations,
but if you expect more than a few iterations, use
pixSeedfillBinary().
(2) We use a 3x3 brick SEL for 8-cc filling and a 3x3 plus SEL for 4-cc.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillMorph(*args)
    
    

    try:
        leptonica.pixRunHistogramMorph.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRunHistogramMorph.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRunHistogramMorph not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRunHistogramMorph(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'runtype')       
('l_int32', 'direction')       
('l_int32', 'maxsize')       

:param[in]    pixs:        1 bpp
:param[in]    runtype:     L_RUN_OFF, L_RUN_ON
:param[in]    direction:   L_HORIZ, L_VERT
:param[in]    maxsize:     size of largest runlength counted
:returns:  numa of run-lengths


        """
        args = _convert_params(*args)
        
        return leptonica.pixRunHistogramMorph(*args)
    
    

    try:
        leptonica.pixTophat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixTophat.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixTophat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixTophat(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
('l_int32', 'type')       

:param[in]    pixs:     1 bpp
:param[in]    hsize:    of Sel; must be odd; origin implicitly in center
:param[in]    vsize:    ditto
:param[in]    type:     L_TOPHAT_WHITE: image - opening
L_TOPHAT_BLACK: closing - image
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) If hsize = vsize = 1, returns an image with all 0 data.
(3) The L_TOPHAT_WHITE flag emphasizes small bright regions,
whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
The L_TOPHAT_WHITE tophat can be accomplished by doing a
L_TOPHAT_BLACK tophat on the inverse, or v.v.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixTophat(*args)
    
    

    try:
        leptonica.pixHDome.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixHDome.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHDome not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHDome(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'height')       
('l_int32', 'connectivity')       

:param[in]    pixs:          8 bpp, filling mask
:param[in]    height:        of seed below the filling maskhdome; must be >= 0
:param[in]    connectivity:  4 or 8
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) It is more efficient to use a connectivity of 4 for the fill.
(2) This fills bumps to some level, and extracts the unfilled
part of the bump.  To extract the troughs of basins, first
invert pixs and then apply pixHDome().
(3) It is useful to compare the HDome operation with the TopHat.
The latter extracts peaks or valleys that have a width
not exceeding the size of the structuring element used
in the opening or closing, rsp.  The height of the peak is
irrelevant.  By contrast, for the HDome, the gray seedfill
is used to extract all peaks that have a height not exceeding
a given value, regardless of their width!
(4) Slightly more precisely, suppose you set 'height' = 40.
Then all bumps in pixs with a height greater than or equal
to 40 become, in pixd, bumps with a max value of exactly 40.
All shorter bumps have a max value in pixd equal to the height
of the bump.
(5) The method: the filling mask, pixs, is the image whose peaks
are to be extracted.  The height of a peak is the distance
between the top of the peak and the highest "leak" to the
outside -- think of a sombrero, where the leak occurs
at the highest point on the rim.
(a) Generate a seed, pixd, by subtracting some value, p, from
each pixel in the filling mask, pixs.  The value p is
the 'height' input to this function.
(b) Fill in pixd starting with this seed, clipping by pixs,
in the way described in seedfillGrayLow().  The filling
stops before the peaks in pixs are filled.
For peaks that have a height > p, pixd is filled to
the level equal to the (top-of-the-peak - p).
For peaks of height < p, the peak is left unfilled
from its highest saddle point (the leak to the outside).
(c) Subtract the filled seed (pixd) from the filling mask (pixs).
Note that in this procedure, everything is done starting
with the filling mask, pixs.
(6) For segmentation, the resulting image, pixd, can be thresholded
and used as a seed for another filling operation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHDome(*args)
    
    

    try:
        leptonica.pixFastTophat.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixFastTophat.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFastTophat not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFastTophat(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xsize')       
('l_int32', 'ysize')       
('l_int32', 'type')       

:param[in]    pixs:    8 bpp
:param[in]    xsize:   width of max/min op, smoothing; any integer >= 1
:param[in]    ysize:   height of max/min op, smoothing; any integer >= 1
:param[in]    type:    L_TOPHAT_WHITE: image - min
L_TOPHAT_BLACK: max - image
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Don't be fooled. This is NOT a tophat.  It is a tophat-like
operation, where the result is similar to what you'd get
if you used an erosion instead of an opening, or a dilation
instead of a closing.
(2) Instead of opening or closing at full resolution, it does
a fast downscale/minmax operation, then a quick small smoothing
at low res, a replicative expansion of the "background"
to full res, and finally a removal of the background level
from the input image.  The smoothing step may not be important.
(3) It does not remove noise as well as a tophat, but it is
5 to 10 times faster.
If you need the preciseness of the tophat, don't use this.
(4) The L_TOPHAT_WHITE flag emphasizes small bright regions,
whereas the L_TOPHAT_BLACK flag emphasizes small dark regions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFastTophat(*args)
    
    

    try:
        leptonica.pixMorphGradient.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMorphGradient.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphGradient not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphGradient(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       
('l_int32', 'smoothing')       

:param[in]    pixs:       8 bpp
:param[in]    hsize:      sel width; must be odd; origin implicitly in center
:param[in]    vsize:      sel height
:param[in]    smoothing:  half-width of convolution smoothing filter.
The width is (2 * smoothing + 1, so 0 is no-op.
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphGradient(*args)
    
    

    try:
        leptonica.pixaCentroids.argtypes = [ctypes.c_void_p]
        leptonica.pixaCentroids.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaCentroids not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaCentroids(*args):
        """
        ('PIXA', '*pixa')       

:param[in]    pixa:    of components; 1 or 8 bpp
:returns:  pta of centroids relative to the UL corner of
each pix, or NULL on error

<pre>
Notes:
(1) An error message is returned if any pix has something other
than 1 bpp or 8 bpp depth, and the centroid from that pix
is saved as (0, 0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaCentroids(*args)
    
    

    try:
        leptonica.pixCentroid.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCentroid.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixCentroid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCentroid(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*centtab')       
('l_int32', '*sumtab')       
('l_float32', '*pxave')       
('l_float32', '*pyave')       

:param[in]    pix:       1 or 8 bpp
:param[in]    centtab:   [optional] table for finding centroids; can be null
:param[in]    sumtab:    [optional] table for finding pixel sums; can be null
:param[out]   pxave:     x coordinate of centroid, relative to the UL corner
of the pix
:param[out]   pyave:     y coordinate of centroid, relative to the UL corner
of the pix
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The sum and centroid tables are only used for 1 bpp.
(2) Any table not passed in will be made internally and destroyed
after use.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCentroid(*args)
    




class pngiostub(object):
    """<pre>

Stubs for pngio.c functions
</pre>




"""
    



class sarray1(object):
    """<pre>

Create/Destroy/Copy
SARRAY    *sarrayCreate()
SARRAY    *sarrayCreateInitialized()
SARRAY    *sarrayCreateWordsFromString()
SARRAY    *sarrayCreateLinesFromString()
void      *sarrayDestroy()
SARRAY    *sarrayCopy()
SARRAY    *sarrayClone()

Add/Remove string
l_int32    sarrayAddString()
static l_int32  sarrayExtendArray()
char      *sarrayRemoveString()
l_int32    sarrayReplaceString()
l_int32    sarrayClear()

Accessors
l_int32    sarrayGetCount()
char     **sarrayGetArray()
char      *sarrayGetString()
l_int32    sarrayGetRefcount()
l_int32    sarrayChangeRefcount()

Conversion back to string
char      *sarrayToString()
char      *sarrayToStringRange()

Join 2 sarrays
l_int32    sarrayJoin()
l_int32    sarrayAppendRange()

Pad an sarray to be the same size as another sarray
l_int32    sarrayPadToSameSize()

Convert word sarray to (formatted) line sarray
SARRAY    *sarrayConvertWordsToLines()

Split string on separator list
SARRAY    *sarraySplitString()

Filter sarray
SARRAY    *sarraySelectBySubstring()
SARRAY    *sarraySelectByRange()
l_int32    sarrayParseRange()

Serialize for I/O
SARRAY    *sarrayRead()
SARRAY    *sarrayReadStream()
SARRAY    *sarrayReadMem()
l_int32    sarrayWrite()
l_int32    sarrayWriteStream()
l_int32    sarrayWriteMem()
l_int32    sarrayAppend()

Directory filenames
SARRAY    *getNumberedPathnamesInDirectory()
SARRAY    *getSortedPathnamesInDirectory()
SARRAY    *convertSortedToNumberedPathnames()
SARRAY    *getFilenamesInDirectory()

These functions are important for efficient manipulation
of string data, and they have found widespread use in
leptonica.  For example:
(1) to generate text files: e.g., PostScript and PDF
wrappers around sets of images
(2) to parse text files: e.g., extracting prototypes
from the source to generate allheaders.h
(3) to generate code for compilation: e.g., the fast
dwa code for arbitrary structuring elements.

Comments on usage:

The user is responsible for correctly disposing of strings
that have been extracted from sarrays.  In the following,
"str_not_owned" means the returned handle does not own the string,
and "str_owned" means the returned handle owns the string.
- To extract a string from an Sarray in order to inspect it
or to make a copy of it later, get a handle to it:
copyflag = L_NOCOPY.
In this case, you must neither free the string nor put it
directly in another array:
str-not-owned = sarrayGetString(sa, index, L_NOCOPY);
- To extract a copy of a string from an Sarray, use:
str-owned = sarrayGetString(sa, index, L_COPY);
~ To insert a string that is in one array into another
array (always leaving the first array intact), there are
two options:
(1) use copyflag = L_COPY to make an immediate copy,
which you then add to the second array by insertion:
str-owned = sarrayGetString(sa, index, L_COPY);
sarrayAddString(sa, str-owned, L_INSERT);
(2) use copyflag = L_NOCOPY to get another handle to
the string; you then add a copy of it to the
second string array:
str-not-owned = sarrayGetString(sa, index, L_NOCOPY);
sarrayAddString(sa, str-not-owned, L_COPY).
sarrayAddString() transfers ownership to the Sarray, so never
use L_INSERT if the string is owned by another array.

In all cases, when you use copyflag = L_COPY to extract
a string from an array, you must either free it
or insert it in an array that will be freed later.
</pre>




"""
    
    try:
        leptonica.sarrayCreate.argtypes = [ctypes.c_int32]
        leptonica.sarrayCreate.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    size of string ptr array to be alloc'd; use 0 for default
:returns:  sarray, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreate(*args)
    
    

    try:
        leptonica.sarrayCreateInitialized.argtypes = [ctypes.c_int32, ctypes.c_char_p]
        leptonica.sarrayCreateInitialized.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayCreateInitialized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreateInitialized(*args):
        """
        ('l_int32', 'n')       
('const char', '*initstr')       

:param[in]    n:         size of string ptr array to be alloc'd
:param[in]    initstr:   string to be initialized on the full array
:returns:  sarray, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreateInitialized(*args)
    
    

    try:
        leptonica.sarrayCreateWordsFromString.argtypes = [ctypes.c_char_p]
        leptonica.sarrayCreateWordsFromString.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayCreateWordsFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreateWordsFromString(*args):
        """
        ('const char', '*string')       

:param[in]    string:
:returns:  sarray, or NULL on error

<pre>
Notes:
(1) This finds the number of word substrings, creates an sarray
of this size, and puts copies of each substring into the sarray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreateWordsFromString(*args)
    
    

    try:
        leptonica.sarrayCreateLinesFromString.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.sarrayCreateLinesFromString.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayCreateLinesFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCreateLinesFromString(*args):
        """
        ('const char', '*string')       
('l_int32', 'blankflag')       

:param[in]    string:
:param[in]    blankflag:    0 to exclude blank lines; 1 to include
:returns:  sarray, or NULL on error

<pre>
Notes:
(1) This finds the number of line substrings, each of which
ends with a newline, and puts a copy of each substring
in a new sarray.
(2) The newline characters are removed from each substring.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCreateLinesFromString(*args)
    
    

    try:
        leptonica.sarrayDestroy.argtypes = [ctypes.c_void_p]
        leptonica.sarrayDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayDestroy(*args):
        """
        ('SARRAY', '**psa')       

:param[in,out]   psa:    will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the sarray.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayDestroy(*args)
    
    

    try:
        leptonica.sarrayCopy.argtypes = [ctypes.c_void_p]
        leptonica.sarrayCopy.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayCopy(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:    string array
:returns:  copy of sarray, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayCopy(*args)
    
    

    try:
        leptonica.sarrayClone.argtypes = [ctypes.c_void_p]
        leptonica.sarrayClone.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayClone(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:    string array
:returns:  ptr to same sarray, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayClone(*args)
    
    

    try:
        leptonica.sarrayAddString.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.sarrayAddString.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayAddString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayAddString(*args):
        """
        ('SARRAY', '*sa')       
('const char', '*string')       
('l_int32', 'copyflag')       

:param[in]    sa:         string array
:param[in]    string:     string to be added
:param[in]    copyflag:   L_INSERT, L_NOCOPY or L_COPY
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See usage comments at the top of this file.  L_INSERT is
equivalent to L_NOCOPY.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayAddString(*args)
    
    

    try:
        leptonica.sarrayRemoveString.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayRemoveString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function sarrayRemoveString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayRemoveString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       

:param[in]    sa:       string array
:param[in]    index:    of string within sarray
:returns:  removed string, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayRemoveString(*args)
    
    

    try:
        leptonica.sarrayReplaceString.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32]
        leptonica.sarrayReplaceString.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayReplaceString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayReplaceString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       
('char', '*newstr')       
('l_int32', 'copyflag')       

:param[in]    sa:         string array
:param[in]    index:      of string within sarray to be replaced
:param[in]    newstr:     string to replace existing one
:param[in]    copyflag:   L_INSERT, L_COPY
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys an existing string and replaces it with
the new string or a copy of it.
(2) By design, an sarray is always compacted, so there are
never any holes (null ptrs) in the ptr array up to the
current count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayReplaceString(*args)
    
    

    try:
        leptonica.sarrayClear.argtypes = [ctypes.c_void_p]
        leptonica.sarrayClear.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayClear not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayClear(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:    string array
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayClear(*args)
    
    

    try:
        leptonica.sarrayGetCount.argtypes = [ctypes.c_void_p]
        leptonica.sarrayGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function sarrayGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetCount(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:    string array
:returns:  count, or 0 if no strings or on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetCount(*args)
    
    

    try:
        leptonica.sarrayGetArray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayGetArray.restype = ctypes.POINTER(ctypes.POINTER(ctypes.c_char))
    except AttributeError:
        sys.stderr.write("Warning - function sarrayGetArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetArray(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', '*pnalloc')       
('l_int32', '*pn')       

:param[in]    sa:        string array
:param[out]   pnalloc:   [optional] number allocated string ptrs
:param[out]   pn:        [optional] number allocated strings
:returns:  ptr to string array, or NULL on error

<pre>
Notes:
(1) Caution: the returned array is not a copy, so caller
must not destroy it!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetArray(*args)
    
    

    try:
        leptonica.sarrayGetString.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarrayGetString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function sarrayGetString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'index')       
('l_int32', 'copyflag')       

:param[in]    sa:         string array
:param[in]    index:      to the index-th string
:param[in]    copyflag:   L_NOCOPY or L_COPY
:returns:  string, or NULL on error

<pre>
Notes:
(1) See usage comments at the top of this file.
(2) To get a pointer to the string itself, use L_NOCOPY.
To get a copy of the string, use L_COPY.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetString(*args)
    
    

    try:
        leptonica.sarrayGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.sarrayGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function sarrayGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGetRefcount(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:     string array
:returns:  refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGetRefcount(*args)
    
    

    try:
        leptonica.sarrayChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayChangeRefcount(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'delta')       

:param[in]    sa:      string array
:param[in]    delta:   change to be applied
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayChangeRefcount(*args)
    
    

    try:
        leptonica.sarrayToString.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayToString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function sarrayToString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayToString(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'addnlflag')       

:param[in]    sa:          string array
:param[in]    addnlflag:   flag: 0 adds nothing to each substring
1 adds '\n' to each substring
2 adds ' ' to each substring
:returns:  dest string, or NULL on error

<pre>
Notes:
(1) Concatenates all the strings in the sarray, preserving
all white space.
(2) If addnlflag != 0, adds either a '\n' or a ' ' after
each substring.
(3) This function was NOT implemented as:
for (i = 0; i < n; i++)
strcat(dest, sarrayGetString(sa, i, L_NOCOPY));
Do you see why?
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayToString(*args)
    
    

    try:
        leptonica.sarrayToStringRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarrayToStringRange.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function sarrayToStringRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayToStringRange(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'first')       
('l_int32', 'nstrings')       
('l_int32', 'addnlflag')       

:param[in]   sa:          string array
:param[in]   first:       index of first string to use; starts with 0
:param[in]   nstrings:    number of strings to append into the result; use
0 to append to the end of the sarray
:param[in]   addnlflag:   flag: 0 adds nothing to each substring
1 adds '\n' to each substring
2 adds ' ' to each substring
:returns:  dest string, or NULL on error

<pre>
Notes:
(1) Concatenates the specified strings inthe sarray, preserving
all white space.
(2) If addnlflag != 0, adds either a '\n' or a ' ' after
each substring.
(3) If the sarray is empty, this returns a string with just
the character corresponding to %addnlflag.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayToStringRange(*args)
    
    

    try:
        leptonica.sarrayJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayJoin(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       

:param[in]    sa1:   to be added to
:param[in]    sa2:   append to sa1
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Copies of the strings in sarray2 are added to sarray1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayJoin(*args)
    
    

    try:
        leptonica.sarrayAppendRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarrayAppendRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayAppendRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayAppendRange(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       
('l_int32', 'start')       
('l_int32', 'end')       

:param[in]    sa1:     to be added to
:param[in]    sa2:     append specified range of strings in sa2 to sa1
:param[in]    start:   index of first string of sa2 to append
:param[in]    end:     index of last string of sa2 to append;
-1 to append to end of array
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Copies of the strings in sarray2 are added to sarray1.
(2) The [start ... end] range is truncated if necessary.
(3) Use end == -1 to append to the end of sa2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayAppendRange(*args)
    
    

    try:
        leptonica.sarrayPadToSameSize.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.sarrayPadToSameSize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayPadToSameSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayPadToSameSize(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       
('const char', '*padstring')       

:param[in]    sa1,: sa2
:param[in]    padstring:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If two sarrays have different size, this adds enough
instances of %padstring to the smaller so that they are
the same size.  It is useful when two or more sarrays
are being sequenced in parallel, and it is necessary to
find a valid string at each index.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayPadToSameSize(*args)
    
    

    try:
        leptonica.sarrayConvertWordsToLines.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarrayConvertWordsToLines.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayConvertWordsToLines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayConvertWordsToLines(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'linesize')       

:param[in]    sa:  sa      of individual words
:param[in]    linesize:    max num of chars in each line
:returns:  saout sa of formatted lines, or NULL on error

<pre>
Notes:
(1) This is useful for re-typesetting text to a specific maximum
line length.  The individual words in the input sarray
are concatenated into textlines.  An input word string of zero
length is taken to be a paragraph separator.  Each time
such a string is found, the current line is ended and
a new line is also produced that contains just the
string of zero length "".  When the output sarray
of lines is eventually converted to a string with newlines
typically appended to each line string, the empty
strings are just converted to newlines, producing the visible
paragraph separation.
(2) What happens when a word is larger than linesize?
We write it out as a single line anyway!  Words preceding
or following this long word are placed on lines preceding
or following the line with the long word.  Why this choice?
Long "words" found in text documents are typically URLs, and
it's often desirable not to put newlines in the middle of a URL.
The text display program e.g., text editor will typically
wrap the long "word" to fit in the window.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayConvertWordsToLines(*args)
    
    

    try:
        leptonica.sarraySelectBySubstring.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.sarraySelectBySubstring.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarraySelectBySubstring not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySelectBySubstring(*args):
        """
        ('SARRAY', '*sain')       
('const char', '*substr')       

:param[in]    sain:     input sarray
:param[in]    substr:   [optional] substring for matching; can be NULL
:returns:  saout output sarray, filtered with substring or NULL on error

<pre>
Notes:
(1) This selects all strings in sain that have substr as a substring.
Note that we can't use strncmp() because we're looking for
a match to the substring anywhere within each filename.
(2) If substr == NULL, returns a copy of the sarray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySelectBySubstring(*args)
    
    

    try:
        leptonica.sarraySelectByRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.sarraySelectByRange.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarraySelectByRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySelectByRange(*args):
        """
        ('SARRAY', '*sain')       
('l_int32', 'first')       
('l_int32', 'last')       

:param[in]    sain:    input sarray
:param[in]    first:   index of first string to be selected
:param[in]    last:    index of last string to be selected;
use 0 to go to the end of the sarray
:returns:  saout   output sarray, or NULL on error

<pre>
Notes:
(1) This makes %saout consisting of copies of all strings in %sain
in the index set [first ... last].  Use %last == 0 to get all
strings from %first to the last string in the sarray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySelectByRange(*args)
    
    

    try:
        leptonica.sarrayParseRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.sarrayParseRange.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function sarrayParseRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayParseRange(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'start')       
('l_int32', '*pactualstart')       
('l_int32', '*pend')       
('l_int32', '*pnewstart')       
('const char', '*substr')       
('l_int32', 'loc')       

:param[in]    sa:             input sarray
:param[in]    start:          index to start range search
:param[out]   pactualstart:   index of actual start; may be > 'start'
:param[out]   pend:           index of end
:param[out]   pnewstart:      index of start of next range
:param[in]    substr:         substring for matching at beginning of string
:param[in]    loc:            byte offset within the string for the pattern;
use -1 if the location does not matter.
:returns:  0 if valid range found; 1 otherwise

<pre>
Notes:
(1) This finds the range of the next set of strings in SA,
beginning the search at 'start', that does NOT have
the substring 'substr' either at the indicated location
in the string or anywhere in the string.  The input
variable 'loc' is the specified offset within the string;
use -1 to indicate 'anywhere in the string'.
(2) Always check the return value to verify that a valid range
was found.
(3) If a valid range is not found, the values of actstart,
end and newstart are all set to the size of sa.
(4) If this is the last valid range, newstart returns the value n.
In use, this should be tested before calling the function.
(5) Usage example.  To find all the valid ranges in a file
where the invalid lines begin with two dashes, copy each
line in the file to a string in an sarray, and do:
start = 0;
while (!sarrayParseRange(sa, start, &actstart, &end, &start,
"--", 0))
lept_stderr("start = %d, end = %d\n", actstart, end);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayParseRange(*args)
    
    

    try:
        leptonica.sarrayRead.argtypes = [ctypes.c_char_p]
        leptonica.sarrayRead.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  sarray, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayRead(*args)
    
    

    try:
        leptonica.sarrayReadStream.argtypes = [ctypes.c_void_p]
        leptonica.sarrayReadStream.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  sarray, or NULL on error

<pre>
Notes:
(1) We store the size of each string along with the string.
The limit on the number of strings is 25M.
The limit on the size of any string is 2^30 bytes.
(2) This allows a string to have embedded newlines.  By reading
the entire string, as determined by its size, we are
not affected by any number of embedded newlines.
(3) It is OK for the sarray to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayReadStream(*args)
    
    

    try:
        leptonica.sarrayReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.sarrayReadMem.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    serialization in ascii
:param[in]    size:    of data; can use strlen to get it
:returns:  sarray, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayReadMem(*args)
    
    

    try:
        leptonica.sarrayWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.sarrayWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayWrite(*args):
        """
        ('const char', '*filename')       
('SARRAY', '*sa')       

:param[in]    filename:
:param[in]    sa:          string array
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayWrite(*args)
    
    

    try:
        leptonica.sarrayWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayWriteStream(*args):
        """
        ('FILE', '*fp')       
('SARRAY', '*sa')       

:param[in]    fp:    file stream
:param[in]    sa:    string array
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This appends a '\n' to each string, which is stripped
off by sarrayReadStream().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayWriteStream(*args)
    
    

    try:
        leptonica.sarrayWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('SARRAY', '*sa')       

:param[out]   pdata:    data of serialized sarray; ascii
:param[out]   psize:    size of returned data
:param[in]    sa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a sarray in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayWriteMem(*args)
    
    

    try:
        leptonica.sarrayAppend.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.sarrayAppend.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayAppend not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayAppend(*args):
        """
        ('const char', '*filename')       
('SARRAY', '*sa')       

:param[in]    filename:
:param[in]    sa:
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayAppend(*args)
    
    

    try:
        leptonica.getNumberedPathnamesInDirectory.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.getNumberedPathnamesInDirectory.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function getNumberedPathnamesInDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getNumberedPathnamesInDirectory(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       
('l_int32', 'maxnum')       

:param[in]    dirname:   directory name
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    numpre:    number of characters in name before number
:param[in]    numpost:   number of characters in name after the number,
up to a dot before an extension
:param[in]    maxnum:    only consider page numbers up to this value
:returns:  sarray of numbered pathnames, or NULL on error

<pre>
Notes:
(1) Returns the full pathnames of the numbered filenames in
the directory.  The number in the filename is the index
into the sarray.  For indices for which there are no filenames,
an empty string ("") is placed into the sarray.
This makes reading numbered files very simple.  For example,
the image whose filename includes number N can be retrieved using
pixReadIndexed(sa, N);
(2) If %substr is not NULL, only filenames that contain
the substring can be included.  If %substr is NULL,
all matching filenames are used.
(3) If no numbered files are found, it returns an empty sarray,
with no initialized strings.
(4) It is assumed that the page number is contained within
the basename (the filename without directory or extension).
%numpre is the number of characters in the basename
preceding the actual page number; %numpost is the number
following the page number, up to either the end of the
basename or a ".", whichever comes first.
(5) This is useful when all filenames contain numbers that are
not necessarily consecutive.  0-padding is not required.
(6) To use a O(n) matching algorithm, the largest page number
is found and two internal arrays of this size are created.
This maximum is constrained not to exceed %maxsum,
to make sure that an unrealistically large number is not
accidentally used to determine the array sizes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getNumberedPathnamesInDirectory(*args)
    
    

    try:
        leptonica.getSortedPathnamesInDirectory.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.getSortedPathnamesInDirectory.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function getSortedPathnamesInDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getSortedPathnamesInDirectory(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'first')       
('l_int32', 'nfiles')       

:param[in]    dirname:   directory name
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    first:     0-based
:param[in]    nfiles:    use 0 for all to the end
:returns:  sarray of sorted pathnames, or NULL on error

<pre>
Notes:
(1) Use %substr to filter filenames in the directory.  If
%substr == NULL, this takes all files.
(2) The files in the directory, after optional filtering by
the substring, are lexically sorted in increasing order.
Use %first and %nfiles to select a contiguous set of files.
(3) The full pathnames are returned for the requested sequence.
If no files are found after filtering, returns an empty sarray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getSortedPathnamesInDirectory(*args)
    
    

    try:
        leptonica.convertSortedToNumberedPathnames.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertSortedToNumberedPathnames.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function convertSortedToNumberedPathnames not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertSortedToNumberedPathnames(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       
('l_int32', 'maxnum')       

:param[in]    sa:        sorted pathnames including zero-padded integers
:param[in]    numpre:    number of characters in name before number
:param[in]    numpost:   number of characters in name after the number,
up to a dot before an extension
:param[in]    maxnum:    only consider page numbers up to this value
:returns:  sarray of numbered pathnames, or NULL on error

<pre>
Notes:
(1) Typically, numpre = numpost = 0; e.g., when the filename
just has a number followed by an optional extension.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertSortedToNumberedPathnames(*args)
    
    

    try:
        leptonica.getFilenamesInDirectory.argtypes = [ctypes.c_char_p]
        leptonica.getFilenamesInDirectory.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function getFilenamesInDirectory not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getFilenamesInDirectory(*args):
        """
        ('const char', '*dirname')       

:param[in]    dirname:     directory name
:returns:  sarray of file names, or NULL on error

<pre>
Notes:
(1) The versions compiled under unix and cygwin use the POSIX C
library commands for handling directories.  For windows,
there is a separate implementation.
(2) It returns an array of filename tails; i.e., only the part of
the path after the last slash.
(3) Use of the d_type field of dirent is not portable:
"According to POSIX, the dirent structure contains a field
char d_name[] of unspecified size, with at most NAME_MAX
characters preceding the terminating null character.  Use
of other fields will harm the portability of your programs."
(4) As a consequence of (3), we note several things:
~ MINGW doesn't have a d_type member.
~ Older versions of gcc (e.g., 2.95.3) return DT_UNKNOWN
for d_type from all files.
On these systems, this function will return directories
(except for '.' and '..', which are eliminated using
the d_name field).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getFilenamesInDirectory(*args)
    




class sarray2(object):
    """<pre>

Sort
SARRAY     *sarraySort()
SARRAY     *sarraySortByIndex()
l_int32     stringCompareLexical()

Set operations using aset (rbtree)
SARRAY     *sarrayUnionByAset()
SARRAY     *sarrayRemoveDupsByAset()
SARRAY     *sarrayIntersectionByAset()
L_ASET     *l_asetCreateFromSarray()

Set operations using hashing (dnahash)
l_int32     sarrayRemoveDupsByHash()
SARRAY     *sarrayIntersectionByHash()
l_int32     sarrayFindStringByHash()
L_DNAHASH  *l_dnaHashCreateFromSarray()

Miscellaneous operations
SARRAY     *sarrayGenerateIntegers()
l_int32     sarrayLookupCSKV()


We have two implementations of set operations on an array of strings:

(1) Using an underlying tree (rbtree)
This uses a good 64 bit hashing function for the key,
that is not expected to have hash collisions (and we do
not test for them).  The tree is built up of the hash
values, and if the hash is found in the tree, it is
assumed that the string has already been found.

(2) Using an underlying hashing of the keys (dnahash)
This uses a fast 64 bit hashing function for the key,
which is then hashed into a bucket (a dna in a dnaHash).
Because hash collisions can occur, the index into the
sarray for the string that gave rise to that key is stored,
and the dna (bucket) is traversed, using the stored indices
to determine if that string had already been seen.

</pre>




"""
    
    try:
        leptonica.sarraySort.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.sarraySort.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarraySort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySort(*args):
        """
        ('SARRAY', '*saout')       
('SARRAY', '*sain')       
('l_int32', 'sortorder')       

:param[in]    saout:       output sarray; can be NULL or equal to sain
:param[in]    sain:        input sarray
:param[in]    sortorder:   L_SORT_INCREASING or L_SORT_DECREASING
:returns:  saout output sarray, sorted by ascii value, or NULL on error

<pre>
Notes:
(1) Set saout = sain for in-place; otherwise, set naout = NULL.
(2) Shell sort, modified from K&R, 2nd edition, p.62.
Slow but simple O(n logn) sort.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySort(*args)
    
    

    try:
        leptonica.sarraySortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarraySortByIndex.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarraySortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarraySortByIndex(*args):
        """
        ('SARRAY', '*sain')       
('NUMA', '*naindex')       

:param[in]    sain:
:param[in]    naindex:   na that maps from the new sarray to the input sarray
:returns:  saout sorted, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarraySortByIndex(*args)
    
    

    try:
        leptonica.stringCompareLexical.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.stringCompareLexical.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function stringCompareLexical not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def stringCompareLexical(*args):
        """
        ('const char', '*str1')       
('const char', '*str2')       

:param[in]    str1:
:param[in]    str2:
:returns:  1 if str1 > str2 lexically; 0 otherwise

<pre>
Notes:
(1) If the lexical values are identical, return a 0, to
indicate that no swapping is required to sort the strings.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.stringCompareLexical(*args)
    
    

    try:
        leptonica.sarrayUnionByAset.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayUnionByAset.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayUnionByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayUnionByAset(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       

:param[in]    sa1,: sa2
:returns:  sad   with the union of the string set, or NULL on error

<pre>
Notes:
(1) Duplicates are removed from the concatenation of the two arrays.
(2) The key for each string is a 64-bit hash.
(2) Algorithm: Concatenate the two sarrays.  Then build a set,
using hashed strings as keys.  As the set is built, first do
a find; if not found, add the key to the set and add the string
to the output sarray.  This is O(nlogn).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayUnionByAset(*args)
    
    

    try:
        leptonica.sarrayRemoveDupsByAset.argtypes = [ctypes.c_void_p]
        leptonica.sarrayRemoveDupsByAset.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayRemoveDupsByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayRemoveDupsByAset(*args):
        """
        ('SARRAY', '*sas')       

:param[in]    sas:
:returns:  sad  with duplicates removed, or NULL on error

<pre>
Notes:
(1) This is O(nlogn), considerably slower than
sarrayRemoveDupsByHash() for large string arrays.
(2) The key for each string is a 64-bit hash.
(3) Build a set, using hashed strings as keys.  As the set is
built, first do a find; if not found, add the key to the
set and add the string to the output sarray.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayRemoveDupsByAset(*args)
    
    

    try:
        leptonica.sarrayIntersectionByAset.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayIntersectionByAset.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayIntersectionByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayIntersectionByAset(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       

:param[in]    sa1,: sa2
:returns:  sad  with the intersection of the string set, or NULL on error

<pre>
Notes:
(1) Algorithm: put the larger sarray into a set, using the string
hashes as the key values.  Then run through the smaller sarray,
building an output sarray and a second set from the strings
in the larger array: if a string is in the first set but
not in the second, add the string to the output sarray and hash
it into the second set.  The second set is required to make
sure only one instance of each string is put into the output sarray.
This is O(mlogn), {m,n} = sizes of {smaller,larger} input arrays.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayIntersectionByAset(*args)
    
    

    try:
        leptonica.l_asetCreateFromSarray.argtypes = [ctypes.c_void_p]
        leptonica.l_asetCreateFromSarray.restype = lambda address: L_ASET(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_asetCreateFromSarray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_asetCreateFromSarray(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:
:returns:  set using a string hash into a uint64 as the key


        """
        args = _convert_params(*args)
        
        return leptonica.l_asetCreateFromSarray(*args)
    
    

    try:
        leptonica.sarrayRemoveDupsByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayRemoveDupsByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayRemoveDupsByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayRemoveDupsByHash(*args):
        """
        ('SARRAY', '*sas')       
('SARRAY', '**psad')       
('L_DNAHASH', '**pdahash')       

:param[in]    sas:
:param[out]   psad:      unique set of strings; duplicates removed
:param[out]   pdahash:   [optional] dnahash used for lookup
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Generates a sarray with unique values.
(2) The dnahash is built up with sad to assure uniqueness.
It can be used to find if a string is in the set:
sarrayFindValByHash(sad, dahash, str, &index)
(3) The hash of the string location is simple and fast.  It scales
up with the number of buckets to insure a fairly random
bucket selection input strings.
(4) This is faster than sarrayRemoveDupsByAset(), because the
bucket lookup is O(n), although there is a double-loop
lookup within the dna in each bucket.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayRemoveDupsByHash(*args)
    
    

    try:
        leptonica.sarrayIntersectionByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.sarrayIntersectionByHash.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayIntersectionByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayIntersectionByHash(*args):
        """
        ('SARRAY', '*sa1')       
('SARRAY', '*sa2')       

:param[in]    sa1,: sa2
:returns:  sad  intersection of the strings, or NULL on error

<pre>
Notes:
(1) This is faster than sarrayIntersectionByAset(), because the
bucket lookup is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayIntersectionByHash(*args)
    
    

    try:
        leptonica.sarrayFindStringByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.sarrayFindStringByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayFindStringByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayFindStringByHash(*args):
        """
        ('SARRAY', '*sa')       
('L_DNAHASH', '*dahash')       
('const char', '*str')       
('l_int32', '*pindex')       

:param[in]    sa:
:param[in]    dahash:   built from sa
:param[in]    str:      arbitrary string
:param[out]   pindex:   index into %sa if %str is in %sa; -1 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Fast lookup in dnaHash associated with a sarray, to see if a
random string %str is already stored in the hash table.
(2) We use a strong hash function to minimize the chance that
two different strings hash to the same key value.
(3) We select the number of buckets to be about 5% of the size
of the input sarray, so that when fully populated, each
bucket (dna) will have about 20 entries, each being an index
into sa.  In lookup, after hashing to the key, and then
again to the bucket, we traverse the bucket (dna), using the
index into sa to check if %str has been found before.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayFindStringByHash(*args)
    
    

    try:
        leptonica.l_dnaHashCreateFromSarray.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaHashCreateFromSarray.restype = lambda address: L_DNAHASH(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashCreateFromSarray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashCreateFromSarray(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:
:returns:  dahash, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashCreateFromSarray(*args)
    
    

    try:
        leptonica.sarrayGenerateIntegers.argtypes = [ctypes.c_int32]
        leptonica.sarrayGenerateIntegers.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function sarrayGenerateIntegers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayGenerateIntegers(*args):
        """
        ('l_int32', 'n')       

:param[in]   n:
:returns:  sa  of printed numbers, 1 - n, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayGenerateIntegers(*args)
    
    

    try:
        leptonica.sarrayLookupCSKV.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.sarrayLookupCSKV.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function sarrayLookupCSKV not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def sarrayLookupCSKV(*args):
        """
        ('SARRAY', '*sa')       
('const char', '*keystring')       
('char', '**pvalstring')       

:param[in]    sa:          of strings, each being a comma-separated pair
of strings, the first being a key and the
second a value
:param[in]    keystring:   an input string to match with each key in %sa
:param[out]   pvalstring:  the returned value string corresponding to the
input key string, if found; otherwise NULL
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The input %sa can have other strings that are not in
comma-separated key-value format.  These will be ignored.
(2) This returns a copy of the first value string in %sa whose
key string matches the input %keystring.
(3) White space is not ignored; all white space before the ','
is used for the keystring in matching.  This allows the
key and val strings to have white space (e.g., multiple words).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.sarrayLookupCSKV(*args)
    




class boxfunc3(object):
    """<pre>

Boxa/Boxaa painting into pix
PIX             *pixMaskConnComp()
PIX             *pixMaskBoxa()
PIX             *pixPaintBoxa()
PIX             *pixSetBlackOrWhiteBoxa()
PIX             *pixPaintBoxaRandom()
PIX             *pixBlendBoxaRandom()
PIX             *pixDrawBoxa()
PIX             *pixDrawBoxaRandom()
PIX             *boxaaDisplay()
PIXA            *pixaDisplayBoxaa()

Split mask components into Boxa
BOXA            *pixSplitIntoBoxa()
BOXA            *pixSplitComponentIntoBoxa()
static l_int32   pixSearchForRectangle()

Represent horizontal or vertical mosaic strips
BOXA            *makeMosaicStrips()

Comparison between boxa
l_int32          boxaCompareRegions()

Reliable selection of a single large box
BOX             *pixSelectLargeULComp()
BOX             *boxaSelectLargeULBox()

See summary in pixPaintBoxa() of various ways to paint and draw
boxes on images.
</pre>




"""
    
    try:
        leptonica.pixMaskConnComp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixMaskConnComp.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaskConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskConnComp(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('BOXA', '**pboxa')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   4 or 8
:param[out]   pboxa:          [optional] bounding boxes of c.c.
:returns:  pixd 1 bpp mask over the c.c., or NULL on error

<pre>
Notes:
(1) This generates a mask image with ON pixels over the
b.b. of the c.c. in pixs.  If there are no ON pixels in pixs,
pixd will also have no ON pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskConnComp(*args)
    
    

    try:
        leptonica.pixMaskBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixMaskBoxa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMaskBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMaskBoxa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'op')       

:param[in]    pixd:    [optional] may be NULL
:param[in]    pixs:    any depth; not cmapped
:param[in]    boxa:    of boxes, to paint
:param[in]    op:      L_SET_PIXELS, L_CLEAR_PIXELS, L_FLIP_PIXELS
:returns:  pixd with masking op over the boxes, or NULL on error

<pre>
Notes:
(1) This can be used with:
pixd = NULL  (makes a new pixd)
pixd = pixs  (in-place)
(2) If pixd == NULL, this first makes a copy of pixs, and then
bit-twiddles over the boxes.  Otherwise, it operates directly
on pixs.
(3) This simple function is typically used with 1 bpp images.
It uses the 1-image rasterop function, rasteropUniLow(),
to set, clear or flip the pixels in pixd.
(4) If you want to generate a 1 bpp mask of ON pixels from the boxes
in a Boxa, in a pix of size (w,h):
pix = pixCreate(w, h, 1);
pixMaskBoxa(pix, pix, boxa, L_SET_PIXELS);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMaskBoxa(*args)
    
    

    try:
        leptonica.pixPaintBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixPaintBoxa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixPaintBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_uint32', 'val')       

:param[in]    pixs:    any depth, can be cmapped
:param[in]    boxa:    of boxes, to paint
:param[in]    val:     rgba color to paint
:returns:  pixd with painted boxes, or NULL on error

<pre>
Notes:
(1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
and the boxa is painted using a colormap; otherwise,
it is converted to 32 bpp rgb.
(2) There are several ways to display a box on an image:
Paint it as a solid color
Draw the outline
Blend the outline or region with the existing image
We provide painting and drawing here; blending is in blend.c.
When painting or drawing, the result can be either a
cmapped image or an rgb image.  The dest will be cmapped
if the src is either 1 bpp or has a cmap that is not full.
To force RGB output, use pixConvertTo8(pixs, FALSE)
before calling any of these paint and draw functions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintBoxa(*args)
    
    

    try:
        leptonica.pixSetBlackOrWhiteBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSetBlackOrWhiteBoxa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSetBlackOrWhiteBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetBlackOrWhiteBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'op')       

:param[in]    pixs:    any depth, can be cmapped
:param[in]    boxa:    [optional] of boxes, to clear or set
:param[in]    op:      L_SET_BLACK, L_SET_WHITE
:returns:  pixd with boxes filled with white or black, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetBlackOrWhiteBoxa(*args)
    
    

    try:
        leptonica.pixPaintBoxaRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixPaintBoxaRandom.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixPaintBoxaRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixPaintBoxaRandom(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       

:param[in]    pixs:    any depth, can be cmapped
:param[in]    boxa:    of boxes, to paint
:returns:  pixd with painted boxes, or NULL on error

<pre>
Notes:
(1) If pixs is 1 bpp, we paint the boxa using a colormap;
otherwise, we convert to 32 bpp.
(2) We use up to 254 different colors for painting the regions.
(3) If boxes overlap, the later ones paint over earlier ones.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixPaintBoxaRandom(*args)
    
    

    try:
        leptonica.pixBlendBoxaRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixBlendBoxaRandom.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlendBoxaRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlendBoxaRandom(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_float32', 'fract')       

:param[in]    pixs:    any depth; can be cmapped
:param[in]    boxa:    of boxes, to blend/paint
:param[in]    fract:   of box color to use
:returns:  pixd 32 bpp, with blend/painted boxes, or NULL on error

<pre>
Notes:
(1) pixs is converted to 32 bpp.
(2) This differs from pixPaintBoxaRandom(), in that the
colors here are blended with the color of pixs.
(3) We use up to 254 different colors for painting the regions.
(4) If boxes overlap, the final color depends only on the last
rect that is used.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlendBoxaRandom(*args)
    
    

    try:
        leptonica.pixDrawBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_uint32]
        leptonica.pixDrawBoxa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDrawBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDrawBoxa(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'width')       
('l_uint32', 'val')       

:param[in]    pixs:    any depth; can be cmapped
:param[in]    boxa:    of boxes, to draw
:param[in]    width:   of lines
:param[in]    val:     rgba color to draw
:returns:  pixd with outlines of boxes added, or NULL on error

<pre>
Notes:
(1) If pixs is 1 bpp or is colormapped, it is converted to 8 bpp
and the boxa is drawn using a colormap; otherwise,
it is converted to 32 bpp rgb.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDrawBoxa(*args)
    
    

    try:
        leptonica.pixDrawBoxaRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixDrawBoxaRandom.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDrawBoxaRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDrawBoxaRandom(*args):
        """
        ('PIX', '*pixs')       
('BOXA', '*boxa')       
('l_int32', 'width')       

:param[in]    pixs:     any depth, can be cmapped
:param[in]    boxa:     of boxes, to draw
:param[in]    width:    thickness of line
:returns:  pixd with box outlines drawn, or NULL on error

<pre>
Notes:
(1) If pixs is 1 bpp, we draw the boxa using a colormap;
otherwise, we convert to 32 bpp.
(2) We use up to 254 different colors for drawing the boxes.
(3) If boxes overlap, the later ones draw over earlier ones.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDrawBoxaRandom(*args)
    
    

    try:
        leptonica.boxaaDisplay.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_uint32, ctypes.c_uint32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaDisplay.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaDisplay not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaDisplay(*args):
        """
        ('PIX', '*pixs')       
('BOXAA', '*baa')       
('l_int32', 'linewba')       
('l_int32', 'linewb')       
('l_uint32', 'colorba')       
('l_uint32', 'colorb')       
('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    pixs:     [optional] 1 bpp
:param[in]    baa:      boxaa, typically from a 2d sort
:param[in]    linewba:  line width to display outline of each boxa
:param[in]    linewb:   line width to display outline of each box
:param[in]    colorba:  color to display boxa
:param[in]    colorb:   color to display box
:param[in]    w:    width of outupt pix; use 0 if determined by %pixs or %baa
:param[in]    h:    height of outupt pix; use 0 if determined by %pixs or %baa
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %pixs exists, this renders the boxes over an 8 bpp version
of it.  Otherwise, it renders the boxes over an empty image
with a white background.
(2) If %pixs exists, the dimensions of %pixd are the same,
and input values of %w and %h are ignored.
If %pixs is NULL, the dimensions of %pixd are determined by
- %w and %h if both are > 0, or
- the minimum size required using all boxes in %baa.

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaDisplay(*args)
    
    

    try:
        leptonica.pixaDisplayBoxaa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaDisplayBoxaa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaDisplayBoxaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaDisplayBoxaa(*args):
        """
        ('PIXA', '*pixas')       
('BOXAA', '*baa')       
('l_int32', 'colorflag')       
('l_int32', 'width')       

:param[in]    pixas:       any depth, can be cmapped
:param[in]    baa:         boxes to draw on input pixa
:param[in]    colorflag:   L_DRAW_RED, L_DRAW_GREEN, etc
:param[in]    width:       thickness of lines
:returns:  pixa with box outlines drawn on each pix, or NULL on error

<pre>
Notes:
(1) All pix in %pixas that are not rgb are converted to rgb.
(2) Each boxa in %baa contains boxes that will be drawn on
the corresponding pix in %pixas.
(3) The color of the boxes drawn on each pix are selected with
%colorflag:
For red, green or blue: use L_DRAW_RED, etc.
For sequential r, g, b: use L_DRAW_RGB
For random colors: use L_DRAW_RANDOM
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaDisplayBoxaa(*args)
    
    

    try:
        leptonica.pixSplitIntoBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSplitIntoBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSplitIntoBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitIntoBoxa(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minsum')       
('l_int32', 'skipdist')       
('l_int32', 'delta')       
('l_int32', 'maxbg')       
('l_int32', 'maxcomps')       
('l_int32', 'remainder')       

:param[in]    pixs:       1 bpp
:param[in]    minsum:     minimum pixels to trigger propagation
:param[in]    skipdist:   distance before computing sum for propagation
:param[in]    delta:      difference required to stop propagation
:param[in]    maxbg:      maximum number of allowed bg pixels in ref scan
:param[in]    maxcomps:   use 0 for unlimited number of subdivided components
:param[in]    remainder:  set to 1 to get b.b. of remaining stuff
:returns:  boxa of rectangles covering the fg of pixs, or NULL on error

<pre>
Notes:
(1) This generates a boxa of rectangles that covers
the fg of a mask.  For each 8-connected component in pixs,
it does a greedy partitioning, choosing the largest
rectangle found from each of the four directions at each iter.
See pixSplitComponentIntoBoxa() for details.
(2) The input parameters give some flexibility for boundary
noise.  The resulting set of rectangles may cover some
bg pixels.
(3) This should be used when there are a small number of
mask components, each of which has sides that are close
to horizontal and vertical.  The input parameters %delta
and %maxbg determine whether or not holes in the mask are covered.
(4) The parameter %maxcomps gives the maximum number of allowed
rectangles extracted from any single connected component.
Use 0 if no limit is to be applied.
(5) The flag %remainder specifies whether we take a final bounding
box for anything left after the maximum number of allowed
rectangle is extracted.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitIntoBoxa(*args)
    
    

    try:
        leptonica.pixSplitComponentIntoBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSplitComponentIntoBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSplitComponentIntoBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSplitComponentIntoBoxa(*args):
        """
        ('PIX', '*pix')       
('BOX', '*box')       
('l_int32', 'minsum')       
('l_int32', 'skipdist')       
('l_int32', 'delta')       
('l_int32', 'maxbg')       
('l_int32', 'maxcomps')       
('l_int32', 'remainder')       

:param[in]    pix:        1 bpp
:param[in]    box:        [optional] location of pix w/rt an origin
:param[in]    minsum:     minimum pixels to trigger propagation
:param[in]    skipdist:   distance before computing sum for propagation
:param[in]    delta:      difference required to stop propagation
:param[in]    maxbg:      maximum number of allowed bg pixels in ref scan
:param[in]    maxcomps:   use 0 for unlimited number of subdivided components
:param[in]    remainder:  set to 1 to get b.b. of remaining stuff
:returns:  boxa of rectangles covering the fg of pix, or NULL on error

<pre>
Notes:
(1) This generates a boxa of rectangles that covers
the fg of a mask.  It does so by a greedy partitioning of
the mask, choosing the largest rectangle found from
each of the four directions at each step.
(2) The input parameters give some flexibility for boundary
noise.  The resulting set of rectangles must cover all
the fg pixels and, in addition, may cover some bg pixels.
Using small input parameters on a noiseless mask (i.e., one
that has only large vertical and horizontal edges) will
result in a proper covering of only the fg pixels of the mask.
(3) The input is assumed to be a single connected component, that
may have holes.  From each side, sweep inward, counting
the pixels.  If the count becomes greater than %minsum,
and we have moved forward a further amount %skipdist,
record that count ('countref'), but don't accept if the scan
contains more than %maxbg bg pixels.  Continue the scan
until we reach a count that differs from countref by at
least %delta, at which point the propagation stops.  The box
swept out gets a score, which is the sum of fg pixels
minus a penalty.  The penalty is the number of bg pixels
in the box.  This is done from all four sides, and the
side with the largest score is saved as a rectangle.
The process repeats until there is either no rectangle
left, or there is one that can't be captured from any
direction.  For the latter case, we simply accept the
last rectangle.
(4) The input box is only used to specify the location of
the UL corner of pix, with respect to an origin that
typically represents the UL corner of an underlying image,
of which pix is one component.  If %box is null,
the UL corner is taken to be (0, 0).
(5) The parameter %maxcomps gives the maximum number of allowed
rectangles extracted from any single connected component.
Use 0 if no limit is to be applied.
(6) The flag %remainder specifies whether we take a final bounding
box for anything left after the maximum number of allowed
rectangle is extracted.
(7) So if %maxcomps > 0, it specifies that we want no more than
the first %maxcomps rectangles that satisfy the input
criteria.  After this, we can get a final rectangle that
bounds everything left over by setting %remainder == 1.
If %remainder == 0, we only get rectangles that satisfy
the input criteria.
(8) It should be noted that the removal of rectangles can
break the original c.c. into several c.c.
(9) Summing up:
If %maxcomp == 0, the splitting proceeds as far as possible.
If %maxcomp > 0, the splitting stops when %maxcomps are
found, or earlier if no more components can be selected.
If %remainder == 1 and components remain that cannot be
selected, they are returned as a single final rectangle;
otherwise, they are ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSplitComponentIntoBoxa(*args)
    
    

    try:
        leptonica.makeMosaicStrips.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.makeMosaicStrips.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeMosaicStrips not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeMosaicStrips(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'direction')       
('l_int32', 'size')       

:param[in]    w,: h
:param[in]    direction:    L_SCAN_HORIZONTAL or L_SCAN_VERTICAL
:param[in]    size:         of strips in the scan direction
:returns:  boxa, or NULL on error

<pre>
Notes:
(1) For example, this can be used to generate a pixa of
vertical strips of width 10 from an image, using:
pixGetDimensions(pix, &w, &h, NULL);
boxa = makeMosaicStrips(w, h, L_SCAN_HORIZONTAL, 10);
pixa = pixClipRectangles(pix, boxa);
All strips except the last will be the same width.  The
last strip will have width w % 10.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeMosaicStrips(*args)
    
    

    try:
        leptonica.boxaCompareRegions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaCompareRegions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaCompareRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaCompareRegions(*args):
        """
        ('BOXA', '*boxa1')       
('BOXA', '*boxa2')       
('l_int32', 'areathresh')       
('l_int32', '*pnsame')       
('l_float32', '*pdiffarea')       
('l_float32', '*pdiffxor')       
('PIX', '**ppixdb')       

:param[in]    boxa1,: boxa2
:param[in]    areathresh:  minimum area of boxes to be considered
:param[out]   pnsame:      true if same number of boxes
:param[out]   pdiffarea:   fractional difference in total area
:param[out]   pdiffxor:    [optional] fractional difference in xor of regions
:param[out]   ppixdb:      [optional] debug pix showing two boxa
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This takes 2 boxa, removes all boxes smaller than a given area,
and compares the remaining boxes between the boxa.
(2) The area threshold is introduced to help remove noise from
small components.  Any box with a smaller value of w * h
will be removed from consideration.
(3) The xor difference is the most stringent test, requiring alignment
of the corresponding boxes.  It is also more computationally
intensive and is optionally returned.  Alignment is to the
UL corner of each region containing all boxes, as given by
boxaGetExtent().
(4) Both fractional differences are with respect to the total
area in the two boxa.  They range from 0.0 to 1.0.
A perfect match has value 0.0.  If both boxa are empty,
we return 0.0; if one is empty we return 1.0.
(5) An example input might be the rectangular regions of a
segmentation mask for text or images from two pages.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaCompareRegions(*args)
    
    

    try:
        leptonica.pixSelectLargeULComp.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSelectLargeULComp.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectLargeULComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectLargeULComp(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'areaslop')       
('l_int32', 'yslop')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    areaslop:       fraction near but less than 1.0
:param[in]    yslop:          number of pixels in y direction
:param[in]    connectivity:   4 or 8
:returns:  box, or NULL on error

<pre>
Notes:
(1) This selects a box near the top (first) and left (second)
of the image, from the set of all boxes that have
area >= %areaslop * (area of biggest box),
where %areaslop is some fraction; say ~ 0.9.
(2) For all boxes satisfying the above condition, select
the left-most box that is within %yslop (say, 20) pixels
of the box nearest the top.
(3) This can be used to reliably select a specific one of
the largest regions in an image, for applications where
there are expected to be small variations in region size
and location.
(4) See boxSelectLargeULBox() for implementation details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectLargeULComp(*args)
    
    

    try:
        leptonica.boxaSelectLargeULBox.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaSelectLargeULBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSelectLargeULBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSelectLargeULBox(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'areaslop')       
('l_int32', 'yslop')       

:param[in]    boxas:      1 bpp
:param[in]    areaslop:   fraction near but less than 1.0
:param[in]    yslop:      number of pixels in y direction
:returns:  box, or NULL on error

<pre>
Notes:
(1) See usage notes in pixSelectLargeULComp().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSelectLargeULBox(*args)
    




class boxfunc4(object):
    """<pre>

Boxa and Boxaa range selection
BOXA     *boxaSelectRange()
BOXAA    *boxaaSelectRange()

Boxa size selection
BOXA     *boxaSelectBySize()
NUMA     *boxaMakeSizeIndicator()
BOXA     *boxaSelectByArea()
NUMA     *boxaMakeAreaIndicator()
BOXA     *boxaSelectByWHRatio()
NUMA     *boxaMakeWHRatioIndicator()
BOXA     *boxaSelectWithIndicator()

Boxa permutation
BOXA     *boxaPermutePseudorandom()
BOXA     *boxaPermuteRandom()
l_int32   boxaSwapBoxes()

Boxa and box conversions
PTA      *boxaConvertToPta()
BOXA     *ptaConvertToBoxa()
PTA      *boxConvertToPta()
BOX      *ptaConvertToBox()

Miscellaneous boxa functions
l_int32   boxaGetExtent()
l_int32   boxaGetCoverage()
l_int32   boxaaSizeRange()
l_int32   boxaSizeRange()
l_int32   boxaLocationRange()
NUMA     *boxaGetSizes()
l_int32   boxaGetArea()
PIX      *boxaDisplayTiled()
</pre>




"""
    
    try:
        leptonica.boxaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSelectRange.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSelectRange(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'copyflag')       

:param[in]    boxas:
:param[in]    first:      use 0 to select from the beginning
:param[in]    last:       use -1 to select to the end
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) The copyflag specifies what we do with each box from boxas.
Specifically, L_CLONE inserts a clone into boxad of each
selected box from boxas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSelectRange(*args)
    
    

    try:
        leptonica.boxaaSelectRange.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaSelectRange.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaSelectRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaSelectRange(*args):
        """
        ('BOXAA', '*baas')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'copyflag')       

:param[in]    baas:
:param[in]    first:      use 0 to select from the beginning
:param[in]    last:       use -1 to select to the end
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  baad, or NULL on error

<pre>
Notes:
(1) The copyflag specifies what we do with each boxa from baas.
Specifically, L_CLONE inserts a clone into baad of each
selected boxa from baas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaSelectRange(*args)
    
    

    try:
        leptonica.boxaSelectBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaSelectBySize.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSelectBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSelectBySize(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'type')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       

:param[in]    boxas:
:param[in]    width,: height    threshold dimensions
:param[in]    type:             L_SELECT_WIDTH, L_SELECT_HEIGHT,
L_SELECT_IF_EITHER, L_SELECT_IF_BOTH
:param[in]    relation:         L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:         [optional] 1 if changed; 0 if clone returned
:returns:  boxad filtered set, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) Uses box copies in the new boxa.
(3) If the selection type is L_SELECT_WIDTH, the input
height is ignored, and v.v.
(4) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSelectBySize(*args)
    
    

    try:
        leptonica.boxaMakeSizeIndicator.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaMakeSizeIndicator.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaMakeSizeIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaMakeSizeIndicator(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'width')       
('l_int32', 'height')       
('l_int32', 'type')       
('l_int32', 'relation')       

:param[in]    boxa:
:param[in]    width,: height   threshold dimensions
:param[in]    type:            L_SELECT_WIDTH, L_SELECT_HEIGHT,
L_SELECT_IF_EITHER, L_SELECT_IF_BOTH
:param[in]    relation:        L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:  na indicator array, or NULL on error

<pre>
Notes:
(1) The args specify constraints on the size of the
components that are kept.
(2) If the selection type is L_SELECT_WIDTH, the input
height is ignored, and v.v.
(3) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaMakeSizeIndicator(*args)
    
    

    try:
        leptonica.boxaSelectByArea.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaSelectByArea.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSelectByArea not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSelectByArea(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'area')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       

:param[in]    boxas:
:param[in]    area:       threshold value of width * height
:param[in]    relation:   L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:   [optional] 1 if changed; 0 if clone returned
:returns:  boxad filtered set, or NULL on error

<pre>
Notes:
(1) Uses box copies in the new boxa.
(2) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSelectByArea(*args)
    
    

    try:
        leptonica.boxaMakeAreaIndicator.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaMakeAreaIndicator.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaMakeAreaIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaMakeAreaIndicator(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'area')       
('l_int32', 'relation')       

:param[in]    boxa:
:param[in]    area:       threshold value of width * height
:param[in]    relation:   L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:  na indicator array, or NULL on error

<pre>
Notes:
(1) To keep small components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep large components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaMakeAreaIndicator(*args)
    
    

    try:
        leptonica.boxaSelectByWHRatio.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaSelectByWHRatio.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSelectByWHRatio not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSelectByWHRatio(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', 'ratio')       
('l_int32', 'relation')       
('l_int32', '*pchanged')       

:param[in]    boxas:
:param[in]    ratio:     width/height threshold value
:param[in]    relation:  L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:param[out]   pchanged:  [optional] 1 if changed; 0 if clone returned
:returns:  boxad filtered set, or NULL on error

<pre>
Notes:
(1) Uses box copies in the new boxa.
(2) To keep narrow components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep wide components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSelectByWHRatio(*args)
    
    

    try:
        leptonica.boxaMakeWHRatioIndicator.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaMakeWHRatioIndicator.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaMakeWHRatioIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaMakeWHRatioIndicator(*args):
        """
        ('BOXA', '*boxa')       
('l_float32', 'ratio')       
('l_int32', 'relation')       

:param[in]    boxa:
:param[in]    ratio:     width/height threshold value
:param[in]    relation:  L_SELECT_IF_LT, L_SELECT_IF_GT,
L_SELECT_IF_LTE, L_SELECT_IF_GTE
:returns:  na indicator array, or NULL on error

<pre>
Notes:
(1) To keep narrow components, use relation = L_SELECT_IF_LT or
L_SELECT_IF_LTE.
To keep wide components, use relation = L_SELECT_IF_GT or
L_SELECT_IF_GTE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaMakeWHRatioIndicator(*args)
    
    

    try:
        leptonica.boxaSelectWithIndicator.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSelectWithIndicator.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSelectWithIndicator not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSelectWithIndicator(*args):
        """
        ('BOXA', '*boxas')       
('NUMA', '*na')       
('l_int32', '*pchanged')       

:param[in]    boxas:
:param[in]    na:         indicator numa
:param[out]   pchanged:   [optional] 1 if changed; 0 if clone returned
:returns:  boxad, or NULL on error

<pre>
Notes:
(1) Returns a copy of the boxa if no components are removed.
(2) Uses box copies in the new boxa.
(3) The indicator numa has values 0 (ignore) and 1 (accept).
(4) If all indicator values are 0, the returned boxa is empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSelectWithIndicator(*args)
    
    

    try:
        leptonica.boxaPermutePseudorandom.argtypes = [ctypes.c_void_p]
        leptonica.boxaPermutePseudorandom.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaPermutePseudorandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaPermutePseudorandom(*args):
        """
        ('BOXA', '*boxas')       

:param[in]    boxas:   input boxa
:returns:  boxad with boxes permuted, or NULL on error

<pre>
Notes:
(1) This does a pseudorandom in-place permutation of the boxes.
(2) The result is guaranteed not to have any boxes in their
original position, but it is not very random.  If you
need randomness, use boxaPermuteRandom().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaPermutePseudorandom(*args)
    
    

    try:
        leptonica.boxaPermuteRandom.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaPermuteRandom.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaPermuteRandom not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaPermuteRandom(*args):
        """
        ('BOXA', '*boxad')       
('BOXA', '*boxas')       

:param[in]    boxad:    [optional]   can be null or equal to boxas
:param[in]    boxas:    input boxa
:returns:  boxad with boxes permuted, or NULL on error

<pre>
Notes:
(1) If boxad is null, make a copy of boxas and permute the copy.
Otherwise, boxad must be equal to boxas, and the operation
is done in-place.
(2) If boxas is empty, return an empty boxad.
(3) This does a random in-place permutation of the boxes,
by swapping each box in turn with a random box.  The
result is almost guaranteed not to have any boxes in their
original position.
(4) MSVC rand() has MAX_RAND = 2^15 - 1, so it will not do
a proper permutation is the number of boxes exceeds this.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaPermuteRandom(*args)
    
    

    try:
        leptonica.boxaSwapBoxes.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSwapBoxes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSwapBoxes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSwapBoxes(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'i')       
('l_int32', 'j')       

:param[in]    boxa:
:param[in]    i,: j      two indices of boxes, that are to be swapped
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSwapBoxes(*args)
    
    

    try:
        leptonica.boxaConvertToPta.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaConvertToPta.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaConvertToPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaConvertToPta(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'ncorners')       

:param[in]    boxa:
:param[in]    ncorners:     2 or 4 for the representation of each box
:returns:  pta with %ncorners points for each box in the boxa,
or NULL on error

<pre>
Notes:
(1) If ncorners == 2, we select the UL and LR corners.
Otherwise we save all 4 corners in this order: UL, UR, LL, LR.
(2) Other boxa --> pta functions are:
boxaExtractAsPta(): allows extraction of any dimension
and/or side location, with each in a separate pta.
boxaExtractCorners(): extracts any of the four corners as a pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaConvertToPta(*args)
    
    

    try:
        leptonica.ptaConvertToBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ptaConvertToBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaConvertToBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaConvertToBoxa(*args):
        """
        ('PTA', '*pta')       
('l_int32', 'ncorners')       

:param[in]    pta:
:param[in]    ncorners:   2 or 4 for the representation of each box
:returns:  boxa with one box for each 2 or 4 points in the pta,
or NULL on error

<pre>
Notes:
(1) For 2 corners, the order of the 2 points is UL, LR.
For 4 corners, the order of points is UL, UR, LL, LR.
(2) Each derived box is the minimum size containing all corners.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaConvertToBoxa(*args)
    
    

    try:
        leptonica.boxConvertToPta.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxConvertToPta.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxConvertToPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxConvertToPta(*args):
        """
        ('BOX', '*box')       
('l_int32', 'ncorners')       

:param[in]    box:
:param[in]    ncorners:   2 or 4 for the representation of the box
:returns:  pta with %ncorners points, or NULL on error

<pre>
Notes:
(1) If ncorners == 2, we select the UL and LR corners.
Otherwise we save all 4 corners in this order: UL, UR, LL, LR.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxConvertToPta(*args)
    
    

    try:
        leptonica.ptaConvertToBox.argtypes = [ctypes.c_void_p]
        leptonica.ptaConvertToBox.restype = lambda address: BOX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaConvertToBox not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaConvertToBox(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  box minimum containing all points in the pta, or NULL on error

<pre>
Notes:
(1) For 2 corners, the order of the 2 points is UL, LR.
For 4 corners, the order of points is UL, UR, LL, LR.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaConvertToBox(*args)
    
    

    try:
        leptonica.boxaGetExtent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetExtent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetExtent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetExtent(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('BOX', '**pbox')       

:param[in]    boxa:
:param[out]   pw:      [optional] width
:param[out]   ph:      [optional] height
:param[out]   pbox:    [optional]  minimum box containing all boxes in boxa
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This computes the minimum rectangular bounding region
that contains all valid boxes in a boxa.
(2) The returned w and h are the minimum size image
that would contain all boxes untranslated.
(3) If there are no valid boxes, returned w and h are 0 and
all parameters in the returned box are 0.  This
is not an error, because an empty boxa is valid and
boxaGetExtent() is required for serialization.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetExtent(*args)
    
    

    try:
        leptonica.boxaGetCoverage.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaGetCoverage.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetCoverage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetCoverage(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'wc')       
('l_int32', 'hc')       
('l_int32', 'exactflag')       
('l_float32', '*pfract')       

:param[in]    boxa:
:param[in]    wc,: hc     dimensions of overall clipping rectangle with UL
corner at (0, 0 that is covered by the boxes.
:param[in]    exactflag:  1 for guaranteeing an exact result; 0 for getting
an exact result only if the boxes do not overlap
:param[out]   pfract:     sum of box area as fraction of w * h
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The boxes in boxa are clipped to the input rectangle.
(2) * When %exactflag == 1, we generate a 1 bpp pix of size
wc x hc, paint all the boxes black, and count the fg pixels.
This can take 1 msec on a large page with many boxes.
When %exactflag == 0, we clip each box to the wc x hc region
and sum the resulting areas.  This is faster.
The results are the same when none of the boxes overlap
within the wc x hc region.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetCoverage(*args)
    
    

    try:
        leptonica.boxaaSizeRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaaSizeRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaaSizeRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaSizeRange(*args):
        """
        ('BOXAA', '*baa')       
('l_int32', '*pminw')       
('l_int32', '*pminh')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       

:param[in]    baa:
:param[out]   pminw:    [optional] min width of all boxes
:param[out]   pmaxw:    [optional] max width of all boxes
:param[out]   pminh:    [optional] min height of all boxes
:param[out]   pmaxh:    [optional] max height of all boxes
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaSizeRange(*args)
    
    

    try:
        leptonica.boxaSizeRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSizeRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSizeRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSizeRange(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*pminw')       
('l_int32', '*pminh')       
('l_int32', '*pmaxw')       
('l_int32', '*pmaxh')       

:param[in]    boxa:
:param[out]   pminw:    [optional] min width of all boxes
:param[out]   pmaxw:    [optional] max width of all boxes
:param[out]   pminh:    [optional] min height of all boxes
:param[out]   pmaxh:    [optional] max height of all boxes
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSizeRange(*args)
    
    

    try:
        leptonica.boxaLocationRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaLocationRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaLocationRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaLocationRange(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*pminx')       
('l_int32', '*pminy')       
('l_int32', '*pmaxx')       
('l_int32', '*pmaxy')       

:param[in]    boxa:
:param[out]   pminx:    [optional] min (UL corner) x value of all boxes
:param[out]   pminy:    [optional] min (UL corner) y value of all boxes
:param[out]   pmaxx:    [optional] max (UL corner) x value of all boxes
:param[out]   pmaxy:    [optional] max (UL corner) y value of all boxes
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaLocationRange(*args)
    
    

    try:
        leptonica.boxaGetSizes.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetSizes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetSizes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetSizes(*args):
        """
        ('BOXA', '*boxa')       
('NUMA', '**pnaw')       
('NUMA', '**pnah')       

:param[in]    boxa:
:param[out]   pnaw:    [optional] widths of valid boxes
:param[out]   pnah:    [optional] heights of valid boxes
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetSizes(*args)
    
    

    try:
        leptonica.boxaGetArea.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaGetArea.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaGetArea not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaGetArea(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', '*parea')       

:param[in]    boxa:
:param[out]   parea:    total area of all boxes
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Measures the total area of the boxes, without regard to overlaps.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaGetArea(*args)
    
    

    try:
        leptonica.boxaDisplayTiled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaDisplayTiled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaDisplayTiled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaDisplayTiled(*args):
        """
        ('BOXA', '*boxas')       
('PIXA', '*pixa')       
('l_int32', 'first')       
('l_int32', 'last')       
('l_int32', 'maxwidth')       
('l_int32', 'linewidth')       
('l_float32', 'scalefactor')       
('l_int32', 'background')       
('l_int32', 'spacing')       
('l_int32', 'border')       

:param[in]    boxas:
:param[in]    pixa:          [optional] background for each box
:param[in]    first:         index of first box
:param[in]    last:          index of last box; use -1 to go to end
:param[in]    maxwidth:      of output image
:param[in]    linewidth:     width of box outlines, before scaling
:param[in]    scalefactor:   applied to every box; use 1.0 for no scaling
:param[in]    background:    0 for white, 1 for black; this is the color
of the spacing between the images
:param[in]    spacing:       between images, and on outside
:param[in]    border:        width of black border added to each image;
use 0 for no border
:returns:  pixd of tiled images of boxes, or NULL on error

<pre>
Notes:
(1) Displays each box separately in a tiled 32 bpp image.
(2) If pixa is defined, it must have the same count as the boxa,
and it will be a background over with each box is rendered.
If pixa is not defined, the boxes will be rendered over
blank images of identical size.
(3) See pixaDisplayTiledInRows() for other parameters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaDisplayTiled(*args)
    




class boxfunc5(object):
    """<pre>

Boxa sequence fitting
BOXA     *boxaSmoothSequenceMedian()
BOXA     *boxaWindowedMedian()
BOXA     *boxaModifyWithBoxa()
BOXA     *boxaConstrainSize()
BOXA     *boxaReconcileEvenOddHeight()
static l_int32   boxaTestEvenOddHeight()
BOXA     *boxaReconcilePairWidth()
l_int32   boxaSizeConsistency1()
l_int32   boxaSizeConsistency2()
BOXA     *boxaReconcileAllByMedian()
BOXA     *boxaReconcileSidesByMedian()
static void      adjustSidePlotName()  -- debug
BOXA     *boxaReconcileSizeByMedian()
l_int32   boxaPlotSides()   [for debugging]
l_int32   boxaPlotSizes()   [for debugging]
BOXA     *boxaFillSequence()
static l_int32   boxaFillAll()
l_int32   boxaSizeVariation()
l_int32   boxaMedianDimensions()
</pre>




"""
    
    try:
        leptonica.boxaSmoothSequenceMedian.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaSmoothSequenceMedian.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaSmoothSequenceMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSmoothSequenceMedian(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'halfwin')       
('l_int32', 'subflag')       
('l_int32', 'maxdiff')       
('l_int32', 'extrapixels')       
('l_int32', 'debug')       

:param[in]    boxas:        source boxa
:param[in]    halfwin:      half-width of sliding window; used to find median
:param[in]    subflag:      L_USE_MINSIZE, L_USE_MAXSIZE,
L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF,
L_USE_CAPPED_MIN, L_USE_CAPPED_MAX
:param[in]    maxdiff:      parameter used with L_SUB_ON_LOC_DIFF,
L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN,
L_USE_CAPPED_MAX
:param[in]    extrapixels:  pixels added on all sides (or subtracted
if %extrapixels < 0) when using
L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF
:param[in]    debug:        1 for debug output
:returns:  boxad fitted boxa, or NULL on error

<pre>
Notes:
(1) The target width of the sliding window is 2 * %halfwin + 1.
If necessary, this will be reduced by boxaWindowedMedian().
(2) This returns a modified version of %boxas by constructing
for each input box a box that has been smoothed with windowed
median filtering.  The filtering is done to each of the
box sides independently, and it is computed separately for
sequences of even and odd boxes.  The output %boxad is
constructed from the input boxa and the filtered boxa,
depending on %subflag.  See boxaModifyWithBoxa() for
details on the use of %subflag, %maxdiff and %extrapixels.
(3) This is useful for removing noise separately in the even
and odd sets, where the box edge locations can have
discontinuities but otherwise vary roughly linearly within
intervals of size %halfwin or larger.
(4) If you don't need to handle even and odd sets separately,
just do this:
boxam = boxaWindowedMedian(boxas, halfwin, debug);
boxad = boxaModifyWithBoxa(boxas, boxam, subflag, maxdiff,
extrapixels);
boxaDestroy(&boxam);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSmoothSequenceMedian(*args)
    
    

    try:
        leptonica.boxaWindowedMedian.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaWindowedMedian.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaWindowedMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaWindowedMedian(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'halfwin')       
('l_int32', 'debug')       

:param[in]    boxas:     source boxa
:param[in]    halfwin:   half width of window over which the median is found
:param[in]    debug:     1 for debug output
:returns:  boxad smoothed boxa, or NULL on error

<pre>
Notes:
(1) This finds a set of boxes (boxad) where each edge of each box is
a windowed median smoothed value to the edges of the
input set of boxes (boxas).
(2) Invalid input boxes are filled from nearby ones.
(3) The returned boxad can then be used in boxaModifyWithBoxa()
to selectively change the boxes in the source boxa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaWindowedMedian(*args)
    
    

    try:
        leptonica.boxaModifyWithBoxa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaModifyWithBoxa.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaModifyWithBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaModifyWithBoxa(*args):
        """
        ('BOXA', '*boxas')       
('BOXA', '*boxam')       
('l_int32', 'subflag')       
('l_int32', 'maxdiff')       
('l_int32', 'extrapixels')       

:param[in]    boxas:
:param[in]    boxam:        boxa with boxes used to modify those in boxas
:param[in]    subflag:      L_USE_MINSIZE, L_USE_MAXSIZE,
L_SUB_ON_LOC_DIFF, L_SUB_ON_SIZE_DIFF,
L_USE_CAPPED_MIN, L_USE_CAPPED_MAX
:param[in]    maxdiff:      parameter used with L_SUB_ON_LOC_DIFF,
L_SUB_ON_SIZE_DIFF, L_USE_CAPPED_MIN,
L_USE_CAPPED_MAX
:param[in]    extrapixels:  pixels added on all sides (or subtracted
if %extrapixels < 0) when using
L_SUB_ON_LOC_DIFF and L_SUB_ON_SIZE_DIFF
:returns:  boxad  result after adjusting boxes in boxas, or NULL on error.

<pre>
Notes:
(1) This takes two input boxa (boxas, boxam) and constructs boxad,
where each box in boxad is generated from the corresponding
boxes in boxas and boxam.  The rule for constructing each
output box depends on %subflag and %maxdiff.  Let boxs be
a box from %boxas and boxm be a box from %boxam.
If %subflag == L_USE_MINSIZE: the output box is the intersection
of the two input boxes.
If %subflag == L_USE_MAXSIZE: the output box is the union of the
two input boxes; i.e., the minimum bounding rectangle for the
two input boxes.
If %subflag == L_SUB_ON_LOC_DIFF: each side of the output box
is found separately from the corresponding side of boxs and boxm.
Use the boxm side, expanded by %extrapixels, if greater than
%maxdiff pixels from the boxs side.
If %subflag == L_SUB_ON_SIZE_DIFF: the sides of the output box
are determined in pairs from the width and height of boxs
and boxm.  If the boxm width differs by more than %maxdiff
pixels from boxs, use the boxm left and right sides,
expanded by %extrapixels.  Ditto for the height difference.
For the last two flags, each side of the output box is found
separately from the corresponding side of boxs and boxm,
according to these rules, where "smaller"("bigger") mean in a
direction that decreases(increases) the size of the output box:
If %subflag == L_USE_CAPPED_MIN: use the Min of boxm
with the Max of (boxs, boxm +- %maxdiff), where the sign
is adjusted to make the box smaller (e.g., use "+" on left side).
If %subflag == L_USE_CAPPED_MAX: use the Max of boxm
with the Min of (boxs, boxm +- %maxdiff), where the sign
is adjusted to make the box bigger (e.g., use "-" on left side).
Use of the last 2 flags is further explained in (3) and (4).
(2) boxas and boxam must be the same size.  If boxam == NULL,
this returns a copy of boxas with a warning.
(3) If %subflag == L_SUB_ON_LOC_DIFF, use boxm for each side
where the corresponding sides differ by more than %maxdiff.
Two extreme cases:
(a) set %maxdiff == 0 to use only values from boxam in boxad.
(b) set %maxdiff == 10000 to ignore all values from boxam;
then boxad will be the same as boxas.
(4) If %subflag == L_USE_CAPPED_MAX: use boxm if boxs is smaller;
use boxs if boxs is bigger than boxm by an amount up to %maxdiff;
and use boxm +- %maxdiff (the 'capped' value) if boxs is
bigger than boxm by an amount larger than %maxdiff.
Similarly, with interchange of Min/Max and sign of %maxdiff,
for %subflag == L_USE_CAPPED_MIN.
(5) If either of corresponding boxes in boxas and boxam is invalid,
an invalid box is copied to the result.
(6) Typical input for boxam may be the output of boxaLinearFit().
where outliers have been removed and each side is LS fit to a line.
(7) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
this uses two boxes and does not specify target dimensions.
Additional constraints on the size of each box can be enforced
by following this operation with boxaConstrainSize(), taking
boxad as input.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaModifyWithBoxa(*args)
    
    

    try:
        leptonica.boxaConstrainSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaConstrainSize.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaConstrainSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaConstrainSize(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'width')       
('l_int32', 'widthflag')       
('l_int32', 'height')       
('l_int32', 'heightflag')       

:param[in]    boxas:
:param[in]    width:        force width of all boxes to this size;
input 0 to use the median width
:param[in]    widthflag:    L_ADJUST_SKIP, L_ADJUST_LEFT, L_ADJUST_RIGHT,
or L_ADJUST_LEFT_AND_RIGHT
:param[in]    height:       force height of all boxes to this size;
input 0 to use the median height
:param[in]    heightflag:   L_ADJUST_SKIP, L_ADJUST_TOP, L_ADJUST_BOT,
or L_ADJUST_TOP_AND_BOT
:returns:  boxad adjusted so all boxes are the same size

<pre>
Notes:
(1) Forces either width or height (or both) of every box in
the boxa to a specified size, by moving the indicated sides.
(2) Not all input boxes need to be valid.  Median values will be
used with invalid boxes.
(3) Typical input might be the output of boxaLinearFit(),
where each side has been fit.
(4) Unlike boxaAdjustWidthToTarget() and boxaAdjustHeightToTarget(),
this is not dependent on a difference threshold to change the size.
(5) On error, a message is issued and a copy of the input boxa
is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaConstrainSize(*args)
    
    

    try:
        leptonica.boxaReconcileEvenOddHeight.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_int32]
        leptonica.boxaReconcileEvenOddHeight.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReconcileEvenOddHeight not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReconcileEvenOddHeight(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'sides')       
('l_int32', 'delh')       
('l_int32', 'op')       
('l_float32', 'factor')       
('l_int32', 'start')       

:param[in]    boxas:    containing at least 3 valid boxes in even and odd
:param[in]    sides:    L_ADJUST_TOP, L_ADJUST_BOT, L_ADJUST_TOP_AND_BOT
:param[in]    delh:     threshold on median height difference
:param[in]    op:       L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX
:param[in]    factor:   > 0.0, typically near 1.0
:param[in]    start:    0 if pairing (0,1), etc; 1 if pairing (1,2), etc
:returns:  boxad adjusted, or a copy of boxas on error

<pre>
Notes:
(1) The basic idea is to reconcile differences in box height
in the even and odd boxes, by moving the top and/or bottom
edges in the even and odd boxes.  Choose the edge or edges
to be moved, whether to adjust the boxes with the min
or the max of the medians, and the threshold on the median
difference between even and odd box heights for the operations
to take place.  The same threshold is also used to
determine if each individual box edge is to be adjusted.
(2) Boxes are conditionally reset with either the same top (y)
value or the same bottom value, or both.  The value is
determined by the greater or lesser of the medians of the
even and odd boxes, with the choice depending on the value
of %op, which selects for either min or max median height.
If the median difference between even and odd boxes is
greater than %dely, then any individual box edge that differs
from the selected median by more than %dely is set to
the selected median times a factor typically near 1.0.
(3) Note that if selecting for minimum height, you will choose
the largest y-value for the top and the smallest y-value for
the bottom of the box.
(4) Typical input might be the output of boxaSmoothSequenceMedian(),
where even and odd boxa have been independently regulated.
(5) Require at least 3 valid even boxes and 3 valid odd boxes.
Median values will be used for invalid boxes.
(6) If the median height is not representative of the boxes
in %boxas, this can make things much worse.  In that case,
ignore the value of %op, and force pairwise equality of the
heights, with pairwise maximal vertical extension.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReconcileEvenOddHeight(*args)
    
    

    try:
        leptonica.boxaReconcilePairWidth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.boxaReconcilePairWidth.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReconcilePairWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReconcilePairWidth(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'delw')       
('l_int32', 'op')       
('l_float32', 'factor')       
('NUMA', '*na')       

:param[in]    boxas:
:param[in]    delw:      threshold on adjacent width difference
:param[in]    op:        L_ADJUST_CHOOSE_MIN, L_ADJUST_CHOOSE_MAX
:param[in]    factor:    > 0.0, typically near 1.0
:param[in]    na:        [optional] indicator array allowing change
:returns:  boxad adjusted, or a copy of boxas on error

<pre>
Notes:
(1) This reconciles differences in the width of adjacent boxes,
by moving one side of one of the boxes in each pair.
If the widths in the pair differ by more than some
threshold, move either the left side for even boxes or
the right side for odd boxes, depending on if we're choosing
the min or max.  If choosing min, the width of the max is
set to factor * (width of min).  If choosing max, the width
of the min is set to factor * (width of max).
(2) If %na exists, it is an indicator array corresponding to the
boxes in %boxas.  If %na != NULL, only boxes with an
indicator value of 1 are allowed to adjust; otherwise,
all boxes can adjust.
(3) Typical input might be the output of boxaSmoothSequenceMedian(),
where even and odd boxa have been independently regulated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReconcilePairWidth(*args)
    
    

    try:
        leptonica.boxaSizeConsistency1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSizeConsistency1.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSizeConsistency1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSizeConsistency1(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'type')       
('l_float32', 'threshp')       
('l_float32', 'threshm')       
('l_float32', '*pfvarp')       
('l_float32', '*pfvarm')       
('l_int32', '*psame')       

:param[in]    boxas:     of size >= 10
:param[in]    type:      L_CHECK_WIDTH, L_CHECK_HEIGHT
:param[in]    threshp:   threshold for pairwise fractional variation
:param[in]    threshm:   threshold for fractional variation from median
:param[out]   pfvarp:    [optional] average fractional pairwise variation
:param[out]   pfvarm:    [optional] average fractional median variation
:param[out]   psame:     decision for uniformity of page size (1, 0, -1)

<pre>
Notes:
(1) This evaluates a boxa for particular types of dimensional
variation.  Select either width or height variation.  Then
it returns two numbers: one is based on pairwise (even/odd)
variation; the other is based on the average variation
from the boxa median.
(2) For the pairwise variation, get the fraction of the absolute
difference in dimension of each pair of boxes, and take
the average value.  The median variation is simply the
the average of the fractional deviation from the median
of all the boxes.
(3) Use 0 for default values of %threshp and %threshm.  They are
threshp:  0.02
threshm:  0.015
(4) The intended application is that the boxes are a sequence of
page regions in a book scan, and we calculate two numbers
that can give an indication if the pages are approximately
the same size.  The pairwise variation should be small if
the boxes are correctly calculated.  If there are a
significant number of random or systematic outliers, the
pairwise variation will be large, and no decision will be made
(i.e., return same == -1).  Here are the possible outcomes:
Pairwise Var    Median Var    Decision
------------    ----------    --------
small           small         same size  (1)
small           large         different size  (0)
large           small/large   unknown   (-1)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSizeConsistency1(*args)
    
    

    try:
        leptonica.boxaSizeConsistency2.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.boxaSizeConsistency2.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSizeConsistency2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSizeConsistency2(*args):
        """
        ('BOXA', '*boxas')       
('l_float32', '*pfdevw')       
('l_float32', '*pfdevh')       
('l_int32', 'debug')       

:param[in]    boxas:     of size >= 10
:param[out]   pfdevw:    average fractional deviation from median width
:param[out]   pfdevh:    average fractional deviation from median height
:param[in]    debug:     1 for debug plot output of input and regularized
width and height

<pre>
Notes:
(1) This evaluates a boxa for consistency of the box sizes.
The intended application is that the boxes are a sequence of
page regions in a book scan, and the output is a decision
about whether the pages should be approximately the same size.
The determination should be robust to outliers, both random
and (for many cases) systematic.
(2) This differs from boxaSizeConsistency1() in that it attempts
to correct for box dimensional errors before doing the
evaluation.  For this reason, it may be less robust.
(3) Adjacent even and odd boxes are expected to be the same size.
Take them pairwise, and assume the minimum height, hmin,
is correct.  Then for (the usual case) wmin/hmin > 0.5, assume
the minimum width is correct.  If wmin/hmin <= 0.5, assume
the maximum width is correct.
(4) After correcting each pair so that they are the same size,
compute the average fractional deviation, from median width and
height.  A deviation of width or height by more than about
0.02 is evidence that the boxes may be from a non-homogeneous
source, such as a book with significantly different page sizes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSizeConsistency2(*args)
    
    

    try:
        leptonica.boxaReconcileAllByMedian.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaReconcileAllByMedian.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReconcileAllByMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReconcileAllByMedian(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'select1')       
('l_int32', 'select2')       
('l_int32', 'thresh')       
('l_int32', 'extra')       
('PIXA', '*pixadb')       

:param[in]    boxas:    containing at least 6 valid boxes
:param[in]    select1:  L_ADJUST_LEFT_AND_RIGHT or L_ADJUST_SKIP
:param[in]    select2:  L_ADJUST_TOP_AND_BOT or L_ADJUST_SKIP
:param[in]    thresh:   threshold number of pixels to make adjustment
:param[in]    extra:    extra pixels to add beyond median value
:param[in]    pixadb:   use NULL to skip debug output
:returns:  boxad  possibly adjusted from boxas; a copy of boxas on error

<pre>
Notes:
(1) This uses boxaReconcileSidesByMedian() to reconcile
the left-and-right and/or top-and-bottom sides of the
even and odd boxes, separately.
(2) See boxaReconcileSidesByMedian() for use of %thresh and %extra.
(3) If all box sides are within %thresh of the median value,
the returned box will be identical to %boxas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReconcileAllByMedian(*args)
    
    

    try:
        leptonica.boxaReconcileSidesByMedian.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.boxaReconcileSidesByMedian.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReconcileSidesByMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReconcileSidesByMedian(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'select')       
('l_int32', 'thresh')       
('l_int32', 'extra')       
('PIXA', '*pixadb')       

:param[in]    boxas:    containing at least 3 valid boxes
:param[in]    select:   L_ADJUST_LEFT, L_ADJUST_RIGHT, etc.
:param[in]    thresh:   threshold number of pixels to make adjustment
:param[in]    extra:    extra pixels to add beyond median value
:param[in]    pixadb:   use NULL to skip debug output
:returns:  boxad  possibly adjusted from boxas; a copy of boxas on error

<pre>
Notes:
(1) This modifies individual box sides if their location differs
significantly (>= %thresh) from the median value.
(2) %select specifies which sides are to be checked.
(3) %thresh specifies the tolerance for different side locations.
Any box side that differs from the median by this much will
be set to the median value, plus the %extra amount.
(4) If %extra is positive, the box dimensions are expanded.
For example, for the left side, a positive %extra results in
moving the left side farther to the left (i.e., in a negative
direction).
(5) If all box sides are within %thresh - 1 of the median value,
the returned box will be identical to %boxas.
(6) N.B. If you expect that even and odd box sides should be
significantly different, this function must be called separately
on the even and odd boxes in %boxas.  Note also that the
higher level function boxaReconcileAllByMedian() handles the
even and odd box sides separately.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReconcileSidesByMedian(*args)
    
    

    try:
        leptonica.boxaReconcileSizeByMedian.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaReconcileSizeByMedian.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaReconcileSizeByMedian not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaReconcileSizeByMedian(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'type')       
('l_float32', 'dfract')       
('l_float32', 'sfract')       
('l_float32', 'factor')       
('NUMA', '**pnadelw')       
('NUMA', '**pnadelh')       
('l_float32', '*pratiowh')       

:param[in]    boxas:    containing at least 6 valid boxes
:param[in]    type:     L_CHECK_WIDTH, L_CHECK_HEIGHT, L_CHECK_BOTH
:param[in]    dfract:   threshold fraction of dimensional variation from
median; in range (0 ... 1); typ. about 0.05.
:param[in]    sfract:   threshold fraction of side variation from median;
in range (0 ... 1); typ. about 0.04.
:param[in]    factor:   expansion for fixed box beyond median width;
should be near 1.0.
:param[out]   pnadelw:  [optional] diff from median width for boxes
above threshold
:param[out]   pnadelh:  [optional] diff from median height for boxes
above threshold
:param[out]   pratiowh: [optional] ratio of median width/height of boxas
:returns:  boxad  possibly adjusted from boxas; a copy of boxas on error

<pre>
Notes:
(1) The basic idea is to identify significant differences in box
dimension (either width or height) and modify the outlier boxes.
(2) %type specifies if we are reconciling the width, height or both.
(3) %dfract specifies the tolerance for different dimensions. Any
box with a fractional difference from the median size that
exceeds %dfract will be altered.
(4) %sfract specifies the tolerance for different side locations.
If a box has been marked by (3) for alteration, any side
location that differs from the median side location by
more than %sfract of the median dimension (medw or medh)
will be moved.
(5) Median width and height are found for all valid boxes (i.e.,
for all boxes with width and height > 0.
Median side locations are found separately for even and odd boxes,
using only boxes that are "inliers"; i.e., that have been
found by (3) to be within tolerance for width or height.
(6) If all box dimensions are within threshold of the median size,
just return a copy.  Otherwise, box sides of the outliers
will be adjusted.
(7) Using %sfract, sides that are sufficiently far from the median
are first moved to the median value.  Then they are moved
together (in or out) so that the final box dimension
is %factor times the median dimension.
(8) The arrays that are the initial deviation from median size
(width and height) are optionally returned.  Also optionally
returned is the median w/h asperity ratio of the input %boxas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaReconcileSizeByMedian(*args)
    
    

    try:
        leptonica.boxaPlotSides.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaPlotSides.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaPlotSides not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaPlotSides(*args):
        """
        ('BOXA', '*boxa')       
('const char', '*plotname')       
('NUMA', '**pnal')       
('NUMA', '**pnat')       
('NUMA', '**pnar')       
('NUMA', '**pnab')       
('PIX', '**ppixd')       

:param[in]    boxa:       source boxa
:param[in]    plotname:   [optional], can be NULL
:param[out]   pnal:       [optional] na of left sides
:param[out]   pnat:       [optional] na of top sides
:param[out]   pnar:       [optional] na of right sides
:param[out]   pnab:       [optional] na of bottom sides
:param[out]   ppixd:      pix of the output plot
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This debugging function shows the progression of the four
sides in the boxa.  There must be at least 2 boxes.
(2) If there are invalid boxes (e.g., if only even or odd
indices have valid boxes), this will fill them with the
nearest valid box before plotting.
(3) The plotfiles are put in /tmp/lept/plots/, and are named
either with %plotname or, if NULL, a default name.  If
%plotname is used, make sure it has no whitespace characters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaPlotSides(*args)
    
    

    try:
        leptonica.boxaPlotSizes.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaPlotSizes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaPlotSizes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaPlotSizes(*args):
        """
        ('BOXA', '*boxa')       
('const char', '*plotname')       
('NUMA', '**pnaw')       
('NUMA', '**pnah')       
('PIX', '**ppixd')       

:param[in]    boxa:       source boxa
:param[in]    plotname:   [optional], can be NULL
:param[out]   pnaw:       [optional] na of widths
:param[out]   pnah:       [optional] na of heights
:param[out]   ppixd:      pix of the output plot
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This debugging function shows the progression of box width
and height in the boxa.  There must be at least 2 boxes.
(2) If there are invalid boxes (e.g., if only even or odd
indices have valid boxes), this will fill them with the
nearest valid box before plotting.
(3) The plotfiles are put in /tmp/lept/plots/, and are named
either with %plotname or, if NULL, a default name.  If
%plotname is used, make sure it has no whitespace characters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaPlotSizes(*args)
    
    

    try:
        leptonica.boxaFillSequence.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaFillSequence.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaFillSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaFillSequence(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', 'useflag')       
('l_int32', 'debug')       

:param[in]    boxas:      with at least 3 boxes
:param[in]    useflag:    L_USE_ALL_BOXES, L_USE_SAME_PARITY_BOXES
:param[in]    debug:      1 for debug output
:returns:  boxad filled boxa, or NULL on error

<pre>
Notes:
(1) This simple function replaces invalid boxes with a copy of
the nearest valid box, selected from either the entire
sequence (L_USE_ALL_BOXES) or from the boxes with the
same parity (L_USE_SAME_PARITY_BOXES).  It returns a new boxa.
(2) This is useful if you expect boxes in the sequence to
vary slowly with index.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaFillSequence(*args)
    
    

    try:
        leptonica.boxaSizeVariation.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaSizeVariation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaSizeVariation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaSizeVariation(*args):
        """
        ('BOXA', '*boxa')       
('l_int32', 'type')       
('l_float32', '*pdel_evenodd')       
('l_float32', '*prms_even')       
('l_float32', '*prms_odd')       
('l_float32', '*prms_all')       

:param[in]    boxa:           at least 4 boxes
:param[in]    type:           L_SELECT_WIDTH, L_SELECT_HEIGHT
:param[out]   pdel_evenodd:   [optional] average absolute value of
(even - odd) size pairs
:param[out]   prms_even:      [optional] rms deviation of even boxes
:param[out]   prms_odd:       [optional] rms deviation of odd boxes
:param[out]   prms_all:       [optional] rms deviation of all boxes
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This gives several measures of the smoothness of either the
width or height of a sequence of boxes.
See boxaMedianDimensions() for some other measures.
(2) Statistics can be found separately for even and odd boxes.
Additionally, the average pair-wise difference between
adjacent even and odd boxes can be returned.
(3) The use case is bounding boxes for scanned page images,
where ideally the sizes should have little variance.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaSizeVariation(*args)
    
    

    try:
        leptonica.boxaMedianDimensions.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaMedianDimensions.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function boxaMedianDimensions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaMedianDimensions(*args):
        """
        ('BOXA', '*boxas')       
('l_int32', '*pmedw')       
('l_int32', '*pmedh')       
('l_int32', '*pmedwe')       
('l_int32', '*pmedwo')       
('l_int32', '*pmedhe')       
('l_int32', '*pmedho')       
('NUMA', '**pnadelw')       
('NUMA', '**pnadelh')       

:param[in]    boxas:    containing at least 3 valid boxes in even and odd
:param[out]   pmedw:    [optional] median width of all boxes
:param[out]   pmedh:    [optional] median height of all boxes
:param[out]   pmedwe:   [optional] median width of even boxes
:param[out]   pmedwo:   [optional] median width of odd boxes
:param[out]   pmedhe:   [optional] median height of even boxes
:param[out]   pmedho:   [optional] median height of odd boxes
:param[out]   pnadelw:  [optional] width diff of each box from median
:param[out]   pnadelh:  [optional] height diff of each box from median
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This provides information that (1) allows identification of
boxes that have unusual (outlier) width or height, and (2) can
be used to regularize the sizes of the outlier boxes, assuming
that the boxes satisfy a fairly regular sequence and should
mostly have the same width and height.
(2) This finds the median width and height, as well as separate
median widths and heights of even and odd boxes.  It also
generates arrays that give the difference in width and height
of each box from the median, which can be used to correct
individual boxes.
(3) All return values are optional.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaMedianDimensions(*args)
    




class flipdetect(object):
    """<pre>

High-level interface for detection and correction
l_int32      pixOrientCorrect()

Page orientation detection (pure rotation by 90 degree increments):
l_int32      pixOrientDetect()
l_int32      makeOrientDecision()
l_int32      pixUpDownDetect()
l_int32      pixUpDownDetectGeneral()
l_int32      pixOrientDetectDwa()
l_int32      pixUpDownDetectDwa()
l_int32      pixUpDownDetectGeneralDwa()

Page mirror detection (flip 180 degrees about line in plane of image):
l_int32      pixMirrorDetect()
l_int32      pixMirrorDetectDwa()

Static debug helper
void         pixDebugFlipDetect()

===================================================================

Page transformation detection:

Once a page is deskewed, there are 8 possible states that it
can be in, shown symbolically below.  Suppose state 0 is correct.

0: correct     1          2          3
+------+   +------+   +------+   +------+
| **** |   | *    |   | **** |   |    * |
| *    |   | *    |   |    * |   |    * |
| *    |   | **** |   |    * |   | **** |
+------+   +------+   +------+   +------+

4          5          6          7
+-----+    +-----+    +-----+    +-----+
| *** |    |   * |    | *** |    | *   |
|   * |    |   * |    | *   |    | *   |
|   * |    |   * |    | *   |    | *   |
|   * |    | *** |    | *   |    | *** |
+-----+    +-----+    +-----+    +-----+

Each of the other seven can be derived from state 0 by applying some
combination of a 90 degree clockwise rotation, a flip about
a horizontal line, and a flip about a vertical line,
all abbreviated as:
R = Rotation (about a line perpendicular to the image)
H = Horizontal flip (about a vertical line in the plane of the image)
V = Vertical flip (about a horizontal line in the plane of the image)

We get these transformations:
RHV
000  -> 0
001  -> 1
010  -> 2
011  -> 3
100  -> 4
101  -> 5
110  -> 6
111  -> 7

Note that in four of these, the sum of H and V is 1 (odd).
For these four, we have a change in parity (handedness) of
the image, and the transformation cannot be performed by
rotation about a vertical line out of the page.   Under
rotation R, the set of 8 transformations decomposes into
two subgroups linking {0, 3, 4, 7} and {1, 2, 5, 6} independently.

pixOrientDetect*() tests for a pure rotation (0, 90, 180, 270 degrees).
It doesn't change parity.

pixMirrorDetect*() tests for a horizontal flip about the vertical axis.
It changes parity.

The landscape/portrait rotation can be detected in two ways:

(1) Compute the deskew confidence for an image segment,
both as is and rotated 90 degrees  (see skew.c).

(2) Compute the ascender/descender signal for the image,
both as is and rotated 90 degrees  (implemented here).

The ascender/descender signal is useful for determining text
orientation in Roman alphabets because the incidence of letters
with straight-line ascenders (b, d, h, k, l, 't') outnumber
those with descenders ('g', p, q).  The letters 't' and 'g'
will respond variably to the filter, depending on the type face.

What about the mirror image situations?  These aren't common
unless you're dealing with film, for example.
But you can reliably test if the image has undergone a
parity-changing flip once about some axis in the plane
of the image, using pixMirrorDetect*().  This works ostensibly by
counting the number of characters with ascenders that
stick out to the left and right of the ascender.  Characters
that are not mirror flipped are more likely to extend to the
right (b, h, k) than to the left (d).  Of course, that is for
text that is rightside-up.  So before you apply the mirror
test, it is necessary to insure that the text has the ascenders
going up, and not down or to the left or right.  But here's
what *really* happens.  It turns out that the pre-filtering before
the hit-miss transform (HMT) is crucial, and surprisingly, when
the pre-filtering is chosen to generate a large signal, the majority
of the signal comes from open regions of common lower-case
letters such as 'e', 'c' and 'f'.

All operations are given in two implementations whose results are
identical: rasterop morphology and dwa morphology.  The dwa
implementations are between 2x and 3x faster.

The set of operations you actually use depends on your prior knowledge:

(1) If the page is known to be either rightside-up or upside-down, use
either pixOrientDetect*() with pleftconf = NULL, or
pixUpDownDetect*().   [The '*' refers to either the rasterop
or dwa versions.]

(2) If any of the four orientations are possible, use pixOrientDetect*().

(3) If the text is horizontal and rightside-up, the only remaining
degree of freedom is a left-right mirror flip: use
pixMirrorDetect*().

(4) If you have a relatively large amount of numbers on the page,
us the slower pixUpDownDetectGeneral().

We summarize the full orientation and mirror flip detection process:

(1) First determine which of the four 90 degree rotations
causes the text to be rightside-up.  This can be done
with either skew confidence or the pixOrientDetect*()
signals.  For the latter, see the table for pixOrientDetect().

(2) Then, with ascenders pointing up, apply pixMirrorDetect*().
In the normal situation the confidence confidence will be
large and positive.  However, if mirror flipped, the
confidence will be large and negative.

A high-level interface, pixOrientCorrect() combines the detection
of the orientation with the rotation decision and the rotation itself.

Finally, use can be made of programs such as exiftool and convert to
read exif camera orientation data in jpeg files and conditionally rotate.
Here is an example shell script, made by Dan9er:
==================================================================
#!/bin/sh
#   orientByExif.sh
#   Dependencies: exiftool (exiflib) and convert (ImageMagick)
#   Note: if there is no exif orientation data in the jpeg file,
#         this simply copies the input file.
#
if [[ -z $(command -v exiftool) || -z $(command -v convert) ]]; then
echo "You need to install dependencies; e.g.:"
echo "   sudo apt install libimage-exiftool-perl"
echo "   sudo apt install imagemagick"
exit 1
fi
if [[ $# != 2 ]]; then
echo "Syntax: orientByExif infile outfile"
exit 2
fi
if [[ ${1: -4} != ".jpg" ]]; then
echo "File is not a jpeg"
exit 3
fi
if [[ $(exiftool -s3 -n -Orientation "$1") = 1 ]]; then
echo "Image is already upright"
exit 0
fi
convert "$1" -auto-orient "$2"
echo "Done"
exit 0
==================================================================
</pre>




"""
    
    try:
        leptonica.pixOrientCorrect.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixOrientCorrect.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOrientCorrect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOrientCorrect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'minupconf')       
('l_float32', 'minratio')       
('l_float32', '*pupconf')       
('l_float32', '*pleftconf')       
('l_int32', '*protation')       
('l_int32', 'debug')       

:param[in]    pixs:        1 bpp, deskewed, English text, 150 - 300 ppi
:param[in]    minupconf:   minimum value for which a decision can be made
:param[in]    minratio:    minimum conf ratio required for a decision
:param[out]   pupconf:     [optional] ; use NULL to skip
:param[out]   pleftconf:   [optional] ; use NULL to skip
:param[out]   protation:   [optional] ; use NULL to skip
:param[in]    debug:       1 for debug output; 0 otherwise
:returns:  pixd  may be rotated by 90, 180 or 270; null on error

<pre>
Notes:
(1) Simple top-level function to detect if Roman text is in
reading orientation, and to rotate the image accordingly if not.
(2) Returns a copy if no rotation is needed.
(3) See notes for pixOrientDetect() and pixOrientDecision().
Use 0.0 for default values for %minupconf and %minratio
(4) Optional output of intermediate confidence results and
the rotation performed on pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOrientCorrect(*args)
    
    

    try:
        leptonica.pixOrientDetect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOrientDetect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixOrientDetect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOrientDetect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pupconf')       
('l_float32', '*pleftconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text, 150 - 300 ppi
:param[out]   pupconf:    [optional] ; may be NULL
:param[out]   pleftconf:  [optional] ; may be NULL
:param[in]    mincount:   min number of up + down; use 0 for default
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See "Measuring document image skew and orientation"
Dan S. Bloomberg, Gary E. Kopec and Lakshmi Dasari
IS&T/SPIE EI'95, Conference 2422: Document Recognition II
pp 302-316, Feb 6-7, 1995, San Jose, CA
(2) upconf is the normalized difference between up ascenders
and down ascenders.  The image is analyzed without rotation
for being rightside-up or upside-down.  Set &upconf to null
to skip this operation.
(3) leftconf is the normalized difference between up ascenders
and down ascenders in the image after it has been
rotated 90 degrees clockwise.  With that rotation, ascenders
projecting to the left in the source image will project up
in the rotated image.  We compute this by rotating 90 degrees
clockwise and testing for up and down ascenders.  Set
&leftconf to null to skip this operation.
(4) Note that upconf and leftconf are not linear measures of
confidence, e.g., in a range between 0 and 100.  They
measure how far you are out on the tail of a (presumably)
normal distribution.  For example, a confidence of 10 means
that it is nearly certain that the difference did not
happen at random.  However, these values must be interpreted
cautiously, taking into consideration the estimated prior
for a particular orientation or mirror flip.   The up-down
signal is very strong if applied to text with ascenders
up and down, and relatively weak for text at 90 degrees,
but even at 90 degrees, the difference can look significant.
For example, suppose the ascenders are oriented horizontally,
but the test is done vertically.  Then upconf can
be < -MIN_CONF_FOR_UP_DOWN, suggesting the text may be
upside-down.  However, if instead the test were done
horizontally, leftconf will be very much larger
(in absolute value), giving the correct orientation.
(5) If you compute both upconf and leftconf, and there is
sufficient signal, the following table determines the
cw angle necessary to rotate pixs so that the text is
rightside-up:
0 deg :           upconf >> 1,    abs(upconf) >> abs(leftconf)
90 deg :          leftconf >> 1,  abs(leftconf) >> abs(upconf)
180 deg :         upconf << -1,   abs(upconf) >> abs(leftconf)
270 deg :         leftconf << -1, abs(leftconf) >> abs(upconf)
(6) One should probably not interpret the direction unless
there are a sufficient number of counts for both orientations,
in which case neither upconf nor leftconf will be 0.0.
(7) This algorithm will fail on some images, such as tables,
where most of the characters are numbers and appear as
uppercase, but there are some repeated words that give a
biased signal.  It may be advisable to run a table detector
first (e.g., pixDecideIfTable()), and not run the orientation
detector if it is a table.
(8) Uses rasterop implementation of HMT.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOrientDetect(*args)
    
    

    try:
        leptonica.makeOrientDecision.argtypes = [ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32]
        leptonica.makeOrientDecision.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function makeOrientDecision not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeOrientDecision(*args):
        """
        ('l_float32', 'upconf')       
('l_float32', 'leftconf')       
('l_float32', 'minupconf')       
('l_float32', 'minratio')       
('l_int32', '*porient')       
('l_int32', 'debug')       

:param[in]    upconf:      nonzero
:param[in]    leftconf:    nonzero
:param[in]    minupconf:   minimum value for which a decision can be made
:param[in]    minratio:    minimum conf ratio required for a decision
:param[out]   porient:     text orientation enum {0,1,2,3,4}
:param[in]    debug:       1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This can be run after pixOrientDetect()
(2) Both upconf and leftconf must be nonzero; otherwise the
orientation cannot be determined.
(3) The abs values of the input confidences are compared to
minupconf.
(4) The abs value of the largest of (upconf/leftconf) and
(leftconf/upconf) is compared with minratio.
(5) Input 0.0 for the default values for minupconf and minratio.
(6) The return value of orient is interpreted thus:
L_TEXT_ORIENT_UNKNOWN:  not enough evidence to determine
L_TEXT_ORIENT_UP:       text rightside-up
L_TEXT_ORIENT_LEFT:     landscape, text up facing left
L_TEXT_ORIENT_DOWN:     text upside-down
L_TEXT_ORIENT_RIGHT:    landscape, text up facing right
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeOrientDecision(*args)
    
    

    try:
        leptonica.pixUpDownDetect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixUpDownDetect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text, 150 - 300 ppi
:param[out]   pconf:      confidence that text is rightside-up
:param[in]    mincount:   min number of up + down; use 0 for default
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Special (typical, slightly faster) case, where the pixels
identified through the HMT (hit-miss transform) are not
clipped by a truncated word mask pixm.  See pixOrientDetect()
and pixUpDownDetectGeneral() for details.
(2) The returned confidence is the normalized difference
between the number of detected up and down ascenders,
assuming that the text is either rightside-up or upside-down
and not rotated at a 90 degree angle.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetect(*args)
    
    

    try:
        leptonica.pixUpDownDetectGeneral.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetectGeneral.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixUpDownDetectGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetectGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'npixels')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text, 150 - 300 ppi
:param[out]   pconf:      confidence that text is rightside-up
:param[in]    mincount:   min number of up + down; use 0 for default
:param[in]    npixels:    number of pixels removed from each side of word box
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixOrientDetect() for other details.
(2) %conf is the normalized difference between the number of
detected up and down ascenders, assuming that the text
is either rightside-up or upside-down and not rotated
at a 90 degree angle.
(3) The typical mode of operation is %npixels == 0.
If %npixels > 0, this removes HMT matches at the
beginning and ending of "words."  This is useful for
pages that may have mostly digits, because if npixels == 0,
leading "1" and "3" digits can register as having
ascenders or descenders, and "7" digits can match descenders.
Consequently, a page image of only digits may register
as being upside-down.
(4) We want to count the number of instances found using the HMT.
An expensive way to do this would be to count the
number of connected components.  A cheap way is to do a rank
reduction cascade that reduces each component to a single
pixel, and results (after two or three 2x reductions)
in one pixel for each of the original components.
After the reduction, you have a much smaller pix over
which to count pixels.  We do only 2 reductions, because
this function is designed to work for input pix between
150 and 300 ppi, and an 8x reduction on a 150 ppi image
is going too far -- components will get merged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetectGeneral(*args)
    
    

    try:
        leptonica.pixOrientDetectDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOrientDetectDwa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixOrientDetectDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOrientDetectDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pupconf')       
('l_float32', '*pleftconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       

:param[in]    pixs:        1 bpp, deskewed, English text
:param[out]   pupconf:     [optional] ; may be NULL
:param[out]   pleftconf:   [optional] ; may be NULL
:param[in]    mincount:    min number of up + down; use 0 for default
:param[in]    debug:       1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Same interface as for pixOrientDetect().  See notes
there for usage.
(2) Uses auto-gen'd code for the Sels defined at the
top of this file, with some renaming of functions.
The auto-gen'd code is in fliphmtgen.c, and can
be generated by a simple executable; see prog/flipselgen.c.
(3) This runs about 2.5 times faster than the pixOrientDetect().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOrientDetectDwa(*args)
    
    

    try:
        leptonica.pixUpDownDetectDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetectDwa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixUpDownDetectDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetectDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text, 150 - 300 ppi
:param[out]   pconf:      confidence that text is rightside-up
:param[in]    mincount:   min number of up + down; use 0 for default
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Faster (DWA) version of pixUpDownDetect().
(2) This is a special case (but typical and slightly faster) of
pixUpDownDetectGeneralDwa(), where the pixels identified
through the HMT (hit-miss transform) are not clipped by
a truncated word mask pixm.  See pixUpDownDetectGeneral()
for usage and other details.
(3) The returned confidence is the normalized difference
between the number of detected up and down ascenders,
assuming that the text is either rightside-up or upside-down
and not rotated at a 90 degree angle.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetectDwa(*args)
    
    

    try:
        leptonica.pixUpDownDetectGeneralDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixUpDownDetectGeneralDwa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixUpDownDetectGeneralDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixUpDownDetectGeneralDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'npixels')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text
:param[out]   pconf:      confidence that text is rightside-up
:param[in]    mincount:   min number of up + down; use 0 for default
:param[in]    npixels:    number of pixels removed from each side of word box
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See the notes in pixUpDownDetectGeneral() for usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixUpDownDetectGeneralDwa(*args)
    
    

    try:
        leptonica.pixMirrorDetect.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMirrorDetect.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMirrorDetect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMirrorDetect(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text
:param[out]   pconf:      confidence that text is not LR mirror reversed
:param[in]    mincount:   min number of left + right; use 0 for default
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) For this test, it is necessary that the text is horizontally
oriented, with ascenders going up.
(2) conf is the normalized difference between the number of
right and left facing characters with ascenders.
Left-facing are {d}; right-facing are {b, h, k}.
At least that was the expectation.  In practice, we can
really just say that it is the normalized difference in
hits using two specific hit-miss filters, textsel1 and textsel2,
after the image has been suitably pre-filtered so that
these filters are effective.  See (4) for what's really happening.
(3) A large positive conf value indicates normal text, whereas
a large negative conf value means the page is mirror reversed.
(4) The implementation is a bit tricky.  The general idea is
to fill the x-height part of characters, but not the space
between them, before doing the HMT.  This is done by
finding pixels added using two different operations -- a
horizontal close and a vertical dilation -- and adding
the intersection of these sets to the original.  It turns
out that the original intuition about the signal was largely
in error: much of the signal for right-facing characters
comes from the lower part of common x-height characters, like
the e and c, that remain open after these operations.
So it's important that the operations to close the x-height
parts of the characters are purposely weakened sufficiently
to allow these characters to remain open.  The wonders
of morphology!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMirrorDetect(*args)
    
    

    try:
        leptonica.pixMirrorDetectDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixMirrorDetectDwa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMirrorDetectDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMirrorDetectDwa(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*pconf')       
('l_int32', 'mincount')       
('l_int32', 'debug')       

:param[in]    pixs:       1 bpp, deskewed, English text
:param[out]   pconf:      confidence that text is not LR mirror reversed
:param[in]    mincount:   min number of left + right; use 0 for default
:param[in]    debug:      1 for debug output; 0 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) We assume the text is horizontally oriented, with
ascenders going up.
(2) See notes in pixMirrorDetect().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMirrorDetectDwa(*args)
    




class morph(object):
    """<pre>

Generic binary morphological ops implemented with rasterop
PIX     *pixDilate()
PIX     *pixErode()
PIX     *pixHMT()
PIX     *pixOpen()
PIX     *pixClose()
PIX     *pixCloseSafe()
PIX     *pixOpenGeneralized()
PIX     *pixCloseGeneralized()

Binary morphological (raster) ops with brick Sels
PIX     *pixDilateBrick()
PIX     *pixErodeBrick()
PIX     *pixOpenBrick()
PIX     *pixCloseBrick()
PIX     *pixCloseSafeBrick()

Binary composed morphological (raster) ops with brick Sels
l_int32  selectComposableSels()
l_int32  selectComposableSizes()
PIX     *pixDilateCompBrick()
PIX     *pixErodeCompBrick()
PIX     *pixOpenCompBrick()
PIX     *pixCloseCompBrick()
PIX     *pixCloseSafeCompBrick()

Functions associated with boundary conditions
void     resetMorphBoundaryCondition()
l_int32  getMorphBorderPixelColor()

Static helpers for arg processing
static PIX     *processMorphArgs1()
static PIX     *processMorphArgs2()

You are provided with many simple ways to do binary morphology.
In particular, if you are using brick Sels, there are six
convenient methods, all specially tailored for separable operations
on brick Sels.  A "brick" Sel is a Sel that is a rectangle
of solid SEL_HITs with the origin at or near the center.
Note that a brick Sel can have one dimension of size 1.
This is very common.  All the brick Sel operations are
separable, meaning the operation is done first in the horizontal
direction and then in the vertical direction.  If one of the
dimensions is 1, this is a special case where the operation is
only performed in the other direction.

These six brick Sel methods are enumerated as follows:

(1) Brick Sels: pix*Brick(), where * = {Dilate, Erode, Open, Close}.
These are separable rasterop implementations.  The Sels are
automatically generated, used, and destroyed at the end.
You can get the result as a new Pix, in-place back into the src Pix,
or written to another existing Pix.

(2) Brick Sels: pix*CompBrick(), where * = {Dilate, Erode, Open, Close}.
These are separable, 2-way composite, rasterop implementations.
The Sels are automatically generated, used, and destroyed at the end.
You can get the result as a new Pix, in-place back into the src Pix,
or written to another existing Pix.  For large Sels, these are
considerably faster than the corresponding pix*Brick() functions.
N.B.:  The size of the Sels that are actually used are typically
close to, but not exactly equal to, the size input to the function.

(3) Brick Sels: pix*BrickDwa(), where * = {Dilate, Erode, Open, Close}.
These are separable dwa (destination word accumulation)
implementations.  They use auto-gen'd dwa code.  You can get
the result as a new Pix, in-place back into the src Pix,
or written to another existing Pix.  This is typically
about 3x faster than the analogous rasterop pix*Brick()
function, but it has the limitation that the Sel size must
be less than 63.  This is pre-set to work on a number
of pre-generated Sels.  If you want to use other Sels, the
code can be auto-gen'd for them; see the instructions in morphdwa.c.

(4) Same as (1), but you run it through pixMorphSequence(), with
the sequence string either compiled in or generated using snprintf.
All intermediate images and Sels are created, used and destroyed.
You always get the result as a new Pix.  For example, you can
specify a separable 11 x 17 brick opening as "o11.17",
or you can specify the horizontal and vertical operations
explicitly as "o11.1 + o1.11".  See morphseq.c for details.

(5) Same as (2), but you run it through pixMorphCompSequence(), with
the sequence string either compiled in or generated using snprintf.
All intermediate images and Sels are created, used and destroyed.
You always get the result as a new Pix.  See morphseq.c for details.

(6) Same as (3), but you run it through pixMorphSequenceDwa(), with
the sequence string either compiled in or generated using snprintf.
All intermediate images and Sels are created, used and destroyed.
You always get the result as a new Pix.  See morphseq.c for details.

If you are using Sels that are not bricks, you have two choices:
(a) simplest: use the basic rasterop implementations (pixDilate(), ...)
(b) fastest: generate the destination word accumumlation (dwa)
code for your Sels and compile it with the library.

For an example, see flipdetect.c, which gives implementations
using hit-miss Sels with both the rasterop and dwa versions.
For the latter, the dwa code resides in fliphmtgen.c, and it
was generated by prog/flipselgen.c.  Both the rasterop and dwa
implementations are tested by prog/fliptest.c.

A global constant MORPH_BC is used to set the boundary conditions
for rasterop-based binary morphology.  MORPH_BC, in morph.c,
is set by default to ASYMMETRIC_MORPH_BC for a non-symmetric
convention for boundary pixels in dilation and erosion:
All pixels outside the image are assumed to be OFF
for both dilation and erosion.
To use a symmetric definition, see comments in pixErode()
and reset MORPH_BC to SYMMETRIC_MORPH_BC, using
resetMorphBoundaryCondition().

Boundary artifacts are possible in closing when the non-symmetric
boundary conditions are used, because foreground pixels very close
to the edge can be removed.  This can be avoided by using either
the symmetric boundary conditions or the function pixCloseSafe(),
which adds a border before the operation and removes it afterwards.

The hit-miss transform (HMT) is the bit-and of 2 erosions:
(erosion of the src by the hits)  &  (erosion of the bit-inverted
src by the misses)

The 'generalized opening' is an HMT followed by a dilation that uses
only the hits of the hit-miss Sel.
The 'generalized closing' is a dilation (again, with the hits
of a hit-miss Sel), followed by the HMT.
Both of these 'generalized' functions are idempotent.

These functions are extensively tested in prog/binmorph1_reg.c,
prog/binmorph2_reg.c, and prog/binmorph3_reg.c.
</pre>




"""
    
    try:
        leptonica.pixDilate.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixDilate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilate(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) This dilates src using hits in Sel.
(2) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixDilate(NULL, pixs, ...);
(b) pixDilate(pixs, pixs, ...);
(c) pixDilate(pixd, pixs, ...);
(4) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilate(*args)
    
    

    try:
        leptonica.pixErode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixErode.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErode(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) This erodes src using hits in Sel.
(2) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixErode(NULL, pixs, ...);
(b) pixErode(pixs, pixs, ...);
(c) pixErode(pixd, pixs, ...);
(4) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErode(*args)
    
    

    try:
        leptonica.pixHMT.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixHMT.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHMT not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHMT(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:   [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:   1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) The hit-miss transform erodes the src, using both hits
and misses in the Sel.  It ANDs the shifted src for hits
and ANDs the inverted shifted src for misses.
(2) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixHMT(NULL, pixs, ...);
(b) pixHMT(pixs, pixs, ...);
(c) pixHMT(pixd, pixs, ...);
(4) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHMT(*args)
    
    

    try:
        leptonica.pixOpen.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOpen.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpen(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) Generic morphological opening, using hits in the Sel.
(2) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(3) For clarity, if the case is known, use these patterns:
(a) pixd = pixOpen(NULL, pixs, ...);
(b) pixOpen(pixs, pixs, ...);
(c) pixOpen(pixd, pixs, ...);
(4) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpen(*args)
    
    

    try:
        leptonica.pixClose.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixClose.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixClose not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixClose(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd: [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs: 1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) Generic morphological closing, using hits in the Sel.
(2) This implementation is a strict dual of the opening if
symmetric boundary conditions are used (see notes at top
of this file).
(3) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(4) For clarity, if the case is known, use these patterns:
(a) pixd = pixClose(NULL, pixs, ...);
(b) pixClose(pixs, pixs, ...);
(c) pixClose(pixd, pixs, ...);
(5) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixClose(*args)
    
    

    try:
        leptonica.pixCloseSafe.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCloseSafe.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseSafe not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseSafe(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:   [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:   1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) Generic morphological closing, using hits in the Sel.
(2) If non-symmetric boundary conditions are used, this
function adds a border of OFF pixels that is of
sufficient size to avoid losing pixels from the dilation,
and it removes the border after the operation is finished.
It thus enforces a correct extensive result for closing.
(3) If symmetric b.c. are used, it is not necessary to add
and remove this border.
(4) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(5) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseSafe(NULL, pixs, ...);
(b) pixCloseSafe(pixs, pixs, ...);
(c) pixCloseSafe(pixd, pixs, ...);
(6) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseSafe(*args)
    
    

    try:
        leptonica.pixOpenGeneralized.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixOpenGeneralized.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenGeneralized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenGeneralized(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:   [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:   1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) Generalized morphological opening, using both hits and
misses in the Sel.
(2) This does a hit-miss transform, followed by a dilation
using the hits.
(3) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(4) For clarity, if the case is known, use these patterns:
(a) pixd = pixOpenGeneralized(NULL, pixs, ...);
(b) pixOpenGeneralized(pixs, pixs, ...);
(c) pixOpenGeneralized(pixd, pixs, ...);
(5) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenGeneralized(*args)
    
    

    try:
        leptonica.pixCloseGeneralized.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixCloseGeneralized.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseGeneralized not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseGeneralized(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('SEL', '*sel')       

:param[in]    pixd:   [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:   1 bpp
:param[in]    sel:
:returns:  pixd

<pre>
Notes:
(1) Generalized morphological closing, using both hits and
misses in the Sel.
(2) This does a dilation using the hits, followed by a
hit-miss transform.
(3) This operation is a dual of the generalized opening.
(4) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(5) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseGeneralized(NULL, pixs, ...);
(b) pixCloseGeneralized(pixs, pixs, ...);
(c) pixCloseGeneralized(pixd, pixs, ...);
(6) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseGeneralized(*args)
    
    

    try:
        leptonica.pixDilateBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do separably if both hsize and vsize are > 1.
(4) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(5) For clarity, if the case is known, use these patterns:
(a) pixd = pixDilateBrick(NULL, pixs, ...);
(b) pixDilateBrick(pixs, pixs, ...);
(c) pixDilateBrick(pixd, pixs, ...);
(6) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateBrick(*args)
    
    

    try:
        leptonica.pixErodeBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do separably if both hsize and vsize are > 1.
(4) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(5) For clarity, if the case is known, use these patterns:
(a) pixd = pixErodeBrick(NULL, pixs, ...);
(b) pixErodeBrick(pixs, pixs, ...);
(c) pixErodeBrick(pixd, pixs, ...);
(6) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeBrick(*args)
    
    

    try:
        leptonica.pixOpenBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do separably if both hsize and vsize are > 1.
(4) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(5) For clarity, if the case is known, use these patterns:
(a) pixd = pixOpenBrick(NULL, pixs, ...);
(b) pixOpenBrick(pixs, pixs, ...);
(c) pixOpenBrick(pixd, pixs, ...);
(6) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenBrick(*args)
    
    

    try:
        leptonica.pixCloseBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do separably if both hsize and vsize are > 1.
(4) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(5) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseBrick(NULL, pixs, ...);
(b) pixCloseBrick(pixs, pixs, ...);
(c) pixCloseBrick(pixd, pixs, ...);
(6) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseBrick(*args)
    
    

    try:
        leptonica.pixCloseSafeBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseSafeBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseSafeBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseSafeBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do separably if both hsize and vsize are > 1.
(4) Safe closing adds a border of 0 pixels, of sufficient size so
that all pixels in input image are processed within
32-bit words in the expanded image.  As a result, there is
no special processing for pixels near the boundary, and there
are no boundary effects.  The border is removed at the end.
(5) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(6) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseBrick(NULL, pixs, ...);
(b) pixCloseBrick(pixs, pixs, ...);
(c) pixCloseBrick(pixd, pixs, ...);
(7) The size of the result is determined by pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseSafeBrick(*args)
    
    

    try:
        leptonica.selectComposableSizes.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selectComposableSizes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selectComposableSizes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selectComposableSizes(*args):
        """
        ('l_int32', 'size')       
('l_int32', '*pfactor1')       
('l_int32', '*pfactor2')       

:param[in]    size:       of sel to be decomposed
:param[out]   pfactor1:   larger factor
:param[out]   pfactor2:   smaller factor
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This works for Sel sizes up to 10000, which seems sufficient.
(2) The composable sel size is typically within +- 1 of
the requested size.  Up to size = 300, the maximum difference
is +- 2.
(3) We choose an overall cost function where the penalty for
the size difference between input and actual is 4 times
the penalty for additional rasterops.
(4) Returned values: factor1 >= factor2
If size > 1, then factor1 > 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selectComposableSizes(*args)
    
    

    try:
        leptonica.pixDilateCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateCompBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do compositely for each dimension > 1.
(4) Do separably if both hsize and vsize are > 1.
(5) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(6) For clarity, if the case is known, use these patterns:
(a) pixd = pixDilateCompBrick(NULL, pixs, ...);
(b) pixDilateCompBrick(pixs, pixs, ...);
(c) pixDilateCompBrick(pixd, pixs, ...);
(7) The dimensions of the resulting image are determined by pixs.
(8) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateCompBrick(*args)
    
    

    try:
        leptonica.pixErodeCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeCompBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do compositely for each dimension > 1.
(4) Do separably if both hsize and vsize are > 1.
(5) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(6) For clarity, if the case is known, use these patterns:
(a) pixd = pixErodeCompBrick(NULL, pixs, ...);
(b) pixErodeCompBrick(pixs, pixs, ...);
(c) pixErodeCompBrick(pixd, pixs, ...);
(7) The dimensions of the resulting image are determined by pixs.
(8) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeCompBrick(*args)
    
    

    try:
        leptonica.pixOpenCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenCompBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do compositely for each dimension > 1.
(4) Do separably if both hsize and vsize are > 1.
(5) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(6) For clarity, if the case is known, use these patterns:
(a) pixd = pixOpenCompBrick(NULL, pixs, ...);
(b) pixOpenCompBrick(pixs, pixs, ...);
(c) pixOpenCompBrick(pixd, pixs, ...);
(7) The dimensions of the resulting image are determined by pixs.
(8) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenCompBrick(*args)
    
    

    try:
        leptonica.pixCloseCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseCompBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do compositely for each dimension > 1.
(4) Do separably if both hsize and vsize are > 1.
(5) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(6) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseCompBrick(NULL, pixs, ...);
(b) pixCloseCompBrick(pixs, pixs, ...);
(c) pixCloseCompBrick(pixd, pixs, ...);
(7) The dimensions of the resulting image are determined by pixs.
(8) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseCompBrick(*args)
    
    

    try:
        leptonica.pixCloseSafeCompBrick.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseSafeCompBrick.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseSafeCompBrick not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseSafeCompBrick(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Sel is a brick with all elements being hits
(2) The origin is at (x, y) = (hsize/2, vsize/2)
(3) Do compositely for each dimension > 1.
(4) Do separably if both hsize and vsize are > 1.
(5) Safe closing adds a border of 0 pixels, of sufficient size so
that all pixels in input image are processed within
32-bit words in the expanded image.  As a result, there is
no special processing for pixels near the boundary, and there
are no boundary effects.  The border is removed at the end.
(6) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(7) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseSafeCompBrick(NULL, pixs, ...);
(b) pixCloseSafeCompBrick(pixs, pixs, ...);
(c) pixCloseSafeCompBrick(pixd, pixs, ...);
(8) The dimensions of the resulting image are determined by pixs.
(9) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseSafeCompBrick(*args)
    
    

    try:
        leptonica.resetMorphBoundaryCondition.argtypes = [ctypes.c_int32]
        leptonica.resetMorphBoundaryCondition.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function resetMorphBoundaryCondition not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def resetMorphBoundaryCondition(*args):
        """
        ('l_int32', 'bc')       

:param[in]    bc:    SYMMETRIC_MORPH_BC, ASYMMETRIC_MORPH_BC
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.resetMorphBoundaryCondition(*args)
    
    

    try:
        leptonica.getMorphBorderPixelColor.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.getMorphBorderPixelColor.restype = ctypes.c_uint32
    except AttributeError:
        sys.stderr.write("Warning - function getMorphBorderPixelColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getMorphBorderPixelColor(*args):
        """
        ('l_int32', 'type')       
('l_int32', 'depth')       

:param[in]    type: L_MORPH_DILATE, L_MORPH_ERODE
:param[in]    depth: of pix
:returns:  color of border pixels for this operation


        """
        args = _convert_params(*args)
        
        return leptonica.getMorphBorderPixelColor(*args)
    




class pnmio(object):
    """<pre>

Stream interface
PIX             *pixReadStreamPnm()
l_int32          readHeaderPnm()
l_int32          freadHeaderPnm()
l_int32          pixWriteStreamPnm()
l_int32          pixWriteStreamAsciiPnm()
l_int32          pixWriteStreamPam()

Read/write to memory
PIX             *pixReadMemPnm()
l_int32          readHeaderMemPnm()
l_int32          pixWriteMemPnm()
l_int32          pixWriteMemPam()

Local helpers
static l_int32   pnmReadNextAsciiValue();
static l_int32   pnmReadNextNumber();
static l_int32   pnmReadNextString();
static l_int32   pnmSkipCommentLines();

These are here by popular demand, with the help of Mattias
Kregert (mattias@kregert.se), who provided the first implementation.

The pnm formats are exceedingly simple, because they have
no compression and no colormaps.  They support images that
are 1 bpp; 2, 4, 8 and 16 bpp grayscale; and rgb.

The original pnm formats ("ASCII") are included for completeness,
but their use is deprecated for all but tiny iconic images.
They are extremely wasteful of memory; for example, the P1 binary
ASCII format is 16 times as big as the packed uncompressed
format, because 2 characters are used to represent every bit
(pixel) in the image.  Reading is slow because we check for extra
white space and EOL at every sample value.

The packed pnm formats ("raw") give file sizes similar to
bmp files, which are uncompressed packed.  However, bmp
are more flexible, because they can support colormaps.

We don't differentiate between the different types ("pbm",
"pgm", "ppm") at the interface level, because this is really a
"distinction without a difference."  You read a file, you get
the appropriate Pix.  You write a file from a Pix, you get the
appropriate type of file.  If there is a colormap on the Pix,
and the Pix is more than 1 bpp, you get either an 8 bpp pgm
or a 24 bpp RGB pnm, depending on whether the colormap colors
are gray or rgb, respectively.

This follows the general policy that the I/O routines don't
make decisions about the content of the image -- you do that
with image processing before you write it out to file.
The I/O routines just try to make the closest connection
possible between the file and the Pix in memory.

On systems like windows without fmemopen() and open_memstream(),
we write data to a temp file and read it back for operations
between pix and compressed-data, such as pixReadMemPnm() and
pixWriteMemPnm().

The P7 format is new. It introduced a header with multiple
lines containing distinct tags for the various fields.
See: http://netpbm.sourceforge.net/doc/pam.html

WIDTH <int>         ; mandatory, exactly once
HEIGHT <int>        ; mandatory, exactly once
DEPTH <int>         ; mandatory, exactly once,
; its meaning is equivalent to spp
MAXVAL <int>        ; mandatory, one of 1, 3, 15, 255 or 65535
TUPLTYPE <string>   ; optional; BLACKANDWHITE, GRAYSCALE, RGB
; and optional suffix _ALPHA, e.g. RGB_ALPHA
ENDHDR              ; mandatory, last header line

Reading BLACKANDWHITE_ALPHA and GRAYSCALE_ALPHA, which have a DEPTH
value of 2, is supported. The original image is converted to a Pix
with 32-bpp and alpha channel (spp == 4).

Writing P7 format is currently selected for 32-bpp with alpha
channel, i.e. for Pix which have spp == 4, using pixWriteStreamPam().
Jürgen Buchmüller provided the implementation for the P7 (pam) format.
</pre>




"""
    
    try:
        leptonica.pixReadStreamPnm.argtypes = [ctypes.c_void_p]
        leptonica.pixReadStreamPnm.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamPnm(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:   file stream opened for read
:returns:  pix, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamPnm(*args)
    
    

    try:
        leptonica.readHeaderPnm.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderPnm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderPnm(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
('l_int32', '*ptype')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       

:param[in]    filename:
:param[out]   pw:       [optional]
:param[out]   ph:       [optional]
:param[out]   pd:       [optional]
:param[out]   ptype:    [optional] pnm type
:param[out]   pbps:     [optional] bits/sample
:param[out]   pspp:     [optional] samples/pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderPnm(*args)
    
    

    try:
        leptonica.freadHeaderPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderPnm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function freadHeaderPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderPnm(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
('l_int32', '*ptype')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       

:param[in]    fp:     file stream opened for read
:param[out]   pw:     [optional]
:param[out]   ph:     [optional]
:param[out]   pd:     [optional]
:param[out]   ptype:  [optional] pnm type
:param[out]   pbps:   [optional]  bits/sample
:param[out]   pspp:   [optional]  samples/pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderPnm(*args)
    
    

    try:
        leptonica.pixWriteStreamPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamPnm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPnm(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       

:param[in]   fp:    file stream opened for write
:param[in]   pix:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This writes "raw" packed format only:
1 bpp --> pbm (P4)
2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm (P5)
2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm (P6)
(2) 24 bpp rgb are not supported in leptonica, but this will
write them out as a packed array of bytes (3 to a pixel).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPnm(*args)
    
    

    try:
        leptonica.pixWriteStreamAsciiPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamAsciiPnm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamAsciiPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamAsciiPnm(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       

:param[in]   fp:    file stream opened for write
:param[in]   pix:
:returns:  0 if OK; 1 on error

Writes "ASCII" format only:
1 bpp --> pbm P1
2, 4, 8, 16 bpp, no colormap or grayscale colormap --> pgm P2
2, 4, 8 bpp with color-valued colormap, or rgb --> rgb ppm P3


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamAsciiPnm(*args)
    
    

    try:
        leptonica.pixWriteStreamPam.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteStreamPam.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamPam not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPam(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       

:param[in]   fp:    file stream opened for write
:param[in]   pix:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This writes arbitrary PAM (P7) packed format.
(2) 24 bpp rgb are not supported in leptonica, but this will
write them out as a packed array of bytes (3 to a pixel).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPam(*args)
    
    

    try:
        leptonica.pixReadMemPnm.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.pixReadMemPnm.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemPnm(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]   data:   const; pnm-encoded
:param[in]   size:   of data
:returns:  pix, or NULL on error

<pre>
Notes:
(1) The %size byte of %data must be a null character.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemPnm(*args)
    
    

    try:
        leptonica.readHeaderMemPnm.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemPnm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderMemPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemPnm(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pd')       
('l_int32', '*ptype')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       

:param[in]    data:    const; pnm-encoded
:param[in]    size:    of data
:param[out]   pw:      [optional]
:param[out]   ph:      [optional]
:param[out]   pd:      [optional]
:param[out]   ptype:   [optional] pnm type
:param[out]   pbps:    [optional] bits/sample
:param[out]   pspp:    [optional] samples/pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemPnm(*args)
    
    

    try:
        leptonica.pixWriteMemPnm.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemPnm.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemPnm not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPnm(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       

:param[out]   pdata:   data of PNM image
:param[out]   psize:   size of returned data
:param[in]    pix:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteStreamPnm() for usage.  This version writes to
memory instead of to a file stream.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPnm(*args)
    
    

    try:
        leptonica.pixWriteMemPam.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixWriteMemPam.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemPam not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPam(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       

:param[out]   pdata:   data of PAM image
:param[out]   psize:   size of returned data
:param[in]    pix:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteStreamPnm() for usage.  This version writes to
memory instead of to a file stream.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPam(*args)
    




class scale1(object):
    """<pre>
Top-level scaling
PIX      *pixScale()
PIX      *pixScaleToSizeRel()
PIX      *pixScaleToSize()
PIX      *pixScaleToResolution()
PIX      *pixScaleGeneral()

Linearly interpreted (usually up-) scaling
PIX      *pixScaleLI()
PIX      *pixScaleColorLI()
PIX      *pixScaleColor2xLI()
PIX      *pixScaleColor4xLI()
PIX      *pixScaleGrayLI()
PIX      *pixScaleGray2xLI()
PIX      *pixScaleGray4xLI()

Upscale 2x followed by binarization
PIX      *pixScaleGray2xLIThresh()
PIX      *pixScaleGray2xLIDither()

Upscale 4x followed by binarization
PIX      *pixScaleGray4xLIThresh()
PIX      *pixScaleGray4xLIDither()

Scaling by closest pixel sampling
PIX      *pixScaleBySampling()
PIX      *pixScaleBySamplingToSize()
PIX      *pixScaleByIntSampling()

Fast integer factor subsampling RGB to gray and to binary
PIX      *pixScaleRGBToGrayFast()
PIX      *pixScaleRGBToBinaryFast()
PIX      *pixScaleGrayToBinaryFast()

Downscaling with (antialias) smoothing
PIX      *pixScaleSmooth()
PIX      *pixScaleSmoothToSize()
PIX      *pixScaleRGBToGray2()   [special 2x reduction to gray]

Downscaling with (antialias) area mapping
PIX      *pixScaleAreaMap()
PIX      *pixScaleAreaMap2()
PIX      *pixScaleAreaMapToSize()

Binary scaling by closest pixel sampling
PIX      *pixScaleBinary()

Low-level static functions:

Color (interpolated) scaling: general case
static void       scaleColorLILow()

Grayscale (interpolated) scaling: general case
static void       scaleGrayLILow()

Color (interpolated) scaling: 2x upscaling
static void       scaleColor2xLILow()
static void       scaleColor2xLILineLow()

Grayscale (interpolated) scaling: 2x upscaling
static void       scaleGray2xLILow()
static void       scaleGray2xLILineLow()

Grayscale (interpolated) scaling: 4x upscaling
static void       scaleGray4xLILow()
static void       scaleGray4xLILineLow()

Grayscale and color scaling by closest pixel sampling
static l_int32    scaleBySamplingLow()

Color and grayscale downsampling with (antialias) lowpass filter
static l_int32    scaleSmoothLow()
static void       scaleRGBToGray2Low()

Color and grayscale downsampling with (antialias) area mapping
static l_int32    scaleColorAreaMapLow()
static l_int32    scaleGrayAreaMapLow()
static l_int32    scaleAreaMapLow2()

Binary scaling by closest pixel sampling
static l_int32    scaleBinaryLow()
</pre>




"""
    
    try:
        leptonica.pixScale.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScale.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScale not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScale(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixs:       1, 2, 4, 8, 16 and 32 bpp
:param[in]    scalex,: scaley
:returns:  pixd, or NULL on error

This function scales 32 bpp RGB; 2, 4 or 8 bpp palette color;
2, 4, 8 or 16 bpp gray; and binary images.

When the input has palette color, the colormap is removed and
the result is either 8 bpp gray or 32 bpp RGB, depending on whether
the colormap has color entries.  Images with 2, 4 or 16 bpp are
converted to 8 bpp.

Because pixScale is meant to be a very simple interface to a
number of scaling functions, including the use of unsharp masking,
the type of scaling and the sharpening parameters are chosen
by default.  Grayscale and color images are scaled using one
of five methods, depending on the scale factors:
1. antialiased subsampling (lowpass filtering followed by
subsampling, implemented by convolution, for tiny scale factors:
min(scalex, scaley) < 0.02.
2. antialiased subsampling (implemented by area mapping, for
small scale factors:
max(scalex, scaley) < 0.2 and min(scalex, scaley) >= 0.02.
3. antialiased subsampling with sharpening, for scale factors
between 0.2 and 0.7
4. linear interpolation with sharpening, for scale factors between
0.7 and 1.4
5. linear interpolation without sharpening, for scale factors >= 1.4.

One could use subsampling for scale factors very close to 1.0,
because it preserves sharp edges.  Linear interpolation blurs
edges because the dest pixels will typically straddle two src edge
pixels.  Subsmpling removes entire columns and rows, so the edge is
not blurred.  However, there are two reasons for not doing this.
First, it moves edges, so that a straight line at a large angle to
both horizontal and vertical will have noticeable kinks where
horizontal and vertical rasters are removed.  Second, although it
is very fast, you get good results on sharp edges by applying
a sharpening filter.

For images with sharp edges, sharpening substantially improves the
image quality for scale factors between about 0.2 and about 2.0.
pixScale uses a small amount of sharpening by default because
it strengthens edge pixels that are weak due to anti-aliasing.
The default sharpening factors are:
for scaling factors < 0.7:   sharpfract = 0.2    sharpwidth = 1
for scaling factors >= 0.7:  sharpfract = 0.4    sharpwidth = 2
The cases where the sharpening halfwidth is 1 or 2 have special
implementations and are about twice as fast as the general case.

However, sharpening is computationally expensive, and one needs
to consider the speed-quality tradeoff:
For upscaling of RGB images, linear interpolation plus default
sharpening is about 5 times slower than upscaling alone.
For downscaling, area mapping plus default sharpening is
about 10 times slower than downscaling alone.
When the scale factor is larger than 1.4, the cost of sharpening,
which is proportional to image area, is very large compared to the
incremental quality improvement, so we cut off the default use of
sharpening at 1.4.  Thus, for scale factors greater than 1.4,
pixScale only does linear interpolation.

In many situations you will get a satisfactory result by scaling
without sharpening: call pixScaleGeneral with %sharpfract = 0.0.
Alternatively, if you wish to sharpen but not use the default
value, first call pixScaleGeneral with %sharpfract = 0.0, and
then sharpen explicitly using pixUnsharpMasking.

Binary images are scaled to binary by sampling the closest pixel,
without any low-pass filtering averaging of neighboring pixels.
This will introduce aliasing for reductions.  Aliasing can be
prevented by using pixScaleToGray instead.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScale(*args)
    
    

    try:
        leptonica.pixScaleToSizeRel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleToSizeRel.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToSizeRel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToSizeRel(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'delw')       
('l_int32', 'delh')       

:param[in]    pixs:
:param[in]    delw:    change in width, in pixels; 0 means no change
:param[in]    delh:    change in height, in pixels; 0 means no change
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToSizeRel(*args)
    
    

    try:
        leptonica.pixScaleToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleToSize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    pixs:    1, 2, 4, 8, 16 and 32 bpp
:param[in]    wd:      target width; use 0 if using height as target
:param[in]    hd:      target height; use 0 if using width as target
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The output scaled image has the dimension(s) you specify:
To specify the width with isotropic scaling, set %hd = 0.
To specify the height with isotropic scaling, set %wd = 0.
If both %wd and %hd are specified, the image is scaled
(in general, anisotropically) to that size.
It is an error to set both %wd and %hd to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToSize(*args)
    
    

    try:
        leptonica.pixScaleToResolution.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p]
        leptonica.pixScaleToResolution.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToResolution not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToResolution(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'target')       
('l_float32', 'assumed')       
('l_float32', '*pscalefact')       

:param[in]    pixs:
:param[in]    target:      desired resolution
:param[in]    assumed:     assumed resolution if not defined; typ. 300.
:param[out]   pscalefact:  [optional] actual scaling factor used
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToResolution(*args)
    
    

    try:
        leptonica.pixScaleGeneral.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixScaleGeneral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGeneral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGeneral(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('l_float32', 'sharpfract')       
('l_int32', 'sharpwidth')       

:param[in]    pixs:         1, 2, 4, 8, 16 and 32 bpp
:param[in]    scalex:       must be > 0.0
:param[in]    scaley:       must be > 0.0
:param[in]    sharpfract:   use 0.0 to skip sharpening
:param[in]    sharpwidth:   halfwidth of low-pass filter; typ. 1 or 2
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See pixScale() for usage.
(2) This interface may change in the future, as other special
cases are added.
(3) For tiny scaling factors
minscale < 0.02:        use a simple lowpass filter
(4) The actual sharpening factors used depend on the maximum
of the two scale factors (maxscale):
maxscale <= 0.2:        no sharpening
0.2 < maxscale < 1.4:   uses the input parameters
maxscale >= 1.4:        no sharpening
(5) To avoid sharpening for grayscale and color images with
scaling factors between 0.2 and 1.4, call this function
with %sharpfract == 0.0.
(6) To use arbitrary sharpening in conjunction with scaling,
call this function with %sharpfract = 0.0, and follow this
with a call to pixUnsharpMasking() with your chosen parameters.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGeneral(*args)
    
    

    try:
        leptonica.pixScaleLI.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleLI(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixs:       2, 4, 8 or 32 bpp; with or without colormap
:param[in]    scalex:     must be >= 0.7
:param[in]    scaley:     must be >= 0.7
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function should only be used when the scale factors are
greater than or equal to 0.7, and typically greater than 1.
If both scale factors are smaller than 0.7, we issue a warning
and call pixScaleGeneral(), which will invoke area mapping
without sharpening.
(2) This works on 2, 4, 8, 16 and 32 bpp images, as well as on
2, 4 and 8 bpp images that have a colormap.  If there is a
colormap, it is removed to either gray or RGB, depending
on the colormap.
(3) This does a linear interpolation on the src image.
(4) It dispatches to much faster implementations for
the special cases of 2x and 4x expansion.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleLI(*args)
    
    

    try:
        leptonica.pixScaleColorLI.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleColorLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleColorLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleColorLI(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixs:       32 bpp, representing rgb
:param[in]    scalex:     must be >= 0.7
:param[in]    scaley:     must be >= 0.7
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) If both scale factors are smaller than 0.7, we issue a warning
and call pixScaleGeneral(), which will invoke area mapping
without sharpening.  This is particularly important for
document images with sharp edges.
(2) For the general case, it's about 4x faster to manipulate
the color pixels directly, rather than to make images
out of each of the 3 components, scale each component
using the pixScaleGrayLI(), and combine the results back
into an rgb image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleColorLI(*args)
    
    

    try:
        leptonica.pixScaleColor2xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleColor2xLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleColor2xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleColor2xLI(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp, representing rgb
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is a special case of linear interpolated scaling,
for 2x upscaling.  It is about 8x faster than using
the generic pixScaleColorLI(), and about 4x faster than
using the special 2x scale function pixScaleGray2xLI()
on each of the three components separately.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleColor2xLI(*args)
    
    

    try:
        leptonica.pixScaleColor4xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleColor4xLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleColor4xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleColor4xLI(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    32 bpp, representing rgb
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is a special case of color linear interpolated scaling,
for 4x upscaling.  It is about 3x faster than using
the generic pixScaleColorLI().
(2) This scales each component separately, using pixScaleGray4xLI().
It would be about 4x faster to inline the color code properly,
in analogy to scaleColor4xLILow(), and I leave this as
an exercise for someone who really needs it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleColor4xLI(*args)
    
    

    try:
        leptonica.pixScaleGrayLI.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleGrayLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGrayLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayLI(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixs:       8 bpp grayscale, no cmap
:param[in]    scalex:     must be >= 0.7
:param[in]    scaley:     must be >= 0.7
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function is appropriate for upscaling magnification, where the
scale factor is > 1, as well as for a small amount of downscaling
reduction, with scale factor >= 0.7.  If the scale factor is < 0.7,
the best result is obtained by area mapping.
(2) Here are some details:
- For each pixel in the dest, this does a linear
interpolation of 4 neighboring pixels in the src.
Specifically, consider the UL corner of src and
dest pixels.  The UL corner of the dest falls within
a src pixel, whose four corners are the UL corners
of 4 adjacent src pixels.  The value of the dest
is taken by linear interpolation using the values of
the four src pixels and the distance of the UL corner
of the dest from each corner.
- If the image is expanded so that the dest pixel is
smaller than the src pixel, such interpolation
is a reasonable approach.  This interpolation is
also good for a small image reduction factor that
is not more than a 2x reduction.
- The linear interpolation algorithm for scaling is
identical in form to the area-mapping algorithm
for grayscale rotation.  The latter corresponds to a
translation of each pixel without scaling.
- This function is NOT optimal if the scaling involves
a large reduction.  If the image is significantly
reduced, so that the dest pixel is much larger than
the src pixels, this interpolation, which is over src
pixels only near the UL corner of the dest pixel,
is not going to give a good area-mapping average.
Because area mapping for image scaling is considerably
more computationally intensive than linear interpolation,
we choose not to use it.  For large image reduction,
linear interpolation over adjacent src pixels
degenerates asymptotically to subsampling.  But
subsampling without a low-pass pre-filter causes
aliasing by the nyquist theorem.  To avoid aliasing,
a low-pass filter e.g., an averaging filter of
size roughly equal to the dest pixel i.e., the reduction
factor should be applied to the src before subsampling.
- As an alternative to low-pass filtering and subsampling
for large reduction factors, linear interpolation can
also be done between the widely separated src pixels in
which the corners of the dest pixel lie.  This also is
not optimal, as it samples src pixels only near the
corners of the dest pixel, and it is not implemented.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayLI(*args)
    
    

    try:
        leptonica.pixScaleGray2xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray2xLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGray2xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray2xLI(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    8 bpp grayscale, not cmapped
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is a special case of gray linear interpolated scaling,
for 2x upscaling.  It is about 6x faster than using
the generic pixScaleGrayLI().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray2xLI(*args)
    
    

    try:
        leptonica.pixScaleGray4xLI.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray4xLI.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGray4xLI not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray4xLI(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    8 bpp grayscale, not cmapped
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is a special case of gray linear interpolated scaling,
for 4x upscaling.  It is about 12x faster than using
the generic pixScaleGrayLI().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray4xLI(*args)
    
    

    try:
        leptonica.pixScaleGray2xLIThresh.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGray2xLIThresh.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGray2xLIThresh not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray2xLIThresh(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    thresh:  between 0 and 256
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This does 2x upscale on pixs, using linear interpolation,
followed by thresholding to binary.
(2) Buffers are used to avoid making a large grayscale image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray2xLIThresh(*args)
    
    

    try:
        leptonica.pixScaleGray2xLIDither.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray2xLIDither.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGray2xLIDither not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray2xLIDither(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    8 bpp, not cmapped
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This does 2x upscale on pixs, using linear interpolation,
followed by Floyd-Steinberg dithering to binary.
(2) Buffers are used to avoid making a large grayscale image.
~ Two line buffers are used for the src, required for the 2x
LI upscale.
~ Three line buffers are used for the intermediate image.
Two are filled with each 2xLI row operation; the third is
needed because the upscale and dithering ops are out of sync.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray2xLIDither(*args)
    
    

    try:
        leptonica.pixScaleGray4xLIThresh.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGray4xLIThresh.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGray4xLIThresh not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray4xLIThresh(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       

:param[in]    pixs:    8 bpp
:param[in]    thresh:  between 0 and 256
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This does 4x upscale on pixs, using linear interpolation,
followed by thresholding to binary.
(2) Buffers are used to avoid making a large grayscale image.
(3) If a full 4x expanded grayscale image can be kept in memory,
this function is only about 10% faster than separately doing
a linear interpolation to a large grayscale image, followed
by thresholding to binary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray4xLIThresh(*args)
    
    

    try:
        leptonica.pixScaleGray4xLIDither.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleGray4xLIDither.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGray4xLIDither not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGray4xLIDither(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    8 bpp, not cmapped
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This does 4x upscale on pixs, using linear interpolation,
followed by Floyd-Steinberg dithering to binary.
(2) Buffers are used to avoid making a large grayscale image.
~ Two line buffers are used for the src, required for the
4xLI upscale.
~ Five line buffers are used for the intermediate image.
Four are filled with each 4xLI row operation; the fifth
is needed because the upscale and dithering ops are
out of sync.
(3) If a full 4x expanded grayscale image can be kept in memory,
this function is only about 5% faster than separately doing
a linear interpolation to a large grayscale image, followed
by error-diffusion dithering to binary.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGray4xLIDither(*args)
    
    

    try:
        leptonica.pixScaleBySampling.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleBySampling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleBySampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleBySampling(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixs:       1, 2, 4, 8, 16, 32 bpp
:param[in]    scalex:     must be > 0.0
:param[in]    scaley:     must be > 0.0
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function samples from the source without
filtering.  As a result, aliasing will occur for
subsampling (%scalex and/or %scaley < 1.0).
(2) If %scalex == 1.0 and %scaley == 1.0, returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleBySampling(*args)
    
    

    try:
        leptonica.pixScaleBySamplingToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleBySamplingToSize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleBySamplingToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleBySamplingToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    pixs:    1, 2, 4, 8, 16 and 32 bpp
:param[in]    wd:      target width; use 0 if using height as target
:param[in]    hd:      target height; use 0 if using width as target
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This guarantees that the output scaled image has the
dimension(s) you specify.
~ To specify the width with isotropic scaling, set %hd = 0.
~ To specify the height with isotropic scaling, set %wd = 0.
~ If both %wd and %hd are specified, the image is scaled
(in general, anisotropically) to that size.
~ It is an error to set both %wd and %hd to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleBySamplingToSize(*args)
    
    

    try:
        leptonica.pixScaleByIntSampling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleByIntSampling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleByIntSampling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleByIntSampling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]    pixs:     1, 2, 4, 8, 16, 32 bpp
:param[in]    factor:   integer subsampling
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Simple interface to pixScaleBySampling(), for
isotropic integer reduction.
(2) If %factor == 1, returns a copy.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleByIntSampling(*args)
    
    

    try:
        leptonica.pixScaleRGBToGrayFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleRGBToGrayFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleRGBToGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleRGBToGrayFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'color')       

:param[in]    pixs:     32 bpp rgb
:param[in]    factor:   integer reduction factor >= 1
:param[in]    color:    one of COLOR_RED, COLOR_GREEN, COLOR_BLUE
:returns:  pixd 8 bpp, or NULL on error

<pre>
Notes:
(1) This does simultaneous subsampling by an integer factor and
extraction of the color from the RGB pix.
(2) It is designed for maximum speed, and is used for quickly
generating a downsized grayscale image from a higher resolution
RGB image.  This would typically be used for image analysis.
(3) The standard color byte order (RGBA) is assumed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleRGBToGrayFast(*args)
    
    

    try:
        leptonica.pixScaleRGBToBinaryFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleRGBToBinaryFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleRGBToBinaryFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleRGBToBinaryFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'thresh')       

:param[in]    pixs:     32 bpp RGB
:param[in]    factor:   integer reduction factor >= 1
:param[in]    thresh:   binarization threshold
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This does simultaneous subsampling by an integer factor and
conversion from RGB to gray to binary.
(2) It is designed for maximum speed, and is used for quickly
generating a downsized binary image from a higher resolution
RGB image.  This would typically be used for image analysis.
(3) It uses the green channel to represent the RGB pixel intensity.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleRGBToBinaryFast(*args)
    
    

    try:
        leptonica.pixScaleGrayToBinaryFast.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleGrayToBinaryFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGrayToBinaryFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayToBinaryFast(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       
('l_int32', 'thresh')       

:param[in]    pixs:     8 bpp grayscale
:param[in]    factor:   integer reduction factor >= 1
:param[in]    thresh:   binarization threshold
:returns:  pixd 1 bpp, or NULL on error

<pre>
Notes:
(1) This does simultaneous subsampling by an integer factor and
thresholding from gray to binary.
(2) It is designed for maximum speed, and is used for quickly
generating a downsized binary image from a higher resolution
gray image.  This would typically be used for image analysis.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayToBinaryFast(*args)
    
    

    try:
        leptonica.pixScaleSmooth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleSmooth.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleSmooth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleSmooth(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pix:       2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap
:param[in]    scalex:    must be < 0.7
:param[in]    scaley:    must be < 0.7
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function should only be used when the scale factors are less
than 0.7.  If either scale factor is >= 0.7, issue a warning
and call pixScaleGeneral(), which will invoke linear interpolation
without sharpening.
(2) This works only on 2, 4, 8 and 32 bpp images, and if there is
a colormap, it is removed by converting to RGB.
(3) It does simple (flat filter) convolution, with a filter size
commensurate with the amount of reduction, to avoid antialiasing.
(4) It does simple subsampling after smoothing, which is appropriate
for this range of scaling.  Linear interpolation gives essentially
the same result with more computation for these scale factors,
so we don't use it.
(5) The result is the same as doing a full block convolution followed by
subsampling, but this is faster because the results of the block
convolution are only computed at the subsampling locations.
In fact, the computation time is approximately independent of
the scale factor, because the convolution kernel is adjusted
so that each source pixel is summed approximately once.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleSmooth(*args)
    
    

    try:
        leptonica.pixScaleSmoothToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleSmoothToSize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleSmoothToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleSmoothToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    pixs:   2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap
:param[in]    wd:     target width; use 0 if using height as target
:param[in]    hd:     target height; use 0 if using width as target
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See notes in pixScaleSmooth().
(2) The output scaled image has the dimension(s) you specify:
- To specify the width with isotropic scaling, set %hd = 0.
- To specify the height with isotropic scaling, set %wd = 0.
- If both %wd and %hd are specified, the image is scaled
(in general, anisotropically) to that size.
- It is an error to set both %wd and %hd to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleSmoothToSize(*args)
    
    

    try:
        leptonica.pixScaleRGBToGray2.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleRGBToGray2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleRGBToGray2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleRGBToGray2(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'rwt')       
('l_float32', 'gwt')       
('l_float32', 'bwt')       

:param[in]    pixs:            32 bpp rgb
:param[in]    rwt,: gwt, bwt   must sum to 1.0
:returns:  pixd, 8 bpp, 2x reduced, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleRGBToGray2(*args)
    
    

    try:
        leptonica.pixScaleAreaMap.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleAreaMap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleAreaMap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAreaMap(*args):
        """
        ('PIX', '*pix')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pix:       2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap
:param[in]    scalex:    must be < 0.7; minimum is 0.02
:param[in]    scaley:    must be < 0.7; minimum is 0.02
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This is a low-pass filter that averages over fractional pixels.
It should only be used when the scale factors are less than 0.7.
If either scale factor is greater than or equal to 0.7, we
issue a warning and call pixScaleGeneral(), which will invoke
linear interpolation without sharpening.
(2) The minimum scale factor allowed for area mapping reduction
is 0.02.  Various overflows will occur when scale factors are
less than about 1/256.  If a scale factor smaller than 0.02
is given, we use pixScaleSmooth(), which is a low-pass filter
that averages over entire pixels.
(3) This works only on 2, 4, 8 and 32 bpp images.  If there is
a colormap, it is removed by converting to RGB.  In other
cases, we issue a warning and call pixScaleGeneral().
(4) This is faster than pixScale() because it does not do sharpening.
(5) It does a relatively expensive area mapping computation, to
avoid antialiasing.  It is about 2x slower than pixScaleSmooth(),
but the results are much better on fine text.
(6) pixScaleAreaMap2() is typically about 7x faster for the special
case of 2x reduction for color images, and about 9x faster
for grayscale images.  Surprisingly, the improvement in speed
when using a cascade of 2x reductions for small scale factors is
less than one might expect, and in most situations gives
poorer image quality.  But see (6).
(7) For reductions between 0.35 and 0.5, a 2x area map reduction
followed by using pixScaleGeneral() on a 2x larger scalefactor
(which further reduces the image size using bilinear interpolation)
would give a significant speed increase, with little loss of
quality, but this is not enabled as it would break too many tests.
For scaling factors below 0.35, scaling atomically is nearly
as fast as using a cascade of 2x scalings, and gives
better results.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAreaMap(*args)
    
    

    try:
        leptonica.pixScaleAreaMap2.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleAreaMap2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleAreaMap2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAreaMap2(*args):
        """
        ('PIX', '*pix')       

:param[in]    pix:     2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function does an area mapping (average) for 2x
reduction.
(2) This works only on 2, 4, 8 and 32 bpp images.  If there is
a colormap, it is removed by converting to RGB.
(3) Compared to the general pixScaleAreaMap(), for this function
gray processing is about 14x faster and color processing
is about 4x faster.  Consequently, pixScaleAreaMap2() is
incorporated into the general area map scaling function,
for the special cases of 2x, 4x, 8x and 16x reduction.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAreaMap2(*args)
    
    

    try:
        leptonica.pixScaleAreaMapToSize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleAreaMapToSize.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleAreaMapToSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAreaMapToSize(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'wd')       
('l_int32', 'hd')       

:param[in]    pixs:    2, 4, 8 or 32 bpp; and 2, 4, 8 bpp with colormap
:param[in]    wd:      target width; use 0 if using height as target
:param[in]    hd:      target height; use 0 if using width as target
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See notes in pixScaleAreaMap().
(2) The output scaled image has the dimension(s) you specify:
- To specify the width with isotropic scaling, set %hd = 0.
- To specify the height with isotropic scaling, set %wd = 0.
- If both %wd and %hd are specified, the image is scaled
(in general, anisotropically) to that size.
- It is an error to set both %wd and %hd to 0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAreaMapToSize(*args)
    
    

    try:
        leptonica.pixScaleBinary.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleBinary(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixs:      1 bpp
:param[in]    scalex:    must be > 0.0
:param[in]    scaley:    must be > 0.0
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This function samples from the source without
filtering.  As a result, aliasing will occur for
subsampling (scalex and scaley < 1.0).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleBinary(*args)
    




class scale2(object):
    """<pre>
Scale-to-gray (1 bpp --> 8 bpp; arbitrary downscaling)
PIX      *pixScaleToGray()
PIX      *pixScaleToGrayFast()

Scale-to-gray (1 bpp --> 8 bpp; integer downscaling)
PIX      *pixScaleToGray2()
PIX      *pixScaleToGray3()
PIX      *pixScaleToGray4()
PIX      *pixScaleToGray6()
PIX      *pixScaleToGray8()
PIX      *pixScaleToGray16()

Scale-to-gray by mipmap(1 bpp --> 8 bpp, arbitrary reduction)
PIX      *pixScaleToGrayMipmap()

Grayscale scaling using mipmap
PIX      *pixScaleMipmap()

Replicated (integer) expansion (all depths)
PIX      *pixExpandReplicate()

Grayscale downscaling using min and max
PIX      *pixScaleGrayMinMax()
PIX      *pixScaleGrayMinMax2()

Grayscale downscaling using rank value
PIX      *pixScaleGrayRankCascade()
PIX      *pixScaleGrayRank2()

Helper function for transferring alpha with scaling
l_int32   pixScaleAndTransferAlpha()

RGB scaling including alpha (blend) component
PIX      *pixScaleWithAlpha()

Low-level static functions:

Scale-to-gray 2x
static void       scaleToGray2Low()
static l_uint32  *makeSumTabSG2()
static l_uint8   *makeValTabSG2()

Scale-to-gray 3x
static void       scaleToGray3Low()
static l_uint32  *makeSumTabSG3()
static l_uint8   *makeValTabSG3()

Scale-to-gray 4x
static void       scaleToGray4Low()
static l_uint32  *makeSumTabSG4()
static l_uint8   *makeValTabSG4()

Scale-to-gray 6x
static void       scaleToGray6Low()
static l_uint8   *makeValTabSG6()

Scale-to-gray 8x
static void       scaleToGray8Low()
static l_uint8   *makeValTabSG8()

Scale-to-gray 16x
static void       scaleToGray16Low()

Grayscale mipmap
static l_int32    scaleMipmapLow()
</pre>




"""
    
    try:
        leptonica.pixScaleToGray.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleToGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalefactor')       

:param[in]    pixs:          1 bpp
:param[in]    scalefactor:   reduction: must be > 0.0 and < 1.0
:returns:  pixd 8 bpp, scaled down by scalefactor in each direction,
or NULL on error.

<pre>
Notes:

For faster scaling in the range of scalefactors from 0.0625 to 0.5,
with very little difference in quality, use pixScaleToGrayFast().

Binary images have sharp edges, so they intrinsically have very
high frequency content.  To avoid aliasing, they must be low-pass
filtered, which tends to blur the edges.  How can we keep relatively
crisp edges without aliasing?  The trick is to do binary upscaling
followed by a power-of-2 scaleToGray.  For large reductions, where
you don't end up with much detail, some corners can be cut.

The intent here is to get high quality reduced grayscale
images with relatively little computation.  We do binary
pre-scaling followed by scaleToGrayN() for best results,
esp. to avoid excess blur when the scale factor is near
an inverse power of 2.  Where a low-pass filter is required,
we use simple convolution kernels: either the hat filter for
linear interpolation or a flat filter for larger downscaling.
Other choices, such as a perfect bandpass filter with infinite extent
(the sinc) or various approximations to it (e.g., lanczos), are
unnecessarily expensive.

The choices made are as follows:
(1) Do binary upscaling before scaleToGrayN() for scalefactors > 1/8
(2) Do binary downscaling before scaleToGray8() for scalefactors
between 1/16 and 1/8.
(3) Use scaleToGray16() before grayscale downscaling for
scalefactors less than 1/16
Another reasonable choice would be to start binary downscaling
for scalefactors below 1/4, rather than below 1/8 as we do here.

The general scaling rules, not all of which are used here, go as follows:
(1) For grayscale upscaling, use pixScaleGrayLI().  However,
note that edges will be visibly blurred for scalefactors
near (but above) 1.0.  Replication will avoid edge blur,
and should be considered for factors very near 1.0.
(2) For grayscale downscaling with a scale factor larger than
about 0.7, use pixScaleGrayLI().  For scalefactors near
(but below) 1.0, you tread between Scylla and Charybdis.
pixScaleGrayLI() again gives edge blurring, but
pixScaleBySampling() gives visible aliasing.
(3) For grayscale downscaling with a scale factor smaller than
about 0.7, use pixScaleSmooth()
(4) For binary input images, do as much scale to gray as possible
using the special integer functions (2, 3, 4, 8 and 16).
(5) It is better to upscale in binary, followed by scaleToGrayN()
than to do scaleToGrayN() followed by an upscale using either
LI or oversampling.
(6) It may be better to downscale in binary, followed by
scaleToGrayN() than to first use scaleToGrayN() followed by
downscaling.  For downscaling between 8x and 16x, this is
a reasonable option.
(7) For reductions greater than 16x, it's reasonable to use
scaleToGray16() followed by further grayscale downscaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray(*args)
    
    

    try:
        leptonica.pixScaleToGrayFast.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleToGrayFast.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGrayFast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGrayFast(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalefactor')       

:param[in]    pixs:          1 bpp
:param[in]    scalefactor:   reduction: must be > 0.0 and < 1.0
:returns:  pixd 8 bpp, scaled down by scalefactor in each direction,
or NULL on error.

<pre>
Notes:
(1) See notes in pixScaleToGray() for the basic approach.
(2) This function is considerably less expensive than pixScaleToGray()
for scalefactor in the range (0.0625 ... 0.5), and the
quality is nearly as good.
(3) Unlike pixScaleToGray(), which does binary upscaling before
downscaling for scale factors >= 0.0625, pixScaleToGrayFast()
first downscales in binary for all scale factors < 0.5, and
then does a 2x scale-to-gray as the final step.  For
scale factors < 0.0625, both do a 16x scale-to-gray, followed
by further grayscale reduction.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGrayFast(*args)
    
    

    try:
        leptonica.pixScaleToGray2.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray2(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  pixd 8 bpp, scaled down by 2x in each direction,
or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray2(*args)
    
    

    try:
        leptonica.pixScaleToGray3.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray3.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray3(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  pixd 8 bpp, scaled down by 3x in each direction,
or NULL on error.

<pre>
Notes:
(1) Speed is about 100 x 10^6 src-pixels/sec/GHz.
Another way to express this is it processes 1 src pixel
in about 10 cycles.
(2) The width of pixd is truncated is truncated to a factor of 8.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray3(*args)
    
    

    try:
        leptonica.pixScaleToGray4.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray4.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray4(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  pixd 8 bpp, scaled down by 4x in each direction,
or NULL on error.

<pre>
Notes:
(1) The width of pixd is truncated is truncated to a factor of 2.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray4(*args)
    
    

    try:
        leptonica.pixScaleToGray6.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray6.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray6 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray6(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  pixd 8 bpp, scaled down by 6x in each direction,
or NULL on error.

<pre>
Notes:
(1) The width of pixd is truncated is truncated to a factor of 8.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray6(*args)
    
    

    try:
        leptonica.pixScaleToGray8.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray8.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray8 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray8(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  pixd 8 bpp, scaled down by 8x in each direction,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray8(*args)
    
    

    try:
        leptonica.pixScaleToGray16.argtypes = [ctypes.c_void_p]
        leptonica.pixScaleToGray16.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGray16 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGray16(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  pixd 8 bpp, scaled down by 16x in each direction,
or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGray16(*args)
    
    

    try:
        leptonica.pixScaleToGrayMipmap.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleToGrayMipmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleToGrayMipmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleToGrayMipmap(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalefactor')       

:param[in]    pixs:          1 bpp
:param[in]    scalefactor:   reduction: must be > 0.0 and < 1.0
:returns:  pixd 8 bpp, scaled down by scalefactor in each direction,
or NULL on error.

<pre>
Notes:

This function is here mainly for pedagogical reasons.
Mip-mapping is widely used in graphics for texture mapping, because
the texture changes smoothly with scale.  This is accomplished by
constructing a multiresolution pyramid and, for each pixel,
doing a linear interpolation between corresponding pixels in
the two planes of the pyramid that bracket the desired resolution.
The computation is very efficient, and is implemented in hardware
in high-end graphics cards.

We can use mip-mapping for scale-to-gray by using two scale-to-gray
reduced images (we don't need the entire pyramid) selected from
the set {2x, 4x, ... 16x}, and interpolating.  However, we get
severe aliasing, probably because we are subsampling from the
higher resolution image.  The method is very fast, but the result
is very poor.  In fact, the results don't look any better than
either subsampling off the higher-res grayscale image or oversampling
on the lower-res image.  Consequently, this method should NOT be used
for generating reduced images, scale-to-gray or otherwise.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleToGrayMipmap(*args)
    
    

    try:
        leptonica.pixScaleMipmap.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleMipmap.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleMipmap not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleMipmap(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       
('l_float32', 'scale')       

:param[in]    pixs1:    high res 8 bpp, no cmap
:param[in]    pixs2:    low res -- 2x reduced -- 8 bpp, no cmap
:param[in]    scale:    reduction with respect to high res image, > 0.5
:returns:  8 bpp pix, scaled down by reduction in each direction,
or NULL on error.

<pre>
Notes:
(1) See notes in pixScaleToGrayMipmap().
(2) This function suffers from aliasing effects that are
easily seen in document images.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleMipmap(*args)
    
    

    try:
        leptonica.pixExpandReplicate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExpandReplicate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExpandReplicate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExpandReplicate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'factor')       

:param[in]    pixs:     1, 2, 4, 8, 16, 32 bpp
:param[in]    factor:   integer scale factor for replicative expansion
:returns:  pixd scaled up, or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.pixExpandReplicate(*args)
    
    

    try:
        leptonica.pixScaleGrayMinMax.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleGrayMinMax.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGrayMinMax not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayMinMax(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'xfact')       
('l_int32', 'yfact')       
('l_int32', 'type')       

:param[in]    pixs:     8 bpp, not cmapped
:param[in]    xfact:    x downscaling factor; integer
:param[in]    yfact:    y downscaling factor; integer
:param[in]    type:     L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF
:returns:  pixd 8 bpp

<pre>
Notes:
(1) The downscaled pixels in pixd are the min, max or (max - min)
of the corresponding set of xfact * yfact pixels in pixs.
(2) Using L_CHOOSE_MIN is equivalent to a grayscale erosion,
using a brick Sel of size (xfact * yfact), followed by
subsampling within each (xfact * yfact) cell.  Using
L_CHOOSE_MAX is equivalent to the corresponding dilation.
(3) Using L_CHOOSE_MAXDIFF finds the difference between max
and min values in each cell.
(4) For the special case of downscaling by 2x in both directions,
pixScaleGrayMinMax2() is about 2x more efficient.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayMinMax(*args)
    
    

    try:
        leptonica.pixScaleGrayMinMax2.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGrayMinMax2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGrayMinMax2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayMinMax2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    type:    L_CHOOSE_MIN, L_CHOOSE_MAX, L_CHOOSE_MAXDIFF
:returns:  pixd 8 bpp downscaled by 2x

<pre>
Notes:
(1) Special version for 2x reduction.  The downscaled pixels
in pixd are the min, max or (max - min) of the corresponding
set of 4 pixels in pixs.
(2) The max and min operations are a special case (for levels 1
and 4) of grayscale analog to the binary rank scaling operation
pixReduceRankBinary2().  Note, however, that because of
the photometric definition that higher gray values are
lighter, the erosion-like L_CHOOSE_MIN will darken
the resulting image, corresponding to a threshold level 1
in the binary case.  Likewise, L_CHOOSE_MAX will lighten
the pixd, corresponding to a threshold level of 4.
(3) To choose any of the four rank levels in a 2x grayscale
reduction, use pixScaleGrayRank2().
(4) This runs at about 70 MPix/sec/GHz of source data for
erosion and dilation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayMinMax2(*args)
    
    

    try:
        leptonica.pixScaleGrayRankCascade.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixScaleGrayRankCascade.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGrayRankCascade not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayRankCascade(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'level1')       
('l_int32', 'level2')       
('l_int32', 'level3')       
('l_int32', 'level4')       

:param[in]    pixs:    8 bpp, not cmapped
:param[in]    level1,: level2    ...
:param[in]    level3,: level4    rank thresholds, in set {0, 1, 2, 3, 4}
:returns:  pixd 8 bpp, downscaled by up to 16x

<pre>
Notes:
(1) This performs up to four cascaded 2x rank reductions.
(2) Use level = 0 to truncate the cascade.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayRankCascade(*args)
    
    

    try:
        leptonica.pixScaleGrayRank2.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixScaleGrayRank2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleGrayRank2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleGrayRank2(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'rank')       

:param[in]    pixs:    8 bpp, no cmap
:param[in]    rank:    1 (darkest), 2, 3, 4 (lightest)
:returns:  pixd 8 bpp, downscaled by 2x

<pre>
Notes:
(1) Rank 2x reduction.  If rank == 1(4), the downscaled pixels
in pixd are the min(max) of the corresponding set of
4 pixels in pixs.  Values 2 and 3 are intermediate.
(2) This is the grayscale analog to the binary rank scaling operation
pixReduceRankBinary2().  Here, because of the photometric
definition that higher gray values are lighter, rank 1 gives
the darkest pixel, whereas rank 4 gives the lightest pixel.
This is opposite to the binary rank operation.
(3) For rank = 1 and 4, this calls pixScaleGrayMinMax2(),
which runs at about 70 MPix/sec/GHz of source data.
For rank 2 and 3, this runs 3x slower, at about 25 MPix/sec/GHz.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleGrayRank2(*args)
    
    

    try:
        leptonica.pixScaleAndTransferAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixScaleAndTransferAlpha.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleAndTransferAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleAndTransferAlpha(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       

:param[in]    pixd:      32 bpp, scaled image
:param[in]    pixs:      32 bpp, original unscaled image
:param[in]    scalex:    must be > 0.0
:param[in]    scaley:    must be > 0.0
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This scales the alpha component of pixs and inserts into pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleAndTransferAlpha(*args)
    
    

    try:
        leptonica.pixScaleWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_float]
        leptonica.pixScaleWithAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixScaleWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixScaleWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'scalex')       
('l_float32', 'scaley')       
('PIX', '*pixg')       
('l_float32', 'fract')       

:param[in]    pixs:      32 bpp rgb or cmapped
:param[in]    scalex:    must be > 0.0
:param[in]    scaley:    must be > 0.0
:param[in]    pixg:      [optional] 8 bpp, can be null
:param[in]    fract:     between 0.0 and 1.0, with 0.0 fully transparent
and 1.0 fully opaque
:returns:  pixd 32 bpp rgba, or NULL on error

<pre>
Notes:
(1) The alpha channel is transformed separately from pixs,
and aligns with it, being fully transparent outside the
boundary of the transformed pixs.  For pixels that are fully
transparent, a blending function like pixBlendWithGrayMask()
will give zero weight to corresponding pixels in pixs.
(2) Scaling is done with area mapping or linear interpolation,
depending on the scale factors.  Default sharpening is done.
(3) If pixg is NULL, it is generated as an alpha layer that is
partially opaque, using %fract.  Otherwise, it is cropped
to pixs if required, and %fract is ignored.  The alpha
channel in pixs is never used.
(4) Colormaps are removed to 32 bpp.
(5) The default setting for the border values in the alpha channel
is 0 (transparent) for the outermost ring of pixels and
(0.5 * fract * 255) for the second ring.  When blended over
a second image, this
(a) shrinks the visible image to make a clean overlap edge
with an image below, and
(b) softens the edges by weakening the aliasing there.
Use l_setAlphaMaskBorder() to change these values.
(6) A subtle use of gamma correction is to remove gamma correction
before scaling and restore it afterwards.  This is done
by sandwiching this function between a gamma/inverse-gamma
photometric transform:
pixt = pixGammaTRCWithAlpha(NULL, pixs, 1.0 / gamma, 0, 255);
pixd = pixScaleWithAlpha(pixt, scalex, scaley, NULL, fract);
pixGammaTRCWithAlpha(pixd, pixd, gamma, 0, 255);
pixDestroy(&pixt);
This has the side-effect of producing artifacts in the very
dark regions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixScaleWithAlpha(*args)
    




class ccbord(object):
    """<pre>

CCBORDA and CCBORD creation and destruction
CCBORDA         *ccbaCreate()
void            *ccbaDestroy()
CCBORD          *ccbCreate()
void            *ccbDestroy()

CCBORDA addition
l_int32          ccbaAddCcb()
static l_int32   ccbaExtendArray()

CCBORDA accessors
l_int32          ccbaGetCount()
l_int32          ccbaGetCcb()

Top-level border-finding routines
CCBORDA         *pixGetAllCCBorders()
static CCBORD   *pixGetCCBorders()
PTAA            *pixGetOuterBordersPtaa()
static PTA      *pixGetOuterBorderPta()

Lower-level border location routines
PTAA            *pixGetOuterBorder()
static l_int32   pixGetHoleBorder()
static l_int32   findNextBorderPixel()
static void      locateOutsideSeedPixel()

Border conversions
l_int32          ccbaGenerateGlobalLocs()
l_int32          ccbaGenerateStepChains()
l_int32          ccbaStepChainsToPixCoords()
l_int32          ccbaGenerateSPGlobalLocs()

Conversion to single path
l_int32          ccbaGenerateSinglePath()
PTA             *getCutPathForHole()

Border and full image rendering
PIX             *ccbaDisplayBorder()
PIX             *ccbaDisplaySPBorder()
PIX             *ccbaDisplayImage1()
PIX             *ccbaDisplayImage2()

Serialize for I/O
l_int32          ccbaWrite()
l_int32          ccbaWriteStream()
l_int32          ccbaRead()
l_int32          ccbaReadStream()

SVG output
l_int32          ccbaWriteSVG()
char            *ccbaWriteSVGString()


Border finding is tricky because components can have
holes, which also need to be traced out.  The outer
border can be connected with all the hole borders,
so that there is a single border for each component.
[Alternatively, the connecting paths can be eliminated if
you're willing to have a set of borders for each
component (an exterior border and some number of
interior ones), with "line to" operations tracing
out each border and "move to" operations going from
one border to the next.]

Here's the plan.  We get the pix for each connected
component, and trace its exterior border.  We then
find the holes (if any) in the pix, and separately
trace out their borders, all using the same
border-following rule that has ON pixels on the right
side of the path.

[For svg, we may want to turn each set of borders for a c.c.
into a closed path.  This can be done by tunnelling
through the component from the outer border to each of the
holes, going in and coming out along the same path so
the connection will be invisible in any rendering
(display or print) from the outline.  The result is a
closed path, where the outside border is traversed
cw and each hole is traversed ccw.  The svg renderer
is assumed to handle these closed borders properly.]

Each border is a closed path that is traversed in such
a way that the stuff inside the c.c. is on the right
side of the traveller.  The border of a singly-connected
component is thus traversed cw, and the border of the
holes inside a c.c. are traversed ccw.  Suppose we have
a list of all the borders of each c.c., both the cw and ccw
traversals.  How do we reconstruct the image?

Reconstruction:

Method 1.  Topological method using connected components.
We have closed borders composed of cw border pixels for the
exterior of c.c. and ccw border pixels for the interior (holes)
in the c.c.
(a) Initialize the destination to be OFF.  Then,
in any order:
(b) Fill the components within and including the cw borders,
and sequentially XOR them onto the destination.
(c) Fill the components within but not including the ccw
borders and sequentially XOR them onto the destination.
The components that are XOR'd together can be generated as follows:
(a) For each closed cw path, use pixFillClosedBorders():
(1) Turn on the path pixels in a subimage that
minimally supports the border.
(2) Do a 4-connected fill from a seed of 1 pixel width
on the border, using the inverted image in (1) as
a filling mask.
(3) Invert the fill result: this gives the component
including the exterior cw path, with all holes
filled.
(b) For each closed ccw path (hole):
(1) Turn on the path pixels in a subimage that minimally
supports the path.
(2) Find a seed pixel on the inside of this path.
(3) Do a 4-connected fill from this seed pixel, using
the inverted image of the path in (1) as a filling
mask.

------------------------------------------------------

Method 2.  A variant of Method 1.  Topological.
In Method 1, we treat the exterior border differently from
the interior (hole) borders.  Here, all borders in a c.c.
are treated equally:
(1) Start with a pix with a 1 pixel OFF boundary
enclosing all the border pixels of the c.c.
This is the filling mask.
(2) Make a seed image of the same size as follows:  for
each border, put one seed pixel OUTSIDE the border
(where OUTSIDE is determined by the inside/outside
convention for borders).
(3) Seedfill into the seed image, filling in the regions
determined by the filling mask.  The fills are clipped
by the border pixels.
(4) Inverting this, we get the c.c. properly filled,
with the holes empty!
(5) Rasterop using XOR the filled c.c. (but not the 1
pixel boundary) into the full dest image.

Method 2 is about 1.2x faster than Method 1 on text images,
and about 2x faster on complex images (e.g., with halftones).

------------------------------------------------------

Method 3.  The traditional way to fill components delineated
by boundaries is through scan line conversion.  It's a bit
tricky, and I have not yet tried to implement it.

------------------------------------------------------

Method 4.  [Nota Bene: this method probably doesn't work, and
won't be implemented.  If I get a more traditional scan line
conversion algorithm working, I'll erase these notes.]
Render all border pixels on a destination image,
which will be the final result after scan conversion.  Assign
a value 1 to pixels on cw paths, 2 to pixels on ccw paths,
and 3 to pixels that are on both paths.  Each of the paths
is an 8-connected component.  Now scan across each raster
line.  The attempt is to make rules for each scan line
that are independent of neighboring scanlines.  Here are
a set of rules for writing ON pixels on a destination raster image:

(a) The rasterizer will be in one of two states: ON and OFF.
(b) Start each line in the OFF state.  In the OFF state,
skip pixels until you hit a path of any type.  Turn
the path pixel ON.
(c) If the state is ON, each pixel you encounter will
be turned on, until and including hitting a path pixel.
(d) When you hit a path pixel, if the path does NOT cut
through the line, so that there is not an 8-cc path
pixel (of any type) both above and below, the state
is unchanged (it stays either ON or OFF).
(e) If the path does cut through, but with a possible change
of pixel type, then we decide whether or
not to toggle the state based on the values of the
path pixel and the path pixels above and below:
(1) if a 1 path cuts through, toggle;
(1) if a 2 path cuts through, toggle;
(3) if a 3 path cuts through, do not toggle;
(4) if on one side a 3 touches both a 1 and a 2, use the 2
(5) if a 3 has any 1 neighbors, toggle; else if it has
no 1 neighbors, do not toggle;
(6) if a 2 has any neighbors that are 1 or 3,
do not toggle
(7) if a 1 has neighbors 1 and x (x = 2 or 3),
toggle


To visualize how these rules work, consider the following
component with border pixels labeled according to the scheme
above.  We also show the values of the interior pixels
(w=OFF, b=ON), but these of course must be inferred properly
from the rules above:

3
3  w  3             1  1  1
1  2  1          1  b  2  b  1
1  b  1             3  w  2  1
3  b  1          1  b  2  b  1
3  w  3                1  1  1
3  w  3
1  b  2  b  1
1  2  w  2  1
1  b  2  w  2  b  1
1  2  w  2  1
1  2  b  1
1  b  1
1


Even if this works, which is unlikely, it will certainly be
slow because decisions have to be made on a pixel-by-pixel
basis when encountering borders.

</pre>




"""
    
    try:
        leptonica.ccbaCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaCreate.restype = lambda address: CCBORDA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaCreate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'n')       

:param[in]    pixs:    1 bpp; can be null
:param[in]    n:       initial number of ptrs
:returns:  ccba, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaCreate(*args)
    
    

    try:
        leptonica.ccbaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDestroy(*args):
        """
        ('CCBORDA', '**pccba')       

:param[in,out]   pccba:     will be set to null befoe returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDestroy(*args)
    
    

    try:
        leptonica.ccbCreate.argtypes = [ctypes.c_void_p]
        leptonica.ccbCreate.restype = lambda address: CCBORD(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbCreate(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    [optional]; can be null
:returns:  ccb or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbCreate(*args)
    
    

    try:
        leptonica.ccbDestroy.argtypes = [ctypes.c_void_p]
        leptonica.ccbDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function ccbDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbDestroy(*args):
        """
        ('CCBORD', '**pccb')       

:param[in,out]   pccb:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.ccbDestroy(*args)
    
    

    try:
        leptonica.ccbaAddCcb.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaAddCcb.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaAddCcb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaAddCcb(*args):
        """
        ('CCBORDA', '*ccba')       
('CCBORD', '*ccb')       

:param[in]    ccba:
:param[in]    ccb:     to be added by insertion
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaAddCcb(*args)
    
    

    try:
        leptonica.ccbaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function ccbaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGetCount(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:
:returns:  count, with 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGetCount(*args)
    
    

    try:
        leptonica.ccbaGetCcb.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaGetCcb.restype = lambda address: CCBORD(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaGetCcb not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGetCcb(*args):
        """
        ('CCBORDA', '*ccba')       
('l_int32', 'index')       

:param[in]    ccba:
:param[in]    index:
:returns:  ccb, or NULL on error

<pre>
Notes:
(1) This returns a clone of the ccb; it must be destroyed
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGetCcb(*args)
    
    

    try:
        leptonica.pixGetAllCCBorders.argtypes = [ctypes.c_void_p]
        leptonica.pixGetAllCCBorders.restype = lambda address: CCBORDA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetAllCCBorders not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetAllCCBorders(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:    1 bpp
:returns:  ccborda, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetAllCCBorders(*args)
    
    

    try:
        leptonica.pixGetOuterBordersPtaa.argtypes = [ctypes.c_void_p]
        leptonica.pixGetOuterBordersPtaa.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGetOuterBordersPtaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetOuterBordersPtaa(*args):
        """
        ('PIX', '*pixs')       

:param[in]    pixs:     1 bpp
:returns:  ptaa of outer borders, in global coords, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetOuterBordersPtaa(*args)
    
    

    try:
        leptonica.pixGetOuterBorder.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetOuterBorder.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetOuterBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetOuterBorder(*args):
        """
        ('CCBORD', '*ccb')       
('PIX', '*pixs')       
('BOX', '*box')       

:param[in]    ccb:     unfilled
:param[in]    pixs:    for the component at hand
:param[in]    box:     for the component, in global coords
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) the border is saved in relative coordinates within
the c.c. (pixs).  Because the calculation is done
in pixb with added 1 pixel border, we must subtract
1 from each pixel value before storing it.
(2) the stopping condition is that after the first pixel is
returned to, the next pixel is the second pixel.  Having
these 2 pixels recur in sequence proves the path is closed,
and we do not store the second pixel again.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetOuterBorder(*args)
    
    

    try:
        leptonica.ccbaGenerateGlobalLocs.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGenerateGlobalLocs.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaGenerateGlobalLocs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateGlobalLocs(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:     with local chain ptaa of borders computed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This uses the pixel locs in the local ptaa, which are all
relative to each c.c., to find the global pixel locations,
and stores them in the global ptaa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateGlobalLocs(*args)
    
    

    try:
        leptonica.ccbaGenerateStepChains.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGenerateStepChains.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaGenerateStepChains not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateStepChains(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:     with local chain ptaa of borders computed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This uses the pixel locs in the local ptaa,
which are all relative to each c.c., to find
the step directions for successive pixels in
the chain, and stores them in the step numaa.
(2) To get the step direction, use
1   2   3
0   P   4
7   6   5
where P is the previous pixel at (px, py).  The step direction
is the number (from 0 through 7) for each relative location
of the current pixel at (cx, cy).  It is easily found by
indexing into a 2-d 3x3 array (dirtab).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateStepChains(*args)
    
    

    try:
        leptonica.ccbaStepChainsToPixCoords.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaStepChainsToPixCoords.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaStepChainsToPixCoords not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaStepChainsToPixCoords(*args):
        """
        ('CCBORDA', '*ccba')       
('l_int32', 'coordtype')       

:param[in]    ccba:        with step chains numaa of borders
:param[in]    coordtype:   CCB_GLOBAL_COORDS or CCB_LOCAL_COORDS
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This uses the step chain data in each ccb to determine
the pixel locations, either global or local,
and stores them in the appropriate ptaa,
either global or local.  For the latter, the
pixel locations are relative to the c.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaStepChainsToPixCoords(*args)
    
    

    try:
        leptonica.ccbaGenerateSPGlobalLocs.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.ccbaGenerateSPGlobalLocs.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaGenerateSPGlobalLocs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateSPGlobalLocs(*args):
        """
        ('CCBORDA', '*ccba')       
('l_int32', 'ptsflag')       

:param[in]    ccba:
:param[in]    ptsflag:      CCB_SAVE_ALL_PTS or CCB_SAVE_TURNING_PTS
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This calculates the splocal rep if not yet made.
(2) It uses the local pixel values in splocal, the single
path pta, which are all relative to each c.c., to find
the corresponding global pixel locations, and stores
them in the spglobal pta.
(3) This lists only the turning points: it both makes a
valid svg file and is typically about half the size
when all border points are listed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateSPGlobalLocs(*args)
    
    

    try:
        leptonica.ccbaGenerateSinglePath.argtypes = [ctypes.c_void_p]
        leptonica.ccbaGenerateSinglePath.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaGenerateSinglePath not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaGenerateSinglePath(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Generates a single border in local pixel coordinates.
For each c.c., if there is just an outer border, copy it.
If there are also hole borders, for each hole border,
determine the smallest horizontal or vertical
distance from the border to the outside of the c.c.,
and find a path through the c.c. for this cut.
We do this in a way that guarantees a pixel from the
hole border is the starting point of the path, and
we must verify that the path intersects the outer
border (if it intersects it, then it ends on it).
One can imagine pathological cases, but they may not
occur in images of text characters and un-textured
line graphics.
(2) Once it is verified that the path through the c.c.
intersects both the hole and outer borders, we
generate the full single path for all borders in the
c.c.  Starting at the start point on the outer
border, when we hit a line on a cut, we take
the cut, do the hold border, and return on the cut
to the outer border.  We compose a pta of the
outer border pts that are on cut paths, and for
every point on the outer border (as we go around),
we check against this pta.  When we find a matching
point in the pta, we do its cut path and hole border.
The single path is saved in the ccb.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaGenerateSinglePath(*args)
    
    

    try:
        leptonica.getCutPathForHole.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getCutPathForHole.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function getCutPathForHole not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getCutPathForHole(*args):
        """
        ('PIX', '*pix')       
('PTA', '*pta')       
('BOX', '*boxinner')       
('l_int32', '*pdir')       
('l_int32', '*plen')       

:param[in]    pix:        1 bpp, of c.c.
:param[in]    pta:        of outer border
:param[in]    boxinner:   bounding box of hole path
:param[out]   pdir:       direction (0-3), returned; only needed for debug
:param[out]   plen:       length of path, returned
:returns:  pta of pts on cut path from the hole border
to the outer border, including end points on
both borders; or NULL on error

<pre>
Notes:
(1) If we don't find a path, we return a pta with no pts
in it and len = 0.
(2) The goal is to get a reasonably short path between the
inner and outer borders, that goes entirely within the fg of
the pix.  This function is cheap-and-dirty, may fail for some
holes in complex topologies such as those you might find in a
moderately dark scanned halftone.  If it fails to find a
path to any particular hole, it gives a warning, and because
that hole path is not included, the hole will not be rendered.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getCutPathForHole(*args)
    
    

    try:
        leptonica.ccbaDisplayBorder.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplayBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaDisplayBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplayBorder(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:
:returns:  pix of border pixels, or NULL on error

<pre>
Notes:
(1) Uses global ptaa, which gives each border pixel in
global coordinates, and must be computed in advance
by calling ccbaGenerateGlobalLocs().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplayBorder(*args)
    
    

    try:
        leptonica.ccbaDisplaySPBorder.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplaySPBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaDisplaySPBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplaySPBorder(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:
:returns:  pix of border pixels, or NULL on error

<pre>
Notes:
(1) Uses spglobal pta, which gives each border pixel in
global coordinates, one path per c.c., and must
be computed in advance by calling ccbaGenerateSPGlobalLocs().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplaySPBorder(*args)
    
    

    try:
        leptonica.ccbaDisplayImage1.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplayImage1.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaDisplayImage1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplayImage1(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]    ccba:
:returns:  pix of image, or NULL on error

<pre>
Notes:
(1) Uses local ptaa, which gives each border pixel in
local coordinates, so the actual pixel positions must
be computed using all offsets.
(2) For the holes, use coordinates relative to the c.c.
(3) This is slower than Method 2.
(4) This uses topological properties (Method 1) to do scan
conversion to raster

This algorithm deserves some commentary.

I first tried the following:
~ outer borders: 4-fill from outside, stopping at the
border, using pixFillClosedBorders()
~ inner borders: 4-fill from outside, stopping again
at the border, XOR with the border, and invert
to get the hole.  This did not work, because if
you have a hole border that looks like:

x x x x x x
x          x
x   x x x   x
x x o x   x
x     x
x     x
x x x

if you 4-fill from the outside, the pixel 'o' will
not be filled!  XORing with the border leaves it OFF.
Inverting then gives a single bad ON pixel that is not
actually part of the hole.

So what you must do instead is 4-fill the holes from inside.
You can do this from a seedfill, using a pix with the hole
border as the filling mask.  But you need to start with a
pixel inside the hole.  How is this determined?  The best
way is from the contour.  We have a right-hand shoulder
rule for inside (i.e., the filled region).   Take the
first 2 pixels of the hole border, and compute dx and dy
(second coord minus first coord:  dx = sx - fx, dy = sy - fy).
There are 8 possibilities, depending on the values of dx and
dy (which can each be -1, 0, and +1, but not both 0).
These 8 cases can be broken into 4; see the simple algorithm below.
Once you have an interior seed pixel, you fill from the seed,
clipping with the hole border pix by filling into its invert.

You then successively XOR these interior filled components, in any order.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplayImage1(*args)
    
    

    try:
        leptonica.ccbaDisplayImage2.argtypes = [ctypes.c_void_p]
        leptonica.ccbaDisplayImage2.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaDisplayImage2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaDisplayImage2(*args):
        """
        ('CCBORDA', '*ccba')       

:param[in]   ccba:
:returns:  pix of image, or NULL on error

<pre>
Notes:
(1) Uses local chain ptaa, which gives each border pixel in
local coordinates, so the actual pixel positions must
be computed using all offsets.
(2) Treats exterior and hole borders on equivalent
footing, and does all calculations on a pix
that spans the c.c. with a 1 pixel added boundary.
(3) This uses topological properties (Method 2) to do scan
conversion to raster
(4) The algorithm is described at the top of this file (Method 2).
It is preferred to Method 1 because it is between 1.2x and 2x
faster than Method 1.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaDisplayImage2(*args)
    
    

    try:
        leptonica.ccbaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.ccbaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWrite(*args):
        """
        ('const char', '*filename')       
('CCBORDA', '*ccba')       

:param[in]    filename:
:param[in]    ccba:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWrite(*args)
    
    

    try:
        leptonica.ccbaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ccbaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWriteStream(*args):
        """
        ('FILE', '*fp')       
('CCBORDA', '*ccba')       

:param[in]    fp:       file stream
:param[in]    ccba:
:returns:  0 if OK; 1 on error

Format:
\code
ccba: %7d cc\n num. c.c.) (ascii)   (18B
pix width 4B
pix height 4B
[for i = 1, ncc]
ulx  4B
uly  4B
w    4B       -- not req'd for reconstruction
h    4B       -- not req'd for reconstruction
number of borders 4B
[for j = 1, nb]
startx  4B
starty  4B
[for k = 1, nb]
2 steps 1B
end in z8 or 88  1B
\endcode


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWriteStream(*args)
    
    

    try:
        leptonica.ccbaRead.argtypes = [ctypes.c_char_p]
        leptonica.ccbaRead.restype = lambda address: CCBORDA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  ccba, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaRead(*args)
    
    

    try:
        leptonica.ccbaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.ccbaReadStream.restype = lambda address: CCBORDA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ccbaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]     fp:     file stream
:returns:   ccba, or NULL on error

\code
Format:  ccba: %7d cc\n num. c.c.) (ascii)   (17B
pix width 4B
pix height 4B
[for i = 1, ncc]
ulx  4B
uly  4B
w    4B       -- not req'd for reconstruction
h    4B       -- not req'd for reconstruction
number of borders 4B
[for j = 1, nb]
startx  4B
starty  4B
[for k = 1, nb]
2 steps 1B
end in z8 or 88  1B
\endcode


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaReadStream(*args)
    
    

    try:
        leptonica.ccbaWriteSVG.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.ccbaWriteSVG.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ccbaWriteSVG not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWriteSVG(*args):
        """
        ('const char', '*filename')       
('CCBORDA', '*ccba')       

:param[in]    filename:
:param[in]    ccba:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWriteSVG(*args)
    
    

    try:
        leptonica.ccbaWriteSVGString.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.ccbaWriteSVGString.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function ccbaWriteSVGString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ccbaWriteSVGString(*args):
        """
        ('const char', '*filename')       
('CCBORDA', '*ccba')       

:param[in]    filename:
:param[in]    ccba:
:returns:  string in svg-formatted, that can be written to file,
or NULL on error.


        """
        args = _convert_params(*args)
        
        return leptonica.ccbaWriteSVGString(*args)
    




class fliphmtgen(object):
    """"""
    



class morphdwa(object):
    """<pre>

Binary morphological (dwa) ops with brick Sels
PIX     *pixDilateBrickDwa()
PIX     *pixErodeBrickDwa()
PIX     *pixOpenBrickDwa()
PIX     *pixCloseBrickDwa()

Binary composite morphological (dwa) ops with brick Sels
PIX     *pixDilateCompBrickDwa()
PIX     *pixErodeCompBrickDwa()
PIX     *pixOpenCompBrickDwa()
PIX     *pixCloseCompBrickDwa()

Binary extended composite morphological (dwa) ops with brick Sels
PIX     *pixDilateCompBrickExtendDwa()
PIX     *pixErodeCompBrickExtendDwa()
PIX     *pixOpenCompBrickExtendDwa()
PIX     *pixCloseCompBrickExtendDwa()
l_int32  getExtendedCompositeParameters()

These are higher-level interfaces for dwa morphology with brick Sels.
Because many morphological operations are performed using
separable brick Sels, it is useful to have a simple interface
for this.

We have included all 58 of the brick Sels that are generated
by selaAddBasic().  These are sufficient for all the decomposable
bricks up to size 63, which is the limit for dwa Sels with
origins at the center of the Sel.

All three sets can be used as the basic interface for general
brick operations.  Here are the internal calling sequences:

(1) If you try to apply a non-decomposable operation, such as
pixErodeBrickDwa(), with a Sel size that doesn't exist,
this calls a decomposable operation, pixErodeCompBrickDwa(),
instead.  This can differ in linear Sel size by up to
2 pixels from the request.

(2) If either Sel brick dimension is greater than 63, the extended
composite function is called.

(3) The extended composite function calls the composite function
a number of times with size 63, and once with size < 63.
Because each operation with a size of 63 is done compositely
with 7 x 9 (exactly 63), the net result is correct in
length to within 2 pixels.

For composite operations, both using a comb and extended (beyond 63),
horizontal and vertical operations are composed separately
and sequentially.

We have also included use of all the 76 comb Sels that are generated
by selaAddDwaCombs().  The generated code is in dwacomb.2.c
and dwacomblow.2.c.  These are used for the composite dwa
brick operations.

The non-composite brick operations, such as pixDilateBrickDwa(),
will call the associated composite operation in situations where
the requisite brick Sel has not been compiled into fmorphgen*.1.c.

If you want to use brick Sels that are not represented in the
basic set of 58, you must generate the dwa code to implement them.
You have three choices for how to use these:

(1) Add both the new Sels and the dwa code to the library:
~ For simplicity, add your new brick Sels to those defined
in selaAddBasic().
~ Recompile the library.
~ Make prog/fmorphautogen.
~ Run prog/fmorphautogen, to generate new versions of the
dwa code in fmorphgen.1.c and fmorphgenlow.1.c.
~ Copy these two files to src.
~ Recompile the library again.
~ Use the new brick Sels in your program and compile it.

(2) Make both the new Sels and dwa code outside the library,
and link it directly to an executable:
~ Write a function to generate the new Sels in a Sela, and call
fmorphautogen(sela, <N>, filename) to generate the code.
~ Compile your program that uses the newly generated function
pixMorphDwa_<N>(), and link to the two new C files.

(3) Make the new Sels in the library and use the dwa code outside it:
~ Add code in the library to generate your new brick Sels.
(It is suggested that you NOT add these Sels to the
selaAddBasic() function; write a new function that generates
a new Sela.)
~ Recompile the library.
~ Write a small program that generates the Sela and calls
fmorphautogen(sela, <N>, filename) to generate the code.
~ Compile your program that uses the newly generated function
pixMorphDwa_<N>(), and link to the two new C files.
As an example of this approach, see prog/dwamorph*_reg.c:
~ added selaAddDwaLinear() to sel2.c
~ wrote dwamorph1_reg.c, to generate the dwa code.
~ compiled and linked the generated code with the application,
dwamorph2_reg.c.  (Note: because this was a regression test,
dwamorph1_reg also builds and runs the application program.)
</pre>




"""
    
    try:
        leptonica.pixDilateBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:    [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:    1 bpp
:param[in]    hsize:   width of brick Sel
:param[in]    vsize:   height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) These implement 2D brick Sels, using linear Sels generated
with selaAddBasic().
(2) A brick Sel has hits for all elements.
(3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(4) Do separably if both hsize and vsize are > 1.
(5) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(6) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(7) For clarity, if the case is known, use these patterns:
(a) pixd = pixDilateBrickDwa(NULL, pixs, ...);
(b) pixDilateBrickDwa(pixs, pixs, ...);
(c) pixDilateBrickDwa(pixd, pixs, ...);
(8) The size of pixd is determined by pixs.
(9) If either linear Sel is not found, this calls
the appropriate decomposible function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateBrickDwa(*args)
    
    

    try:
        leptonica.pixErodeBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) These implement 2D brick Sels, using linear Sels generated
with selaAddBasic().
(2) A brick Sel has hits for all elements.
(3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(4) Do separably if both hsize and vsize are > 1.
(5) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(6) Note that we must always set or clear the border pixels
before each operation, depending on the the b.c.
(symmetric or asymmetric).
(7) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(8) For clarity, if the case is known, use these patterns:
(a) pixd = pixErodeBrickDwa(NULL, pixs, ...);
(b) pixErodeBrickDwa(pixs, pixs, ...);
(c) pixErodeBrickDwa(pixd, pixs, ...);
(9) The size of the result is determined by pixs.
(10) If either linear Sel is not found, this calls
the appropriate decomposible function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeBrickDwa(*args)
    
    

    try:
        leptonica.pixOpenBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) These implement 2D brick Sels, using linear Sels generated
with selaAddBasic().
(2) A brick Sel has hits for all elements.
(3) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(4) Do separably if both hsize and vsize are > 1.
(5) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(6) Note that we must always set or clear the border pixels
before each operation, depending on the the b.c.
(symmetric or asymmetric).
(7) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(8) For clarity, if the case is known, use these patterns:
(a) pixd = pixOpenBrickDwa(NULL, pixs, ...);
(b) pixOpenBrickDwa(pixs, pixs, ...);
(c) pixOpenBrickDwa(pixd, pixs, ...);
(9) The size of the result is determined by pixs.
(10) If either linear Sel is not found, this calls
the appropriate decomposible function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenBrickDwa(*args)
    
    

    try:
        leptonica.pixCloseBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) This is a 'safe' closing; we add an extra border of 32 OFF
pixels for the standard asymmetric b.c.
(2) These implement 2D brick Sels, using linear Sels generated
with selaAddBasic().
(3) A brick Sel has hits for all elements.
(4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(5) Do separably if both hsize and vsize are > 1.
(6) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(7) Note that we must always set or clear the border pixels
before each operation, depending on the the b.c.
(symmetric or asymmetric).
(8) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(9) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseBrickDwa(NULL, pixs, ...);
(b) pixCloseBrickDwa(pixs, pixs, ...);
(c) pixCloseBrickDwa(pixd, pixs, ...);
(10) The size of the result is determined by pixs.
(11) If either linear Sel is not found, this calls
the appropriate decomposible function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseBrickDwa(*args)
    
    

    try:
        leptonica.pixDilateCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateCompBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) These implement a separable composite dilation with 2D brick Sels.
(2) For efficiency, it may decompose each linear morphological
operation into two (brick + comb).
(3) A brick Sel has hits for all elements.
(4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(5) Do separably if both hsize and vsize are > 1.
(6) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(7) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(8) For clarity, if the case is known, use these patterns:
(a) pixd = pixDilateCompBrickDwa(NULL, pixs, ...);
(b) pixDilateCompBrickDwa(pixs, pixs, ...);
(c) pixDilateCompBrickDwa(pixd, pixs, ...);
(9) The size of pixd is determined by pixs.
(10) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateCompBrickDwa(*args)
    
    

    try:
        leptonica.pixErodeCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeCompBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) These implement a separable composite erosion with 2D brick Sels.
(2) For efficiency, it may decompose each linear morphological
operation into two (brick + comb).
(3) A brick Sel has hits for all elements.
(4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(5) Do separably if both hsize and vsize are > 1.
(6) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(7) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(8) For clarity, if the case is known, use these patterns:
(a) pixd = pixErodeCompBrickDwa(NULL, pixs, ...);
(b) pixErodeCompBrickDwa(pixs, pixs, ...);
(c) pixErodeCompBrickDwa(pixd, pixs, ...);
(9) The size of pixd is determined by pixs.
(10) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeCompBrickDwa(*args)
    
    

    try:
        leptonica.pixOpenCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenCompBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) These implement a separable composite opening with 2D brick Sels.
(2) For efficiency, it may decompose each linear morphological
operation into two (brick + comb).
(3) A brick Sel has hits for all elements.
(4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(5) Do separably if both hsize and vsize are > 1.
(6) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(7) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(8) For clarity, if the case is known, use these patterns:
(a) pixd = pixOpenCompBrickDwa(NULL, pixs, ...);
(b) pixOpenCompBrickDwa(pixs, pixs, ...);
(c) pixOpenCompBrickDwa(pixd, pixs, ...);
(9) The size of pixd is determined by pixs.
(10) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenCompBrickDwa(*args)
    
    

    try:
        leptonica.pixCloseCompBrickDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseCompBrickDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseCompBrickDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseCompBrickDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) This implements a separable composite safe closing with 2D
brick Sels.
(2) For efficiency, it may decompose each linear morphological
operation into two (brick + comb).
(3) A brick Sel has hits for all elements.
(4) The origin of the Sel is at (x, y) = (hsize/2, vsize/2)
(5) Do separably if both hsize and vsize are > 1.
(6) It is necessary that both horizontal and vertical Sels
of the input size are defined in the basic sela.
(7) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(8) For clarity, if the case is known, use these patterns:
(a) pixd = pixCloseCompBrickDwa(NULL, pixs, ...);
(b) pixCloseCompBrickDwa(pixs, pixs, ...);
(c) pixCloseCompBrickDwa(pixd, pixs, ...);
(9) The size of pixd is determined by pixs.
(10) CAUTION: both hsize and vsize are being decomposed.
The decomposer chooses a product of sizes (call them
'terms') for each that is close to the input size,
but not necessarily equal to it.  It attempts to optimize:
(a) for consistency with the input values: the product
of terms is close to the input size
(b) for efficiency of the operation: the sum of the
terms is small; ideally about twice the square
root of the input size.
So, for example, if the input hsize = 37, which is
a prime number, the decomposer will break this into two
terms, 6 and 6, so that the net result is a dilation
with hsize = 36.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseCompBrickDwa(*args)
    
    

    try:
        leptonica.pixDilateCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDilateCompBrickExtendDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDilateCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDilateCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) Ankur Jain suggested and implemented extending the composite
DWA operations beyond the 63 pixel limit.  This is a
simplified and approximate implementation of the extension.
This allows arbitrary Dwa morph operations using brick Sels,
by decomposing the horizontal and vertical dilations into
a sequence of 63-element dilations plus a dilation of size
between 3 and 62.
(2) The 63-element dilations are exact, whereas the extra dilation
is approximate, because the underlying decomposition is
in pixDilateCompBrickDwa().  See there for further details.
(3) There are three cases:
(a) pixd == null   (result into new pixd)
(b) pixd == pixs   (in-place; writes result back to pixs)
(c) pixd != pixs   (puts result into existing pixd)
(4) There is no need to call this directly:  pixDilateCompBrickDwa()
calls this function if either brick dimension exceeds 63.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDilateCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.pixErodeCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixErodeCompBrickExtendDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixErodeCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixErodeCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
(1) See pixDilateCompBrickExtendDwa() for usage.
(2) There is no need to call this directly:  pixErodeCompBrickDwa()
calls this function if either brick dimension exceeds 63.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixErodeCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.pixOpenCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixOpenCompBrickExtendDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixOpenCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixOpenCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
1) There are three cases:
a) pixd == null   (result into new pixd
b) pixd == pixs   (in-place; writes result back to pixs
c) pixd != pixs   (puts result into existing pixd
2) There is no need to call this directly:  pixOpenCompBrickDwa(
calls this function if either brick dimension exceeds 63.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixOpenCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.pixCloseCompBrickExtendDwa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixCloseCompBrickExtendDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixCloseCompBrickExtendDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixCloseCompBrickExtendDwa(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('l_int32', 'hsize')       
('l_int32', 'vsize')       

:param[in]    pixd:     [optional]; this can be null, equal to pixs,
or different from pixs
:param[in]    pixs:     1 bpp
:param[in]    hsize:    width of brick Sel
:param[in]    vsize:    height of brick Sel
:returns:  pixd

<pre>
Notes:
1) There are three cases:
a) pixd == null   (result into new pixd
b) pixd == pixs   (in-place; writes result back to pixs
c) pixd != pixs   (puts result into existing pixd
2) There is no need to call this directly:  pixCloseCompBrickDwa(
calls this function if either brick dimension exceeds 63.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixCloseCompBrickExtendDwa(*args)
    
    

    try:
        leptonica.getExtendedCompositeParameters.argtypes = [ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getExtendedCompositeParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getExtendedCompositeParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getExtendedCompositeParameters(*args):
        """
        ('l_int32', 'size')       
('l_int32', '*pn')       
('l_int32', '*pextra')       
('l_int32', '*pactualsize')       

:param[in]    size:          of linear Sel
:param[out]   pn:            number of 63 wide convolutions
:param[out]   pextra:        size of extra Sel
:param[out]   pactualsize:   [optional] actual size used in operation
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The DWA implementation allows Sels to be used with hits
up to 31 pixels from the origin, either horizontally or
vertically.  Larger Sels can be used if decomposed into
a set of operations with Sels not exceeding 63 pixels
in either width or height (and with the origin as close
to the center of the Sel as possible).
(2) This returns the decomposition of a linear Sel of length
%size into a set of %n Sels of length 63 plus an extra
Sel of length %extra.
(3) For notation, let w == %size, n == %n, and e == %extra.
We have 1 < e < 63.

Then if w < 64, we have n = 0 and e = w.
The general formula for w > 63 is:
w = 63 + (n - 1) * 62 + (e - 1)

Where did this come from?  Each successive convolution with
a Sel of length L adds a total length (L - 1) to w.
This accounts for using 62 for each additional Sel of size 63,
and using (e - 1) for the additional Sel of size e.

Solving for n and e for w > 63:
n = 1 + Int((w - 63) / 62)
e = w - 63 - (n - 1) * 62 + 1

The extra part is decomposed into two factors f1 and f2,
and the actual size of the extra part is
e' = f1 * f2
Then the actual width is:
w' = 63 + (n - 1) * 62 + f1 * f2 - 1
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getExtendedCompositeParameters(*args)
    




class pnmiostub(object):
    """<pre>

Stubs for pnmio.c functions
</pre>




"""
    



class ccthin(object):
    """<pre>

PIXA   *pixaThinConnected()
PIX    *pixThinConnected()
PIX    *pixThinConnectedBySet()
SELA   *selaMakeThinSets()
</pre>




"""
    
    try:
        leptonica.pixaThinConnected.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaThinConnected.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaThinConnected not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaThinConnected(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('l_int32', 'maxiters')       

:param[in]   pixas:          of 1 bpp pix
:param[in]   type:           L_THIN_FG, L_THIN_BG
:param[in]   connectivity:   4 or 8
:param[in]   maxiters:       max number of iters allowed;
use 0 to iterate until completion
:returns:  pixds, or NULL on error

<pre>
Notes:
(1) See notes in pixThinConnected().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaThinConnected(*args)
    
    

    try:
        leptonica.pixThinConnected.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixThinConnected.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThinConnected not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThinConnected(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'connectivity')       
('l_int32', 'maxiters')       

:param[in]   pixs:           1 bpp
:param[in]   type:           L_THIN_FG, L_THIN_BG
:param[in]   connectivity:   4 or 8
:param[in]   maxiters:       max number of iters allowed;
use 0 to iterate until completion
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See "Connectivity-preserving morphological image transformations,"
Dan S. Bloomberg, in SPIE Visual Communications and Image
Processing, Conference 1606, pp. 320-334, November 1991,
Boston, MA.   A web version is available at
http://www.leptonica.com/papers/conn.pdf
(2) This is a simple interface for two of the best iterative
morphological thinning algorithms, for 4-c.c and 8-c.c.
Each iteration uses a mixture of parallel operations
(using several different 3x3 Sels) and serial operations.
Specifically, each thinning iteration consists of
four sequential thinnings from each of four directions.
Each of these thinnings is a parallel composite
operation, where the union of a set of HMTs are set
subtracted from the input.  For 4-cc thinning, we
use 3 HMTs in parallel, and for 8-cc thinning we use 4 HMTs.
(3) A "good" thinning algorithm is one that generates a skeleton
that is near the medial axis and has neither pruned
real branches nor left extra dendritic branches.
(4) Duality between operations on fg and bg require switching
the connectivity.  To thin the foreground, which is the usual
situation, use type == L_THIN_FG.  Thickening the foreground
is equivalent to thinning the background (type == L_THIN_BG),
where the alternate connectivity gets preserved.
For example, to thicken the fg with 2 rounds of iterations
using 4-c.c., thin the bg using Sels that preserve 8-connectivity:
Pix *pix = pixThinConnected(pixs, L_THIN_BG, 8, 2);
(5) This makes and destroys the sela set each time. It's not a large
overhead, but if you are calling this thousands of times on
very small images, you can avoid the overhead; e.g.
Sela *sela = selaMakeThinSets(1, 0);  // for 4-c.c.
Pix *pix = pixThinConnectedBySet(pixs, L_THIN_FG, sela, 0);
using set 1 for 4-c.c. and set 5 for 8-c.c operations.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThinConnected(*args)
    
    

    try:
        leptonica.pixThinConnectedBySet.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixThinConnectedBySet.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixThinConnectedBySet not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixThinConnectedBySet(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('SELA', '*sela')       
('l_int32', 'maxiters')       

:param[in]   pixs:       1 bpp
:param[in]   type:       L_THIN_FG, L_THIN_BG
:param[in]   sela:       of Sels for parallel composite HMTs
:param[in]   maxiters:   max number of iters allowed;
use 0 to iterate until completion
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) See notes in pixThinConnected().
(2) This takes a sela representing one of 11 sets of HMT Sels.
The HMTs from this set are run in parallel and the result
is OR'd before being subtracted from the source.  For each
iteration, this "parallel" thin is performed four times
sequentially, for sels rotated by 90 degrees in all four
directions.
(3) The "parallel" and "sequential" nomenclature is standard
in digital filtering.  Here, "parallel" operations work on the
same source (pixd), and accumulate the results in a temp
image before actually applying them to the source (in this
case, using an in-place subtraction).  "Sequential" operations
operate directly on the source (pixd) to produce the result
(in this case, with four sequential thinning operations, one
from each of four directions).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixThinConnectedBySet(*args)
    
    

    try:
        leptonica.selaMakeThinSets.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.selaMakeThinSets.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function selaMakeThinSets not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selaMakeThinSets(*args):
        """
        ('l_int32', 'index')       
('l_int32', 'debug')       

:param[in]   index:   into specific sets
:param[in]   debug:   1 to output display of sela
:returns:  sela, or NULL on error

<pre>
Notes:
(1) These are specific sets of HMTs to be used in parallel for
for thinning from each of four directions.
(2) The sets are indexed as follows:
For thinning (e.g., run to completion):
index = 1     sel_4_1, sel_4_2, sel_4_3
index = 2     sel_4_1, sel_4_5, sel_4_6
index = 3     sel_4_1, sel_4_7, sel_4_7_rot
index = 4     sel_48_1, sel_48_1_rot, sel_48_2
index = 5     sel_8_2, sel_8_3, sel_8_5, sel_8_6
index = 6     sel_8_2, sel_8_3, sel_48_2
index = 7     sel_8_1, sel_8_5, sel_8_6
index = 8     sel_8_2, sel_8_3, sel_8_8, sel_8_9
index = 9     sel_8_5, sel_8_6, sel_8_7, sel_8_7_rot
For thickening (e.g., just a few iterations):
index = 10    sel_4_2, sel_4_3
index = 11    sel_8_4
(3) For a very smooth skeleton, use set 1 for 4 connected and
set 5 for 8 connected thins.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selaMakeThinSets(*args)
    




class fmorphauto(object):
    """<pre>

Main function calls:
l_int32             fmorphautogen()
l_int32             fmorphautogen1()
l_int32             fmorphautogen2()

Static helpers:
static SARRAY      *sarrayMakeWplsCode()
static SARRAY      *sarrayMakeInnerLoopDWACode()
static char        *makeBarrelshiftString()


This automatically generates dwa code for erosion and dilation.
Here's a road map for how it all works.

(1) You generate an array (a SELA) of structuring elements (SELs).
This can be done in several ways, including
(a) calling the function selaAddBasic() for
pre-compiled SELs
(b) generating the SELA in code in line
(c) reading in a SELA from file, using selaRead() or
various other formats.

(2) You call fmorphautogen1() and fmorphautogen2() on this SELA.
These use the text files morphtemplate1.txt and
morphtemplate2.txt for building up the source code.  See the file
prog/fmorphautogen.c for an example of how this is done.
The output is written to files named fmorphgen.*.c
and fmorphgenlow.*.c, where "*" is an integer that you
input to this function.  That integer labels both
the output files, as well as all the functions that
are generated.  That way, using different integers,
you can invoke fmorphautogen() any number of times
to get functions that all have different names so that
they can be linked into one program.

(3) You copy the generated source files back to your src
directory for compilation.  Put their names in the
Makefile, regenerate the prototypes, and recompile
the library.  Look at the Makefile to see how I've
included morphgen.1.c and fmorphgenlow.1.c.  These files
provide the high-level interfaces for erosion, dilation,
opening and closing, and the low-level interfaces to
do the actual work, for all 58 SELs in the SEL array.

(4) In an application, you now use this interface.  Again
for the example files in the library, using integer "1":

PIX   *pixMorphDwa_1(PIX *pixd, PIX, *pixs,
l_int32 operation, char *selname);

or

PIX   *pixFMorphopGen_1(PIX *pixd, PIX *pixs,
l_int32 operation, char *selname);

where the operation is one of {L_MORPH_DILATE, L_MORPH_ERODE.
L_MORPH_OPEN, L_MORPH_CLOSE}, and the selname is one
of the set that were defined as the name field of sels.
This set is listed at the beginning of the file fmorphgen.1.c.
For examples of use, see the file prog/binmorph_reg1.c, which
verifies the consistency of the various implementations by
comparing the dwa result with that of full-image rasterops.
</pre>




"""
    
    try:
        leptonica.fmorphautogen.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.fmorphautogen.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fmorphautogen not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fmorphautogen(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       

:param[in]    sela:
:param[in]    fileindex:
:param[in]    filename: [optional]; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This function generates all the code for implementing
dwa morphological operations using all the sels in the sela.
(2) See fmorphautogen1() and fmorphautogen2() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fmorphautogen(*args)
    
    

    try:
        leptonica.fmorphautogen1.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.fmorphautogen1.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function fmorphautogen1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fmorphautogen1(*args):
        """
        ('SELA', '*sela')       
('l_int32', 'fileindex')       
('const char', '*filename')       

:param[in]    sela:
:param[in]    fileindex:
:param[in]    filename: [optional]; can be null
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This function uses morphtemplate1.txt to create a
top-level file that contains two functions.  These
functions will carry out dilation, erosion,
opening or closing for any of the sels in the input sela.
(2) The fileindex parameter is inserted into the output
filename, as described below.
(3) If filename == NULL, the output file is fmorphgen.[n].c,
where [n] is equal to the %fileindex parameter.
(4) If filename != NULL, the output file is [%filename].[n].c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fmorphautogen1(*args)
    




class morphseq(object):
    """<pre>

Run a sequence of binary rasterop morphological operations
PIX     *pixMorphSequence()

Run a sequence of binary composite rasterop morphological operations
PIX     *pixMorphCompSequence()

Run a sequence of binary dwa morphological operations
PIX     *pixMorphSequenceDwa()

Run a sequence of binary composite dwa morphological operations
PIX     *pixMorphCompSequenceDwa()

Parser verifier for binary morphological operations
l_int32  morphSequenceVerify()

Run a sequence of grayscale morphological operations
PIX     *pixGrayMorphSequence()

Run a sequence of color morphological operations
PIX     *pixColorMorphSequence()
</pre>




"""
    
    try:
        leptonica.pixMorphSequence.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixMorphSequence.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       

:param[in]    pixs:
:param[in]    sequence:   string specifying sequence
:param[in]    dispsep:    controls debug display results in the sequence:
0: no output
> 0: gives horizontal separation in pixels between
successive displays
< 0: pdf output; abs(dispsep) is used for naming
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does rasterop morphology on binary images.
(2) This runs a pipeline of operations; no branching is allowed.
(3) This only uses brick Sels, which are created on the fly.
In the future this will be generalized to extract Sels from
a Sela by name.
(4) A new image is always produced; the input image is not changed.
(5) This contains an interpreter, allowing sequences to be
generated and run.
(6) The format of the sequence string is defined below.
(7) In addition to morphological operations, rank order reduction
and replicated expansion allow operations to take place
downscaled by a power of 2.
(8) Intermediate results can optionally be displayed.
(9) Thanks to Dar-Shyang Lee, who had the idea for this and
built the first implementation.
(10) The sequence string is formatted as follows:
~ An arbitrary number of operations,  each separated
by a '+' character.  White space is ignored.
~ Each operation begins with a case-independent character
specifying the operation:
d or D  (dilation)
e or E  (erosion)
o or O  (opening)
c or C  (closing)
r or R  (rank binary reduction)
x or X  (replicative binary expansion)
b or B  (add a border of 0 pixels of this size)
~ The args to the morphological operations are bricks of hits,
and are formatted as a.b, where a and b are horizontal and
vertical dimensions, rsp.
~ The args to the reduction are a sequence of up to 4 integers,
each from 1 to 4.
~ The arg to the expansion is a power of two, in the set
{2, 4, 8, 16}.
(11) An example valid sequence is:
"b32 + o1.3 + C3.1 + r23 + e2.2 + D3.2 + X4"
In this example, the following operation sequence is carried out:
b32: Add a 32 pixel border around the input image
o1.3: Opening with vert sel of length 3 (e.g., 1 x 3)
C3.1: Closing with horiz sel of length 3  (e.g., 3 x 1)
r23: Two successive 2x2 reductions with rank 2 in the first
and rank 3 in the second.  The result is a 4x reduced pix.
e2.2: Erosion with a 2x2 sel (origin will be at x,y: 0,0)
d3.2: Dilation with a 3x2 sel (origin will be at x,y: 1,0)
X4: 4x replicative expansion, back to original resolution
(12) The safe closing is used.  However, if you implement a
closing as separable dilations followed by separable erosions,
it will not be safe.  For that situation, you need to add
a sufficiently large border as the first operation in
the sequence.  This will be removed automatically at the
end.  There are two cautions:
~ When computing what is sufficient, remember that if
reductions are carried out, the border is also reduced.
~ The border is removed at the end, so if a border is
added at the beginning, the result must be at the
same resolution as the input!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequence(*args)
    
    

    try:
        leptonica.pixMorphCompSequence.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixMorphCompSequence.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphCompSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphCompSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       

:param[in]    pixs:
:param[in]    sequence:   string specifying sequence
:param[in]    dispsep:    controls debug display of results in the sequence:
0: no output
> 0: gives horizontal separation in pixels between
successive displays
< 0: pdf output; abs(dispsep) is used for naming
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does rasterop morphology on binary images, using composite
operations for extra speed on large Sels.
(2) Safe closing is used atomically.  However, if you implement a
closing as a sequence with a dilation followed by an
erosion, it will not be safe, and to ensure that you have
no boundary effects you must add a border in advance and
remove it at the end.
(3) For other usage details, see the notes for pixMorphSequence().
(4) The sequence string is formatted as follows:
~ An arbitrary number of operations,  each separated
by a '+' character.  White space is ignored.
~ Each operation begins with a case-independent character
specifying the operation:
d or D  (dilation)
e or E  (erosion)
o or O  (opening)
c or C  (closing)
r or R  (rank binary reduction)
x or X  (replicative binary expansion)
b or B  (add a border of 0 pixels of this size)
~ The args to the morphological operations are bricks of hits,
and are formatted as a.b, where a and b are horizontal and
vertical dimensions, rsp.
~ The args to the reduction are a sequence of up to 4 integers,
each from 1 to 4.
~ The arg to the expansion is a power of two, in the set
{2, 4, 8, 16}.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphCompSequence(*args)
    
    

    try:
        leptonica.pixMorphSequenceDwa.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixMorphSequenceDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphSequenceDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphSequenceDwa(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       

:param[in]    pixs:
:param[in]    sequence:   string specifying sequence
:param[in]    dispsep:    controls debug display of results in the sequence:
0: no output
> 0: gives horizontal separation in pixels between
successive displays
< 0: pdf output; abs(dispsep) is used for naming
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does dwa morphology on binary images.
(2) This runs a pipeline of operations; no branching is allowed.
(3) This only uses brick Sels that have been pre-compiled with
dwa code.
(4) A new image is always produced; the input image is not changed.
(5) This contains an interpreter, allowing sequences to be
generated and run.
(6) See pixMorphSequence() for further information about usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphSequenceDwa(*args)
    
    

    try:
        leptonica.pixMorphCompSequenceDwa.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.pixMorphCompSequenceDwa.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixMorphCompSequenceDwa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMorphCompSequenceDwa(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       

:param[in]    pixs:
:param[in]    sequence:   string specifying sequence
:param[in]    dispsep:    controls debug display of results in the sequence:
0: no output
> 0: gives horizontal separation in pixels between
successive displays
< 0: pdf output; abs(dispsep) is used for naming
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This does dwa morphology on binary images, using brick Sels.
(2) This runs a pipeline of operations; no branching is allowed.
(3) It implements all brick Sels that have dimensions up to 63
on each side, using a composite (linear + comb) when useful.
(4) A new image is always produced; the input image is not changed.
(5) This contains an interpreter, allowing sequences to be
generated and run.
(6) See pixMorphSequence() for further information about usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMorphCompSequenceDwa(*args)
    
    

    try:
        leptonica.morphSequenceVerify.argtypes = [ctypes.c_void_p]
        leptonica.morphSequenceVerify.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function morphSequenceVerify not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def morphSequenceVerify(*args):
        """
        ('SARRAY', '*sa')       

:param[in]    sa:    string array of operation sequence
:returns:  TRUE if valid; FALSE otherwise or on error

<pre>
Notes:
(1) This does verification of valid binary morphological
operation sequences.
(2) See pixMorphSequence() for notes on valid operations
in the sequence.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.morphSequenceVerify(*args)
    
    

    try:
        leptonica.pixGrayMorphSequence.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixGrayMorphSequence.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixGrayMorphSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGrayMorphSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
('l_int32', 'dispy')       

:param[in]    pixs:
:param[in]    sequence:   string specifying sequence
:param[in]    dispsep:    controls debug display of results in the sequence:
0: no output
> 0: gives horizontal separation in pixels between
successive displays
< 0: pdf output; abs(dispsep) is used for naming
:param[in]    dispy:      if dispsep > 0, this gives the y-value of the
UL corner for display; otherwise it is ignored
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This works on 8 bpp grayscale images.
(2) This runs a pipeline of operations; no branching is allowed.
(3) This only uses brick SELs.
(4) A new image is always produced; the input image is not changed.
(5) This contains an interpreter, allowing sequences to be
generated and run.
(6) The format of the sequence string is defined below.
(7) In addition to morphological operations, the composite
morph/subtract tophat can be performed.
(8) Sel sizes (width, height) must each be odd numbers.
(9) Intermediate results can optionally be displayed
(10) The sequence string is formatted as follows:
~ An arbitrary number of operations,  each separated
by a '+' character.  White space is ignored.
~ Each operation begins with a case-independent character
specifying the operation:
d or D  (dilation)
e or E  (erosion)
o or O  (opening)
c or C  (closing)
t or T  (tophat)
~ The args to the morphological operations are bricks of hits,
and are formatted as a.b, where a and b are horizontal and
vertical dimensions, rsp. (each must be an odd number)
~ The args to the tophat are w or W (for white tophat)
or b or B (for black tophat), followed by a.b as for
the dilation, erosion, opening and closing.
Example valid sequences are:
"c5.3 + o7.5"
"c9.9 + tw9.9"
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGrayMorphSequence(*args)
    
    

    try:
        leptonica.pixColorMorphSequence.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixColorMorphSequence.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixColorMorphSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixColorMorphSequence(*args):
        """
        ('PIX', '*pixs')       
('const char', '*sequence')       
('l_int32', 'dispsep')       
('l_int32', 'dispy')       

:param[in]    pixs:
:param[in]    sequence:   string specifying sequence
:param[in]    dispsep:    controls debug display of results in the sequence:
0: no output
> 0: gives horizontal separation in pixels between
successive displays
< 0: pdf output; abs(dispsep) is used for naming
:param[in]    dispy:      if dispsep > 0, this gives the y-value of the
UL corner for display; otherwise it is ignored
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This works on 32 bpp rgb images.
(2) Each component is processed separately.
(3) This runs a pipeline of operations; no branching is allowed.
(4) This only uses brick SELs.
(5) A new image is always produced; the input image is not changed.
(6) This contains an interpreter, allowing sequences to be
generated and run.
(7) Sel sizes (width, height) must each be odd numbers.
(8) The format of the sequence string is defined below.
(9) Intermediate results can optionally be displayed.
(10) The sequence string is formatted as follows:
~ An arbitrary number of operations,  each separated
by a '+' character.  White space is ignored.
~ Each operation begins with a case-independent character
specifying the operation:
d or D  (dilation)
e or E  (erosion)
o or O  (opening)
c or C  (closing)
~ The args to the morphological operations are bricks of hits,
and are formatted as a.b, where a and b are horizontal and
vertical dimensions, rsp. (each must be an odd number)
Example valid sequences are:
"c5.3 + o7.5"
"D9.1"
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixColorMorphSequence(*args)
    




class projective(object):
    """<pre>

Projective (4 pt) image transformation using a sampled
(to nearest integer) transform on each dest point
PIX      *pixProjectiveSampledPta()
PIX      *pixProjectiveSampled()

Projective (4 pt) image transformation using interpolation
(or area mapping) for anti-aliasing images that are
2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
PIX      *pixProjectivePta()
PIX      *pixProjective()
PIX      *pixProjectivePtaColor()
PIX      *pixProjectiveColor()
PIX      *pixProjectivePtaGray()
PIX      *pixProjectiveGray()

Projective transform including alpha (blend) component
PIX      *pixProjectivePtaWithAlpha()

Projective coordinate transformation
l_int32   getProjectiveXformCoeffs()
l_int32   projectiveXformSampledPt()
l_int32   projectiveXformPt()

A projective transform can be specified as a specific functional
mapping between 4 points in the source and 4 points in the dest.
It preserves straight lines, but is less stable than a bilinear
transform, because it contains a division by a quantity that
can get arbitrarily small.)

We give both a projective coordinate transformation and
two projective image transformations.

For the former, we ask for the coordinate value (x',y')
in the transformed space for any point (x,y) in the original
space.  The coefficients of the transformation are found by
solving 8 simultaneous equations for the 8 coordinates of
the 4 points in src and dest.  The transformation can then
be used to compute the associated image transform, by
computing, for each dest pixel, the relevant pixel(s) in
the source.  This can be done either by taking the closest
src pixel to each transformed dest pixel ("sampling") or
by doing an interpolation and averaging over 4 source
pixels with appropriate weightings ("interpolated").

A typical application would be to remove keystoning
due to a projective transform in the imaging system.

The projective transform is given by specifying two equations:

x' = (ax + by + c) / (gx + hy + 1)
y' = (dx + ey + f) / (gx + hy + 1)

where the eight coefficients have been computed from four
sets of these equations, each for two corresponding data pts.
In practice, once the coefficients are known, we use the
equations "backwards": for each point (x,y) in the dest image,
these two equations are used to compute the corresponding point
(x',y') in the src.  That computed point in the src is then used
to determine the corresponding dest pixel value in one of two ways:

~ sampling: simply take the value of the src pixel in which this
point falls
~ interpolation: take appropriate linear combinations of the
four src pixels that this dest pixel would
overlap, with the coefficients proportional
to the amount of overlap

For small warp where there is little scale change, (e.g.,
for rotation) area mapping is nearly equivalent to interpolation.

Typical relative timing of pointwise transforms (sampled = 1.0):
8 bpp:   sampled        1.0
interpolated   1.5
32 bpp:  sampled        1.0
interpolated   1.6
Additionally, the computation time/pixel is nearly the same
for 8 bpp and 32 bpp, for both sampled and interpolated.
</pre>




"""
    
    try:
        leptonica.pixProjectiveSampledPta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjectiveSampledPta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectiveSampledPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveSampledPta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary.
(2) Retains colormap, which you can do for a sampled transform..
(3) No 3 of the 4 points may be collinear.
(4) For 8 and 32 bpp pix, better quality is obtained by the
somewhat slower pixProjectivePta().  See that
function for relative timings between sampled and interpolated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveSampledPta(*args)
    
    

    try:
        leptonica.pixProjectiveSampled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjectiveSampled.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectiveSampled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveSampled(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths
:param[in]    vc:        vector of 8 coefficients for projective transform
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary.
(2) Retains colormap, which you can do for a sampled transform..
(3) For 8 or 32 bpp, much better quality is obtained by the
somewhat slower pixProjective().  See that function
for relative timings between sampled and interpolated.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveSampled(*args)
    
    

    try:
        leptonica.pixProjectivePta.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjectivePta.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectivePta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePta(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths; colormap ok
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary
(2) Removes any existing colormap, if necessary, before transforming
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePta(*args)
    
    

    try:
        leptonica.pixProjective.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixProjective.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjective not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjective(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_int32', 'incolor')       

:param[in]    pixs:      all depths; colormap ok
:param[in]    vc:        vector of 8 coefficients for projective transform
:param[in]    incolor:   L_BRING_IN_WHITE, L_BRING_IN_BLACK
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) Brings in either black or white pixels from the boundary
(2) Removes any existing colormap, if necessary, before transforming
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjective(*args)
    
    

    try:
        leptonica.pixProjectivePtaColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixProjectivePtaColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectivePtaColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePtaColor(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint32', 'colorval')       

:param[in]    pixs: 32 bpp
:param[in]    ptad:  4 pts of final coordinate space
:param[in]    ptas:  4 pts of initial coordinate space
:param[in]    colorval: e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePtaColor(*args)
    
    

    try:
        leptonica.pixProjectiveColor.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_uint32]
        leptonica.pixProjectiveColor.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectiveColor not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveColor(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint32', 'colorval')       

:param[in]    pixs:       32 bpp
:param[in]    vc:         vector of 8 coefficients for projective transform
:param[in]    colorval:   e.g., 0 to bring in BLACK, 0xffffff00 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveColor(*args)
    
    

    try:
        leptonica.pixProjectivePtaGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixProjectivePtaGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectivePtaGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePtaGray(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('l_uint8', 'grayval')       

:param[in]    pixs:      8 bpp
:param[in]    ptad:      4 pts of final coordinate space
:param[in]    ptas:      4 pts of initial coordinate space
:param[in]    grayval:   0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePtaGray(*args)
    
    

    try:
        leptonica.pixProjectiveGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_ubyte]
        leptonica.pixProjectiveGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectiveGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectiveGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', '*vc')       
('l_uint8', 'grayval')       

:param[in]    pixs:      8 bpp
:param[in]    vc:        vector of 8 coefficients for projective transform
:param[in]    grayval:   0 to bring in BLACK, 255 for WHITE
:returns:  pixd, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectiveGray(*args)
    
    

    try:
        leptonica.pixProjectivePtaWithAlpha.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.pixProjectivePtaWithAlpha.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixProjectivePtaWithAlpha not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixProjectivePtaWithAlpha(*args):
        """
        ('PIX', '*pixs')       
('PTA', '*ptad')       
('PTA', '*ptas')       
('PIX', '*pixg')       
('l_float32', 'fract')       
('l_int32', 'border')       

:param[in]    pixs:     32 bpp rgb
:param[in]    ptad:     4 pts of final coordinate space
:param[in]    ptas:     4 pts of initial coordinate space
:param[in]    pixg:     [optional] 8 bpp, for alpha channel, can be null
:param[in]    fract:    between 0.0 and 1.0, with 0.0 fully transparent
and 1.0 fully opaque
:param[in]    border:   of pixels added to capture transformed source pixels
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The alpha channel is transformed separately from pixs,
and aligns with it, being fully transparent outside the
boundary of the transformed pixs.  For pixels that are fully
transparent, a blending function like pixBlendWithGrayMask()
will give zero weight to corresponding pixels in pixs.
(2) If pixg is NULL, it is generated as an alpha layer that is
partially opaque, using %fract.  Otherwise, it is cropped
to pixs if required and %fract is ignored.  The alpha channel
in pixs is never used.
(3) Colormaps are removed.
(4) When pixs is transformed, it doesn't matter what color is brought
in because the alpha channel will be transparent (0) there.
(5) To avoid losing source pixels in the destination, it may be
necessary to add a border to the source pix before doing
the projective transformation.  This can be any non-negative
number.
(6) The input %ptad and %ptas are in a coordinate space before
the border is added.  Internally, we compensate for this
before doing the projective transform on the image after
the border is added.
(7) The default setting for the border values in the alpha channel
is 0 (transparent) for the outermost ring of pixels and
(0.5 * fract * 255) for the second ring.  When blended over
a second image, this
(a) shrinks the visible image to make a clean overlap edge
with an image below, and
(b) softens the edges by weakening the aliasing there.
Use l_setAlphaMaskBorder() to change these values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixProjectivePtaWithAlpha(*args)
    
    

    try:
        leptonica.getProjectiveXformCoeffs.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.getProjectiveXformCoeffs.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function getProjectiveXformCoeffs not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getProjectiveXformCoeffs(*args):
        """
        ('PTA', '*ptas')       
('PTA', '*ptad')       
('l_float32', '**pvc')       

:param[in]    ptas:   source 4 points; unprimed
:param[in]    ptad:   transformed 4 points; primed
:param[out]   pvc:    vector of coefficients of transform
:returns:  0 if OK; 1 on error

We have a set of 8 equations, describing the projective
transformation that takes 4 points ptas into 4 other
points ptad.  These equations are:

x1' = c[0]*x1 + c[1]*y1 + c[2]) / (c[6]*x1 + c[7]*y1 + 1
y1' = c[3]*x1 + c[4]*y1 + c[5]) / (c[6]*x1 + c[7]*y1 + 1
x2' = c[0]*x2 + c[1]*y2 + c[2]) / (c[6]*x2 + c[7]*y2 + 1
y2' = c[3]*x2 + c[4]*y2 + c[5]) / (c[6]*x2 + c[7]*y2 + 1
x3' = c[0]*x3 + c[1]*y3 + c[2]) / (c[6]*x3 + c[7]*y3 + 1
y3' = c[3]*x3 + c[4]*y3 + c[5]) / (c[6]*x3 + c[7]*y3 + 1
x4' = c[0]*x4 + c[1]*y4 + c[2]) / (c[6]*x4 + c[7]*y4 + 1
y4' = c[3]*x4 + c[4]*y4 + c[5]) / (c[6]*x4 + c[7]*y4 + 1

Multiplying both sides of each eqn by the denominator, we get

AC = B

where B and C are column vectors

B = [ x1' y1' x2' y2' x3' y3' x4' y4' ]
C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] c[7] ]

and A is the 8x8 matrix

x1   y1     1     0   0    0   -x1*x1'  -y1*x1'
0    0     0    x1   y1   1   -x1*y1'  -y1*y1'
x2   y2     1     0   0    0   -x2*x2'  -y2*x2'
0    0     0    x2   y2   1   -x2*y2'  -y2*y2'
x3   y3     1     0   0    0   -x3*x3'  -y3*x3'
0    0     0    x3   y3   1   -x3*y3'  -y3*y3'
x4   y4     1     0   0    0   -x4*x4'  -y4*x4'
0    0     0    x4   y4   1   -x4*y4'  -y4*y4'

These eight equations are solved here for the coefficients C.

These eight coefficients can then be used to find the mapping
x,y) --> (x',y':

x' = c[0]x + c[1]y + c[2]) / (c[6]x + c[7]y + 1
y' = c[3]x + c[4]y + c[5]) / (c[6]x + c[7]y + 1

that is implemented in projectiveXformSampled and
projectiveXFormInterpolated.


        """
        args = _convert_params(*args)
        
        return leptonica.getProjectiveXformCoeffs(*args)
    
    

    try:
        leptonica.projectiveXformSampledPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.projectiveXformSampledPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function projectiveXformSampledPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def projectiveXformSampledPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pxp')       
('l_int32', '*pyp')       

:param[in]    vc:         vector of 8 coefficients
:param[in]    x,: y       initial point
:param[out]   pxp,: pyp   transformed point
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This finds the nearest pixel coordinates of the transformed point.
(2) It does not check ptrs for returned data!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.projectiveXformSampledPt(*args)
    
    

    try:
        leptonica.projectiveXformPt.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.projectiveXformPt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function projectiveXformPt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def projectiveXformPt(*args):
        """
        ('l_float32', '*vc')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pxp')       
('l_float32', '*pyp')       

:param[in]    vc:         vector of 8 coefficients
:param[in]    x,: y       initial point
:param[out]   pxp,: pyp   transformed point
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This computes the floating point location of the transformed point.
(2) It does not check ptrs for returned data!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.projectiveXformPt(*args)
    




class seedfill(object):
    """<pre>

Binary seedfill (source: Luc Vincent)
PIX         *pixSeedfillBinary()
PIX         *pixSeedfillBinaryRestricted()
static void  seedfillBinaryLow()

Applications of binary seedfill to find and fill holes,
remove c.c. touching the border and fill bg from border:
PIX         *pixHolesByFilling()
PIX         *pixFillClosedBorders()
PIX         *pixExtractBorderConnComps()
PIX         *pixRemoveBorderConnComps()
PIX         *pixFillBgFromBorder()

Hole-filling of components to bounding rectangle
PIX         *pixFillHolesToBoundingRect()

Gray seedfill (source: Luc Vincent:fast-hybrid-grayscale-reconstruction)
l_int32      pixSeedfillGray()
l_int32      pixSeedfillGrayInv()
static void  seedfillGrayLow()
static void  seedfillGrayInvLow()


Gray seedfill (source: Luc Vincent: sequential-reconstruction algorithm)
l_int32      pixSeedfillGraySimple()
l_int32      pixSeedfillGrayInvSimple()
static void  seedfillGrayLowSimple()
static void  seedfillGrayInvLowSimple()

Gray seedfill variations
PIX         *pixSeedfillGrayBasin()

Distance function (source: Luc Vincent)
PIX         *pixDistanceFunction()
static void  distanceFunctionLow()

Seed spread (based on distance function)
PIX         *pixSeedspread()
static void  seedspreadLow()

Local extrema:
l_int32      pixLocalExtrema()
static l_int32  pixQualifyLocalMinima()
l_int32      pixSelectedLocalExtrema()
PIX         *pixFindEqualValues()

Selection of minima in mask of connected components
PTA         *pixSelectMinInConnComp()

Removal of seeded connected components from a mask
PIX         *pixRemoveSeededComponents()


ITERATIVE RASTER-ORDER SEEDFILL

The basic method in the Vincent seedfill (aka reconstruction)
algorithm is simple.  We describe here the situation for
binary seedfill.  Pixels are sampled in raster order in
the seed image.  If they are 4-connected to ON pixels
either directly above or to the left, and are not masked
out by the mask image, they are turned on (or remain on).
(Ditto for 8-connected, except you need to check 3 pixels
on the previous line as well as the pixel to the left
on the current line.  This is extra computational work
for relatively little gain, so it is preferable
in most situations to use the 4-connected version.)
The algorithm proceeds from UR to LL of the image, and
then reverses and sweeps up from LL to UR.
These double sweeps are iterated until there is no change.
At this point, the seed has entirely filled the region it
is allowed to, as delimited by the mask image.

The grayscale seedfill is a straightforward generalization
of the binary seedfill, and is described in seedfillLowGray().

For some applications, the filled seed will later be OR'd
with the negative of the mask.   This is used, for example,
when you flood fill into a 4-connected region of OFF pixels
and you want the result after those pixels are turned ON.

Note carefully that the mask we use delineates which pixels
are allowed to be ON as the seed is filled.  We will call this
a "filling mask".  As the seed expands, it is repeatedly
ANDed with the filling mask: s & fm.  The process can equivalently
be formulated using the inverse of the filling mask, which
we will call a "blocking mask": bm = ~fm.   As the seed
expands, the blocking mask is repeatedly used to prevent
the seed from expanding into the blocking mask.  This is done
by set subtracting the blocking mask from the expanded seed:
s - bm.  Set subtraction of the blocking mask is equivalent
to ANDing with the inverse of the blocking mask: s & (~bm).
But from the inverse relation between blocking and filling
masks, this is equal to s & fm, which proves the equivalence.

For efficiency, the pixels can be taken in larger units
for processing, but still in raster order.  It is natural
to take them in 32-bit words.  The outline of the work
to be done for 4-cc (not including special cases for boundary
words, such as the first line or the last word in each line)
is as follows.  Let the filling mask be m.  The
seed is to fill "under" the mask; i.e., limited by an AND
with the mask.  Let the current word be w, the word
in the line above be wa, and the previous word in the
current line be wp.   Let t be a temporary word that
is used in computation.  Note that masking is performed by
w & m.  (If we had instead used a "blocking" mask, we
would perform masking by the set subtraction operation,
w - m, which is defined to be w & ~m.)

The entire operation can be implemented with shifts,
logical operations and tests.  For each word in the seed image
there are two steps.  The first step is to OR the word with
the word above and with the rightmost pixel in wp (call it "x").
Because wp is shifted one pixel to its right, "x" is ORed
to the leftmost pixel of w.  We then clip to the ON pixels in
the mask.  The result is
t  <--  (w | wa | x000... ) & m
We've now finished taking data from above and to the left.
The second step is to allow filling to propagate horizontally
in t, always making sure that it is properly masked at each
step.  So if filling can be done (i.e., t is neither all 0s
nor all 1s), iteratively take:
t  <--  (t | (t >> 1) | (t << 1)) & m
until t stops changing.  Then write t back into w.

Finally, the boundary conditions require we note that in doing
the above steps:
(a) The words in the first row have no wa
(b) The first word in each row has no wp in that row
(c) The last word in each row must be masked so that
pixels don't propagate beyond the right edge of the
actual image.  (This is easily accomplished by
setting the out-of-bound pixels in m to OFF.)
</pre>




"""
    
    try:
        leptonica.pixSeedfillBinary.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillBinary.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillBinary not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillBinary(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       

:param[in]    pixd:          [optional]; can be null, equal to pixs,
or different from pixs; 1 bpp
:param[in]    pixs:          1 bpp seed
:param[in]    pixm:          1 bpp filling mask
:param[in]    connectivity:  4 or 8
:returns:  pixd always

<pre>
Notes:
(1) This is for binary seedfill (aka "binary reconstruction").
(2) There are 3 cases:
(a) pixd == null (make a new pixd)
(b) pixd == pixs (in-place)
(c) pixd != pixs
(3) If you know the case, use these patterns for clarity:
(a) pixd = pixSeedfillBinary(NULL, pixs, ...);
(b) pixSeedfillBinary(pixs, pixs, ...);
(c) pixSeedfillBinary(pixd, pixs, ...);
(4) The resulting pixd contains the filled seed.  For some
applications you want to OR it with the inverse of
the filling mask.
(5) The input seed and mask images can be different sizes, but
in typical use the difference, if any, would be only
a few pixels in each direction.  If the sizes differ,
the clipping is handled by the low-level function
seedfillBinaryLow().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillBinary(*args)
    
    

    try:
        leptonica.pixSeedfillBinaryRestricted.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillBinaryRestricted.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillBinaryRestricted not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillBinaryRestricted(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
('l_int32', 'xmax')       
('l_int32', 'ymax')       

:param[in]    pixd:          [optional]; can be null, equal to pixs,
or different from pixs; 1 bpp
:param[in]    pixs:          1 bpp seed
:param[in]    pixm:          1 bpp filling mask
:param[in]    connectivity:  4 or 8
:param[in]    xmax:          max distance in x direction of fill into mask
:param[in]    ymax:          max distance in y direction of fill into mask
:returns:  pixd always

<pre>
Notes:
(1) See usage for pixSeedfillBinary(), which has unrestricted fill.
In pixSeedfillBinary(), the filling distance is unrestricted
and can be larger than pixs, depending on the topology of
th mask.
(2) There are occasions where it is useful not to permit the
fill to go more than a certain distance into the mask.
%xmax specifies the maximum horizontal distance allowed
in the fill; %ymax does likewise in the vertical direction.
(3) Operationally, the max "distance" allowed for the fill
is a linear distance from the original seed, independent
of the actual mask topology.
(4) Another formulation of this problem, not implemented,
would use the manhattan distance from the seed, as
determined by a breadth-first search starting at the seed
boundaries and working outward where the mask fg allows.
How this might use the constraints of separate xmax and ymax
is not clear.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillBinaryRestricted(*args)
    
    

    try:
        leptonica.pixHolesByFilling.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixHolesByFilling.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixHolesByFilling not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixHolesByFilling(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   4 or 8
:returns:  pixd  inverted image of all holes, or NULL on error

Action:
1 Start with 1-pixel black border on otherwise white pixd
2 Use the inverted pixs as the filling mask to fill in
all the pixels from the border to the pixs foreground
3 OR the result with pixs to have an image with all
ON pixels except for the holes.
4 Invert the result to get the holes as foreground

<pre>
Notes:
(1) To get 4-c.c. holes of the 8-c.c. as foreground, use
4-connected filling; to get 8-c.c. holes of the 4-c.c.
as foreground, use 8-connected filling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixHolesByFilling(*args)
    
    

    try:
        leptonica.pixFillClosedBorders.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFillClosedBorders.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFillClosedBorders not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillClosedBorders(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   filling connectivity 4 or 8
:returns:  pixd  all topologically outer closed borders are filled
as connected comonents, or NULL on error

<pre>
Notes:
(1) Start with 1-pixel black border on otherwise white pixd
(2) Subtract input pixs to remove border pixels that were
also on the closed border
(3) Use the inverted pixs as the filling mask to fill in
all the pixels from the outer border to the closed border
on pixs
(4) Invert the result to get the filled component, including
the input border
(5) If the borders are 4-c.c., use 8-c.c. filling, and v.v.
(6) Closed borders within c.c. that represent holes, etc., are filled.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillClosedBorders(*args)
    
    

    try:
        leptonica.pixExtractBorderConnComps.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixExtractBorderConnComps.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixExtractBorderConnComps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixExtractBorderConnComps(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   filling connectivity 4 or 8
:returns:  pixd  all pixels in the src that are in connected
components touching the border, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixExtractBorderConnComps(*args)
    
    

    try:
        leptonica.pixRemoveBorderConnComps.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixRemoveBorderConnComps.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveBorderConnComps not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveBorderConnComps(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   filling connectivity 4 or 8
:returns:  pixd  all pixels in the src that are not touching the
border or NULL on error

<pre>
Notes:
(1) This removes all fg components touching the border.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveBorderConnComps(*args)
    
    

    try:
        leptonica.pixFillBgFromBorder.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixFillBgFromBorder.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFillBgFromBorder not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillBgFromBorder(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   filling connectivity 4 or 8
:returns:  pixd with the background c.c. touching the border
filled to foreground, or NULL on error

<pre>
Notes:
(1) This fills all bg components touching the border to fg.
It is the photometric inverse of pixRemoveBorderConnComps().
(2) Invert the result to get the "holes" left after this fill.
This can be done multiple times, extracting holes within
holes after each pair of fillings.  Specifically, this code
peels away n successive embeddings of components:
\code
pix1 = <initial image>
for (i = 0; i < 2 * n; i++) {
pix2 = pixFillBgFromBorder(pix1, 8);
pixInvert(pix2, pix2);
pixDestroy(&pix1);
pix1 = pix2;
}
\endcode
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillBgFromBorder(*args)
    
    

    try:
        leptonica.pixFillHolesToBoundingRect.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.pixFillHolesToBoundingRect.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFillHolesToBoundingRect not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFillHolesToBoundingRect(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minsize')       
('l_float32', 'maxhfract')       
('l_float32', 'minfgfract')       

:param[in]    pixs:         1 bpp
:param[in]    minsize:      min number of pixels in the hole
:param[in]    maxhfract:    max hole area as fraction of fg pixels in the cc
:param[in]    minfgfract:   min fg area as fraction of bounding rectangle
:returns:  pixd   with some holes possibly filled and some c.c. possibly
expanded to their bounding rects, or NULL on error

<pre>
Notes:
(1) This does not fill holes that are smaller in area than 'minsize'.
(2) This does not fill holes with an area larger than
'maxhfract' times the fg area of the c.c.
(3) This does not expand the fg of the c.c. to bounding rect if
the fg area is less than 'minfgfract' times the area of the
bounding rect.
(4) The decisions are made as follows:
~ Decide if we are filling the holes; if so, when using
the fg area, include the filled holes.
~ Decide based on the fg area if we are filling to a bounding rect.
If so, do it.
If not, fill the holes if the condition is satisfied.
(5) The choice of minsize depends on the resolution.
(6) For solidifying image mask regions on printed materials,
which tend to be rectangular, values for maxhfract
and minfgfract around 0.5 are reasonable.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFillHolesToBoundingRect(*args)
    
    

    try:
        leptonica.pixSeedfillGray.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGray.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGray(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       

:param[in]    pixs:           8 bpp seed; filled in place
:param[in]    pixm:           8 bpp filling mask
:param[in]    connectivity:   4 or 8
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place filling operation on the seed, pixs,
where the clipping mask is always above or at the level
of the seed as it is filled.
(2) For details of the operation, see the description in
seedfillGrayLow() and the code there.
(3) As an example of use, see the description in pixHDome().
There, the seed is an image where each pixel is a fixed
amount smaller than the corresponding mask pixel.
(4) Reference paper :
L. Vincent, Morphological grayscale reconstruction in image
analysis: applications and efficient algorithms, IEEE Transactions
on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGray(*args)
    
    

    try:
        leptonica.pixSeedfillGrayInv.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGrayInv.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillGrayInv not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGrayInv(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       

:param[in]    pixs:           8 bpp seed; filled in place
:param[in]    pixm:           8 bpp filling mask
:param[in]    connectivity:   4 or 8
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place filling operation on the seed, pixs,
where the clipping mask is always below or at the level
of the seed as it is filled.  Think of filling up a basin
to a particular level, given by the maximum seed value
in the basin.  Outside the filled region, the mask
is above the filling level.
(2) Contrast this with pixSeedfillGray(), where the clipping mask
is always above or at the level of the fill.  An example
of its use is the hdome fill, where the seed is an image
where each pixel is a fixed amount smaller than the
corresponding mask pixel.
(3) The basin fill, pixSeedfillGrayBasin(), is a special case
where the seed pixel values are generated from the mask,
and where the implementation uses pixSeedfillGray() by
inverting both the seed and mask.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGrayInv(*args)
    
    

    try:
        leptonica.pixSeedfillGraySimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGraySimple.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillGraySimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGraySimple(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       

:param[in]    pixs:           8 bpp seed; filled in place
:param[in]    pixm:           8 bpp filling mask
:param[in]    connectivity:   4 or 8
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place filling operation on the seed, pixs,
where the clipping mask is always above or at the level
of the seed as it is filled.
(2) For details of the operation, see the description in
seedfillGrayLowSimple() and the code there.
(3) As an example of use, see the description in pixHDome().
There, the seed is an image where each pixel is a fixed
amount smaller than the corresponding mask pixel.
(4) Reference paper :
L. Vincent, Morphological grayscale reconstruction in image
analysis: applications and efficient algorithms, IEEE Transactions
on  Image Processing, vol. 2, no. 2, pp. 176-201, 1993.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGraySimple(*args)
    
    

    try:
        leptonica.pixSeedfillGrayInvSimple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedfillGrayInvSimple.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillGrayInvSimple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGrayInvSimple(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       

:param[in]    pixs:           8 bpp seed; filled in place
:param[in]    pixm:           8 bpp filling mask
:param[in]    connectivity:   4 or 8
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is an in-place filling operation on the seed, pixs,
where the clipping mask is always below or at the level
of the seed as it is filled.  Think of filling up a basin
to a particular level, given by the maximum seed value
in the basin.  Outside the filled region, the mask
is above the filling level.
(2) Contrast this with pixSeedfillGraySimple(), where the clipping mask
is always above or at the level of the fill.  An example
of its use is the hdome fill, where the seed is an image
where each pixel is a fixed amount smaller than the
corresponding mask pixel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGrayInvSimple(*args)
    
    

    try:
        leptonica.pixSeedfillGrayBasin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSeedfillGrayBasin.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedfillGrayBasin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedfillGrayBasin(*args):
        """
        ('PIX', '*pixb')       
('PIX', '*pixm')       
('l_int32', 'delta')       
('l_int32', 'connectivity')       

:param[in]    pixb:           binary mask giving seed locations
:param[in]    pixm:           8 bpp basin-type filling mask
:param[in]    delta:          amount of seed value above mask
:param[in]    connectivity:   4 or 8
:returns:  pixd filled seed if OK, NULL on error

<pre>
Notes:
(1) This fills from a seed within basins defined by a filling mask.
The seed value(s) are greater than the corresponding
filling mask value, and the result has the bottoms of
the basins raised by the initial seed value.
(2) The seed has value 255 except where pixb has fg (1), which
are the seed 'locations'.  At the seed locations, the seed
value is the corresponding value of the mask pixel in pixm
plus %delta.  If %delta == 0, we return a copy of pixm.
(3) The actual filling is done using the standard grayscale filling
operation on the inverse of the mask and using the inverse
of the seed image.  After filling, we return the inverse of
the filled seed.
(4) As an example of use: pixm can describe a grayscale image
of text, where the (dark) text pixels are basins of
low values; pixb can identify the local minima in pixm (say, at
the bottom of the basins); and delta is the amount that we wish
to raise (lighten) the basins.  We construct the seed
(a.k.a marker) image from pixb, pixm and %delta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedfillGrayBasin(*args)
    
    

    try:
        leptonica.pixDistanceFunction.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixDistanceFunction.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixDistanceFunction not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixDistanceFunction(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       
('l_int32', 'outdepth')       
('l_int32', 'boundcond')       

:param[in]    pixs:           1 bpp
:param[in]    connectivity:   4 or 8
:param[in]    outdepth:       8 or 16 bits for pixd
:param[in]    boundcond:      L_BOUNDARY_BG, L_BOUNDARY_FG
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This computes the distance of each pixel from the nearest
background pixel.  All bg pixels therefore have a distance of 0,
and the fg pixel distances increase linearly from 1 at the
boundary.  It can also be used to compute the distance of
each pixel from the nearest fg pixel, by inverting the input
image before calling this function.  Then all fg pixels have
a distance 0 and the bg pixel distances increase linearly
from 1 at the boundary.
(2) The algorithm, described in Leptonica on the page on seed
filling and connected components, is due to Luc Vincent.
In brief, we generate an 8 or 16 bpp image, initialized
with the fg pixels of the input pix set to 1 and the
1-boundary pixels (i.e., the boundary pixels of width 1 on
the four sides set as either:
L_BOUNDARY_BG: 0
L_BOUNDARY_FG:  max
where max = 0xff for 8 bpp and 0xffff for 16 bpp.
Then do raster/anti-raster sweeps over all pixels interior
to the 1-boundary, where the value of each new pixel is
taken to be 1 more than the minimum of the previously-seen
connected pixels (using either 4 or 8 connectivity).
Finally, set the 1-boundary pixels using the mirrored method;
this removes the max values there.
(3) Using L_BOUNDARY_BG clamps the distance to 0 at the
boundary.  Using L_BOUNDARY_FG allows the distance
at the image boundary to "float".
(4) For 4-connected, one could initialize only the left and top
1-boundary pixels, and go all the way to the right
and bottom; then coming back reset left and top.  But we
instead use a method that works for both 4- and 8-connected.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixDistanceFunction(*args)
    
    

    try:
        leptonica.pixSeedspread.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixSeedspread.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSeedspread not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSeedspread(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connectivity')       

:param[in]    pixs:           8 bpp
:param[in]    connectivity:   4 or 8
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) The raster/anti-raster method for implementing this filling
operation was suggested by Ray Smith.
(2) This takes an arbitrary set of nonzero pixels in pixs, which
can be sparse, and spreads (extrapolates) the values to
fill all the pixels in pixd with the nonzero value it is
closest to in pixs.  This is similar (though not completely
equivalent) to doing a Voronoi tiling of the image, with a
tile surrounding each pixel that has a nonzero value.
All pixels within a tile are then closer to its "central"
pixel than to any others.  Then assign the value of the
"central" pixel to each pixel in the tile.
(3) This is implemented by computing a distance function in parallel
with the fill.  The distance function uses free boundary
conditions (assumed maxval outside), and it controls the
propagation of the pixels in pixd away from the nonzero
(seed) values.  This is done in 2 traversals (raster/antiraster).
In the raster direction, whenever the distance function
is nonzero, the spread pixel takes on the value of its
predecessor that has the minimum distance value.  In the
antiraster direction, whenever the distance function is nonzero
and its value is replaced by a smaller value, the spread
pixel takes the value of the predecessor with the minimum
distance value.
(4) At boundaries where a pixel is equidistant from two
nearest nonzero (seed) pixels, the decision of which value
to use is arbitrary (greedy in search for minimum distance).
This can give rise to strange-looking results, particularly
for 4-connectivity where the L1 distance is computed from
steps in N,S,E and W directions (no diagonals).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSeedspread(*args)
    
    

    try:
        leptonica.pixLocalExtrema.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixLocalExtrema.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixLocalExtrema not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLocalExtrema(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'maxmin')       
('l_int32', 'minmax')       
('PIX', '**ppixmin')       
('PIX', '**ppixmax')       

:param[in]    pixs:       8 bpp
:param[in]    maxmin:     max allowed for the min in a 3x3 neighborhood;
use 0 for default which is to have no upper bound
:param[in]    minmax:     min allowed for the max in a 3x3 neighborhood;
use 0 for default which is to have no lower bound
:param[out]   ppixmin:    [optional] mask of local minima
:param[out]   ppixmax:    [optional] mask of local maxima
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This gives the actual local minima and maxima.
A local minimum is a pixel whose surrounding pixels all
have values at least as large, and likewise for a local
maximum.  For the local minima, %maxmin is the upper
bound for the value of pixs.  Likewise, for the local maxima,
%minmax is the lower bound for the value of pixs.
(2) The minima are found by starting with the erosion-and-equality
approach of pixSelectedLocalExtrema().  This is followed
by a qualification step, where each c.c. in the resulting
minimum mask is extracted, the pixels bordering it are
located, and they are queried.  If all of those pixels
are larger than the value of that minimum, it is a true
minimum and its c.c. is saved; otherwise the c.c. is
rejected.  Note that if a bordering pixel has the
same value as the minimum, it must then have a
neighbor that is smaller, so the component is not a
true minimum.
(3) The maxima are found by inverting the image and looking
for the minima there.
(4) The generated masks can be used as markers for
further operations.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixLocalExtrema(*args)
    
    

    try:
        leptonica.pixSelectedLocalExtrema.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSelectedLocalExtrema.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectedLocalExtrema not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectedLocalExtrema(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'mindist')       
('PIX', '**ppixmin')       
('PIX', '**ppixmax')       

:param[in]    pixs:       8 bpp
:param[in]    mindist:    -1 for keeping all pixels; >= 0 specifies distance
:param[out]   ppixmin:    mask of local minima
:param[out]   ppixmax:    mask of local maxima
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This selects those local 3x3 minima that are at least a
specified distance from the nearest local 3x3 maxima, and v.v.
for the selected set of local 3x3 maxima.
The local 3x3 minima is the set of pixels whose value equals
the value after a 3x3 brick erosion, and the local 3x3 maxima
is the set of pixels whose value equals the value after
a 3x3 brick dilation.
(2) mindist is the minimum distance allowed between
local 3x3 minima and local 3x3 maxima, in an 8-connected sense.
mindist == 1 keeps all pixels found in step 1.
mindist == 0 removes all pixels from each mask that are
both a local 3x3 minimum and a local 3x3 maximum.
mindist == 1 removes any local 3x3 minimum pixel that touches a
local 3x3 maximum pixel, and likewise for the local maxima.
To make the decision, visualize each local 3x3 minimum pixel
as being surrounded by a square of size (2 * mindist + 1)
on each side, such that no local 3x3 maximum pixel is within
that square; and v.v.
(3) The generated masks can be used as markers for further operations.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectedLocalExtrema(*args)
    
    

    try:
        leptonica.pixFindEqualValues.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindEqualValues.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixFindEqualValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindEqualValues(*args):
        """
        ('PIX', '*pixs1')       
('PIX', '*pixs2')       

:param[in]    pixs1:    8 bpp
:param[in]    pixs2:    8 bpp
:returns:  pixd 1 bpp mask, or NULL on error

<pre>
Notes:
(1) The two images are aligned at the UL corner, and the returned
image has ON pixels where the pixels in pixs1 and pixs2
have equal values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindEqualValues(*args)
    
    

    try:
        leptonica.pixSelectMinInConnComp.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixSelectMinInConnComp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixSelectMinInConnComp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSelectMinInConnComp(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixm')       
('PTA', '**ppta')       
('NUMA', '**pnav')       

:param[in]    pixs:    8 bpp
:param[in]    pixm:    1 bpp
:param[out]   ppta:    pta of min pixel locations
:param[out]   pnav:    [optional] numa of minima values
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) For each 8 connected component in pixm, this finds
a pixel in pixs that has the lowest value, and saves
it in a Pta.  If several pixels in pixs have the same
minimum value, it picks the first one found.
(2) For a mask pixm of true local minima, all pixels in each
connected component have the same value in pixs, so it is
fastest to select one of them using a special seedfill
operation.  Not yet implemented.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSelectMinInConnComp(*args)
    
    

    try:
        leptonica.pixRemoveSeededComponents.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixRemoveSeededComponents.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixRemoveSeededComponents not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixRemoveSeededComponents(*args):
        """
        ('PIX', '*pixd')       
('PIX', '*pixs')       
('PIX', '*pixm')       
('l_int32', 'connectivity')       
('l_int32', 'bordersize')       

:param[in]    pixd:          [optional]; can be null or equal to pixm; 1 bpp
:param[in]    pixs:          1 bpp seed
:param[in]    pixm:          1 bpp filling mask
:param[in]    connectivity:  4 or 8
:param[in]    bordersize:    amount of border clearing
:returns:  pixd, or NULL on error

<pre>
Notes:
(1) This removes each component in pixm for which there is
at least one seed in pixs.  If pixd == NULL, this returns
the result in a new pixd.  Otherwise, it is an in-place
operation on pixm.  In no situation is pixs altered,
because we do the filling with a copy of pixs.
(2) If bordersize > 0, it also clears all pixels within a
distance %bordersize of the edge of pixd.  This is here
because pixLocalExtrema() typically finds local minima
at the border.  Use %bordersize >= 2 to remove these.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixRemoveSeededComponents(*args)
    




class classapp(object):
    """<pre>

Top-level jb2 correlation and rank-hausdorff
l_int32         jbCorrelation()
l_int32         jbRankHaus()

Extract and classify words in textline order
JBCLASSER      *jbWordsInTextlines()
l_int32         pixGetWordsInTextlines()
l_int32         pixGetWordBoxesInTextlines()

Extract word and character bounding boxes
l_int32         pixFindWordAndCharacterBoxes()

Use word bounding boxes to compare page images
NUMAA          *boxaExtractSortedPattern()
l_int32         numaaCompareImagesByBoxes()
static l_int32  testLineAlignmentX()
static l_int32  countAlignedMatches()
static void     printRowIndices()
</pre>




"""
    
    try:
        leptonica.jbCorrelation.argtypes = [ctypes.c_char_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.jbCorrelation.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbCorrelation not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbCorrelation(*args):
        """
        ('const char', '*dirin')       
('l_float32', 'thresh')       
('l_float32', 'weight')       
('l_int32', 'components')       
('const char', '*rootname')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
('l_int32', 'renderflag')       

:param[in]    dirin:        directory of input images
:param[in]    thresh:       typically ~0.8
:param[in]    weight:       typically ~0.6
:param[in]    components:   JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:param[in]    rootname:     for output files
:param[in]    firstpage:    0-based
:param[in]    npages:       use 0 for all pages in dirin
:param[in]    renderflag:   1 to render from templates; 0 to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The images must be 1 bpp.  If they are not, you can convert
them using convertFilesTo1bpp().
(2) See prog/jbcorrelation for generating more output (e.g.,
for debugging)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbCorrelation(*args)
    
    

    try:
        leptonica.jbRankHaus.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.jbRankHaus.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function jbRankHaus not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbRankHaus(*args):
        """
        ('const char', '*dirin')       
('l_int32', 'size')       
('l_float32', 'rank')       
('l_int32', 'components')       
('const char', '*rootname')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       
('l_int32', 'renderflag')       

:param[in]    dirin:         directory of input images
:param[in]    size:          of Sel used for dilation; typ. 2
:param[in]    rank:          rank value of match; typ. 0.97
:param[in]    components:    JB_CONN_COMPS, JB_CHARACTERS, JB_WORDS
:param[in]    rootname:      for output files
:param[in]    firstpage:     0-based
:param[in]    npages:        use 0 for all pages in dirin
:param[in]    renderflag:    1 to render from templates; 0 to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See prog/jbrankhaus for generating more output (e.g.,
for debugging)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbRankHaus(*args)
    
    

    try:
        leptonica.jbWordsInTextlines.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.jbWordsInTextlines.restype = lambda address: JBCLASSER(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function jbWordsInTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def jbWordsInTextlines(*args):
        """
        ('const char', '*dirin')       
('l_int32', 'reduction')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('l_float32', 'thresh')       
('l_float32', 'weight')       
('NUMA', '**pnatl')       
('l_int32', 'firstpage')       
('l_int32', 'npages')       

:param[in]    dirin:       directory of input pages
:param[in]    reduction:   1 for full res; 2 for half-res
:param[in]    maxwidth:    of word mask components, to be kept
:param[in]    maxheight:   of word mask components, to be kept
:param[in]    thresh:      on correlation; 0.80 is reasonable
:param[in]    weight:      for handling thick text; 0.6 is reasonable
:param[out]   pnatl:       numa with textline index for each component
:param[in]    firstpage:   0-based
:param[in]    npages:      use 0 for all pages in dirin
:returns:  classer for the set of pages

<pre>
Notes:
(1) This is a high-level function.  See prog/jbwords for example
of usage.
(2) Typically, use input of 75 - 150 ppi for finding words.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.jbWordsInTextlines(*args)
    
    

    try:
        leptonica.pixGetWordsInTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetWordsInTextlines.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetWordsInTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetWordsInTextlines(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minwidth')       
('l_int32', 'minheight')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxad')       
('PIXA', '**ppixad')       
('NUMA', '**pnai')       

:param[in]    pixs:        1 bpp, typ. 75 - 150 ppi
:param[in]    minwidth:    of saved components; smaller are discarded
:param[in]    minheight:   of saved components; smaller are discarded
:param[in]    maxwidth:    of saved components; larger are discarded
:param[in]    maxheight:   of saved components; larger are discarded
:param[out]   pboxad:      word boxes sorted in textline line order
:param[out]   ppixad:      word images sorted in textline line order
:param[out]   pnai:        index of textline for each word
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The input should be at a resolution of between 75 and 150 ppi.
(2) The four size constraints on saved components are all
scaled by %reduction.
(3) The result are word images (and their b.b.), extracted in
textline order, at either full res or 2x reduction,
and with a numa giving the textline index for each word.
(4) The pixa and boxa interfaces should make this type of
application simple to put together.  The steps are:
~ generate first estimate of word masks
~ get b.b. of these, and remove the small and big ones
~ extract pixa of the word images, using the b.b.
~ sort actual word images in textline order (2d)
~ flatten them to a pixa (1d), saving the textline index
for each pix
(5) In an actual application, it may be desirable to pre-filter
the input image to remove large components, to extract
single columns of text, and to deskew them.  For example,
to remove both large components and small noisy components
that can interfere with the statistics used to estimate
parameters for segmenting by words, but still retain text lines,
the following image preprocessing can be done:
Pix *pixt = pixMorphSequence(pixs, "c40.1", 0);
Pix *pixf = pixSelectBySize(pixt, 0, 60, 8,
L_SELECT_HEIGHT, L_SELECT_IF_LT, NULL);
pixAnd(pixf, pixf, pixs);  // the filtered image
The closing turns text lines into long blobs, but does not
significantly increase their height.  But if there are many
small connected components in a dense texture, this is likely
to generate tall components that will be eliminated in pixf.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetWordsInTextlines(*args)
    
    

    try:
        leptonica.pixGetWordBoxesInTextlines.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetWordBoxesInTextlines.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetWordBoxesInTextlines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetWordBoxesInTextlines(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'minwidth')       
('l_int32', 'minheight')       
('l_int32', 'maxwidth')       
('l_int32', 'maxheight')       
('BOXA', '**pboxad')       
('NUMA', '**pnai')       

:param[in]    pixs:        1 bpp, typ. 75 - 150 ppi
:param[in]    minwidth:    of saved components; smaller are discarded
:param[in]    minheight:   of saved components; smaller are discarded
:param[in]    maxwidth:    of saved components; larger are discarded
:param[in]    maxheight:   of saved components; larger are discarded
:param[out]   pboxad:      word boxes sorted in textline line order
:param[out]   pnai:        [optional] index of textline for each word
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The input should be at a resolution of between 75 and 150 ppi.
(2) This is a special version of pixGetWordsInTextlines(), that
just finds the word boxes in line order, with a numa
giving the textline index for each word.
See pixGetWordsInTextlines() for more details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetWordBoxesInTextlines(*args)
    
    

    try:
        leptonica.pixFindWordAndCharacterBoxes.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.pixFindWordAndCharacterBoxes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindWordAndCharacterBoxes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindWordAndCharacterBoxes(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*boxs')       
('l_int32', 'thresh')       
('BOXA', '**pboxaw')       
('BOXAA', '**pboxaac')       
('const char', '*debugdir')       

:param[in]    pixs:        2, 4, 8 or 32 bpp; colormap OK; typ. 300 ppi
:param[in]    boxs:        [optional] region to select in pixs
:param[in]    thresh:      binarization threshold (typ. 100 - 150)
:param[out]   pboxaw:      return the word boxes
:param[out]   pboxaac:     return the character boxes
:param[in]    debugdir:    [optional] for debug images; use NULL to skip
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %boxs == NULL, the entire input image is used.
(2) Having an input pix that is not 1bpp is necessary to reduce
touching characters by using a low binarization threshold.
Suggested thresholds are between 100 and 150.
(3) The coordinates in the output boxes are global, with respect
to the input image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindWordAndCharacterBoxes(*args)
    
    

    try:
        leptonica.boxaExtractSortedPattern.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.boxaExtractSortedPattern.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaExtractSortedPattern not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaExtractSortedPattern(*args):
        """
        ('BOXA', '*boxa')       
('NUMA', '*na')       

:param[in]    boxa:    typ. of word bounding boxes, in textline order
:param[in]    na:      index of textline for each box in boxa
:returns:  naa NUMAA, where each numa represents one textline,
or NULL on error

<pre>
Notes:
(1) The input is expected to come from pixGetWordBoxesInTextlines().
(2) Each numa in the output consists of an average y coordinate
of the first box in the textline, followed by pairs of
x coordinates representing the left and right edges of each
of the boxes in the textline.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaExtractSortedPattern(*args)
    
    

    try:
        leptonica.numaaCompareImagesByBoxes.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaaCompareImagesByBoxes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaCompareImagesByBoxes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaCompareImagesByBoxes(*args):
        """
        ('NUMAA', '*naa1')       
('NUMAA', '*naa2')       
('l_int32', 'nperline')       
('l_int32', 'nreq')       
('l_int32', 'maxshiftx')       
('l_int32', 'maxshifty')       
('l_int32', 'delx')       
('l_int32', 'dely')       
('l_int32', '*psame')       
('l_int32', 'debugflag')       

:param[in]    naa1:       for image 1, formatted by boxaExtractSortedPattern()
:param[in]    naa2:       for image 2, formatted by boxaExtractSortedPattern()
:param[in]    nperline:   number of box regions to be used in each textline
:param[in]    nreq:       number of complete row matches required
:param[in]    maxshiftx:  max allowed x shift between two patterns, in pixels
:param[in]    maxshifty:  max allowed y shift between two patterns, in pixels
:param[in]    delx:       max allowed difference in x data, after alignment
:param[in]    dely:       max allowed difference in y data, after alignment
:param[out]   psame:      1 if %nreq row matches are found; 0 otherwise
:param[in]    debugflag:  1 for debug output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Each input numaa describes a set of sorted bounding boxes
(sorted by textline and, within each textline, from
left to right) in the images from which they are derived.
See boxaExtractSortedPattern() for a description of the data
format in each of the input numaa.
(2) This function does an alignment between the input
descriptions of bounding boxes for two images. The
input parameter %nperline specifies the number of boxes
to consider in each line when testing for a match, and
%nreq is the required number of lines that must be well-aligned
to get a match.
(3) Testing by alignment has 3 steps:
(a) Generating the location of word bounding boxes from the
images (prior to calling this function).
(b) Listing all possible pairs of aligned rows, based on
tolerances in horizontal and vertical positions of
the boxes.  Specifically, all pairs of rows are enumerated
whose first %nperline boxes can be brought into close
alignment, based on the delx parameter for boxes in the
line and within the overall the %maxshiftx and %maxshifty
constraints.
(c) Each pair, starting with the first, is used to search
for a set of %nreq - 1 other pairs that can all be aligned
with a difference in global translation of not more
than (%delx, %dely).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaCompareImagesByBoxes(*args)
    




class numabasic(object):
    """<pre>

Numa creation, destruction, copy, clone, etc.
NUMA        *numaCreate()
NUMA        *numaCreateFromIArray()
NUMA        *numaCreateFromFArray()
NUMA        *numaCreateFromString()
void        *numaDestroy()
NUMA        *numaCopy()
NUMA        *numaClone()
l_int32      numaEmpty()

Add/remove number (float or integer)
l_int32      numaAddNumber()
static l_int32  numaExtendArray()
l_int32      numaInsertNumber()
l_int32      numaRemoveNumber()
l_int32      numaReplaceNumber()

Numa accessors
l_int32      numaGetCount()
l_int32      numaSetCount()
l_int32      numaGetIValue()
l_int32      numaGetFValue()
l_int32      numaSetValue()
l_int32      numaShiftValue()
l_int32     *numaGetIArray()
l_float32   *numaGetFArray()
l_int32      numaGetRefcount()
l_int32      numaChangeRefcount()
l_int32      numaGetParameters()
l_int32      numaSetParameters()
l_int32      numaCopyParameters()

Convert to string array
SARRAY      *numaConvertToSarray()

Serialize numa for I/O
NUMA        *numaRead()
NUMA        *numaReadStream()
NUMA        *numaReadMem()
l_int32      numaWriteDebug()
l_int32      numaWrite()
l_int32      numaWriteStream()
l_int32      numaWriteStderr()
l_int32      numaWriteMem()

Numaa creation, destruction, truncation
NUMAA       *numaaCreate()
NUMAA       *numaaCreateFull()
NUMAA       *numaaTruncate()
void        *numaaDestroy()

Add Numa to Numaa
l_int32      numaaAddNuma()
static l_int32   numaaExtendArray()

Numaa accessors
l_int32      numaaGetCount()
l_int32      numaaGetNumaCount()
l_int32      numaaGetNumberCount()
NUMA       **numaaGetPtrArray()
NUMA        *numaaGetNuma()
NUMA        *numaaReplaceNuma()
l_int32      numaaGetValue()
l_int32      numaaAddNumber()

Serialize numaa for I/O
NUMAA       *numaaRead()
NUMAA       *numaaReadStream()
NUMAA       *numaaReadMem()
l_int32      numaaWrite()
l_int32      numaaWriteStream()
l_int32      numaaWriteMem()

(1) The Numa is a struct holding an array of floats.  It can also
be used to store l_int32 values, with some loss of precision
for floats larger than about 10 million.  Use the L_Dna instead
if integers larger than a few million need to be stored.

(2) Always use the accessors in this file, never the fields directly.

(3) Storing and retrieving numbers:

to append a new number to the array, use numaAddNumber().  If
the number is an int, it will will automatically be converted
to l_float32 and stored.

to reset a value stored in the array, use numaSetValue().

to increment or decrement a value stored in the array,
use numaShiftValue().

to obtain a value from the array, use either numaGetIValue()
or numaGetFValue(), depending on whether you are retrieving
an integer or a float.  This avoids doing an explicit cast,
such as
(a) return a l_float32 and cast it to an l_int32
(b) cast the return directly to (l_float32 *) to
satisfy the function prototype, as in
numaGetFValue(na, index, (l_float32 *)&ival);   [ugly!]

(4) int <--> float conversions:

Tradition dictates that type conversions go automatically from
l_int32 --> l_float32, even though it is possible to lose
precision for large integers, whereas you must cast (l_int32)
to go from l_float32 --> l_int32 because you're truncating
to the integer value.

(5) As with other arrays in leptonica, the numa has both an allocated
size and a count of the stored numbers.  When you add a number, it
goes on the end of the array, and causes a realloc if the array
is already filled.  However, in situations where you want to
add numbers randomly into an array, such as when you build a
histogram, you must set the count of stored numbers in advance.
This is done with numaSetCount().  If you set a count larger
than the allocated array, it does a realloc to the size requested.

(6) In situations where the data in a numa correspond to a function
y(x), the values can be either at equal spacings in x or at
arbitrary spacings.  For the former, we can represent all x values
by two parameters: startx (corresponding to y[0]) and delx
for the change in x for adjacent values y[i] and y[i+1].
startx and delx are initialized to 0.0 and 1.0, rsp.
For arbitrary spacings, we use a second numa, and the two
numas are typically denoted nay and nax.

(7) The numa is also the basic struct used for histograms.  Every numa
has startx and delx fields, initialized to 0.0 and 1.0, that can
be used to represent the "x" value for the location of the
first bin and the bin width, respectively.  Accessors are the
numa*Parameters() functions.  All functions that make numa
histograms must set these fields properly, and many functions
that use numa histograms rely on the correctness of these values.
</pre>




"""
    
    try:
        leptonica.numaCreate.argtypes = [ctypes.c_int32]
        leptonica.numaCreate.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    size of number array to be alloc'd 0 for default
:returns:  na, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreate(*args)
    
    

    try:
        leptonica.numaCreateFromIArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaCreateFromIArray.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCreateFromIArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreateFromIArray(*args):
        """
        ('l_int32', '*iarray')       
('l_int32', 'size')       

:param[in]    iarray:    integer array
:param[in]    size:      of the array
:returns:  na, or NULL on error

<pre>
Notes:
(1) We can't insert this int array into the numa, because a numa
takes a float array.  So this just copies the data from the
input array into the numa.  The input array continues to be
owned by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreateFromIArray(*args)
    
    

    try:
        leptonica.numaCreateFromFArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaCreateFromFArray.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCreateFromFArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreateFromFArray(*args):
        """
        ('l_float32', '*farray')       
('l_int32', 'size')       
('l_int32', 'copyflag')       

:param[in]    farray:     float array
:param[in]    size:       of the array
:param[in]    copyflag:   L_INSERT or L_COPY
:returns:  na, or NULL on error

<pre>
Notes:
(1) With L_INSERT, ownership of the input array is transferred
to the returned numa, and all %size elements are considered
to be valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreateFromFArray(*args)
    
    

    try:
        leptonica.numaCreateFromString.argtypes = [ctypes.c_char_p]
        leptonica.numaCreateFromString.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCreateFromString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCreateFromString(*args):
        """
        ('const char', '*str')       

:param[in]    str:    string of comma-separated numbers
:returns:  na, or NULL on error

<pre>
Notes:
(1) The numbers can be ints or floats; they will be interpreted
and stored as floats.  To use them as integers (e.g., for
indexing into arrays), use numaGetIValue(...).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaCreateFromString(*args)
    
    

    try:
        leptonica.numaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.numaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function numaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaDestroy(*args):
        """
        ('NUMA', '**pna')       

:param[in,out] pna:   numa to be destroyed and nulled if it exists
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the numa.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaDestroy(*args)
    
    

    try:
        leptonica.numaCopy.argtypes = [ctypes.c_void_p]
        leptonica.numaCopy.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCopy(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  copy of numa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCopy(*args)
    
    

    try:
        leptonica.numaClone.argtypes = [ctypes.c_void_p]
        leptonica.numaClone.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaClone(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  ptr to same numa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaClone(*args)
    
    

    try:
        leptonica.numaEmpty.argtypes = [ctypes.c_void_p]
        leptonica.numaEmpty.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaEmpty not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaEmpty(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This does not change the allocation of the array.
It just clears the number of stored numbers, so that
the array appears to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaEmpty(*args)
    
    

    try:
        leptonica.numaAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.numaAddNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaAddNumber(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'val')       

:param[in]    na:
:param[in]    val:    float or int to be added; stored as a float
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaAddNumber(*args)
    
    

    try:
        leptonica.numaInsertNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaInsertNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaInsertNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaInsertNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       

:param[in]    na:
:param[in]    index:    location in na to insert new value
:param[in]    val:      float32 or integer to be added
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts na[i] --> na[i + 1] for all i >= index,
and then inserts val as na[index].
(2) It should not be used repeatedly on large arrays,
because the function is O(n).

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaInsertNumber(*args)
    
    

    try:
        leptonica.numaRemoveNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaRemoveNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaRemoveNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRemoveNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       

:param[in]    na:
:param[in]    index:    element to be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts na[i] --> na[i - 1] for all i > index.
(2) It should not be used repeatedly on large arrays,
because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaRemoveNumber(*args)
    
    

    try:
        leptonica.numaReplaceNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaReplaceNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaReplaceNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReplaceNumber(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       

:param[in]    na:
:param[in]    index:    element to be replaced
:param[in]    val:      new value to replace old one
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaReplaceNumber(*args)
    
    

    try:
        leptonica.numaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.numaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetCount(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  count, or 0 if no numbers or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetCount(*args)
    
    

    try:
        leptonica.numaSetCount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaSetCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSetCount(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'newcount')       

:param[in]    na:
:param[in]    newcount:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If newcount <= na->nalloc, this resets na->n.
Using newcount = 0 is equivalent to numaEmpty().
(2) If newcount > na->nalloc, this causes a realloc
to a size na->nalloc = newcount.
(3) All the previously unused values in na are set to 0.0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaSetCount(*args)
    
    

    try:
        leptonica.numaGetFValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetFValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetFValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetFValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', '*pval')       

:param[in]    na:
:param[in]    index:    into numa
:param[out]   pval:     float value; set to 0.0 on error
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Caller may need to check the function return value to
decide if a 0.0 in the returned ival is valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetFValue(*args)
    
    

    try:
        leptonica.numaGetIValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaGetIValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetIValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetIValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_int32', '*pival')       

:param[in]    na:
:param[in]    index: into numa
:param[out]   pival:  integer value; set to 0 on error
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Caller may need to check the function return value to
decide if a 0 in the returned ival is valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetIValue(*args)
    
    

    try:
        leptonica.numaSetValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaSetValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSetValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSetValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'val')       

:param[in]    na:
:param[in]    index:   to element to be set
:param[in]    val:     to set
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSetValue(*args)
    
    

    try:
        leptonica.numaShiftValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaShiftValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaShiftValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaShiftValue(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'index')       
('l_float32', 'diff')       

:param[in]    na:
:param[in]    index:   to element to change relative to the current value
:param[in]    diff:    increment if diff > 0 or decrement if diff < 0
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaShiftValue(*args)
    
    

    try:
        leptonica.numaGetIArray.argtypes = [ctypes.c_void_p]
        leptonica.numaGetIArray.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function numaGetIArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetIArray(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  a copy of the bare internal array, integerized
by rounding, or NULL on error
<pre>
Notes:
(1) A copy of the array is always made, because we need to
generate an integer array from the bare float array.
The caller is responsible for freeing the array.
(2) The array size is determined by the number of stored numbers,
not by the size of the allocated array in the Numa.
(3) This function is provided to simplify calculations
using the bare internal array, rather than continually
calling accessors on the numa.  It is typically used
on an array of size 256.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetIArray(*args)
    
    

    try:
        leptonica.numaGetFArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaGetFArray.restype = ctypes.POINTER(ctypes.c_float)
    except AttributeError:
        sys.stderr.write("Warning - function numaGetFArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetFArray(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'copyflag')       

:param[in]    na:
:param[in]    copyflag:    L_NOCOPY or L_COPY
:returns:  either the bare internal array or a copy of it,
or NULL on error

<pre>
Notes:
(1) If copyflag == L_COPY, it makes a copy which the caller
is responsible for freeing.  Otherwise, it operates
directly on the bare array of the numa.
(2) Very important: for L_NOCOPY, any writes to the array
will be in the numa.  Do not write beyond the size of
the count field, because it will not be accessible
from the numa!  If necessary, be sure to set the count
field to a larger number (such as the alloc size)
BEFORE calling this function.  Creating with numaMakeConstant()
is another way to insure full initialization.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetFArray(*args)
    
    

    try:
        leptonica.numaGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.numaGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetRefcount(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetRefcount(*args)
    
    

    try:
        leptonica.numaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaChangeRefcount(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'delta')       

:param[in]    na:
:param[in]    delta:    change to be applied
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaChangeRefcount(*args)
    
    

    try:
        leptonica.numaGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaGetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaGetParameters(*args):
        """
        ('NUMA', '*na')       
('l_float32', '*pstartx')       
('l_float32', '*pdelx')       

:param[in]    na:
:param[out]   pstartx:    [optional] startx
:param[out]   pdelx:      [optional] delx
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaGetParameters(*args)
    
    

    try:
        leptonica.numaSetParameters.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.numaSetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaSetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaSetParameters(*args):
        """
        ('NUMA', '*na')       
('l_float32', 'startx')       
('l_float32', 'delx')       

:param[in]    na:
:param[in]    startx:  x value corresponding to na[0]
:param[in]    delx:    difference in x values for the situation where the
elements of na correspond to the evaulation of a
function at equal intervals of size %delx
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaSetParameters(*args)
    
    

    try:
        leptonica.numaCopyParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaCopyParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaCopyParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaCopyParameters(*args):
        """
        ('NUMA', '*nad')       
('NUMA', '*nas')       

:param[in]    nad:    destination Numa
:param[in]    nas:    source Numa
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaCopyParameters(*args)
    
    

    try:
        leptonica.numaConvertToSarray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaConvertToSarray.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaConvertToSarray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToSarray(*args):
        """
        ('NUMA', '*na')       
('l_int32', 'size1')       
('l_int32', 'size2')       
('l_int32', 'addzeros')       
('l_int32', 'type')       

:param[in]    na:
:param[in]    size1:      size of conversion field
:param[in]    size2:      for float conversion: size of field to the right
of the decimal point
:param[in]    addzeros:   for integer conversion: to add lead zeros
:param[in]    type:       L_INTEGER_VALUE, L_FLOAT_VALUE
:returns:  a sarray of the float values converted to strings
representing either integer or float values; or NULL on error.

<pre>
Notes:
(1) For integer conversion, size2 is ignored.
For float conversion, addzeroes is ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToSarray(*args)
    
    

    try:
        leptonica.numaRead.argtypes = [ctypes.c_char_p]
        leptonica.numaRead.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  na, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaRead(*args)
    
    

    try:
        leptonica.numaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.numaReadStream.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  numa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaReadStream(*args)
    
    

    try:
        leptonica.numaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.numaReadMem.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    numa serialization; in ascii
:param[in]    size:    of data; can use strlen to get it
:returns:  na, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaReadMem(*args)
    
    

    try:
        leptonica.numaWriteDebug.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.numaWriteDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWriteDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWriteDebug(*args):
        """
        ('const char', '*filename')       
('NUMA', '*na')       

:param[in]    filename:
:param[in]    na:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Debug version, intended for use in the library when writing
to files in a temp directory with names that are compiled in.
This is used instead of numaWrite() for all such library calls.
(2) The global variable LeptDebugOK defaults to 0, and can be set
or cleared by the function setLeptDebugOK().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWriteDebug(*args)
    
    

    try:
        leptonica.numaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.numaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWrite(*args):
        """
        ('const char', '*filename')       
('NUMA', '*na')       

:param[in]    filename:
:param[in]    na:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaWrite(*args)
    
    

    try:
        leptonica.numaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWriteStream(*args):
        """
        ('FILE', '*fp')       
('NUMA', '*na')       

:param[in]    fp:    file stream; use NULL to write to stderr
:param[in]    na:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaWriteStream(*args)
    
    

    try:
        leptonica.numaWriteStderr.argtypes = [ctypes.c_void_p]
        leptonica.numaWriteStderr.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWriteStderr not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWriteStderr(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaWriteStderr(*args)
    
    

    try:
        leptonica.numaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('NUMA', '*na')       

:param[out]   pdata:    data of serialized numa; ascii
:param[out]   psize:    size of returned data
:param[in]    na:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a numa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaWriteMem(*args)
    
    

    try:
        leptonica.numaaCreate.argtypes = [ctypes.c_int32]
        leptonica.numaaCreate.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:     size of numa ptr array to be alloc'd 0 for default
:returns:  naa, or NULL on error



        """
        args = _convert_params(*args)
        
        return leptonica.numaaCreate(*args)
    
    

    try:
        leptonica.numaaCreateFull.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.numaaCreateFull.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaCreateFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaCreateFull(*args):
        """
        ('l_int32', 'nptr')       
('l_int32', 'n')       

:param[in]    nptr:   size of numa ptr array to be alloc'd
:param[in]    n:      size of individual numa arrays to be allocated
to 0 for default
:returns:  naa, or NULL on error

<pre>
Notes:
(1) This allocates numaa and fills the array with allocated numas.
In use, after calling this function, use
numaaAddNumber(naa, index, val);
to add val to the index-th numa in naa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaCreateFull(*args)
    
    

    try:
        leptonica.numaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.numaaTruncate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaTruncate(*args):
        """
        ('NUMAA', '*naa')       

:param[in]    naa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This identifies the largest index containing a numa that
has any numbers within it, destroys all numa beyond that
index, and resets the count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaTruncate(*args)
    
    

    try:
        leptonica.numaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.numaaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function numaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaDestroy(*args):
        """
        ('NUMAA', '**pnaa')       

:param[in,out]  pnaa:   to be destroyed and nulled, if it exists
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.numaaDestroy(*args)
    
    

    try:
        leptonica.numaaAddNuma.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaaAddNuma.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaAddNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaAddNuma(*args):
        """
        ('NUMAA', '*naa')       
('NUMA', '*na')       
('l_int32', 'copyflag')       

:param[in]    naa:
:param[in]    na:         to be added
:param[in]    copyflag:   L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaAddNuma(*args)
    
    

    try:
        leptonica.numaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.numaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetCount(*args):
        """
        ('NUMAA', '*naa')       

:param[in]    naa:
:returns:  count number of numa, or 0 if no numa or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetCount(*args)
    
    

    try:
        leptonica.numaaGetNumaCount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.numaaGetNumaCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaaGetNumaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetNumaCount(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       

:param[in]    naa:
:param[in]    index:     of numa in naa
:returns:  count of numbers in the referenced numa, or 0 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetNumaCount(*args)
    
    

    try:
        leptonica.numaaGetNumberCount.argtypes = [ctypes.c_void_p]
        leptonica.numaaGetNumberCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function numaaGetNumberCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetNumberCount(*args):
        """
        ('NUMAA', '*naa')       

:param[in]    naa:
:returns:  count total number of numbers in the numaa,
or 0 if no numbers or on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetNumberCount(*args)
    
    

    try:
        leptonica.numaaGetPtrArray.argtypes = [ctypes.c_void_p]
        leptonica.numaaGetPtrArray.restype = ctypes.c_void_p
    except AttributeError:
        sys.stderr.write("Warning - function numaaGetPtrArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetPtrArray(*args):
        """
        ('NUMAA', '*naa')       

:param[in]    naa:
:returns:  the internal array of ptrs to Numa, or NULL on error

<pre>
Notes:
(1) This function is convenient for doing direct manipulation on
a fixed size array of Numas.  To do this, it sets the count
to the full size of the allocated array of Numa ptrs.
The originating Numaa owns this array: DO NOT free it!
(2) Intended usage:
Numaa *naa = numaaCreate(n);
Numa **array = numaaGetPtrArray(naa);
...  [manipulate Numas directly on the array]
numaaDestroy(&naa);
(3) Cautions:
~ Do not free this array; it is owned by tne Numaa.
~ Do not call any functions on the Numaa, other than
numaaDestroy() when you're finished with the array.
Adding a Numa will force a resize, destroying the ptr array.
~ Do not address the array outside its allocated size.
With the bare array, there are no protections.  If the
allocated size is n, array[n] is an error.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetPtrArray(*args)
    
    

    try:
        leptonica.numaaGetNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.numaaGetNuma.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaGetNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetNuma(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    naa:
:param[in]    index:        to the index-th numa
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  numa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetNuma(*args)
    
    

    try:
        leptonica.numaaReplaceNuma.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.numaaReplaceNuma.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaReplaceNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaReplaceNuma(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
('NUMA', '*na')       

:param[in]    naa:
:param[in]    index:    to the index-th numa
:param[in]    na:       insert and replace any existing one
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Any existing numa is destroyed, and the input one
is inserted in its place.
(2) If the index is invalid, return 1 (error)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaReplaceNuma(*args)
    
    

    try:
        leptonica.numaaGetValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaaGetValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaGetValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaGetValue(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'i')       
('l_int32', 'j')       
('l_float32', '*pfval')       
('l_int32', '*pival')       

:param[in]    naa:
:param[in]    i:       index of numa within numaa
:param[in]    j:       index into numa
:param[out]   pfval:   [optional] float value
:param[out]   pival:   [optional] int value
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaGetValue(*args)
    
    

    try:
        leptonica.numaaAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.numaaAddNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaAddNumber(*args):
        """
        ('NUMAA', '*naa')       
('l_int32', 'index')       
('l_float32', 'val')       

:param[in]    naa:
:param[in]    index:    of numa within numaa
:param[in]    val:      float or int to be added; stored as a float
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Adds to an existing numa only.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaAddNumber(*args)
    
    

    try:
        leptonica.numaaRead.argtypes = [ctypes.c_char_p]
        leptonica.numaaRead.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  naa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaRead(*args)
    
    

    try:
        leptonica.numaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.numaaReadStream.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:     file stream
:returns:  naa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaReadStream(*args)
    
    

    try:
        leptonica.numaaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.numaaReadMem.restype = lambda address: NUMAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:     numaa serialization; in ascii
:param[in]    size:     of data; can use strlen to get it
:returns:  naa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaReadMem(*args)
    
    

    try:
        leptonica.numaaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.numaaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaWrite(*args):
        """
        ('const char', '*filename')       
('NUMAA', '*naa')       

:param[in]    filename:
:param[in]    naa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaWrite(*args)
    
    

    try:
        leptonica.numaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('NUMAA', '*naa')       

:param[in]    fp:     file stream
:param[in]    naa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaaWriteStream(*args)
    
    

    try:
        leptonica.numaaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.numaaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function numaaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('NUMAA', '*naa')       

:param[out]   pdata:    data of serialized numaa; ascii
:param[out]   psize:    size of returned data
:param[in]    naa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a numaa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.numaaWriteMem(*args)
    




class psio1(object):
    """<pre>

|=============================================================|
|                         Important note                      |
|=============================================================|
| Some of these functions require I/O libraries such as       |
| libtiff, libjpeg, and libz.  If you do not have these       |
| libraries, some calls will fail.                            |
|                                                             |
| You can manually deactivate all PostScript writing by       |
| setting this in environ.h:                                  |
| \code                                                       |
|     #define  USE_PSIO     0                                 |
| \endcode                                                    |
| in environ.h.  This will link psio1stub.c                   |
|=============================================================|

This is a PostScript "device driver" for wrapping images
in PostScript.  The images can be rendered by a PostScript
interpreter for viewing, using evince or gv.  They can also be
rasterized for printing, using gs or an embedded interpreter
in a PostScript printer.  And they can be converted to a pdf
using gs (ps2pdf).

Convert specified files to PS
l_int32          convertFilesToPS()
l_int32          sarrayConvertFilesToPS()
l_int32          convertFilesFittedToPS()
l_int32          sarrayConvertFilesFittedToPS()
l_int32          writeImageCompressedToPSFile()

Convert mixed text/image files to PS
l_int32          convertSegmentedPagesToPS()
l_int32          pixWriteSegmentedPageToPS()
l_int32          pixWriteMixedToPS()

Convert any image file to PS for embedding
l_int32          convertToPSEmbed()

Write all images in a pixa out to PS
l_int32          pixaWriteCompressedToPS()
l_int32          pixWriteCompressedToPS()

These PostScript converters are used in three different ways.

(1) For embedding a PS file in a program like TeX.
convertToPSEmbed() handles this for levels 1, 2 and 3 output,
and prog/converttops wraps this in an executable.
converttops is a generalization of Thomas Merz's jpeg2ps wrapper,
in that it works for all types (formats, depth, colormap)
of input images and gives PS output in one of these formats
level 1 (uncompressed)
level 2 (compressed ccittg4 or dct)
level 3 (compressed flate)

(2) For composing a set of pages with any number of images
painted on them, in either level 2 or level 3 formats.

(3) For printing a page image or a set of page images, at a
resolution that optimally fills the page, using
convertFilesFittedToPS().

The top-level calls of utilities in category 2, which can compose
multiple images on a page, and which generate a PostScript file for
printing or display (e.g., conversion to pdf), are:
convertFilesToPS()
convertFilesFittedToPS()
convertSegmentedPagesToPS()

All images are output with page numbers.  Bounding box hints are
more subtle.  They must be included for embeding images in
TeX, for example, and the low-level writers include bounding
box hints by default.  However, these hints should not be included for
multi-page PostScript that is composed of a sequence of images;
consequently, they are not written when calling higher level
functions such as convertFilesToPS(), convertFilesFittedToPS()
and convertSegmentedPagesToPS().  The function l_psWriteBoundingBox()
sets a flag to give low-level control over this.
</pre>




"""
    



class strokes(object):
    """<pre>

Operations on 1 bpp images to:
(1) measure stroke parameters, such as length and average width
(2) change the average stroke width to a given value by eroding
or dilating the image.

These operations are intended to operate on a single text
character, to regularize the stroke width. It is expected
that character matching by correlation, as used in the recog
application, can often be improved by pre-processing both
template and character images to a fixed stroke width.

Stroke parameter measurement
l_int32      pixFindStrokeLength()
l_int32      pixFindStrokeWidth()
NUMA        *pixaFindStrokeWidth()

Stroke width regulation
PIXA        *pixaModifyStrokeWidth()
PIX         *pixModifyStrokeWidth()
PIXA        *pixaSetStrokeWidth()
PIX         *pixSetStrokeWidth()
</pre>




"""
    
    try:
        leptonica.pixFindStrokeLength.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindStrokeLength.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindStrokeLength not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindStrokeLength(*args):
        """
        ('PIX', '*pixs')       
('l_int32', '*tab8')       
('l_int32', '*plength')       

:param[in]    pixs:      1 bpp
:param[in]    tab8:      [optional] table for counting fg pixels; can be NULL
:param[out]   plength:   estimated length of the strokes
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Returns half the number of fg boundary pixels.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindStrokeLength(*args)
    
    

    try:
        leptonica.pixFindStrokeWidth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindStrokeWidth.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindStrokeWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindStrokeWidth(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'thresh')       
('l_int32', '*tab8')       
('l_float32', '*pwidth')       
('NUMA', '**pnahisto')       

:param[in]    pixs:       1 bpp
:param[in]    thresh:     fractional count threshold relative to distance 1
:param[in]    tab8:       [optional] table for counting fg pixels; can be NULL
:param[out]   pwidth:     estimated width of the strokes
:param[out]   pnahisto:   [optional] histo of pixel distances from bg
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This uses two methods to estimate the stroke width:
(a) half the fg boundary length
(b) a value derived from the histogram of the fg distance transform
(2) Distance is measured in 8-connected
(3) %thresh is the minimum fraction N(dist=d)/N(dist=1) of pixels
required to determine if the pixels at distance d are above
the noise. It is typically about 0.15.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindStrokeWidth(*args)
    
    

    try:
        leptonica.pixaFindStrokeWidth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixaFindStrokeWidth.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaFindStrokeWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaFindStrokeWidth(*args):
        """
        ('PIXA', '*pixa')       
('l_float32', 'thresh')       
('l_int32', '*tab8')       
('l_int32', 'debug')       

:param[in]    pixa:     of 1 bpp images
:param[in]    thresh:   fractional count threshold relative to distance 1
:param[in]    tab8:     [optional] table for counting fg pixels; can be NULL
:param[in]    debug:    1 for debug output; 0 to skip
:returns:  na  array of stroke widths for each pix in %pixa; NULL on error

<pre>
Notes:
(1) See pixFindStrokeWidth() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaFindStrokeWidth(*args)
    
    

    try:
        leptonica.pixaModifyStrokeWidth.argtypes = [ctypes.c_void_p, ctypes.c_float]
        leptonica.pixaModifyStrokeWidth.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaModifyStrokeWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaModifyStrokeWidth(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'targetw')       

:param[in]     pixas:      of 1 bpp pix
:param[out]    targetw:    desired width for strokes in each pix
:returns:  pixa  with modified stroke widths, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixaModifyStrokeWidth(*args)
    
    

    try:
        leptonica.pixModifyStrokeWidth.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixModifyStrokeWidth.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixModifyStrokeWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixModifyStrokeWidth(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'width')       
('l_float32', 'targetw')       

:param[in]   pixs:      of 1 bpp pix
:param[in]   width:     measured average stroke width
:param[in]   targetw:   desired stroke width
:returns:  pix  with modified stroke width, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.pixModifyStrokeWidth(*args)
    
    

    try:
        leptonica.pixaSetStrokeWidth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixaSetStrokeWidth.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaSetStrokeWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaSetStrokeWidth(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'width')       
('l_int32', 'thinfirst')       
('l_int32', 'connectivity')       

:param[in]   pixas:          of 1 bpp pix
:param[in]   width:          set stroke width to this value, in [1 ... 100].
:param[in]   thinfirst:      1 to thin all pix to a skeleton first; 0 to skip
:param[in]   connectivity:   4 or 8, to be used if %thinfirst == 1
:returns:  pixa  with all stroke widths being %width, or NULL on error

<pre>
Notes:
(1) If %thinfirst == 1, thin to a skeleton using the specified
%connectivity.  Use %thinfirst == 0 if all pix in pixas
have already been thinned as far as possible.
(2) The image is dilated to the required %width.  This dilation
is not connectivity preserving, so this is typically
used in a situation where merging of c.c. in the individual
pix is not a problem; e.g., where each pix is a single c.c.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaSetStrokeWidth(*args)
    
    

    try:
        leptonica.pixSetStrokeWidth.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixSetStrokeWidth.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixSetStrokeWidth not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixSetStrokeWidth(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'width')       
('l_int32', 'thinfirst')       
('l_int32', 'connectivity')       

:param[in]   pixs:           1 bpp
:param[in]   width:          set stroke width to this value, in [1 ... 100].
:param[in]   thinfirst:      1 to thin all pix to a skeleton first; 0 to skip
:param[in]   connectivity:   4 or 8, to be used if %thinfirst == 1
:returns:  pixd  with stroke width set to %width, or NULL on error

<pre>
Notes:
(1) See notes in pixaSetStrokeWidth().
(2) A white border of sufficient width to avoid boundary
artifacts in the thickening step is added before thinning.
(3) %connectivity == 8 usually gives a slightly smoother result.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixSetStrokeWidth(*args)
    




class dnafunc1(object):
    """<pre>

Rearrangements
l_int32     *l_dnaJoin()
l_int32     *l_dnaaFlattenToDna()

Conversion between numa and dna
NUMA        *l_dnaConvertToNuma()
L_DNA       *numaConvertToDna()

Conversion from pix data to dna
L_DNA       *pixConvertDataToDna()

Set operations using aset (rbtree)
L_DNA       *l_dnaUnionByAset()
L_DNA       *l_dnaRemoveDupsByAset()
L_DNA       *l_dnaIntersectionByAset()
L_ASET      *l_asetCreateFromDna()

Miscellaneous operations
L_DNA       *l_dnaDiffAdjValues()


This file contains an implementation on sets of doubles (or integers)
that uses an underlying tree (rbtree).  The keys stored in the tree
are simply the double array values in the dna.  Use of a DnaHash
is typically more efficient, with O(1) in lookup and insertion.

</pre>




"""
    
    try:
        leptonica.l_dnaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_dnaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaJoin(*args):
        """
        ('L_DNA', '*dad')       
('L_DNA', '*das')       
('l_int32', 'istart')       
('l_int32', 'iend')       

:param[in]    dad:       dest dna; add to this one
:param[in]    das:       [optional] source dna; add from this one
:param[in]    istart:    starting index in das
:param[in]    iend:      ending index in das; use -1 to cat all
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) istart < 0 is taken to mean 'read from the start' (istart = 0)
(2) iend < 0 means 'read to the end'
(3) if das == NULL, this is a no-op
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaJoin(*args)
    
    

    try:
        leptonica.l_dnaaFlattenToDna.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaaFlattenToDna.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaFlattenToDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaFlattenToDna(*args):
        """
        ('L_DNAA', '*daa')       

:param[in]    daa:
:returns:  dad, or NULL on error

<pre>
Notes:
(1) This 'flattens' the dnaa to a dna, by joining successively
each dna in the dnaa.
(2) It leaves the input dnaa unchanged.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaFlattenToDna(*args)
    
    

    try:
        leptonica.l_dnaConvertToNuma.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaConvertToNuma.restype = lambda address: NUMA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaConvertToNuma not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaConvertToNuma(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  na, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaConvertToNuma(*args)
    
    

    try:
        leptonica.numaConvertToDna.argtypes = [ctypes.c_void_p]
        leptonica.numaConvertToDna.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function numaConvertToDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def numaConvertToDna(*args):
        """
        ('NUMA', '*na')       

:param[in]    na:
:returns:  da, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.numaConvertToDna(*args)
    
    

    try:
        leptonica.pixConvertDataToDna.argtypes = [ctypes.c_void_p]
        leptonica.pixConvertDataToDna.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertDataToDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertDataToDna(*args):
        """
        ('PIX', '*pix')       

:param[in]    pix:      32 bpp RGB(A)
:returns:  da, or NULL on error

<pre>
Notes:
(1) This writes the RGBA pixel values into the dna, in row-major order.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertDataToDna(*args)
    
    

    try:
        leptonica.l_dnaUnionByAset.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaUnionByAset.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaUnionByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaUnionByAset(*args):
        """
        ('L_DNA', '*da1')       
('L_DNA', '*da2')       

:param[in]    da1,: da2
:returns:  dad with the union of the set of numbers, or NULL on error

<pre>
Notes:
(1) See sarrayUnionByAset() for the approach.
(2) Here, the key in building the sorted tree is the number itself.
(3) Operations using an underlying tree are O(nlogn), which is
typically less efficient than hashing, which is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaUnionByAset(*args)
    
    

    try:
        leptonica.l_dnaRemoveDupsByAset.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaRemoveDupsByAset.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaRemoveDupsByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaRemoveDupsByAset(*args):
        """
        ('L_DNA', '*das')       

:param[in]    das:
:returns:  dad with duplicates removed, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaRemoveDupsByAset(*args)
    
    

    try:
        leptonica.l_dnaIntersectionByAset.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaIntersectionByAset.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaIntersectionByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaIntersectionByAset(*args):
        """
        ('L_DNA', '*da1')       
('L_DNA', '*da2')       

:param[in]    da1,: da2
:returns:  dad with the intersection of the two arrays, or NULL on error

<pre>
Notes:
(1) See sarrayIntersection() for the approach.
(2) Here, the key in building the sorted tree is the number itself.
(3) Operations using an underlying tree are O(nlogn), which is
typically less efficient than hashing, which is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaIntersectionByAset(*args)
    
    

    try:
        leptonica.l_asetCreateFromDna.argtypes = [ctypes.c_void_p]
        leptonica.l_asetCreateFromDna.restype = lambda address: L_ASET(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_asetCreateFromDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_asetCreateFromDna(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:    source dna
:returns:  set using the doubles in %da as keys


        """
        args = _convert_params(*args)
        
        return leptonica.l_asetCreateFromDna(*args)
    
    

    try:
        leptonica.l_dnaDiffAdjValues.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaDiffAdjValues.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaDiffAdjValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaDiffAdjValues(*args):
        """
        ('L_DNA', '*das')       

:param[in]    das:    input l_dna
:returns:  dad of difference values val[i+1] - val[i],
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaDiffAdjValues(*args)
    




class dnahash(object):
    """<pre>

DnaHash creation, destruction
L_DNAHASH   *l_dnaHashCreate()
void         l_dnaHashDestroy()

DnaHash: Accessors and modifiers
l_int32      l_dnaHashGetCount()
l_int32      l_dnaHashGetTotalCount()
L_DNA       *l_dnaHashGetDna()
l_int32      l_dnaHashAdd()

DnaHash: Operations on Dna
L_DNAHASH   *l_dnaHashCreateFromDna()
l_int32      l_dnaRemoveDupsByHash()
l_int32      l_dnaMakeHistoByHash()
L_DNA       *l_dnaIntersectionByHash()
l_int32      l_dnaFindValByHash()

(1) The DnaHash is an array of Dna.  It is useful for fast
storage and lookup for sets and maps.  If the set or map
is on a Dna itself, the hash is a simple function that
maps a double to a l_uint64; otherwise the function will
map a string or a (x,y) point to a l_uint64.  The result of
the map is the "key", which is then used with the mod
function to select which Dna array is to be used.  The
number of arrays in a DnaHash should be a prime number.
If there are N items, we set up the DnaHash array to have
approximately N/20 Dna, so the average size of these arrays
will be about 20 when fully populated.  The number 20 was
found empirically to be in a broad maximum of efficiency.
(2) Note that the word "hash" is overloaded.  There are actually
two hashing steps: the first hashes the object to a l_uint64,
called the "key", and the second uses the mod function to
"hash" the "key" to the index of a particular Dna in the
DnaHash array.
(3) Insertion and lookup time for DnaHash is O(1).  Hash collisions
are easily handled (we expect an average of 20 for each key),
so we can use simple (fast) hash functions: we deal with
collisions by storing an array for each hash key.
This can be contrasted with using rbtree for sets and
maps, where insertion and lookup are O(logN) and hash functions
are slower because they must be good enough (i.e, random
enough with arbitrary input) to avoid collisions.
(4) Hash functions that map points, strings and floats to l_uint64
are given in utils.c.
(5) The use of the DnaHash (and RBTree) with strings and
(x,y) points can be found in string2.c and ptafunc2.c, rsp.
This file has similar hash set functions, using DnaHash on
two input Dna, for removing duplicates and finding the
intersection.  It also uses DnaHash as a hash map to find
a histogram of counts from an input Dna.
(6) Comparisons in running time, between DnaHash and RBTree, for
large sets of strings and points, are given in prog/hashtest.c.
(7) This is a very simple implementation, that expects that you
know approximately (i.e., within a factor of 2 or 3) how many
items are to be stored when you initialize the DnaHash.
(It would be nice to modify the l_dnaHashAdd() function
to increase the number of bins when the average occupation
exceeds 40 or so.)
(8) Useful rule of thumb for hashing collisions:
For a random hashing function (say, from strings to l_uint64),
the probability of a collision increases as N^2 for N much
less than 2^32.  The quadratic behavior switches over to
approaching 1.0 around 2^32, which is the square root of 2^64.
So, for example, if you have 10^7 strings, the probability
of a single collision using an l_uint64 key is on the order of
(10^7/10^9)^2 ~ 10^-4.
For a million strings you don't need to worry about collisons
(~10-6 probability), and for most applications can use the
RBTree (sorting) implementation with confidence.
</pre>




"""
    
    try:
        leptonica.l_dnaHashCreate.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.l_dnaHashCreate.restype = lambda address: L_DNAHASH(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashCreate(*args):
        """
        ('l_int32', 'nbuckets')       
('l_int32', 'initsize')       

:param[in]   nbuckets:   the number of buckets in the hash table,
which should be prime.
:param[in]   initsize:   initial size of each allocated dna; 0 for default
:returns:  ptr to new dnahash, or NULL on error

<pre>
Notes:
(1) Actual dna are created only as required by l_dnaHashAdd()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashCreate(*args)
    
    

    try:
        leptonica.l_dnaHashDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaHashDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashDestroy(*args):
        """
        ('L_DNAHASH', '**pdahash')       

:param[in,out]   pdahash:   will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashDestroy(*args)
    
    

    try:
        leptonica.l_dnaHashGetCount.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaHashGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashGetCount(*args):
        """
        ('L_DNAHASH', '*dahash')       

:param[in]    dahash:
:returns:  nbuckets allocated, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashGetCount(*args)
    
    

    try:
        leptonica.l_dnaHashGetTotalCount.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaHashGetTotalCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashGetTotalCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashGetTotalCount(*args):
        """
        ('L_DNAHASH', '*dahash')       

:param[in]    dahash:
:returns:  n number of numbers in all dna, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashGetTotalCount(*args)
    
    

    try:
        leptonica.l_dnaHashGetDna.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.c_int32]
        leptonica.l_dnaHashGetDna.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashGetDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashGetDna(*args):
        """
        ('L_DNAHASH', '*dahash')       
('l_uint64', 'key')       
('l_int32', 'copyflag')       

:param[in]    dahash:
:param[in]    key:        key to be hashed into a bucket number
:param[in]    copyflag:   L_NOCOPY, L_COPY, L_CLONE
:returns:  ptr to dna


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashGetDna(*args)
    
    

    try:
        leptonica.l_dnaHashAdd.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.c_double]
        leptonica.l_dnaHashAdd.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashAdd(*args):
        """
        ('L_DNAHASH', '*dahash')       
('l_uint64', 'key')       
('l_float64', 'value')       

:param[in]    dahash:
:param[in]    key:      key to be hashed into a bucket number
:param[in]    value:    float value to be appended to the specific dna
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashAdd(*args)
    
    

    try:
        leptonica.l_dnaHashCreateFromDna.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaHashCreateFromDna.restype = lambda address: L_DNAHASH(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashCreateFromDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashCreateFromDna(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  dahash if OK; 1 on error

<pre>
Notes:
(1) The values stored in the %dahash are indices into %da;
%dahash has no use without %da.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashCreateFromDna(*args)
    
    

    try:
        leptonica.l_dnaRemoveDupsByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaRemoveDupsByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaRemoveDupsByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaRemoveDupsByHash(*args):
        """
        ('L_DNA', '*das')       
('L_DNA', '**pdad')       
('L_DNAHASH', '**pdahash')       

:param[in]    das:
:param[out]   pdad:      hash set
:param[out]   pdahash:   [optional] dnahash used for lookup
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Generates a dna with unique values.
(2) The dnahash is built up with dad to assure uniqueness.
It can be used to find if an element is in the set:
l_dnaFindValByHash(dad, dahash, val, &index)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaRemoveDupsByHash(*args)
    
    

    try:
        leptonica.l_dnaMakeHistoByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaMakeHistoByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaMakeHistoByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaMakeHistoByHash(*args):
        """
        ('L_DNA', '*das')       
('L_DNAHASH', '**pdahash')       
('L_DNA', '**pdav')       
('L_DNA', '**pdac')       

:param[in]    das:
:param[out]   pdahash:    hash map: val --> index
:param[out]   pdav:       [optional] array of values: index --> val
:param[out]   pdac:       [optional] histo array of counts: index --> count
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Generates and returns a dna of occurrences (histogram),
an aligned dna of values, and an associated hashmap.
The hashmap takes %dav and a value, and points into the
histogram in %dac.
(2) The dna of values, %dav, is aligned with the histogram %dac,
and is needed for fast lookup.  It is a hash set, because
the values are unique.
(3) If you only need to make a histogram and get the number of
non-zero entries, here are two methods:
(a) l_dnaMakeHistoByHash(da, &dahash, NULL, NULL);
count = l_dnaHashGetTotalCount(dahash);
(b) l_dnaRemoveDupsByHash(da, &da_nodups, NULL);
count = l_dnaGetCount(da_nodups);
(4) Lookup is simple:
l_dnaFindValByHash(dav, dahash, val, &index);
if (index >= 0)
l_dnaGetIValue(dac, index, &icount);
else
icount = 0;
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaMakeHistoByHash(*args)
    
    

    try:
        leptonica.l_dnaIntersectionByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaIntersectionByHash.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaIntersectionByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaIntersectionByHash(*args):
        """
        ('L_DNA', '*da1')       
('L_DNA', '*da2')       

:param[in]    da1,: da2
:returns:  dad   intersection of the number arrays, or NULL on error

<pre>
Notes:
(1) This uses the same method for building the intersection set
as ptaIntersectionByHash() and sarrayIntersectionByHash().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaIntersectionByHash(*args)
    
    

    try:
        leptonica.l_dnaFindValByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_double, ctypes.c_void_p]
        leptonica.l_dnaFindValByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaFindValByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaFindValByHash(*args):
        """
        ('L_DNA', '*da')       
('L_DNAHASH', '*dahash')       
('l_float64', 'val')       
('l_int32', '*pindex')       

:param[in]    da:
:param[in]    dahash:    containing indices into %da
:param[in]    val:       searching for this number in %da
:param[out]   pindex:    index into da if found; -1 otherwise
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Algo: hash %val into a key; hash the key to get the dna
in %dahash (that holds indices into %da); traverse
the dna of indices looking for %val in %da.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaFindValByHash(*args)
    




class dnabasic(object):
    """<pre>

Dna creation, destruction, copy, clone, etc.
L_DNA       *l_dnaCreate()
L_DNA       *l_dnaCreateFromIArray()
L_DNA       *l_dnaCreateFromDArray()
L_DNA       *l_dnaMakeSequence()
void        *l_dnaDestroy()
L_DNA       *l_dnaCopy()
L_DNA       *l_dnaClone()
l_int32      l_dnaEmpty()

Dna: add/remove number and extend array
l_int32      l_dnaAddNumber()
static l_int32  l_dnaExtendArray()
l_int32      l_dnaInsertNumber()
l_int32      l_dnaRemoveNumber()
l_int32      l_dnaReplaceNumber()

Dna accessors
l_int32      l_dnaGetCount()
l_int32      l_dnaSetCount()
l_int32      l_dnaGetIValue()
l_int32      l_dnaGetDValue()
l_int32      l_dnaSetValue()
l_int32      l_dnaShiftValue()
l_int32     *l_dnaGetIArray()
l_float64   *l_dnaGetDArray()
l_int32      l_dnaGetRefcount()
l_int32      l_dnaChangeRefcount()
l_int32      l_dnaGetParameters()
l_int32      l_dnaSetParameters()
l_int32      l_dnaCopyParameters()

Serialize Dna for I/O
L_DNA       *l_dnaRead()
L_DNA       *l_dnaReadStream()
l_int32      l_dnaWrite()
l_int32      l_dnaWriteStream()

Dnaa creation, destruction
L_DNAA      *l_dnaaCreate()
L_DNAA      *l_dnaaCreateFull()
l_int32      l_dnaaTruncate()
void        *l_dnaaDestroy()

Add Dna to Dnaa
l_int32      l_dnaaAddDna()
static l_int32  l_dnaaExtendArray()

Dnaa accessors
l_int32      l_dnaaGetCount()
l_int32      l_dnaaGetDnaCount()
l_int32      l_dnaaGetNumberCount()
L_DNA       *l_dnaaGetDna()
L_DNA       *l_dnaaReplaceDna()
l_int32      l_dnaaGetValue()
l_int32      l_dnaaAddNumber()

Serialize Dnaa for I/O
L_DNAA      *l_dnaaRead()
L_DNAA      *l_dnaaReadStream()
l_int32      l_dnaaWrite()
l_int32      l_dnaaWriteStream()

(1) The Dna is a struct holding an array of doubles.  It can also
be used to store l_int32 values, up to the full precision
of int32.  Always use it whenever integers larger than a
few million need to be stored.

(2) Always use the accessors in this file, never the fields directly.

(3) Storing and retrieving numbers:

to append a new number to the array, use l_dnaAddNumber().  If
the number is an int, it will will automatically be converted
to l_float64 and stored.

to reset a value stored in the array, use l_dnaSetValue().

to increment or decrement a value stored in the array,
use l_dnaShiftValue().

to obtain a value from the array, use either l_dnaGetIValue()
or l_dnaGetDValue(), depending on whether you are retrieving
an integer or a float64.  This avoids doing an explicit cast,
such as
(a) return a l_float64 and cast it to an l_int32
(b) cast the return directly to (l_float64 *) to
satisfy the function prototype, as in
l_dnaGetDValue(da, index, (l_float64 *)&ival);   [ugly!]

(4) int <--> double conversions:

Conversions go automatically from l_int32 --> l_float64,
without loss of precision.  You must cast (l_int32)
to go from l_float64 --> l_int32 because you're truncating
to the integer value.

(5) As with other arrays in leptonica, the l_dna has both an allocated
size and a count of the stored numbers.  When you add a number, it
goes on the end of the array, and causes a realloc if the array
is already filled.  However, in situations where you want to
add numbers randomly into an array, such as when you build a
histogram, you must set the count of stored numbers in advance.
This is done with l_dnaSetCount().  If you set a count larger
than the allocated array, it does a realloc to the size requested.

(6) In situations where the data in a l_dna correspond to a function
y(x), the values can be either at equal spacings in x or at
arbitrary spacings.  For the former, we can represent all x values
by two parameters: startx (corresponding to y[0]) and delx
for the change in x for adjacent values y[i] and y[i+1].
startx and delx are initialized to 0.0 and 1.0, rsp.
For arbitrary spacings, we use a second l_dna, and the two
l_dnas are typically denoted dnay and dnax.
</pre>




"""
    
    try:
        leptonica.l_dnaCreate.argtypes = [ctypes.c_int32]
        leptonica.l_dnaCreate.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:   size of number array to be alloc'd; 0 for default
:returns:  da, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaCreate(*args)
    
    

    try:
        leptonica.l_dnaCreateFromIArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaCreateFromIArray.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaCreateFromIArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaCreateFromIArray(*args):
        """
        ('l_int32', '*iarray')       
('l_int32', 'size')       

:param[in]    iarray:   integer array
:param[in]    size:     of the array
:returns:  da, or NULL on error

<pre>
Notes:
(1) We can't insert this int array into the l_dna, because a l_dna
takes a double array.  So this just copies the data from the
input array into the l_dna.  The input array continues to be
owned by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaCreateFromIArray(*args)
    
    

    try:
        leptonica.l_dnaCreateFromDArray.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_dnaCreateFromDArray.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaCreateFromDArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaCreateFromDArray(*args):
        """
        ('l_float64', '*darray')       
('l_int32', 'size')       
('l_int32', 'copyflag')       

:param[in]    darray:     float
:param[in]    size:       of the array
:param[in]    copyflag:   L_INSERT or L_COPY
:returns:  da, or NULL on error

<pre>
Notes:
(1) With L_INSERT, ownership of the input array is transferred
to the returned l_dna, and all %size elements are considered
to be valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaCreateFromDArray(*args)
    
    

    try:
        leptonica.l_dnaMakeSequence.argtypes = [ctypes.c_double, ctypes.c_double, ctypes.c_int32]
        leptonica.l_dnaMakeSequence.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaMakeSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaMakeSequence(*args):
        """
        ('l_float64', 'startval')       
('l_float64', 'increment')       
('l_int32', 'size')       

:param[in]    startval:
:param[in]    increment:
:param[in]    size:       of sequence
:returns:  l_dna of sequence of evenly spaced values, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaMakeSequence(*args)
    
    

    try:
        leptonica.l_dnaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaDestroy(*args):
        """
        ('L_DNA', '**pda')       

:param[in,out]   pda:   will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the l_dna.
(2) Always nulls the input ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaDestroy(*args)
    
    

    try:
        leptonica.l_dnaCopy.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaCopy.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaCopy(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  copy of da, or NULL on error

<pre>
Notes:
(1) This removes unused ptrs above da->n.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaCopy(*args)
    
    

    try:
        leptonica.l_dnaClone.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaClone.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaClone not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaClone(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  ptr to same da, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaClone(*args)
    
    

    try:
        leptonica.l_dnaEmpty.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaEmpty.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaEmpty not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaEmpty(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) This does not change the allocation of the array.
It just clears the number of stored numbers, so that
the array appears to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaEmpty(*args)
    
    

    try:
        leptonica.l_dnaAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_double]
        leptonica.l_dnaAddNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaAddNumber(*args):
        """
        ('L_DNA', '*da')       
('l_float64', 'val')       

:param[in]    da:
:param[in]    val:   float or int to be added; stored as a float
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaAddNumber(*args)
    
    

    try:
        leptonica.l_dnaInsertNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_double]
        leptonica.l_dnaInsertNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaInsertNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaInsertNumber(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       
('l_float64', 'val')       

:param[in]    da:
:param[in]    index:   location in da to insert new value
:param[in]    val:     float64 or integer to be added
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts da[i] --> da[i + 1] for all i >= %index,
and then inserts %val as da[%index].
(2) It should not be used repeatedly on large arrays,
because the function is O(n).

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaInsertNumber(*args)
    
    

    try:
        leptonica.l_dnaRemoveNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaRemoveNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaRemoveNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaRemoveNumber(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       

:param[in]    da:
:param[in]    index:    element to be removed
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This shifts da[i] --> da[i - 1] for all i > %index.
(2) It should not be used repeatedly on large arrays,
because the function is O(n).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaRemoveNumber(*args)
    
    

    try:
        leptonica.l_dnaReplaceNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_double]
        leptonica.l_dnaReplaceNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaReplaceNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaReplaceNumber(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       
('l_float64', 'val')       

:param[in]    da:
:param[in]    index:    element to be replaced
:param[in]    val:      new value to replace old one
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaReplaceNumber(*args)
    
    

    try:
        leptonica.l_dnaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetCount(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  count, or 0 if no numbers or on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetCount(*args)
    
    

    try:
        leptonica.l_dnaSetCount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaSetCount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaSetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaSetCount(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'newcount')       

:param[in]    da:
:param[in]    newcount:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %newcount <= da->nalloc, this resets da->n.
Using %newcount = 0 is equivalent to l_dnaEmpty().
(2) If %newcount > da->nalloc, this causes a realloc
to a size da->nalloc = %newcount.
(3) All the previously unused values in da are set to 0.0.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaSetCount(*args)
    
    

    try:
        leptonica.l_dnaGetDValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_dnaGetDValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetDValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetDValue(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       
('l_float64', '*pval')       

:param[in]    da:
:param[in]    index:    into l_dna
:param[out]   pval:     double value; 0.0 on error
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Caller may need to check the function return value to
decide if a 0.0 in the returned ival is valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetDValue(*args)
    
    

    try:
        leptonica.l_dnaGetIValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_dnaGetIValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetIValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetIValue(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       
('l_int32', '*pival')       

:param[in]    da:
:param[in]    index:    into l_dna
:param[out]   pival:    integer value; 0 on error
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Caller may need to check the function return value to
decide if a 0 in the returned ival is valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetIValue(*args)
    
    

    try:
        leptonica.l_dnaSetValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_double]
        leptonica.l_dnaSetValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaSetValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaSetValue(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       
('l_float64', 'val')       

:param[in]    da:
:param[in]    index:    to element to be set
:param[in]    val:      to set element
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaSetValue(*args)
    
    

    try:
        leptonica.l_dnaShiftValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_double]
        leptonica.l_dnaShiftValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaShiftValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaShiftValue(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'index')       
('l_float64', 'diff')       

:param[in]    da:
:param[in]    index:   to element to change relative to the current value
:param[in]    diff:    increment if diff > 0 or decrement if diff < 0
:returns:  0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaShiftValue(*args)
    
    

    try:
        leptonica.l_dnaGetIArray.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaGetIArray.restype = ctypes.POINTER(ctypes.c_int32)
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetIArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetIArray(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  a copy of the bare internal array, integerized
by rounding, or NULL on error
<pre>
Notes:
(1) A copy of the array is made, because we need to
generate an integer array from the bare double array.
The caller is responsible for freeing the array.
(2) The array size is determined by the number of stored numbers,
not by the size of the allocated array in the l_dna.
(3) This function is provided to simplify calculations
using the bare internal array, rather than continually
calling accessors on the l_dna.  It is typically used
on an array of size 256.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetIArray(*args)
    
    

    try:
        leptonica.l_dnaGetDArray.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaGetDArray.restype = ctypes.POINTER(ctypes.c_double)
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetDArray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetDArray(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'copyflag')       

:param[in]    da:
:param[in]    copyflag:   L_NOCOPY or L_COPY
:returns:  either the bare internal array or a copy of it, or NULL on error

<pre>
Notes:
(1) If %copyflag == L_COPY, it makes a copy which the caller
is responsible for freeing.  Otherwise, it operates
directly on the bare array of the l_dna.
(2) Very important: for L_NOCOPY, any writes to the array
will be in the l_dna.  Do not write beyond the size of
the count field, because it will not be accessible
from the l_dna!  If necessary, be sure to set the count
field to a larger number (such as the alloc size)
BEFORE calling this function.  Creating with l_dnaMakeConstant()
is another way to insure full initialization.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetDArray(*args)
    
    

    try:
        leptonica.l_dnaGetRefcount.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaGetRefcount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetRefcount(*args):
        """
        ('L_DNA', '*da')       

:param[in]    da:
:returns:  refcount, or UNDEF on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetRefcount(*args)
    
    

    try:
        leptonica.l_dnaChangeRefcount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaChangeRefcount.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaChangeRefcount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaChangeRefcount(*args):
        """
        ('L_DNA', '*da')       
('l_int32', 'delta')       

:param[in]    da:
:param[in]    delta:    change to be applied
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaChangeRefcount(*args)
    
    

    try:
        leptonica.l_dnaGetParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaGetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaGetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaGetParameters(*args):
        """
        ('L_DNA', '*da')       
('l_float64', '*pstartx')       
('l_float64', '*pdelx')       

:param[in]    da:
:param[out]   pstartx:   [optional] startx
:param[out]   pdelx:     [optional] delx
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaGetParameters(*args)
    
    

    try:
        leptonica.l_dnaSetParameters.argtypes = [ctypes.c_void_p, ctypes.c_double, ctypes.c_double]
        leptonica.l_dnaSetParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaSetParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaSetParameters(*args):
        """
        ('L_DNA', '*da')       
('l_float64', 'startx')       
('l_float64', 'delx')       

:param[in]    da:
:param[in]    startx:   x value corresponding to da[0]
:param[in]    delx:     difference in x values for the situation where the
elements of da correspond to the evaulation of a
function at equal intervals of size %delx
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaSetParameters(*args)
    
    

    try:
        leptonica.l_dnaCopyParameters.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaCopyParameters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaCopyParameters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaCopyParameters(*args):
        """
        ('L_DNA', '*dad')       
('L_DNA', '*das')       

:param[in]    dad:    destination DNuma
:param[in]    das:    source DNuma
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaCopyParameters(*args)
    
    

    try:
        leptonica.l_dnaRead.argtypes = [ctypes.c_char_p]
        leptonica.l_dnaRead.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  da, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaRead(*args)
    
    

    try:
        leptonica.l_dnaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaReadStream.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  da, or NULL on error

<pre>
Notes:
(1) fscanf takes %lf to read a double; fprintf takes %f to write it.
(2) It is OK for the dna to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaReadStream(*args)
    
    

    try:
        leptonica.l_dnaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.l_dnaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaWrite(*args):
        """
        ('const char', '*filename')       
('L_DNA', '*da')       

:param[in]    filename:
:param[in]    da:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaWrite(*args)
    
    

    try:
        leptonica.l_dnaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_DNA', '*da')       

:param[in]    fp:    file stream
:param[in]    da:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaWriteStream(*args)
    
    

    try:
        leptonica.l_dnaaCreate.argtypes = [ctypes.c_int32]
        leptonica.l_dnaaCreate.restype = lambda address: L_DNAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaCreate(*args):
        """
        ('l_int32', 'n')       

:param[in]    n:    size of l_dna ptr array to be alloc'd 0 for default
:returns:  daa, or NULL on error



        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaCreate(*args)
    
    

    try:
        leptonica.l_dnaaCreateFull.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.l_dnaaCreateFull.restype = lambda address: L_DNAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaCreateFull not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaCreateFull(*args):
        """
        ('l_int32', 'nptr')       
('l_int32', 'n')       

:param[in]    nptr:  size of dna ptr array to be alloc'd
:param[in]    n:     size of individual dna arrays to be alloc'd 0 for default
:returns:  daa, or NULL on error

<pre>
Notes:
(1) This allocates a dnaa and fills the array with allocated dnas.
In use, after calling this function, use
l_dnaaAddNumber(dnaa, index, val);
to add val to the index-th dna in dnaa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaCreateFull(*args)
    
    

    try:
        leptonica.l_dnaaTruncate.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaaTruncate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaTruncate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaTruncate(*args):
        """
        ('L_DNAA', '*daa')       

:param[in]    daa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This identifies the largest index containing a dna that
has any numbers within it, destroys all dna beyond that
index, and resets the count.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaTruncate(*args)
    
    

    try:
        leptonica.l_dnaaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaDestroy(*args):
        """
        ('L_DNAA', '**pdaa')       

:param[in,out]   pdaa:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaDestroy(*args)
    
    

    try:
        leptonica.l_dnaaAddDna.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaaAddDna.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaAddDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaAddDna(*args):
        """
        ('L_DNAA', '*daa')       
('L_DNA', '*da')       
('l_int32', 'copyflag')       

:param[in]    daa:
:param[in]    da:         to be added
:param[in]    copyflag:   L_INSERT, L_COPY, L_CLONE
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaAddDna(*args)
    
    

    try:
        leptonica.l_dnaaGetCount.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaaGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaGetCount(*args):
        """
        ('L_DNAA', '*daa')       

:param[in]    daa:
:returns:  count   number of l_dna, or 0 if no l_dna or on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaGetCount(*args)
    
    

    try:
        leptonica.l_dnaaGetDnaCount.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_dnaaGetDnaCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaGetDnaCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaGetDnaCount(*args):
        """
        ('L_DNAA', '*daa')       
('l_int32', 'index')       

:param[in]    daa:
:param[in]    index:   of l_dna in daa
:returns:  count   of numbers in the referenced l_dna, or 0 on error.


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaGetDnaCount(*args)
    
    

    try:
        leptonica.l_dnaaGetNumberCount.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaaGetNumberCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaGetNumberCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaGetNumberCount(*args):
        """
        ('L_DNAA', '*daa')       

:param[in]    daa:
:returns:  count   total number of numbers in the l_dnaa,
or 0 if no numbers or on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaGetNumberCount(*args)
    
    

    try:
        leptonica.l_dnaaGetDna.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.l_dnaaGetDna.restype = lambda address: L_DNA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaGetDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaGetDna(*args):
        """
        ('L_DNAA', '*daa')       
('l_int32', 'index')       
('l_int32', 'accessflag')       

:param[in]    daa:
:param[in]    index:        to the index-th l_dna
:param[in]    accessflag:   L_COPY or L_CLONE
:returns:  l_dna, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaGetDna(*args)
    
    

    try:
        leptonica.l_dnaaReplaceDna.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_dnaaReplaceDna.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaReplaceDna not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaReplaceDna(*args):
        """
        ('L_DNAA', '*daa')       
('l_int32', 'index')       
('L_DNA', '*da')       

:param[in]    daa:
:param[in]    index:   to the index-th l_dna
:param[in]    da:      insert and replace any existing one
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Any existing l_dna is destroyed, and the input one
is inserted in its place.
(2) If %index is invalid, return 1 (error)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaReplaceDna(*args)
    
    

    try:
        leptonica.l_dnaaGetValue.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_dnaaGetValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaGetValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaGetValue(*args):
        """
        ('L_DNAA', '*daa')       
('l_int32', 'i')       
('l_int32', 'j')       
('l_float64', '*pval')       

:param[in]    daa:
:param[in]    i:      index of l_dna within l_dnaa
:param[in]    j:      index into l_dna
:param[out]   pval:   double value
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaGetValue(*args)
    
    

    try:
        leptonica.l_dnaaAddNumber.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_double]
        leptonica.l_dnaaAddNumber.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaAddNumber not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaAddNumber(*args):
        """
        ('L_DNAA', '*daa')       
('l_int32', 'index')       
('l_float64', 'val')       

:param[in]    daa:
:param[in]    index:    of l_dna within l_dnaa
:param[in]    val:      number to be added; stored as a double
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Adds to an existing l_dna only.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaAddNumber(*args)
    
    

    try:
        leptonica.l_dnaaRead.argtypes = [ctypes.c_char_p]
        leptonica.l_dnaaRead.restype = lambda address: L_DNAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  daa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaRead(*args)
    
    

    try:
        leptonica.l_dnaaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaaReadStream.restype = lambda address: L_DNAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:   file stream
:returns:  daa, or NULL on error

<pre>
Notes:
(1) It is OK for the dnaa to be empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaReadStream(*args)
    
    

    try:
        leptonica.l_dnaaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.l_dnaaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaWrite(*args):
        """
        ('const char', '*filename')       
('L_DNAA', '*daa')       

:param[in]    filename:
:param[in]    daa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaWrite(*args)
    
    

    try:
        leptonica.l_dnaaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_dnaaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaaWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_DNAA', '*daa')       

:param[in]    fp:     file stream
:param[in]    daa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaaWriteStream(*args)
    




class ptafunc2(object):
    """<pre>

--------------------------------------
This file has these Pta utilities:
- sorting
- ordered set operations
- hash map operations
--------------------------------------

Sorting
PTA        *ptaSort()
l_int32     ptaGetSortIndex()
PTA        *ptaSortByIndex()
PTAA       *ptaaSortByIndex()
l_int32     ptaGetRankValue()
PTA        *ptaSort2d()
l_int32     ptaEqual()

Set operations using aset (rbtree)
PTA        *ptaUnionByAset()
PTA        *ptaRemoveDupsByAset()
PTA        *ptaIntersectionByAset()
L_ASET     *l_asetCreateFromPta()

Set operations using hashing (dnahash)
PTA        *ptaUnionByHash()
l_int32     ptaRemoveDupsByHash()
PTA        *ptaIntersectionByHash();
l_int32     ptaFindPtByHash()
L_DNAHASH  *l_dnaHashCreateFromPta()


We have two implementations of set operations on an array of points:

(1) Using an underlying tree (rbtree)
This uses a good 64 bit hashing function for the key,
that is not expected to have hash collisions (and we do
not test for them).  The tree is built up of the hash
values, and if the hash is found in the tree, it is
assumed that the point has already been found.

(2) Using an underlying hashing of the keys (dnahash)
This uses a fast 64 bit hashing function for the key,
which is then hashed into a bucket (a dna in a dnaHash).
Because hash collisions can occur, the index into the
pta for the point that gave rise to that key is stored,
and the dna (bucket) is traversed, using the stored indices
to determine if that point had already been seen.

</pre>




"""
    
    try:
        leptonica.ptaSort.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaSort.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaSort not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSort(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       

:param[in]    ptas:
:param[in]    sorttype:    L_SORT_BY_X, L_SORT_BY_Y
:param[in]    sortorder:   L_SORT_INCREASING, L_SORT_DECREASING
:param[out]   pnaindex:    [optional] index of sorted order into
original array
:returns:  ptad sorted version of ptas, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSort(*args)
    
    

    try:
        leptonica.ptaGetSortIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaGetSortIndex.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetSortIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetSortIndex(*args):
        """
        ('PTA', '*ptas')       
('l_int32', 'sorttype')       
('l_int32', 'sortorder')       
('NUMA', '**pnaindex')       

:param[in]    ptas:
:param[in]    sorttype:    L_SORT_BY_X, L_SORT_BY_Y
:param[in]    sortorder:   L_SORT_INCREASING, L_SORT_DECREASING
:param[out]   pnaindex:    index of sorted order into original array
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetSortIndex(*args)
    
    

    try:
        leptonica.ptaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaSortByIndex.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSortByIndex(*args):
        """
        ('PTA', '*ptas')       
('NUMA', '*naindex')       

:param[in]    ptas:
:param[in]    naindex:    na that maps from the new pta to the input pta
:returns:  ptad sorted, or NULL on  error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSortByIndex(*args)
    
    

    try:
        leptonica.ptaaSortByIndex.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaaSortByIndex.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaaSortByIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaaSortByIndex(*args):
        """
        ('PTAA', '*ptaas')       
('NUMA', '*naindex')       

:param[in]    ptaas:
:param[in]    naindex:    na that maps from the new ptaa to the input ptaa
:returns:  ptaad sorted, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaaSortByIndex(*args)
    
    

    try:
        leptonica.ptaGetRankValue.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaGetRankValue.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaGetRankValue not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaGetRankValue(*args):
        """
        ('PTA', '*pta')       
('l_float32', 'fract')       
('PTA', '*ptasort')       
('l_int32', 'sorttype')       
('l_float32', '*pval')       

:param[in]    pta:
:param[in]    fract:      use 0.0 for smallest, 1.0 for largest
:param[in]    ptasort:    [optional] version of %pta sorted by %sorttype
:param[in]    sorttype:   L_SORT_BY_X, L_SORT_BY_Y
:param[out]   pval:       rankval: the x or y value at %fract
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.ptaGetRankValue(*args)
    
    

    try:
        leptonica.ptaSort2d.argtypes = [ctypes.c_void_p]
        leptonica.ptaSort2d.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaSort2d not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaSort2d(*args):
        """
        ('PTA', '*pta')       

:param[in]    ptas:
:returns:  ptad, or NULL on error

<pre>
Notes:
(1) Sort increasing by row-major, scanning down from the UL corner,
where for each value of y, order the pts from left to right.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaSort2d(*args)
    
    

    try:
        leptonica.ptaEqual.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaEqual.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaEqual not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaEqual(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       
('l_int32', '*psame')       

:param[in]    pta1:
:param[in]    pta2:
:param[out]   psame:  1 if same; 0 if different
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) Equality is defined as having the same set of points,
independent of the order in which they are presented.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaEqual(*args)
    
    

    try:
        leptonica.ptaUnionByAset.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaUnionByAset.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaUnionByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaUnionByAset(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       

:param[in]    pta1,: pta2
:returns:  ptad with the union of the set of points, or NULL on error

<pre>
Notes:
(1) See sarrayRemoveDupsByAset() for the approach.
(2) The key is a 64-bit hash from the (x,y) pair.
(3) This is slower than ptaUnionByHash(), mostly because of the
nlogn sort to build up the rbtree.  Do not use for large
numbers of points (say, > 1M).
(4) The *Aset() functions use the sorted l_Aset, which is just
an rbtree in disguise.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaUnionByAset(*args)
    
    

    try:
        leptonica.ptaRemoveDupsByAset.argtypes = [ctypes.c_void_p]
        leptonica.ptaRemoveDupsByAset.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaRemoveDupsByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRemoveDupsByAset(*args):
        """
        ('PTA', '*ptas')       

:param[in]    ptas:    assumed to be integer values
:returns:  ptad with duplicates removed, or NULL on error

<pre>
Notes:
(1) This is slower than ptaRemoveDupsByHash(), mostly because
of the nlogn sort to build up the rbtree.  Do not use for
large numbers of points (say, > 1M).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRemoveDupsByAset(*args)
    
    

    try:
        leptonica.ptaIntersectionByAset.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaIntersectionByAset.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaIntersectionByAset not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaIntersectionByAset(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       

:param[in]    pta1,: pta2
:returns:  ptad intersection of the point sets, or NULL on error

<pre>
Notes:
(1) See sarrayIntersectionByAset() for the approach.
(2) The key is a 64-bit hash from the (x,y) pair.
(3) This is slower than ptaIntersectionByHash(), mostly because
of the nlogn sort to build up the rbtree.  Do not use for
large numbers of points (say, > 1M).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaIntersectionByAset(*args)
    
    

    try:
        leptonica.l_asetCreateFromPta.argtypes = [ctypes.c_void_p]
        leptonica.l_asetCreateFromPta.restype = lambda address: L_ASET(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_asetCreateFromPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_asetCreateFromPta(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  set using a 64-bit hash of (x,y) as the key


        """
        args = _convert_params(*args)
        
        return leptonica.l_asetCreateFromPta(*args)
    
    

    try:
        leptonica.ptaUnionByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaUnionByHash.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaUnionByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaUnionByHash(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       

:param[in]    pta1,: pta2
:returns:  ptad with the union of the set of points, or NULL on error

<pre>
Notes:
(1) This is faster than ptaUnionByAset(), because the
bucket lookup is O(n).  It should be used if the pts are
integers (e.g., representing pixel positions).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaUnionByHash(*args)
    
    

    try:
        leptonica.ptaRemoveDupsByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaRemoveDupsByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaRemoveDupsByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaRemoveDupsByHash(*args):
        """
        ('PTA', '*ptas')       
('PTA', '**pptad')       
('L_DNAHASH', '**pdahash')       

:param[in]    ptas:      assumed to be integer values
:param[out]   pptad:     unique set of pts; duplicates removed
:param[out]   pdahash:   [optional] dnahash used for lookup
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Generates a pta with unique values.
(2) The dnahash is built up with ptad to assure uniqueness.
It can be used to find if a point is in the set:
ptaFindPtByHash(ptad, dahash, x, y, &index)
(3) The hash of the (x,y) location is simple and fast.  It scales
up with the number of buckets to insure a fairly random
bucket selection for adjacent points.
(4) A Dna is used rather than a Numa because we need accurate
representation of 32-bit integers that are indices into ptas.
Integer --> float --> integer conversion makes errors for
integers larger than 10M.
(5) This is faster than ptaRemoveDupsByAset(), because the
bucket lookup is O(n), although there is a double-loop
lookup within the dna in each bucket.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaRemoveDupsByHash(*args)
    
    

    try:
        leptonica.ptaIntersectionByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptaIntersectionByHash.restype = lambda address: PTA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function ptaIntersectionByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaIntersectionByHash(*args):
        """
        ('PTA', '*pta1')       
('PTA', '*pta2')       

:param[in]    pta1,: pta2
:returns:  ptad intersection of the point sets, or NULL on error

<pre>
Notes:
(1) This is faster than ptaIntersectionByAset(), because the
bucket lookup is O(n).  It should be used if the pts are
integers (e.g., representing pixel positions).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaIntersectionByHash(*args)
    
    

    try:
        leptonica.ptaFindPtByHash.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.ptaFindPtByHash.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptaFindPtByHash not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptaFindPtByHash(*args):
        """
        ('PTA', '*pta')       
('L_DNAHASH', '*dahash')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', '*pindex')       

:param[in]    pta:
:param[in]    dahash:     built from pta
:param[in]    x,: y       arbitrary points
:param[out]   pindex:     index into pta if (x,y) is in pta; -1 otherwise
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Fast lookup in dnaHash associated with a pta, to see if a
random point (x,y) is already stored in the hash table.
(2) We use a strong hash function to minimize the chance that
two different points hash to the same key value.
(3) We select the number of buckets to be about 5% of the size
of the input %pta, so that when fully populated, each
bucket (dna) will have about 20 entries, each being an index
into %pta.  In lookup, after hashing to the key, and then
again to the bucket, we traverse the bucket (dna), using the
index into %pta to check if the point (x,y) has been found before.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptaFindPtByHash(*args)
    
    

    try:
        leptonica.l_dnaHashCreateFromPta.argtypes = [ctypes.c_void_p]
        leptonica.l_dnaHashCreateFromPta.restype = lambda address: L_DNAHASH(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_dnaHashCreateFromPta not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_dnaHashCreateFromPta(*args):
        """
        ('PTA', '*pta')       

:param[in]    pta:
:returns:  dahash, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_dnaHashCreateFromPta(*args)
    




class checkerboard(object):
    """"""
    
    try:
        leptonica.pixFindCheckerboardCorners.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixFindCheckerboardCorners.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixFindCheckerboardCorners not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixFindCheckerboardCorners(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'size')       
('l_int32', 'dilation')       
('l_int32', 'nsels')       
('PIX', '**ppix_corners')       
('PTA', '**ppta_corners')       
('PIXA', '*pixadb')       

:param[in]    pixs:           of checkerboard
:param[in]    size:           size of HMT sel; >= 7, typ. 15; 0 for default
:param[in]    dilation:       size of hit and miss squares; typ. 1 or 3; max 5
:param[in]    nsels:          number to use (either 2 or 4)
:param[out]   ppix_corners:   [optional] 1 bpp pix giving corner locations
:param[out]   ppta_corners:   [optional] pta giving corner locations
:param[in]    pixadb:         [optional] pass in pre-allocated
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Use %nsels = 4 if the checkerboard may be rotated by more
than 20 deg.
(2) The values of %size and %dilation that can be used depend on
the square sizes.  Nominal values here are for squares of
size 30 to 50.  In general, because of the viewing angle
of the camera, the "squares" will appear approximately
as a rotated rectangle.
(3) The outputs pix_corners and pta_corners are optional.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixFindCheckerboardCorners(*args)
    
    

    try:
        leptonica.makeCheckerboardCornerSela.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.makeCheckerboardCornerSela.restype = lambda address: SELA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeCheckerboardCornerSela not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeCheckerboardCornerSela(*args):
        """
        ('l_int32', 'size')       
('l_int32', 'dilation')       
('l_int32', 'nsels')       
('PIXA', '*pixadb')       

:param[in]    size:         size of HMT sel; >= 7, typ. 15; 0 for default
:param[in]    dilation:     size of hit and miss squares; typ. 1 or 3; max 5
:param[in]    nsels:        number to use (either 2 or 4)
:param[in]    pixadb:       [optional] pass in pre-allocated
:returns:  sela   hit-miss sels for finding corners, or NULL on error

<pre>
Notes:
(1) Use 4 sels if the checkerboard may be rotated by more than 20 deg.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeCheckerboardCornerSela(*args)
    




class partify(object):
    """<pre>

Top level
l_int32          partifyFiles()
l_int32          partifyPixac()

Helpers
static BOXA     *pixLocateStaveSets()
static l_int32   boxaRemoveVGaps()
</pre>




"""
    
    try:
        leptonica.partifyFiles.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.partifyFiles.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function partifyFiles not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def partifyFiles(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'nparts')       
('const char', '*outroot')       
('const char', '*debugfile')       

:param[in]    dirname:    directory of files
:param[in]    substr:     required filename substring; use NULL for all files
:param[in]    nparts:     number of parts to generate (counting from top)
:param[in]    outroot:    root name of output pdf files
:param[in]    debugfile:  [optional] set to NULL for no debug output
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) All page images are compressed in png format into a pixacomp.
(2) Each page image is deskewed, binarized at 300 ppi,
partified into %nparts, and saved in a set of pixacomps
in tiff-g4 format.
(3) Each partified pixacomp is rendered into a set of page images,
and output as a pdf.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.partifyFiles(*args)
    
    

    try:
        leptonica.partifyPixac.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.partifyPixac.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function partifyPixac not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def partifyPixac(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'nparts')       
('const char', '*outroot')       
('PIXA', '*pixadb')       

:param[in]    pixac:      with at least one image
:param[in]    nparts:     number of parts to generate (counting from top)
:param[in]    outroot:    root name of output pdf files
:param[in]    pixadb:     [optional] debug pixa; can be NULL
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See partifyPixac().
(2) If the image files do not have a resolution, 300 ppi is assumed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.partifyPixac(*args)
    




class rbtree(object):
    """<pre>

Basic functions for using red-black trees.  These are "nearly" balanced
sorted trees with ordering by key that allows insertion, lookup and
deletion of key/value pairs in log(n) time.

We use red-black trees to implement our version of:
a map: a function that maps keys to values (e.g., int64 --> int64).
a set: a collection that is sorted by unique keys (without
associated values)

There are 5 invariant properties of RB trees:
(1) Each node is either red or black.
(2) The root node is black.
(3) All leaves are black and contain no data (null).
(4) Every red node has two children and both are black.  This is
equivalent to requiring the parent of every red node to be black.
(5) All paths from any given node to its leaf nodes contain the
same number of black nodes.

Interface to red-black tree
L_RBTREE       *l_rbtreeCreate()
RB_TYPE        *l_rbtreeLookup()
void            l_rbtreeInsert()
void            l_rbtreeDelete()
void            l_rbtreeDestroy()
L_RBTREE_NODE  *l_rbtreeGetFirst()
L_RBTREE_NODE  *l_rbtreeGetNext()
L_RBTREE_NODE  *l_rbtreeGetLast()
L_RBTREE_NODE  *l_rbtreeGetPrev()
l_int32         l_rbtreeGetCount()
void            l_rbtreePrint()

General comparison function
static l_int32  compareKeys()
</pre>




"""
    
    try:
        leptonica.l_rbtreeCreate.argtypes = [ctypes.c_int32]
        leptonica.l_rbtreeCreate.restype = lambda address: L_RBTREE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeCreate(*args):
        """
        ('l_int32', 'keytype')       

:param[in]   keytype:   defined by an enum for an RB_TYPE union
:returns:      rbtree    container with empty ptr to the root


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeCreate(*args)
    
    

    try:
        leptonica.l_rbtreeLookup.argtypes = [ctypes.c_void_p, RB_TYPE]
        leptonica.l_rbtreeLookup.restype = lambda address: RB_TYPE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeLookup not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeLookup(*args):
        """
        ('L_RBTREE', '*t')       
('RB_TYPE', 'key')       

:param[in]   t:        rbtree, including root node
:param[in]   key:      find a node with this key
:returns:    &value     a pointer to a union, if the node exists; else NULL


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeLookup(*args)
    
    

    try:
        leptonica.l_rbtreeInsert.argtypes = [ctypes.c_void_p, RB_TYPE, RB_TYPE]
        leptonica.l_rbtreeInsert.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeInsert not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeInsert(*args):
        """
        ('L_RBTREE', '*t')       
('RB_TYPE', 'key')       
('RB_TYPE', 'value')       

:param[in]   t:         rbtree, including root node
:param[in]   key:       insert a node with this key, if the key does not
already exist in the tree
:param[in]   value:     typically an int, used for an index
:returns:     void

<pre>
Notes:
(1) If a node with the key already exists, this just updates the value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeInsert(*args)
    
    

    try:
        leptonica.l_rbtreeDelete.argtypes = [ctypes.c_void_p, RB_TYPE]
        leptonica.l_rbtreeDelete.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeDelete not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeDelete(*args):
        """
        ('L_RBTREE', '*t')       
('RB_TYPE', 'key')       

:param[in]   t:     rbtree, including root node
:param[in]   key:   delete the node with this key
:returns:      void


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeDelete(*args)
    
    

    try:
        leptonica.l_rbtreeDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_rbtreeDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeDestroy(*args):
        """
        ('L_RBTREE', '**pt')       

:param[in]   pt:     pointer to tree; will be wet to null before returning
:returns:      void

<pre>
Notes:
(1) Destroys the tree and nulls the input tree ptr.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeDestroy(*args)
    
    

    try:
        leptonica.l_rbtreeGetFirst.argtypes = [ctypes.c_void_p]
        leptonica.l_rbtreeGetFirst.restype = lambda address: L_RBTREE_NODE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeGetFirst not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeGetFirst(*args):
        """
        ('L_RBTREE', '*t')       

:param[in]    t:    rbtree, including root node
:returns:       first node, or NULL on error or if the tree is empty

<pre>
Notes:
(1) This is the first node in an in-order traversal.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeGetFirst(*args)
    
    

    try:
        leptonica.l_rbtreeGetNext.argtypes = [ctypes.c_void_p]
        leptonica.l_rbtreeGetNext.restype = lambda address: L_RBTREE_NODE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeGetNext not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeGetNext(*args):
        """
        ('L_RBTREE_NODE', '*n')       

:param[in]    n:     current node
:returns:       next node, or NULL if it's the last node

<pre>
Notes:
(1) This finds the next node, in an in-order traversal, from
the current node.
(2) It is useful as an iterator for a map.
(3) Call l_rbtreeGetFirst() to get the first node.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeGetNext(*args)
    
    

    try:
        leptonica.l_rbtreeGetLast.argtypes = [ctypes.c_void_p]
        leptonica.l_rbtreeGetLast.restype = lambda address: L_RBTREE_NODE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeGetLast not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeGetLast(*args):
        """
        ('L_RBTREE', '*t')       

:param[in]   t:      rbtree, including root node
:returns:      last node, or NULL on error or if the tree is empty

<pre>
Notes:
(1) This is the last node in an in-order traversal.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeGetLast(*args)
    
    

    try:
        leptonica.l_rbtreeGetPrev.argtypes = [ctypes.c_void_p]
        leptonica.l_rbtreeGetPrev.restype = lambda address: L_RBTREE_NODE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeGetPrev not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeGetPrev(*args):
        """
        ('L_RBTREE_NODE', '*n')       

:param[in]    n:     current node
:returns:       next node, or NULL if it's the first node

<pre>
Notes:
(1) This finds the previous node, in an in-order traversal, from
the current node.
(2) It is useful as an iterator for a map.
(3) Call l_rbtreeGetLast() to get the last node.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeGetPrev(*args)
    
    

    try:
        leptonica.l_rbtreeGetCount.argtypes = [ctypes.c_void_p]
        leptonica.l_rbtreeGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreeGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreeGetCount(*args):
        """
        ('L_RBTREE', '*t')       

:param[in]  t:      rbtree
:returns:     count  the number of nodes in the tree, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreeGetCount(*args)
    
    

    try:
        leptonica.l_rbtreePrint.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_rbtreePrint.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_rbtreePrint not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_rbtreePrint(*args):
        """
        ('FILE', '*fp')       
('L_RBTREE', '*t')       

:param[in]    fp:    file stream
:param[in]    t:     rbtree
:returns:       void


        """
        args = _convert_params(*args)
        
        return leptonica.l_rbtreePrint(*args)
    




class quadtree(object):
    """<pre>

Top level quadtree linear statistics
l_int32   pixQuadtreeMean()
l_int32   pixQuadtreeVariance()

Statistics in an arbitrary rectangle
l_int32   pixMeanInRectangle()
l_int32   pixVarianceInRectangle()

Quadtree regions
BOXAA    *boxaaQuadtreeRegions()

Quadtree access
l_int32   quadtreeGetParent()
l_int32   quadtreeGetChildren()
l_int32   quadtreeMaxLevels()

Display quadtree
PIX      *fpixaDisplayQuadtree()


There are many other statistical quantities that can be computed
in a quadtree, such as rank values, and these can be added as
the need arises.

Similar results that can approximate a single level of the quadtree
can be generated by pixGetAverageTiled().  There we specify the
tile size over which the mean, mean square, and root variance
are generated; the results are saved in a (reduced size) pix.
Because the tile dimensions are integers, it is usually not possible
to obtain tilings that are a power of 2, as required for quadtrees.
</pre>




"""
    
    try:
        leptonica.pixQuadtreeMean.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixQuadtreeMean.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixQuadtreeMean not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadtreeMean(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('PIX', '*pix_ma')       
('FPIXA', '**pfpixa')       

:param[in]    pixs:     8 bpp, no colormap
:param[in]    nlevels:  in quadtree; max allowed depends on image size
:param[in]    pix_ma:   input mean accumulator; can be null
:param[out]   pfpixa:   mean values in quadtree
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The returned fpixa has %nlevels of fpix, each containing
the mean values at its level.  Level 0 has a
single value; level 1 has 4 values; level 2 has 16; etc.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadtreeMean(*args)
    
    

    try:
        leptonica.pixQuadtreeVariance.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixQuadtreeVariance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixQuadtreeVariance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixQuadtreeVariance(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'nlevels')       
('PIX', '*pix_ma')       
('DPIX', '*dpix_msa')       
('FPIXA', '**pfpixa_v')       
('FPIXA', '**pfpixa_rv')       

:param[in]    pixs:        8 bpp, no colormap
:param[in]    nlevels:     in quadtree
:param[in]    pix_ma:      input mean accumulator; can be null
:param[in]    dpix_msa:    input mean square accumulator; can be null
:param[out]   pfpixa_v:    [optional] variance values in quadtree
:param[out]   pfpixa_rv:   [optional] root variance values in quadtree
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The returned fpixav and fpixarv have %nlevels of fpix,
each containing at the respective levels the variance
and root variance values.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixQuadtreeVariance(*args)
    
    

    try:
        leptonica.pixMeanInRectangle.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixMeanInRectangle.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixMeanInRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixMeanInRectangle(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('PIX', '*pixma')       
('l_float32', '*pval')       

:param[in]    pixs:     8 bpp
:param[in]    box:      region to compute mean value
:param[in]    pixma:    mean accumulator
:param[out]   pval:     mean value
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function is intended to be used for many rectangles
on the same image.  It can find the mean within a
rectangle in O(1), independent of the size of the rectangle.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixMeanInRectangle(*args)
    
    

    try:
        leptonica.pixVarianceInRectangle.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixVarianceInRectangle.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixVarianceInRectangle not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixVarianceInRectangle(*args):
        """
        ('PIX', '*pixs')       
('BOX', '*box')       
('PIX', '*pix_ma')       
('DPIX', '*dpix_msa')       
('l_float32', '*pvar')       
('l_float32', '*prvar')       

:param[in]    pixs:        8 bpp
:param[in]    box:         region to compute variance and/or root variance
:param[in]    pix_ma:      mean accumulator
:param[in]    dpix_msa:    mean square accumulator
:param[out]   pvar:        [optional] variance
:param[out]   prvar:       [optional] root variance
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This function is intended to be used for many rectangles
on the same image.  It can find the variance and/or the
square root of the variance within a rectangle in O(1),
independent of the size of the rectangle.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixVarianceInRectangle(*args)
    
    

    try:
        leptonica.boxaaQuadtreeRegions.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.boxaaQuadtreeRegions.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function boxaaQuadtreeRegions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def boxaaQuadtreeRegions(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       
('l_int32', 'nlevels')       

:param[in]    w,: h     size of pix that is being quadtree-ized
:param[in]    nlevels:  number of levels in quadtree
:returns:  baa for quadtree regions at each level, or NULL on error

<pre>
Notes:
(1) The returned boxaa has %nlevels of boxa, each containing
the set of rectangles at that level.  The rectangle at
level 0 is the entire region; at level 1 the region is
divided into 4 rectangles, and at level n there are n^4
rectangles.
(2) At each level, the rectangles in the boxa are in "raster"
order, with LR (fast scan) and TB (slow scan).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.boxaaQuadtreeRegions(*args)
    
    

    try:
        leptonica.quadtreeGetParent.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.quadtreeGetParent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function quadtreeGetParent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def quadtreeGetParent(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'level')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pval')       

:param[in]    fpixa:      mean, variance or root variance
:param[in]    level,:     x, y of current pixel
:param[out]   pval:       parent pixel value, or 0.0 on error
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Check return value for error.  On error, val is returned as 0.0.
(2) The parent is located at:
level - 1
(x/2, y/2)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.quadtreeGetParent(*args)
    
    

    try:
        leptonica.quadtreeGetChildren.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.quadtreeGetChildren.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function quadtreeGetChildren not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def quadtreeGetChildren(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'level')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_float32', '*pval00')       
('l_float32', '*pval10')       
('l_float32', '*pval01')       
('l_float32', '*pval11')       

:param[in]    fpixa:            mean, variance or root variance
:param[in]    level,:           x, y of current pixel
:param[out]   pval00,: pval01,
pval10, pval11   four child pixel values
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Check return value for error.  On error, all return vals are 0.0.
(2) The returned child pixels are located at:
level + 1
(2x, 2y), (2x+1, 2y), (2x, 2y+1), (2x+1, 2y+1)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.quadtreeGetChildren(*args)
    
    

    try:
        leptonica.quadtreeMaxLevels.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.quadtreeMaxLevels.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function quadtreeMaxLevels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def quadtreeMaxLevels(*args):
        """
        ('l_int32', 'w')       
('l_int32', 'h')       

:param[in]    w,: h    dimensions of image
:returns:  maxlevels  maximum number of levels allowed, or -1 on error

<pre>
Notes:
(1) The criterion for maxlevels is that the subdivision not
go down below the single pixel level.  The 1.5 factor
is intended to keep any rectangle from accidentally
having zero dimension due to integer truncation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.quadtreeMaxLevels(*args)
    
    

    try:
        leptonica.fpixaDisplayQuadtree.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.fpixaDisplayQuadtree.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function fpixaDisplayQuadtree not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def fpixaDisplayQuadtree(*args):
        """
        ('FPIXA', '*fpixa')       
('l_int32', 'factor')       
('l_int32', 'fontsize')       

:param[in]    fpixa:     mean, variance or root variance
:param[in]    factor:    replication factor at lowest level
:param[in]    fontsize:  4, ... 20
:returns:  pixd 8 bpp, mosaic of quadtree images, or NULL on error

<pre>
Notes:
(1) The mean and root variance fall naturally in the 8 bpp range,
but the variance is typically outside the range.  This
function displays 8 bpp pix clipped to 255, so the image
pixels will mostly be 255 (white).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.fpixaDisplayQuadtree(*args)
    




class map(object):
    """<pre>

This is an interface for map and set functions, based on using
red-black binary search trees.  Because these trees are sorted,
they are O(nlogn) to build.  They allow logn insertion, find
and deletion of elements.

Both the map and set are ordered by key value, with unique keys.
For the map, the elements are key/value pairs.
For the set we only store unique, ordered keys, and the value
(set to 0 in the implementation) is ignored.

The keys for the map and set can be any of the three types in the
l_rbtree_keytype enum.  The values stored can be any of the four
types in the rb_type union.

In-order forward and reverse iterators are provided for maps and sets.
To forward iterate over the map for any type of key (in this example,
uint32), extracting integer values:

L_AMAP  *m = l_amapCreate(L_UINT_TYPE);
[add elements to the map ...]
L_AMAP_NODE  *n = l_amapGetFirst(m);
while (n) {
l_int32 val = n->value.itype;
// do something ...
n = l_amapGetNext(n);
}

If the nodes are deleted during the iteration:

L_AMAP  *m = l_amapCreate(L_UINT_TYPE);
[add elements to the map ...]
L_AMAP_NODE  *n = l_amapGetFirst(m);
L_AMAP_NODE  *nn;
while (n) {
nn = l_amapGetNext(n);
l_int32 val = n->value.itype;
l_uint32 key = n->key.utype;
// do something ...
l_amapDelete(m, n->key);
n = nn;
}

See prog/maptest.c and prog/settest.c for more examples of usage.

Interface to (a) map using a general key and storing general values
L_AMAP        *l_amapCreate()
RB_TYPE       *l_amapFind()
void           l_amapInsert()
void           l_amapDelete()
void           l_amapDestroy()
L_AMAP_NODE   *l_amapGetFirst()
L_AMAP_NODE   *l_amapGetNext()
L_AMAP_NODE   *l_amapGetLast()
L_AMAP_NODE   *l_amapGetPrev()
l_int32        l_amapSize()

Interface to (a) set using a general key
L_ASET        *l_asetCreate()
RB_TYPE       *l_asetFind()
void           l_asetInsert()
void           l_asetDelete()
void           l_asetDestroy()
L_ASET_NODE   *l_asetGetFirst()
L_ASET_NODE   *l_asetGetNext()
L_ASET_NODE   *l_asetGetLast()
L_ASET_NODE   *l_asetGetPrev()
l_int32        l_asetSize()
</pre>




"""
    



class encoding(object):
    """"""
    
    try:
        leptonica.encodeBase64.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.encodeBase64.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function encodeBase64 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def encodeBase64(*args):
        """
        ('const l_uint8', '*inarray')       
('l_int32', 'insize')       
('l_int32', '*poutsize')       

:param[in]    inarray:     input binary data
:param[in]    insize:      number of bytes in input array
:param[out]   poutsize:    number of bytes in output char array
:returns:  chara with MAX_BASE64_LINE characters + \n in each line

<pre>
Notes:
(1) The input character data is unrestricted binary.
The output encoded data consists of the 64 characters
in the base64 set, plus newlines and the pad character '='.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.encodeBase64(*args)
    
    

    try:
        leptonica.decodeBase64.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.decodeBase64.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function decodeBase64 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def decodeBase64(*args):
        """
        ('const char', '*inarray')       
('l_int32', 'insize')       
('l_int32', '*poutsize')       

:param[in]    inarray:    input encoded char data, with 72 chars/line)
:param[in]    insize:     number of bytes in input array
:param[out]   poutsize:   number of bytes in output byte array
:returns:  bytea decoded byte data, or NULL on error

<pre>
Notes:
(1) The input character data should have only 66 different characters:
The 64 character set for base64 encoding, plus the pad
character '=' and newlines for formatting with fixed line
lengths.  If there are any other characters, the decoder
will declare the input data to be invalid and return NULL.
(2) The decoder ignores newlines and, for a valid input string,
stops reading input when a pad byte is found.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.decodeBase64(*args)
    
    

    try:
        leptonica.encodeAscii85.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.encodeAscii85.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function encodeAscii85 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def encodeAscii85(*args):
        """
        ('const l_uint8', '*inarray')       
('l_int32', 'insize')       
('l_int32', '*poutsize')       

:param[in]    inarray:    input data
:param[in]    insize:     number of bytes in input array
:param[out]   poutsize:   number of bytes in output char array
:returns:  chara with 64 characters + \n in each line

<pre>
Notes:
(1) Ghostscript has a stack break if the last line of
data only has a '>', so we avoid the problem by
always putting '~>' on the last line.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.encodeAscii85(*args)
    
    

    try:
        leptonica.decodeAscii85.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.decodeAscii85.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function decodeAscii85 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def decodeAscii85(*args):
        """
        ('const char', '*inarray')       
('l_int32', 'insize')       
('l_int32', '*poutsize')       

:param[in]    inarray:     ascii85 input data
:param[in]    insize:      number of bytes in input array
:param[out]   poutsize:    number of bytes in output l_uint8 array
:returns:  outarray binary

<pre>
Notes:
(1) We assume the data is properly encoded, so we do not check
for invalid characters or the final '>' character.
(2) We permit whitespace to be added to the encoding in an
arbitrary way.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.decodeAscii85(*args)
    
    

    try:
        leptonica.reformatPacked64.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.reformatPacked64.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function reformatPacked64 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def reformatPacked64(*args):
        """
        ('const char', '*inarray')       
('l_int32', 'insize')       
('l_int32', 'leadspace')       
('l_int32', 'linechars')       
('l_int32', 'addquotes')       
('l_int32', '*poutsize')       

:param[in]    inarray:     base64 encoded string with newlines
:param[in]    insize:      number of bytes in input array
:param[in]    leadspace:   number of spaces in each line before the data
:param[in]    linechars:   number of bytes of data in each line; multiple of 4
:param[in]    addquotes:   1 to add quotes to each line of data; 0 to skip
:param[out]   poutsize:    number of bytes in output char array
:returns:  outarray ascii

<pre>
Notes:
(1) Each line in the output array has %leadspace space characters,
followed optionally by a double-quote, followed by %linechars
bytes of base64 data, followed optionally by a double-quote,
followed by a newline.
(2) This can be used to convert a base64 encoded string to a
string formatted for inclusion in a C source file.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.reformatPacked64(*args)
    




class stringcode(object):
    """<pre>

Generation of code for storing and extracting serializable
leptonica objects (such as pixa, recog, ...).

The input is a set of files with serialized data.
The output is two files, that must be compiled and linked:
~ autogen.*.c: code for base64 unencoding the strings and
deserializing the result.
~ autogen.*.h: function prototypes and base64 encoded strings
of the input data

This should work for any data structures in leptonica that have
Write() and *Read() serialization functions.  An array of 20
of these, including the Pix, is given below.  (The Pix is a special
case, because it is serialized by standardized compression
techniques, instead of a file format determined by leptonica.)

Each time the generator function is invoked, three sets of strings are
produced, which are written into their respective string arrays:
~ string of serialized, gzipped and base 64 encoded data
~ case string for base64 decoding, gunzipping and deserialization,
to return the data struct in memory
~ description string for selecting which struct to return
To create the two output files, a finalize function is invoked.

There are two ways to do this, both shown in prog/autogentest1.c.
~ Explicitly call strcodeGenerate() for each file with the
serialized data structure, followed by strcodeFinalize().
~ Put the filenames of the serialized data structures in a file,
and call strcodeCreateFromFile().

The generated code in autogen.X.c and autogen.X.h (where X is an
integer supplied to strcodeCreate()) is then compiled, and the
original data can be regenerated using the function l_autodecode_X().
A test example is found in the two prog files:
prog/autogentest1.c  -- generates autogen.137.c, autogen.137.h
prog/autogentest2.c  -- uses autogen.137.c, autogen.137.h
In general, the generator (e.g., autogentest1) would be compiled and
run before compiling and running the application (e.g., autogentest2).

L_STRCODE       *strcodeCreate()
static void      strcodeDestroy()    (called as part of finalize)
void             strcodeCreateFromFile()
l_int32          strcodeGenerate()
l_int32          strcodeFinalize()
l_int32          l_getStructStrFromFile()   (useful externally)

Static helpers
static l_int32   l_getIndexFromType()
static l_int32   l_getIndexFromStructname()
static l_int32   l_getIndexFromFile()
static char     *l_genDataString()
static char     *l_genCaseString()
static char     *l_genDescrString()
</pre>




"""
    
    try:
        leptonica.strcodeCreate.argtypes = [ctypes.c_int32]
        leptonica.strcodeCreate.restype = lambda address: L_STRCODE(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function strcodeCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def strcodeCreate(*args):
        """
        ('l_int32', 'fileno')       

:param[in]    fileno:    integer that labels the two output files
:returns:  initialized L_StrCode, or NULL on error

<pre>
Notes:
(1) This struct exists to build two files containing code for
any number of data objects.  The two files are named
autogen.[fileno].c
autogen.[fileno].h
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.strcodeCreate(*args)
    
    

    try:
        leptonica.strcodeCreateFromFile.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.strcodeCreateFromFile.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function strcodeCreateFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def strcodeCreateFromFile(*args):
        """
        ('const char', '*filein')       
('l_int32', 'fileno')       
('const char', '*outdir')       

:param[in]    filein:    containing filenames of serialized data
:param[in]    fileno:    integer that labels the two output files
:param[in]    outdir:    [optional] if null, files are made in /tmp/lept/auto
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The %filein has one filename on each line.
Comment lines begin with "#".
(2) The output is 2 files:
autogen.[fileno].c
autogen.[fileno].h
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.strcodeCreateFromFile(*args)
    
    

    try:
        leptonica.strcodeGenerate.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.strcodeGenerate.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function strcodeGenerate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def strcodeGenerate(*args):
        """
        ('L_STRCODE', '*strcode')       
('const char', '*filein')       
('const char', '*type')       

:param[in]    strcode:    for accumulating data
:param[in]    filein:     input file with serialized data
:param[in]    type:       of data; use the typedef string
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) The generated function name is
l_autodecode_[fileno]()
where [fileno] is the index label for the pair of output files.
(2) To deserialize this data, the function is called with the
argument 'ifunc', which increments each time strcodeGenerate()
is called.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.strcodeGenerate(*args)
    
    

    try:
        leptonica.strcodeFinalize.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.strcodeFinalize.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function strcodeFinalize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def strcodeFinalize(*args):
        """
        ('L_STRCODE', '**pstrcode')       
('const char', '*outdir')       

:param[in,out]  pstrcode:   destroys and sets to null after .c and .h files
have been generated
:param[in]      outdir:     [optional] if NULL, make files in /tmp/lept/auto
:returns:     0 if OK; 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.strcodeFinalize(*args)
    
    

    try:
        leptonica.l_getStructStrFromFile.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.l_getStructStrFromFile.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function l_getStructStrFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_getStructStrFromFile(*args):
        """
        ('const char', '*filename')       
('l_int32', 'field')       
('char', '**pstr')       

:param[in]    filename:
:param[in]    field:   (L_STR_TYPE, L_STR_NAME, L_STR_READER, L_STR_MEMREADER)
:param[out]   pstr:    struct string for this file
:returns:  0 if found, 1 on error.

<pre>
Notes:
(1) For example, if %field == L_STR_NAME, and the file is a serialized
pixa, this will return "Pixa", the name of the struct.
(2) Caller must free the returned string.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_getStructStrFromFile(*args)
    




class bilateral(object):
    """<pre>

Top level approximate separable grayscale or color bilateral filtering
PIX                 *pixBilateral()
PIX                 *pixBilateralGray()

Implementation of approximate separable bilateral filter
static L_BILATERAL  *bilateralCreate()
static void         *bilateralDestroy()
static PIX          *bilateralApply()

Slow, exact implementation of grayscale or color bilateral filtering
PIX                 *pixBilateralExact()
PIX                 *pixBilateralGrayExact()
PIX                 *pixBlockBilateralExact()

Kernel helper function
L_KERNEL            *makeRangeKernel()

This includes both a slow, exact implementation of the bilateral
filter algorithm (given by Sylvain Paris and Frédo Durand),
and a fast, approximate and separable implementation (following
Yang, Tan and Ahuja).  See bilateral.h for algorithmic details.

The bilateral filter has the nice property of applying a gaussian
filter to smooth parts of the image that don't vary too quickly,
while at the same time preserving edges.  The filter is nonlinear
and cannot be decomposed into two separable filters; however,
there exists an approximate method that is separable.  To further
speed up the separable implementation, you can generate the
intermediate data at reduced resolution.

The full kernel is composed of two parts: a spatial gaussian filter
and a nonlinear "range" filter that depends on the intensity difference
between the reference pixel at the spatial kernel origin and any other
pixel within the kernel support.

In our implementations, the range filter is a parameterized,
one-sided, 256-element, monotonically decreasing gaussian function
of the absolute value of the difference between pixel values; namely,
abs(I2 - I1).  In general, any decreasing function can be used,
and more generally,  any two-dimensional kernel can be used if
you wish to relax the 'abs' condition.  (In that case, the range
filter can be 256 x 256).
</pre>




"""
    
    try:
        leptonica.pixBilateral.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBilateral.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilateral not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilateral(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'spatial_stdev')       
('l_float32', 'range_stdev')       
('l_int32', 'ncomps')       
('l_int32', 'reduction')       

:param[in]    pixs:            8 bpp gray or 32 bpp rgb, no colormap
:param[in]    spatial_stdev:   of gaussian kernel; in pixels, > 0.5
:param[in]    range_stdev:     of gaussian range kernel; > 5.0; typ. 50.0
:param[in]    ncomps:          number of intermediate sums J(k,x);
in [4 ... 30]
:param[in]    reduction:       1, 2 or 4
:returns:  pixd   bilateral filtered image, or NULL on error

<pre>
Notes:
(1) This performs a relatively fast, separable bilateral
filtering operation.  The time is proportional to ncomps
and varies inversely approximately as the cube of the
reduction factor.  See bilateral.h for algorithm details.
(2) We impose minimum values for range_stdev and ncomps to
avoid nasty artifacts when either are too small.  We also
impose a constraint on their product:
ncomps * range_stdev >= 100.
So for values of range_stdev >= 25, ncomps can be as small as 4.
Here is a qualitative, intuitive explanation for this constraint.
Call the difference in k values between the J(k) == 'delta', where
'delta' ~ 200 / ncomps
Then this constraint is roughly equivalent to the condition:
'delta' < 2 * range_stdev
Note that at an intensity difference of (2 * range_stdev), the
range part of the kernel reduces the effect by the factor 0.14.
This constraint requires that we have a sufficient number of
PCBs (i.e, a small enough 'delta'), so that for any value of
image intensity I, there exists a k (and a PCB, J(k), such that
|I - k| < range_stdev
Any fewer PCBs and we don't have enough to support this condition.
(3) The upper limit of 30 on ncomps is imposed because the
gain in accuracy is not worth the extra computation.
(4) The size of the gaussian kernel is twice the spatial_stdev
on each side of the origin.  The minimum value of
spatial_stdev, 0.5, is required to have a finite sized
spatial kernel.  In practice, a much larger value is used.
(5) Computation of the intermediate images goes inversely
as the cube of the reduction factor.  If you can use a
reduction of 2 or 4, it is well-advised.
(6) The range kernel is defined over the absolute value of pixel
grayscale differences, and hence must have size 256 x 1.
Values in the array represent the multiplying weight
depending on the absolute gray value difference between
the source pixel and the neighboring pixel, and should
be monotonically decreasing.
(7) Interesting observation.  Run this on prog/fish24.jpg, with
range_stdev = 60, ncomps = 6, and spatial_dev = {10, 30, 50}.
As spatial_dev gets larger, we get the counter-intuitive
result that the body of the red fish becomes less blurry.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilateral(*args)
    
    

    try:
        leptonica.pixBilateralGray.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixBilateralGray.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilateralGray not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilateralGray(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'spatial_stdev')       
('l_float32', 'range_stdev')       
('l_int32', 'ncomps')       
('l_int32', 'reduction')       

:param[in]    pixs:             8 bpp gray
:param[in]    spatial_stdev:    of gaussian kernel; in pixels, > 0.5
:param[in]    range_stdev:      of gaussian range kernel; > 5.0; typ. 50.0
:param[in]    ncomps:           number of intermediate sums J(k,x);
in [4 ... 30]
:param[in]    reduction:        1, 2 or 4
:returns:  pixd   8 bpp bilateral filtered image, or NULL on error

<pre>
Notes:
(1) See pixBilateral() for constraints on the input parameters.
(2) See pixBilateral() for algorithm details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilateralGray(*args)
    
    

    try:
        leptonica.pixBilateralExact.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBilateralExact.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilateralExact not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilateralExact(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*spatial_kel')       
('L_KERNEL', '*range_kel')       

:param[in]    pixs:          8 bpp gray or 32 bpp rgb
:param[in]    spatial_kel:   gaussian kernel
:param[in]    range_kel:     [optional] 256 x 1, monotonically decreasing
:returns:  pixd   8 bpp bilateral filtered image

<pre>
Notes:
(1) The spatial_kel is a conventional smoothing kernel, typically a
2-d Gaussian kernel or other block kernel.  It can be either
normalized or not, but must be everywhere positive.
(2) The range_kel is defined over the absolute value of pixel
grayscale differences, and hence must have size 256 x 1.
Values in the array represent the multiplying weight for each
gray value difference between the target pixel and center of the
kernel, and should be monotonically decreasing.
(3) If range_kel == NULL, a constant weight is applied regardless
of the range value difference.  This degenerates to a regular
pixConvolve() with a normalized kernel.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilateralExact(*args)
    
    

    try:
        leptonica.pixBilateralGrayExact.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixBilateralGrayExact.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBilateralGrayExact not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBilateralGrayExact(*args):
        """
        ('PIX', '*pixs')       
('L_KERNEL', '*spatial_kel')       
('L_KERNEL', '*range_kel')       

:param[in]    pixs:          8 bpp gray
:param[in]    spatial_kel:   gaussian kernel
:param[in]    range_kel:     [optional] 256 x 1, monotonically decreasing
:returns:  pixd   8 bpp bilateral filtered image

<pre>
Notes:
(1) See pixBilateralExact().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBilateralGrayExact(*args)
    
    

    try:
        leptonica.pixBlockBilateralExact.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_float]
        leptonica.pixBlockBilateralExact.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixBlockBilateralExact not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixBlockBilateralExact(*args):
        """
        ('PIX', '*pixs')       
('l_float32', 'spatial_stdev')       
('l_float32', 'range_stdev')       

:param[in]    pixs:             8 bpp gray or 32 bpp rgb
:param[in]    spatial_stdev:    must be > 0.0
:param[in]    range_stdev:      must be > 0.0
:returns:  pixd   8 bpp or 32 bpp bilateral filtered image

<pre>
Notes:
(1) See pixBilateralExact().  This provides an interface using
the standard deviations of the spatial and range filters.
(2) The convolution window halfwidth is 2 * spatial_stdev,
and the square filter size is 4 * spatial_stdev + 1.
The kernel captures 95% of total energy.  This is compensated
by normalization.
(3) The range_stdev is analogous to spatial_halfwidth in the
grayscale domain [0...255], and determines how much damping of the
smoothing operation is applied across edges.  The larger this
value is, the smaller the damping.  The smaller the value, the
more edge details are preserved.  These approximations are useful
for deciding the appropriate cutoff.
kernel[1 * stdev] ~= 0.6  * kernel[0]
kernel[2 * stdev] ~= 0.14 * kernel[0]
kernel[3 * stdev] ~= 0.01 * kernel[0]
If range_stdev is infinite there is no damping, and this
becomes a conventional gaussian smoothing.
This value does not affect the run time.
(4) If range_stdev is negative or zero, the range kernel is
ignored and this degenerates to a straight gaussian convolution.
(5) This is very slow for large spatial filters.  The time
on a 3GHz pentium is roughly
T = 1.2 * 10^-8 * (A * sh^2)  sec
where A = # of pixels, sh = spatial halfwidth of filter.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixBlockBilateralExact(*args)
    
    

    try:
        leptonica.makeRangeKernel.argtypes = [ctypes.c_float]
        leptonica.makeRangeKernel.restype = lambda address: L_KERNEL(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function makeRangeKernel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def makeRangeKernel(*args):
        """
        ('l_float32', 'range_stdev')       

:param[in]    range_stdev:   must be > 0.0
:returns:  kel, or NULL on error

<pre>
Notes:
(1) Creates a one-sided Gaussian kernel with the given
standard deviation.  At grayscale difference of one stdev,
the kernel falls to 0.6, and to 0.01 at three stdev.
(2) A typical input number might be 20.  Then pixels whose
value differs by 60 from the center pixel have their
weight in the convolution reduced by a factor of about 0.01.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.makeRangeKernel(*args)
    




class pixlabel(object):
    """<pre>

Label pixels by an index for connected component membership
PIX         *pixConnCompTransform()

Label pixels by the area of their connected component
PIX         *pixConnCompAreaTransform()

Label pixels to allow incremental computation of connected components
l_int32      pixConnCompIncrInit()
l_int32      pixConnCompIncrAdd()
l_int32      pixGetSortedNeighborValues()

Label pixels with spatially-dependent color coding
PIX         *pixLocToColorTransform()

Pixels get labelled in various ways throughout the leptonica library,
but most of the labelling is implicit, where the new value isn't
even considered to be a label -- it is just a transformed pixel value
that may be transformed again by another operation.  Quantization
by thresholding, and dilation by a structuring element, are examples
of these typical image processing operations.

However, there are some explicit labelling procedures that are useful
as end-points of analysis, where it typically would not make sense
to do further image processing on the result.  Assigning false color
based on pixel properties is an example of such labelling operations.
Such operations typically have 1 bpp input images, and result
in grayscale or color images.

The procedures in this file are concerned with such explicit labelling.
Some of these labelling procedures are also in other places in leptonica:

runlength.c:
This file has two labelling transforms based on runlengths:
pixStrokeWidthTransform() and pixvRunlengthTransform().
The pixels are labelled based on the width of the "stroke" to
which they belong, or on the length of the horizontal or
vertical run in which they are a member.  Runlengths can easily
be filtered using a threshold.

pixafunc2.c:
This file has an operation, pixaDisplayRandomCmap(), that
randomly labels pix in a pixa (that are typically found using
pixConnComp) with up to 256 values, and assigns each value to
a random colormap color.

seedfill.c:
This file has pixDistanceFunction(), that labels each pixel with
its distance from either the foreground or the background.
</pre>




"""
    
    try:
        leptonica.pixConnCompTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixConnCompTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConnCompTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connect')       
('l_int32', 'depth')       

:param[in]     pixs:       1 bpp
:param[in]     connect:    connectivity: 4 or 8
:param[in]     depth:      of pixd: 8 or 16 bpp; use 0 for auto determination
:returns:   pixd   8, 16 or 32 bpp, or NULL on error

<pre>
Notes:
(1) pixd is 8, 16 or 32 bpp, and the pixel values label the
fg component, starting with 1.  Pixels in the bg are labelled 0.
(2) If %depth = 0, the depth of pixd is 8 if the number of c.c.
is less than 254, 16 if the number of c.c is less than 0xfffe,
and 32 otherwise.
(3) If %depth = 8, the assigned label for the n-th component is
1 + n % 254.  We use mod 254 because 0 is uniquely assigned
to black: e.g., see pixcmapCreateRandom().  Likewise,
if %depth = 16, the assigned label uses mod(2^16 - 2), and
if %depth = 32, no mod is taken.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompTransform(*args)
    
    

    try:
        leptonica.pixConnCompAreaTransform.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConnCompAreaTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixConnCompAreaTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompAreaTransform(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'connect')       

:param[in]     pixs:       1 bpp
:param[in]     connect:    connectivity: 4 or 8
:returns:   pixd   32 bpp, 1 spp, or NULL on error

<pre>
Notes:
(1) The pixel values in pixd label the area of the fg component
to which the pixel belongs.  Pixels in the bg are labelled 0.
(2) For purposes of visualization, the output can be converted
to 8 bpp, using pixConvert32To8() or pixMaxDynamicRange().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompAreaTransform(*args)
    
    

    try:
        leptonica.pixConnCompIncrInit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConnCompIncrInit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixConnCompIncrInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompIncrInit(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'conn')       
('PIX', '**ppixd')       
('PTAA', '**pptaa')       
('l_int32', '*pncc')       

:param[in]     pixs:     1 bpp
:param[in]     conn:     connectivity: 4 or 8
:param[out]    ppixd:    32 bpp, with c.c. labelled
:param[out]    pptaa:    with pixel locations indexed by c.c.
:param[out]    pncc:     initial number of c.c.
:returns:   0 if OK, 1 on error

<pre>
Notes:
(1) This labels the connected components in a 1 bpp pix, and
additionally sets up a ptaa that lists the locations of pixels
in each of the components.
(2) It can be used to initialize the output image and arrays for
an application that maintains information about connected
components incrementally as pixels are added.
(3) pixs can be empty or have some foreground pixels.
(4) The connectivity is stored in pixd->special.
(5) Always initialize with the first pta in ptaa being empty
and representing the background value (index 0) in the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompIncrInit(*args)
    
    

    try:
        leptonica.pixConnCompIncrAdd.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.pixConnCompIncrAdd.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixConnCompIncrAdd not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConnCompIncrAdd(*args):
        """
        ('PIX', '*pixs')       
('PTAA', '*ptaa')       
('l_int32', '*pncc')       
('l_float32', 'x')       
('l_float32', 'y')       
('l_int32', 'debug')       

:param[in]     pixs:     32 bpp, with pixels labeled by c.c.
:param[in]     ptaa:     with each pta of pixel locations indexed by c.c.
:param[out]    pncc:     number of c.c
:param[in]     x,y:      location of added pixel
:param[in]     debug:    0 for no output; otherwise output whenever
debug <= nvals, up to debug == 3
:returns:   -1 if nothing happens; 0 if a pixel is added; 1 on error

<pre>
Notes:
(1) This adds a pixel and updates the labeled connected components.
Before calling this function, initialize the process using
pixConnCompIncrInit().
(2) As a result of adding a pixel, one of the following can happen,
depending on the number of neighbors with non-zero value:
(a) nothing: the pixel is already a member of a c.c.
(b) no neighbors: a new component is added, increasing the
number of c.c.
(c) one neighbor: the pixel is added to an existing c.c.
(d) more than one neighbor: the added pixel causes joining of
two or more c.c., reducing the number of c.c.  A maximum
of 4 c.c. can be joined.
(3) When two c.c. are joined, the pixels in the larger index are
relabeled to those of the smaller in pixs, and their locations
are transferred to the pta with the smaller index in the ptaa.
The pta corresponding to the larger index is then deleted.
(4) This is an efficient implementation of a "union-find" operation,
which supports the generation and merging of disjoint sets
of pixels.  This function can be called about 1.3 million times
per second.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConnCompIncrAdd(*args)
    
    

    try:
        leptonica.pixGetSortedNeighborValues.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixGetSortedNeighborValues.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGetSortedNeighborValues not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGetSortedNeighborValues(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'conn')       
('l_int32', '**pneigh')       
('l_int32', '*pnvals')       

:param[in]     pixs:     8, 16 or 32 bpp, with pixels labeled by c.c.
:param[in]     x,: y     location of pixel
:param[in]     conn:     4 or 8 connected neighbors
:param[out]    pneigh:   array of integers, to be filled with
the values of the neighbors, if any
:param[out]    pnvals:   the number of unique neighbor values found
:returns:   0 if OK, 1 on error

<pre>
Notes:
(1) The returned %neigh array is the unique set of neighboring
pixel values, of size nvals, sorted from smallest to largest.
The value 0, which represents background pixels that do
not belong to any set of connected components, is discarded.
(2) If there are no neighbors, this returns %neigh = NULL; otherwise,
the caller must free the array.
(3) For either 4 or 8 connectivity, the maximum number of unique
neighbor values is 4.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGetSortedNeighborValues(*args)
    
    

    try:
        leptonica.pixLocToColorTransform.argtypes = [ctypes.c_void_p]
        leptonica.pixLocToColorTransform.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixLocToColorTransform not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixLocToColorTransform(*args):
        """
        ('PIX', '*pixs')       

:param[in]     pixs:    1 bpp
:returns:   pixd   32 bpp rgb, or NULL on error

<pre>
Notes:
(1) This generates an RGB image where each component value
is coded depending on the (x.y) location and the size
of the fg connected component that the pixel in pixs belongs to.
It is independent of the 4-fold orthogonal orientation, and
only weakly depends on translations and small angle rotations.
Background pixels are black.
(2) Such encodings can be compared between two 1 bpp images
by performing this transform and calculating the
"earth-mover" distance on the resulting R,G,B histograms.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixLocToColorTransform(*args)
    




class bootnumgen1(object):
    """<pre>

Function for generating prog/recog/digits/bootnum1.pa from an
encoded, gzipped and serialized string.

This was generated using the stringcode utility, slightly edited,
and then merged into a single file.

The code and encoded strings were made using the stringcode utility:

L_STRCODE  *strc;
strc = strcodeCreate(101);   // arbitrary integer
strcodeGenerate(strc, "recog/digits/bootnum1.pa", "PIXA");
strcodeFinalize(&strc, ".");

The two output files, autogen.101.c and autogen.101.h, were
then slightly edited and merged into this file.

Call this way:
PIXA  *pixa = l_bootnum_gen1();   (C)
Pixa  *pixa = l_bootnum_gen1();   (C++)
</pre>




"""
    
    try:
        leptonica.l_bootnum_gen1.argtypes = []
        leptonica.l_bootnum_gen1.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_bootnum_gen1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_bootnum_gen1(*args):
        """
               

:returns:   pixa  of labeled digits

<pre>
Call this way:
PIXA  *pixa = l_bootnum_gen1();   (C)
Pixa  *pixa = l_bootnum_gen1();   (C++)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_bootnum_gen1(*args)
    




class bootnumgen2(object):
    """<pre>

Function for generating prog/recog/digits/bootnum2.pa from an
encoded, gzipped and serialized string.

This was generated using the stringcode utility, slightly edited,
and then merged into a single file.

The code and encoded strings were made using the stringcode utility:

L_STRCODE  *strc;
strc = strcodeCreate(102);   // arbitrary integer
strcodeGenerate(strc, "recog/digits/bootnum2.pa", "PIXA");
strcodeFinalize(&strc, ".");

The two output files, autogen.102.c and autogen.102.h, were
then slightly edited and merged into this file.

Call this way:
PIXA  *pixa = l_bootnum_gen2();   (C)
Pixa  *pixa = l_bootnum_gen2();   (C++)
</pre>




"""
    
    try:
        leptonica.l_bootnum_gen2.argtypes = []
        leptonica.l_bootnum_gen2.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_bootnum_gen2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_bootnum_gen2(*args):
        """
               

:returns:   pixa  of labeled digits

<pre>
Call this way:
PIXA  *pixa = l_bootnum_gen2();   (C)
Pixa  *pixa = l_bootnum_gen2();   (C++)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_bootnum_gen2(*args)
    




class bootnumgen3(object):
    """"""
    
    try:
        leptonica.l_bootnum_gen3.argtypes = []
        leptonica.l_bootnum_gen3.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_bootnum_gen3 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_bootnum_gen3(*args):
        """
               

:returns:   pixa  of labeled digits

<pre>
Call this way:
PIXA  *pixa = l_bootnum_gen3();   (C)
Pixa  *pixa = l_bootnum_gen3();   (C++)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_bootnum_gen3(*args)
    




class bootnumgen4(object):
    """<pre>

Function for re-generating prog/recog/digits/bootnum4.pa from an
encoded, gzipped and serialized string.

Call this way:
PIXA  *pixa = l_bootnum_gen4(nsamp);
where nsamp is the number of digit templates requested for each
of the 10 digits.  nsamp can be anything from 1 to 100.

This file was generated using the stringcode utility, in recog_bootnum3.c,
slightly edited, and then merged into a single file.  That program
generated a pixa of 100 mosaic'd samples of each digit,
which was copied to recog/digits/bootnum4.pa.

L_STRCODE  *strc;
strc = strcodeCreate(212);   // arbitrary integer
strcodeGenerate(strc, "recog/digits/bootnum4.pa", "PIXA");
strcodeFinalize(&strc, ".");

The two output files, autogen.212.c and autogen.212.h, were
then slightly edited and merged into this file, and the code
to generate the pixa of sample templates was added.

</pre>




"""
    
    try:
        leptonica.l_bootnum_gen4.argtypes = [ctypes.c_int32]
        leptonica.l_bootnum_gen4.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_bootnum_gen4 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_bootnum_gen4(*args):
        """
        ('l_int32', 'nsamp')       

:param[in]    nsamp:     number of samples to retain for each digit
:returns:   pixa  of labeled digits

<pre>
Notes:
(1) The encoded string and the code to generate pixa1 was
automatically generated.
(2) pixa1 is further processed to make the pixa of labelled digits.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_bootnum_gen4(*args)
    




class jp2kheader(object):
    """<pre>

Read header
l_int32          readHeaderJp2k()
l_int32          freadHeaderJp2k()
l_int32          readHeaderMemJp2k()
l_int32          fgetJp2kResolution()

Note: these function read image metadata from a jp2k file, without
using any jp2k libraries.

To read and write jp2k data, using the OpenJPEG library
(http://www.openjpeg.org), see jpegio.c.
</pre>




"""
    
    try:
        leptonica.readHeaderJp2k.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderJp2k.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderJp2k(*args):
        """
        ('const char', '*filename')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       

:param[in]    filename:
:param[out]   pw: [optional]
:param[out]   ph: [optional]
:param[out]   pbps: [optional]  bits/sample
:param[out]   pspp: [optional]  samples/pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderJp2k(*args)
    
    

    try:
        leptonica.freadHeaderJp2k.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.freadHeaderJp2k.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function freadHeaderJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def freadHeaderJp2k(*args):
        """
        ('FILE', '*fp')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       

:param[in]    fp: file stream opened for read
:param[out]   pw: [optional]
:param[out]   ph: [optional]
:param[out]   pbps: [optional]  bits/sample
:param[out]   pspp: [optional]  samples/pixel
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.freadHeaderJp2k(*args)
    
    

    try:
        leptonica.readHeaderMemJp2k.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.readHeaderMemJp2k.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function readHeaderMemJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def readHeaderMemJp2k(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_int32', '*pw')       
('l_int32', '*ph')       
('l_int32', '*pbps')       
('l_int32', '*pspp')       

:param[in]    data:
:param[in]    size: at least 80
:param[out]   pw: [optional]
:param[out]   ph: [optional]
:param[out]   pbps: [optional]  bits/sample
:param[out]   pspp: [optional]  samples/pixel
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The ISO/IEC reference for jpeg2000 is
http://www.jpeg.org/public/15444-1annexi.pdf
and the file format syntax begins at page 127.
(2) The Image Header Box begins with 'ihdr' = 0x69686472 in
big-endian order.  This typically, but not always, starts
byte 44, with the big-endian data fields beginning at byte 48:
h:    4 bytes
w:    4 bytes
spp:  2 bytes
bps:  1 byte   (contains bps - 1)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.readHeaderMemJp2k(*args)
    




class jp2kheaderstub(object):
    """<pre>

Stubs for jp2kheader.c functions
</pre>




"""
    



class jp2kio(object):
    """<pre>

Read jp2k from file
PIX                *pixReadJp2k()  [special top level]
PIX                *pixReadStreamJp2k()

Write jp2k to file
l_int32             pixWriteJp2k()  [special top level]
l_int32             pixWriteStreamJp2k()
static opj_image_t *pixConvertToOpjImage()

Read/write to memory
PIX                *pixReadMemJp2k()
l_int32             pixWriteMemJp2k()

Static functions from opj 2.0 to retain file stream interface
static opj_stream_t  *opjCreateStream()
[other static helpers]

Based on the OpenJPEG distribution:
http://www.openjpeg.org/
The ISO/IEC reference for jpeg2000 is:
http://www.jpeg.org/public/15444-1annexi.pdf

Compressing to memory and decompressing from memory
---------------------------------------------------
On systems like windows without fmemopen() and open_memstream(),
we write data to a temp file and read it back for operations
between pix and compressed-data, such as pixReadMemJp2k() and
pixWriteMemJp2k().

Pdf can accept jp2k compressed strings directly
-----------------------------------------------
Transcoding (with the uncompress/compress cycle) is not required
to wrap images that have already been compressed with jp2k in pdf,
because the pdf format for jp2k includes the full string of the
jp2k compressed images.  This is also true for jpeg compressed
strings.

N.B.
This is based on the most recent openjpeg release: 2.1.
The openjpeg interface was massively changed from 1.X.  The debian
distribution is way back at 1.3.  We have inquired but are unable
to determine if or when a debian distribution will be built for 2.1.
For version 2.1, the openjpeg.h file is installed in an
openjpeg-2.1 subdirectory, which is hard to support.
In openjpeg-2.1, reading is slow compared to jpeg or webp,
and writing is very slow compared to jpeg or webp.  This is expected
to improve significantly in future versions.
Reading and writing jp2k are supported here for 2.1.
The high-level interface to openjpeg continues to change.
From 2.0 to 2.1, the ability to interface to a C file stream
was removed permanently.  Leptonica supports both file stream
and memory buffer interfaces for every image I/O library, and
it requires the libraries to support at least one of these.
However, openjpeg-2.1 provides neither, so we have brought
several static functions over from openjpeg-2.0 in order to
retain the file stream interface.  See our static function
opjCreateStream().
Specifying a quality factor for jpeg2000 requires caution.  Unlike
jpeg and webp, which have a sensible scale that goes from 0 (very poor)
to 100 (nearly lossless), kakadu and openjpeg use idiosyncratic and
non-intuitive numbers.  kakadu uses "rate/distortion" numbers in
a narrow range around 50,000; openjpeg (and our write interface)
use SNR.  The visually apparent artifacts introduced by compression
are strongly content-dependent and vary in a highly non-linear
way with SNR.  We take SNR = 34 as default, roughly similar in
quality to jpeg's default standard of 75.  For document images,
SNR = 25 is very poor, whereas SNR = 45 is nearly lossless.  If you
use the latter, you will pay dearly in the size of the compressed file.
</pre>




"""
    
    try:
        leptonica.pixReadJp2k.argtypes = [ctypes.c_char_p, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReadJp2k.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadJp2k(*args):
        """
        ('const char', '*filename')       
('l_uint32', 'reduction')       
('BOX', '*box')       
('l_int32', 'hint')       
('l_int32', 'debug')       

:param[in]    filename:
:param[in]    reduction:   scaling factor: 1, 2, 4, 8, 16
:param[in]    box:         [optional] for extracting a subregion, can be null
:param[in]    hint:        a bitwise OR of L_JP2K_* values; 0 for default
:param[in]    debug:       output callback messages, etc
:returns:  pix 8 or 32 bpp, or NULL on error

<pre>
Notes:
(1) This is a special function for reading jp2k files.
The high-level pixReadStream() uses default values:
%reduction = 1
%box = NULL
(2) This decodes at either full resolution or at a reduction by
a power of 2.  The default value %reduction == 1 gives a full
resolution image.  Use %reduction > 1 to get a reduced image.
The actual values of %reduction that can be used on an image
depend on the number of resolution levels chosen when the
image was compressed.  Typical values might be 1, 2, 4, 8 and 16.
Using a value representing a reduction level that was not
stored when the file was written will fail with the message:
"failed to read the header".
(3) Use %box to decode only a part of the image.  The box is defined
at full resolution.  It is reduced internally by %reduction,
and clipping to the right and bottom of the image is automatic.
(4) We presently only handle images with 8 bits/sample (bps).
If the image has 16 bps, the read will fail.
(5) There are 4 possible values of samples/pixel (spp).
The values in brackets give the pixel values in the Pix:
spp = 1  ==>  grayscale           [8 bpp grayscale]
spp = 2  ==>  grayscale + alpha   [32 bpp rgba]
spp = 3  ==>  rgb                 [32 bpp rgb]
spp = 4  ==>  rgba                [32 bpp rgba]
(6) The %hint parameter is reserved for future use.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadJp2k(*args)
    
    

    try:
        leptonica.pixReadStreamJp2k.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReadStreamJp2k.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadStreamJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadStreamJp2k(*args):
        """
        ('FILE', '*fp')       
('l_uint32', 'reduction')       
('BOX', '*box')       
('l_int32', 'hint')       
('l_int32', 'debug')       

:param[in]    fp:          file stream
:param[in]    reduction:   scaling factor: 1, 2, 4, 8
:param[in]    box:         [optional] for extracting a subregion, can be null
:param[in]    hint:        a bitwise OR of L_JP2K_* values; 0 for default
:param[in]    debug:       output callback messages, etc
:returns:  pix 8 or 32 bpp, or NULL on error

<pre>
Notes:
(1) See pixReadJp2k() for usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadStreamJp2k(*args)
    
    

    try:
        leptonica.pixWriteJp2k.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteJp2k.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteJp2k(*args):
        """
        ('const char', '*filename')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'nlevels')       
('l_int32', 'hint')       
('l_int32', 'debug')       

:param[in]    filename:
:param[in]    pix:        any depth, cmap is OK
:param[in]    quality:    SNR > 0; 0 for default (34); 100 for lossless
:param[in]    nlevels:    resolution levels; <= 10; default = 5
:param[in]    hint:       a bitwise OR of L_JP2K_* values; 0 for default
:param[in]    debug:      output callback messages, etc
:returns:  0 if OK; 1 on error

<pre>
Notes:
(1) The %quality parameter is the SNR.  The useful range is narrow:
SNR < 27  (terrible quality)
SNR = 34  (default; approximately equivalent to jpeg quality 75)
SNR = 40  (very high quality)
SNR = 45  (nearly lossless)
Use 0 for default; 100 for lossless.
(2) The %nlevels parameter is the number of resolution levels
to be written.  For example, with nlevels == 5, images with
reduction factors of 1, 2, 4, 8 and 16 are encoded, and retrieval
is done at the level requested when reading.  For default,
use either 5 or 0.
(3) The %hint parameter is not yet in use.
(4) For now, we only support 1 "layer" for quality.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteJp2k(*args)
    
    

    try:
        leptonica.pixWriteStreamJp2k.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteStreamJp2k.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamJp2k(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'nlevels')       
('l_int32', 'hint')       
('l_int32', 'debug')       

:param[in]    fp:         file stream
:param[in]    pix:        any depth, cmap is OK
:param[in]    quality:    SNR > 0; 0 for default (34); 100 for lossless
:param[in]    nlevels:    <= 10
:param[in]    hint:       a bitwise OR of L_JP2K_* values; 0 for default
:param[in]    debug:      output callback messages, etc
:returns:  0 if OK, 1 on error
<pre>
Notes:
(1) See pixWriteJp2k() for usage.
(2) For an encoder with more encoding options, see, e.g.,
https://github.com/OpenJPEG/openjpeg/blob/master/tests/test_tile_encoder.c
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamJp2k(*args)
    
    

    try:
        leptonica.pixReadMemJp2k.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixReadMemJp2k.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixReadMemJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixReadMemJp2k(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       
('l_uint32', 'reduction')       
('BOX', '*box')       
('l_int32', 'hint')       
('l_int32', 'debug')       

:param[in]    data:        const; jpeg-encoded
:param[in]    size:        of data
:param[in]    reduction:   scaling factor: 1, 2, 4, 8
:param[in]    box:         [optional] for extracting a subregion, can be null
:param[in]    hint:        a bitwise OR of L_JP2K_* values; 0 for default
:param[in]    debug:       output callback messages, etc
:returns:  pix, or NULL on error

<pre>
Notes:
(1) This crashes when reading through the fmemopen cookie.
Until we can fix this, we use the file-based work-around.
And fixing this may take some time, because the basic
stream interface is no longer supported in openjpeg.
(2) See pixReadJp2k() for usage.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixReadMemJp2k(*args)
    
    

    try:
        leptonica.pixWriteMemJp2k.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.pixWriteMemJp2k.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemJp2k not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemJp2k(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('PIX', '*pix')       
('l_int32', 'quality')       
('l_int32', 'nlevels')       
('l_int32', 'hint')       
('l_int32', 'debug')       

:param[out]   pdata:     data of jpeg compressed image
:param[out]   psize:     size of returned data
:param[in]    pix:       8 or 32 bpp
:param[in]    quality:   SNR > 0; 0 for default (34); 100 for lossless
:param[in]    nlevels:   0 for default
:param[in]    hint:      a bitwise OR of L_JP2K_* values; 0 for default
:param[in]    debug:     output callback messages, etc
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixWriteJp2k() for usage.  This version writes to
memory instead of to a file stream.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemJp2k(*args)
    




class jp2kiostub(object):
    """<pre>

Stubs for jp2kio.c functions
</pre>




"""
    



class pdfio2(object):
    """<pre>

Lower-level operations for generating pdf.

Intermediate function for single page, multi-image conversion
l_int32              pixConvertToPdfData()

Intermediate function for generating multipage pdf output
l_int32              ptraConcatenatePdfToData()

Convert tiff multipage to pdf file
l_int32              convertTiffMultipageToPdf()

Low-level CID-based operations

Without transcoding
l_int32              l_generateCIDataForPdf()
L_COMP_DATA         *l_generateFlateDataPdf()
L_COMP_DATA         *l_generateJpegData()
L_COMP_DATA         *l_generateJpegDataMem()
static L_COMP_DATA  *l_generateJp2kData()

With transcoding
l_int32              l_generateCIData()
l_int32              pixGenerateCIData()
L_COMP_DATA         *l_generateFlateData()
static L_COMP_DATA  *pixGenerateFlateData()
static L_COMP_DATA  *pixGenerateJpegData()
static L_COMP_DATA  *pixGenerateJp2kData()
static L_COMP_DATA  *pixGenerateG4Data()
L_COMP_DATA         *l_generateG4Data()

Other
l_int32              cidConvertToPdfData()
void                 l_CIDataDestroy()

Helper functions for generating the output pdf string
static l_int32       l_generatePdf()
static void          generateFixedStringsPdf()
static char         *generateEscapeString()
static void          generateMediaboxPdf()
static l_int32       generatePageStringPdf()
static l_int32       generateContentStringPdf()
static l_int32       generatePreXStringsPdf()
static l_int32       generateColormapStringsPdf()
static void          generateTrailerPdf()
static l_int32       makeTrailerStringPdf()
static l_int32       generateOutputDataPdf()

Helper functions for generating multipage pdf output
static l_int32       parseTrailerPdf()
static char         *generatePagesObjStringPdf()
static L_BYTEA      *substituteObjectNumbers()

Create/destroy/access pdf data
static L_PDF_DATA   *pdfdataCreate()
static void          pdfdataDestroy()
static L_COMP_DATA  *pdfdataGetCid()

Set flags for special modes
void                 l_pdfSetG4ImageMask()
void                 l_pdfSetDateAndVersion()
</pre>




"""
    
    try:
        leptonica.pixConvertToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToPdfData(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'type')       
('l_int32', 'quality')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('const char', '*title')       
('L_PDF_DATA', '**plpd')       
('l_int32', 'position')       

:param[in]      pix:       all depths; cmap OK
:param[in]      type:      L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE,
L_JP2K_ENCODE
:param[in]      quality:   for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[out]     pdata:     pdf array
:param[out]     pnbytes:   number of bytes in pdf array
:param[in]      x,: y      location of lower-left corner of image, in pixels,
relative to the PostScript origin (0,0) at
the lower-left corner of the page)
:param[in]      res:       override the resolution of the input image, in ppi;
use 0 to respect resolution embedded in the input
:param[in]      title:     [optional] pdf title; can be null
:param[in,out]  plpd:      ptr to lpd; created on the first invocation and
returned until last image is processed
:param[in]      position:  in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,
L_LAST_IMAGE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %res == 0 and the input resolution field is 0,
this will use DefaultInputRes.
(2) This only writes %data if it is the last image to be
written on the page.
(3) See comments in convertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToPdfData(*args)
    
    

    try:
        leptonica.ptraConcatenatePdfToData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.ptraConcatenatePdfToData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraConcatenatePdfToData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraConcatenatePdfToData(*args):
        """
        ('L_PTRA', '*pa_data')       
('SARRAY', '*sa')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pa_data:    ptra array of pdf strings, each for a
single-page pdf file
:param[in]    sa:         [optional] string array of pathnames for
input pdf files; can be null
:param[out]   pdata:      concatenated pdf data in memory
:param[out]   pnbytes:    number of bytes in pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only works with leptonica-formatted single-page pdf files.
pdf files generated by other programs will have unpredictable
(and usually bad) results.  The requirements for each pdf file:
(a) The Catalog and Info objects are the first two.
(b) Object 3 is Pages
(c) Object 4 is Page
(d) The remaining objects are Contents, XObjects, and ColorSpace
(2) We remove trailers from each page, and append the full trailer
for all pages at the end.
(3) For all but the first file, remove the ID and the first 3
objects (catalog, info, pages), so that each subsequent
file has only objects of these classes:
Page, Contents, XObject, ColorSpace (Indexed RGB).
For those objects, we substitute these refs to objects
in the local file:
Page:  Parent(object 3), Contents, XObject(typically multiple)
XObject:  [ColorSpace if indexed]
The Pages object on the first page (object 3) has a Kids array
of references to all the Page objects, with a Count equal
to the number of pages.  Each Page object refers back to
this parent.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraConcatenatePdfToData(*args)
    
    

    try:
        leptonica.convertTiffMultipageToPdf.argtypes = [ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertTiffMultipageToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertTiffMultipageToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertTiffMultipageToPdf(*args):
        """
        ('const char', '*filein')       
('const char', '*fileout')       

:param[in]    filein:    (tiff)
:param[in]    fileout:   (pdf)
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) A multipage tiff file can also be converted to PS, using
convertTiffMultipageToPS()
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertTiffMultipageToPdf(*args)
    
    

    try:
        leptonica.l_generateCIDataForPdf.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_generateCIDataForPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_generateCIDataForPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateCIDataForPdf(*args):
        """
        ('const char', '*fname')       
('PIX', '*pix')       
('l_int32', 'quality')       
('L_COMP_DATA', '**pcid')       

:param[in]    fname:      [optional] can be null
:param[in]    pix:        [optional] can be null
:param[in]    quality:    for jpeg if transcoded: 1-100; 0 for default (75)
for jp2k if transcoded: 27-45; 0 for default (34)
:param[out]   pcid:       compressed data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) You must set either filename or pix.
(2) Given an image file and optionally a pix raster of that data,
this provides a CID that is compatible with PDF, preferably
without transcoding.
(3) The pix is included for efficiency, in case transcoding
is required and the pix is available to the caller.
(4) We don't try to open files named "stdin" or "-" for Tesseract
compatibility reasons. We may remove this restriction
in the future.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateCIDataForPdf(*args)
    
    

    try:
        leptonica.l_generateFlateDataPdf.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.l_generateFlateDataPdf.restype = lambda address: L_COMP_DATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_generateFlateDataPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateFlateDataPdf(*args):
        """
        ('const char', '*fname')       
('PIX', '*pixs')       

:param[in]    fname:     preferably png
:param[in]    pixs:      [optional] can be null
:returns:  cid containing png data, or NULL on error

<pre>
Notes:
(1) If you hand this a png file, you are going to get
png predictors embedded in the flate data. So it has
come to this. http://xkcd.com/1022/
(2) Exception: if the png is interlaced or if it is RGBA,
it will be transcoded.
(3) If transcoding is required, this will not have to read from
file if you also input a pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateFlateDataPdf(*args)
    
    

    try:
        leptonica.l_generateJpegData.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.l_generateJpegData.restype = lambda address: L_COMP_DATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_generateJpegData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateJpegData(*args):
        """
        ('const char', '*fname')       
('l_int32', 'ascii85flag')       

:param[in]    fname:           of jpeg file
:param[in]    ascii85flag:     0 for jpeg; 1 for ascii85-encoded jpeg
:returns:  cid containing jpeg data, or NULL on error

<pre>
Notes:
(1) Set ascii85flag:
~ 0 for binary data (not permitted in PostScript)
~ 1 for ascii85 (5 for 4) encoded binary data
(not permitted in pdf)
(2) Do not free the data.  l_generateJpegDataMem() will free
the data if the data is invalid, or if it does not use
ascii encoding.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateJpegData(*args)
    
    

    try:
        leptonica.l_generateJpegDataMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32]
        leptonica.l_generateJpegDataMem.restype = lambda address: L_COMP_DATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_generateJpegDataMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateJpegDataMem(*args):
        """
        ('l_uint8', '*data')       
('size_t', 'nbytes')       
('l_int32', 'ascii85flag')       

:param[in]    data:           of jpeg file
:param[in]    nbytes:         of jpeg file
:param[in]    ascii85flag:    0 for jpeg; 1 for ascii85-encoded jpeg
:returns:  cid containing jpeg data, or NULL on error

<pre>
Notes:
(1) See l_generateJpegData().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateJpegDataMem(*args)
    
    

    try:
        leptonica.l_generateCIData.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.l_generateCIData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_generateCIData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateCIData(*args):
        """
        ('const char', '*fname')       
('l_int32', 'type')       
('l_int32', 'quality')       
('l_int32', 'ascii85')       
('L_COMP_DATA', '**pcid')       

:param[in]    fname:
:param[in]    type:       L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE,
L_JP2K_ENCODE
:param[in]    quality:    for jpeg if transcoded: 1-100; 0 for default (75)
for jp2k if transcoded: 27-45; 0 for default (34)
:param[in]    ascii85:    0 for binary; 1 for ascii85-encoded
:param[out]   pcid:       compressed data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This can be used for both PostScript and pdf.
(1) Set ascii85:
~ 0 for binary data (not permitted in PostScript)
~ 1 for ascii85 (5 for 4) encoded binary data
(2) This attempts to compress according to the requested type.
If this can't be done, it falls back to ordinary flate encoding.
(3) This differs from l_generateCIDataPdf(), which determines
the format and attempts to generate the CID without transcoding.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateCIData(*args)
    
    

    try:
        leptonica.pixGenerateCIData.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p]
        leptonica.pixGenerateCIData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixGenerateCIData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixGenerateCIData(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'type')       
('l_int32', 'quality')       
('l_int32', 'ascii85')       
('L_COMP_DATA', '**pcid')       

:param[in]    pixs:       8 or 32 bpp, no colormap
:param[in]    type:       L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE or
L_JP2K_ENCODE
:param[in]    quality:    for jpeg if transcoded: 1-100; 0 for default (75)
for jp2k if transcoded: 27-45; 0 for default (34)
:param[in]    ascii85:    0 for binary; 1 for ascii85-encoded
:param[out]   pcid:       compressed data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Set ascii85:
~ 0 for binary data (not permitted in PostScript)
~ 1 for ascii85 (5 for 4) encoded binary data
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixGenerateCIData(*args)
    
    

    try:
        leptonica.l_generateFlateData.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.l_generateFlateData.restype = lambda address: L_COMP_DATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_generateFlateData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateFlateData(*args):
        """
        ('const char', '*fname')       
('l_int32', 'ascii85flag')       

:param[in]    fname:
:param[in]    ascii85flag:    0 for gzipped; 1 for ascii85-encoded gzipped
:returns:  cid flate compressed image data, or NULL on error

<pre>
Notes:
(1) The input image is converted to one of these 4 types:
~ 1 bpp
~ 8 bpp, no colormap
~ 8 bpp, colormap
~ 32 bpp rgb
(2) Set ascii85flag:
~ 0 for binary data (not permitted in PostScript)
~ 1 for ascii85 (5 for 4) encoded binary data
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateFlateData(*args)
    
    

    try:
        leptonica.l_generateG4Data.argtypes = [ctypes.c_char_p, ctypes.c_int32]
        leptonica.l_generateG4Data.restype = lambda address: L_COMP_DATA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_generateG4Data not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_generateG4Data(*args):
        """
        ('const char', '*fname')       
('l_int32', 'ascii85flag')       

:param[in]    fname:          of g4 compressed file
:param[in]    ascii85flag:    0 for g4 compressed; 1 for ascii85-encoded g4
:returns:  cid g4 compressed image data, or NULL on error

<pre>
Notes:
(1) Set ascii85flag:
~ 0 for binary data (not permitted in PostScript)
~ 1 for ascii85 (5 for 4) encoded binary data
(not permitted in pdf)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_generateG4Data(*args)
    
    

    try:
        leptonica.cidConvertToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.cidConvertToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function cidConvertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def cidConvertToPdfData(*args):
        """
        ('L_COMP_DATA', '*cid')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    cid:       compressed image data
:param[in]    title:     [optional] pdf title; can be NULL
:param[out]   pdata:     output pdf data for image
:param[out]   pnbytes:   size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Caller must not destroy the cid.  It is absorbed in the
lpd and destroyed by this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.cidConvertToPdfData(*args)
    
    

    try:
        leptonica.l_CIDataDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_CIDataDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_CIDataDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_CIDataDestroy(*args):
        """
        ('L_COMP_DATA', '**pcid')       

:param[in,out]   pcid:     will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.l_CIDataDestroy(*args)
    
    

    try:
        leptonica.l_pdfSetG4ImageMask.argtypes = [ctypes.c_int32]
        leptonica.l_pdfSetG4ImageMask.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_pdfSetG4ImageMask not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_pdfSetG4ImageMask(*args):
        """
        ('l_int32', 'flag')       

:param[in]    flag:    1 for writing g4 data as fg only through a mask;
0 for writing fg and bg
:returns:  void

<pre>
Notes:
(1) The default is for writing only the fg (through the mask).
That way when you write a 1 bpp image, the bg is transparent,
so any previously written image remains visible behind it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_pdfSetG4ImageMask(*args)
    
    

    try:
        leptonica.l_pdfSetDateAndVersion.argtypes = [ctypes.c_int32]
        leptonica.l_pdfSetDateAndVersion.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_pdfSetDateAndVersion not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_pdfSetDateAndVersion(*args):
        """
        ('l_int32', 'flag')       

:param[in]    flag:    1 for writing date/time and leptonica version;
0 for omitting this from the metadata
:returns:  void

<pre>
Notes:
(1) The default is for writing this data.  For regression tests
that compare output against golden files, it is useful to omit.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_pdfSetDateAndVersion(*args)
    




class pdfio2stub(object):
    """<pre>

Stubs for pdfio2.c functions
</pre>




"""
    



class pdfio1(object):
    """<pre>

Higher-level operations for generating pdf from images.
Use poppler's pdfimages to invert the process, extracting
raster images from pdf.

|=============================================================|
|                        Important notes                      |
|=============================================================|
| Some of these functions require I/O libraries such as       |
| libtiff, libjpeg, libpng, libz and libopenjp2.  If you do   |
| not have these libraries, some calls will fail.  For        |
| example, if you do not have libopenjp2, you cannot write a  |
| pdf where transcoding is required to incorporate a          |
| jp2k image.                                                 |
|                                                             |
| You can manually deactivate all pdf writing by setting      |
| this in environ.h:                                          |
| \code                                                       |
|      #define  USE_PDFIO     0                               |
| \endcode                                                    |
| This will link the stub file pdfiostub.c.                   |
|=============================================================|

Set 1. These functions convert a set of image files
to a multi-page pdf file, with one image on each page.
All images are rendered at the same (input) resolution.
The images can be specified as being in a directory, or they
can be in an sarray.  The output pdf can be either a file
or an array of bytes in memory.

Set 2. These functions are a special case of set 1, where
no scaling or change in quality is required.  For jpeg and jp2k
images, the bytes in each file can be directly incorporated
into the output pdf, and the wrapping up of multiple image
files is very fast.  For non-interlaced png, the data bytes
including the predictors can also be written directly into the
flate pdf data.  For other image formats (e.g., tiff-g4),
transcoding is required, where the image data is first decompressed
and then the G4 or Flate (gzip) encodings are generated.

Set 3. These functions convert a set of images in memory
to a multi-page pdf, with one image on each page.  The pdf
output can be either a file or an array of bytes in memory.

Set 4. These functions implement a pdf output "device driver"
for wrapping (encoding) any number of images on a single page
in pdf.  The input can be either an image file or a Pix;
the pdf output can be either a file or an array of bytes in memory.

Set 5. These "segmented" functions take a set of image
files, along with optional segmentation information, and
generate a multi-page pdf file, where each page consists
in general of a mixed raster pdf of image and non-image regions.
The segmentation information for each page can be input as
either a mask over the image parts, or as a Boxa of those
regions.

Set 6. These "segmented" functions convert an image and
an optional Boxa of image regions into a mixed raster pdf file
for the page.  The input image can be either a file or a Pix.

Set 7. These functions take a set of single-page pdf files
and concatenates it into a multi-page pdf.  The input can be
a set of either single page pdf files or pdf 'strings' in memory.
The output can be either a file or an array of bytes in memory.

The images in the pdf file can be rendered using a pdf viewer,
such as evince, gv, xpdf or acroread.

Reference on the pdf file format:
http://www.adobe.com/devnet/pdf/pdf_reference_archive.html

1. Convert specified image files to pdf (one image file per page)
l_int32             convertFilesToPdf()
l_int32             saConvertFilesToPdf()
l_int32             saConvertFilesToPdfData()
l_int32             selectDefaultPdfEncoding()

2. Convert specified image files to pdf without scaling
l_int32             convertUnscaledFilesToPdf()
l_int32             saConvertUnscaledFilesToPdf()
l_int32             saConvertUnscaledFilesToPdfData()
l_int32             convertUnscaledToPdfData()

3. Convert multiple images to pdf (one image per page)
l_int32             pixaConvertToPdf()
l_int32             pixaConvertToPdfData()

4. Single page, multi-image converters
l_int32             convertToPdf()
l_int32             convertImageDataToPdf()
l_int32             convertToPdfData()
l_int32             convertImageDataToPdfData()
l_int32             pixConvertToPdf()
l_int32             pixWriteStreamPdf()
l_int32             pixWriteMemPdf()

5. Segmented multi-page, multi-image converter
l_int32             convertSegmentedFilesToPdf()
BOXAA              *convertNumberedMasksToBoxaa()

6. Segmented single page, multi-image converters
l_int32             convertToPdfSegmented()
l_int32             pixConvertToPdfSegmented()
l_int32             convertToPdfDataSegmented()
l_int32             pixConvertToPdfDataSegmented()

7. Multipage concatenation
l_int32             concatenatePdf()
l_int32             saConcatenatePdf()
l_int32             ptraConcatenatePdf()
l_int32             concatenatePdfToData()
l_int32             saConcatenatePdfToData()

The top-level multi-image functions can be visualized as follows:
Output pdf data to file:
convertToPdf()  and  convertImageDataToPdf()
--> pixConvertToPdf()
--> pixConvertToPdfData()

Output pdf data to array in memory:
convertToPdfData()  and  convertImageDataToPdfData()
--> pixConvertToPdfData()

The top-level segmented image functions can be visualized as follows:
Output pdf data to file:
convertToPdfSegmented()
--> pixConvertToPdfSegmented()
--> pixConvertToPdfDataSegmented()

Output pdf data to array in memory:
convertToPdfDataSegmented()
--> pixConvertToPdfDataSegmented()

For multi-page concatenation, there are three different types of input
(1) directory and optional filename filter
(2) sarray of filenames
(3) ptra of byte arrays of pdf data
and two types of output for the concatenated pdf data
(1) filename
(2) data array and size
High-level interfaces are given for each of the six combinations.

Note: When wrapping small images into pdf, it is useful to give
them a relatively low resolution value, to avoid rounding errors
when rendering the images.  For example, if you want an image
of width w pixels to be 5 inches wide on a screen, choose a
resolution w/5.

The very fast functions in section (2) require neither transcoding
nor parsing of the compressed jpeg file.  With three types of image
compression, the compressed strings can be incorporated into
the pdf data without decompression and re-encoding: jpeg, jp2k
and png.  The DCTDecode and JPXDecode filters can handle the
entire jpeg and jp2k encoded string as a byte array in the pdf file.
The FlateDecode filter can handle the png compressed image data,
including predictors that occur as the first byte in each
raster line, but it is necessary to store only the png IDAT chunk
data in the pdf array.  The alternative for wrapping png images
is to transcode them: uncompress into a raster (a pix) and then
gzip the raster data.  This typically results in a larger pdf file
because it doesn't use the two-dimensional png predictor.
Colormaps, which are found in png PLTE chunks, must always be
pulled out and included separately in the pdf.  For CCITT-G4
compression, you can not simply include a tiff G4 file -- you must
either parse it and extract the G4 compressed data within it,
or uncompress to a raster and G4 compress again.
</pre>




"""
    
    try:
        leptonica.convertFilesToPdf.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertFilesToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertFilesToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertFilesToPdf(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    dirname:       directory name containing images
:param[in]    substr:        [optional] substring filter on filenames;
can be NULL
:param[in]    res:           input resolution of all images
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:          encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE or
L_DEFAULT_ENCODE for default)
:param[in]    quality:       for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]    title:         [optional] pdf title; if null, taken from
the first image filename
:param[in]    fileout:       pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %substr is not NULL, only image filenames that contain
the substring can be used.  If %substr == NULL, all files
in the directory are used.
(2) The files in the directory, after optional filtering by
the substring, are lexically sorted in increasing order
before concatenation.
(3) The scalefactor is applied to each image before encoding.
If you enter a value <= 0.0, it will be set to 1.0.
(4) Specifying one of the four encoding types for %type forces
all images to be compressed with that type.  Use 0 to have
the type determined for each image based on depth and whether
or not it has a colormap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertFilesToPdf(*args)
    
    

    try:
        leptonica.saConvertFilesToPdf.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.saConvertFilesToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function saConvertFilesToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def saConvertFilesToPdf(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    sa:            string array of pathnames for images
:param[in]    res:           input resolution of all images
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:          encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE or
L_DEFAULT_ENCODE for default)
:param[in]    quality:       for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]    title:         [optional] pdf title; if null, taken from
the first image filename
:param[in]    fileout:       pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See convertFilesToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.saConvertFilesToPdf(*args)
    
    

    try:
        leptonica.saConvertFilesToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.saConvertFilesToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function saConvertFilesToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def saConvertFilesToPdfData(*args):
        """
        ('SARRAY', '*sa')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    sa:            string array of pathnames for images
:param[in]    res:           input resolution of all images
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:          encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE or
L_DEFAULT_ENCODE for default)
:param[in]    quality:       for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]    title:         [optional] pdf title; if null, taken from
the first image filename
:param[out]   pdata:         output pdf data (of all images
:param[out]   pnbytes:       size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See convertFilesToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.saConvertFilesToPdfData(*args)
    
    

    try:
        leptonica.selectDefaultPdfEncoding.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.selectDefaultPdfEncoding.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function selectDefaultPdfEncoding not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def selectDefaultPdfEncoding(*args):
        """
        ('PIX', '*pix')       
('l_int32', '*ptype')       

:param[in]    pix:
:param[out]   ptype:     L_G4_ENCODE, L_JPEG_ENCODE, L_FLATE_ENCODE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This attempts to choose an encoding for the pix that results
in the smallest file, assuming that if jpeg encoded, it will
use quality = 75.  The decision is approximate, in that
(a) all colormapped images will be losslessly encoded with
gzip (flate), and (b) an image with less than about 20 colors
is likely to be smaller if flate encoded than if encoded
as a jpeg (dct).  For example, an image made by pixScaleToGray3()
will have 10 colors, and flate encoding will give about
twice the compression as jpeg with quality = 75.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.selectDefaultPdfEncoding(*args)
    
    

    try:
        leptonica.convertUnscaledFilesToPdf.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertUnscaledFilesToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertUnscaledFilesToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertUnscaledFilesToPdf(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    dirname:   directory name containing images
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    title:     [optional] pdf title; if null, taken from the first
image filename
:param[in]    fileout:   pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %substr is not NULL, only image filenames that contain
the substring can be used.  If %substr == NULL, all files
in the directory are used.
(2) The files in the directory, after optional filtering by
the substring, are lexically sorted in increasing order
before concatenation.
(3) This is very fast for jpeg, jp2k and some png files, because
the compressed data is wrapped up and concatenated.  For tiffg4
and other types of png, the images must be read and recompressed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertUnscaledFilesToPdf(*args)
    
    

    try:
        leptonica.saConvertUnscaledFilesToPdf.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.saConvertUnscaledFilesToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function saConvertUnscaledFilesToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def saConvertUnscaledFilesToPdf(*args):
        """
        ('SARRAY', '*sa')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    sa:        string array of pathnames for images
:param[in]    title:     [optional] pdf title; if null, taken from the first
image filename
:param[in]    fileout:   pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See convertUnscaledFilesToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.saConvertUnscaledFilesToPdf(*args)
    
    

    try:
        leptonica.saConvertUnscaledFilesToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.saConvertUnscaledFilesToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function saConvertUnscaledFilesToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def saConvertUnscaledFilesToPdfData(*args):
        """
        ('SARRAY', '*sa')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    sa:        string array of pathnames for image files
:param[in]    title:     [optional] pdf title; if null, taken from the first
image filename
:param[out]   pdata:     output pdf data (of all images)
:param[out]   pnbytes:   size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is very fast for jpeg, jp2k and some png files, because
the compressed data is wrapped up and concatenated.  For tiffg4
and other types of png, the images must be read and recompressed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.saConvertUnscaledFilesToPdfData(*args)
    
    

    try:
        leptonica.convertUnscaledToPdfData.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertUnscaledToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertUnscaledToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertUnscaledToPdfData(*args):
        """
        ('const char', '*fname')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    fname:      of image file in all formats
:param[in]    title:      [optional] pdf title; can be NULL
:param[out]   pdata:      output pdf data for image
:param[out]   pnbytes:    size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is very fast for jpeg, jp2k and some png files, because
the compressed data is wrapped up and concatenated.  For tiffg4
and other types of png, the images must be read and recompressed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertUnscaledToPdfData(*args)
    
    

    try:
        leptonica.pixaConvertToPdf.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.pixaConvertToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertToPdf(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    pixa:          containing images all at the same resolution
:param[in]    res:           override the resolution of each input image,
in ppi; use 0 to respect the resolution
embedded in the input images
:param[in]    scalefactor:   scaling factor applied to each image; > 0.0
:param[in]    type:          encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE, or
L_DEFAULT_ENCODE for default)
:param[in]    quality:       for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]    title:         [optional] pdf title
:param[in]    fileout:       pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
colormap and many colors, or 32 bpp; FLATE for anything else.
(2) The scalefactor must be > 0.0; otherwise it is set to 1.0.
(3) Specifying one of the three encoding types for %type forces
all images to be compressed with that type.  Use 0 to have
the type determined for each image based on depth and whether
or not it has a colormap.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertToPdf(*args)
    
    

    try:
        leptonica.pixaConvertToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaConvertToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixaConvertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaConvertToPdfData(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'res')       
('l_float32', 'scalefactor')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pixa:           containing images all at the same resolution
:param[in]    res:            input resolution of all images
:param[in]    scalefactor:    scaling factor applied to each image; > 0.0
:param[in]    type:           encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE, or
L_DEFAULT_ENCODE for default)
:param[in]    quality:        for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]    title:          [optional] pdf title
:param[out]   pdata:          output pdf data of all images
:param[out]   pnbytes:        size of output pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See pixaConvertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaConvertToPdfData(*args)
    
    

    try:
        leptonica.convertToPdf.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.convertToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToPdf(*args):
        """
        ('const char', '*filein')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*fileout')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('const char', '*title')       
('L_PDF_DATA', '**plpd')       
('l_int32', 'position')       

:param[in]      filein:       input image file -- any format
:param[in]      type:         encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, or L_JP2K_ENCODE)
:param[in]      quality:      for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]      fileout:      output pdf file; only required on last
image on page
:param[in]      x,: y         location of lower-left corner of image,
in pixels, relative to the PostScript origin
(0,0) at the lower-left corner of the page
:param[in]      res:          override the resolution of the input image,
in ppi; use 0 to respect the resolution
embedded in the input images
:param[in]      title:        [optional] pdf title; if null, taken from filein
:param[in,out]  plpd:         ptr to lpd, which is created on the first
invocation and returned until last image is
processed, at which time it is destroyed
:param[in]      position:     in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,
L_LAST_IMAGE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) To wrap only one image in pdf, input %plpd = NULL, and
the value of %position will be ignored:
convertToPdf(...  type, quality, x, y, res, NULL, 0);
(2) To wrap multiple images on a single pdf page, this is called
once for each successive image.  Do it this way:
L_PDF_DATA   *lpd;
convertToPdf(...  type, quality, x, y, res, &lpd, L_FIRST_IMAGE);
convertToPdf(...  type, quality, x, y, res, &lpd, L_NEXT_IMAGE);
...
convertToPdf(...  type, quality, x, y, res, &lpd, L_LAST_IMAGE);
This will write the result to the value of %fileout specified
in the first call; succeeding values of %fileout are ignored.
On the last call: the pdf data bytes are computed and written
to %fileout, lpd is destroyed internally, and the returned
value of lpd is null.  So the client has nothing to clean up.
(3) (a) Set %res == 0 to respect the resolution embedded in the
image file.  If no resolution is embedded, it will be set
to the default value.
(b) Set %res to some other value to override the file resolution.
(4) (a) If the input %res and the resolution of the output device
are equal, the image will be "displayed" at the same size
as the original.
(b) If the input %res is 72, the output device will render
the image at 1 pt/pixel.
(c) Some possible choices for the default input pix resolution are:
72 ppi     Render pix on any output device at one pt/pixel
96 ppi     Windows default for generated display images
300 ppi     Typical default for scanned images.
We choose 300, which is sensible for rendering page images.
However,  images come from a variety of sources, and
some are explicitly created for viewing on a display.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertToPdf(*args)
    
    

    try:
        leptonica.convertImageDataToPdf.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.convertImageDataToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertImageDataToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertImageDataToPdf(*args):
        """
        ('l_uint8', '*imdata')       
('size_t', 'size')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*fileout')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('const char', '*title')       
('L_PDF_DATA', '**plpd')       
('l_int32', 'position')       

:param[in]      imdata:       array of formatted image data; e.g., png, jpeg
:param[in]      size:         size of image data
:param[in]      type:         encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, or L_JP2K_ENCODE)
:param[in]      quality:      for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]      fileout:      output pdf file; only required on last
image on page
:param[in]      x,: y         location of lower-left corner of image,
in pixels, relative to the PostScript origin
(0,0) at the lower-left corner of the page
:param[in]      res:          override the resolution of the input image,
in ppi; use 0 to respect the resolution
embedded in the input images
:param[in]      title:        [optional] pdf title
:param[in,out]  plpd:         ptr to lpd, which is created on the first
invocation and returned until last image is
processed, at which time it is destroyed
:param[in]      position:     in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,
L_LAST_IMAGE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %res == 0 and the input resolution field is 0,
this will use DefaultInputRes.
(2) See comments in convertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertImageDataToPdf(*args)
    
    

    try:
        leptonica.convertToPdfData.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.convertToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToPdfData(*args):
        """
        ('const char', '*filein')       
('l_int32', 'type')       
('l_int32', 'quality')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('const char', '*title')       
('L_PDF_DATA', '**plpd')       
('l_int32', 'position')       

:param[in]      filein:       input image file -- any format
:param[in]      type:         encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, or L_JP2K_ENCODE)
:param[in]      quality:      for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[out]     pdata:        pdf data in memory
:param[out]     pnbytes:      number of bytes in pdf data
:param[in]      x,: y         location of lower-left corner of image,
in pixels, relative to the PostScript origin
(0,0) at the lower-left corner of the page
:param[in]      res:          override the resolution of the input image,
in ppi; use 0 to respect the resolution
embedded in the input images
:param[in]      title:        [optional] pdf title; if null, use filein
:param[in,out]  plpd:         ptr to lpd, which is created on the first
invocation and returned until last image is
processed, at which time it is destroyed
:param[in]      position:     in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,
L_LAST_IMAGE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %res == 0 and the input resolution field is 0,
this will use DefaultInputRes.
(2) See comments in convertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertToPdfData(*args)
    
    

    try:
        leptonica.convertImageDataToPdfData.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.convertImageDataToPdfData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertImageDataToPdfData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertImageDataToPdfData(*args):
        """
        ('l_uint8', '*imdata')       
('size_t', 'size')       
('l_int32', 'type')       
('l_int32', 'quality')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('const char', '*title')       
('L_PDF_DATA', '**plpd')       
('l_int32', 'position')       

:param[in]    imdata:       array of formatted image data; e.g., png, jpeg
:param[in]    size:         size of image data
:param[in]    type:         encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, or L_JP2K_ENCODE)
:param[in]    quality:      for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[out]   pdata:        pdf data in memory
:param[out]   pnbytes:      number of bytes in pdf data
:param[in]    x,: y         location of lower-left corner of image,
in pixels, relative to the PostScript origin
(0,0) at the lower-left corner of the page
:param[in]    res:          override the resolution of the input image,
in ppi; use 0 to respect the resolution
embedded in the input images
:param[in]    title:        [optional] pdf title
:param[out]   plpd:         ptr to lpd, which is created on the first
invocation and returned until last image is
processed, at which time it is destroyed
:param[in]    position:     in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,
L_LAST_IMAGE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %res == 0 and the input resolution field is 0,
this will use DefaultInputRes.
(2) See comments in convertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertImageDataToPdfData(*args)
    
    

    try:
        leptonica.pixConvertToPdf.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.pixConvertToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToPdf(*args):
        """
        ('PIX', '*pix')       
('l_int32', 'type')       
('l_int32', 'quality')       
('const char', '*fileout')       
('l_int32', 'x')       
('l_int32', 'y')       
('l_int32', 'res')       
('const char', '*title')       
('L_PDF_DATA', '**plpd')       
('l_int32', 'position')       

:param[in]      pix:
:param[in]      type:         encoding type (L_JPEG_ENCODE, L_G4_ENCODE,
L_FLATE_ENCODE, L_JP2K_ENCODE)
:param[in]      quality:      for jpeg: 1-100; 0 for default (75)
for jp2k: 27-45; 0 for default (34)
:param[in]      fileout:      output pdf file; only required on last
image on page
:param[in]      x,: y         location of lower-left corner of image,
in pixels, relative to the PostScript origin
(0,0) at the lower-left corner of the page
:param[in]      res:          override the resolution of the input image,
in ppi; use 0 to respect the resolution
embedded in the input images
:param[in]      title:        [optional] pdf title
:param[in,out]  plpd:         ptr to lpd, which is created on the first
invocation and returned until last image is
processed, at which time it is destroyed
:param[in]      position:     in image sequence: L_FIRST_IMAGE, L_NEXT_IMAGE,
L_LAST_IMAGE
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %res == 0 and the input resolution field is 0,
this will use DefaultInputRes.
(2) This only writes data to fileout if it is the last
image to be written on the page.
(3) See comments in convertToPdf().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToPdf(*args)
    
    

    try:
        leptonica.pixWriteStreamPdf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixWriteStreamPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteStreamPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteStreamPdf(*args):
        """
        ('FILE', '*fp')       
('PIX', '*pix')       
('l_int32', 'res')       
('const char', '*title')       

:param[in]    fp:       file stream opened for writing
:param[in]    pix:      all depths, cmap OK
:param[in]    res:      override the resolution of the input image, in ppi;
use 0 to respect the resolution embedded in the input
:param[in]    title:    [optional] pdf title; taken from the first image
placed on a page; e.g., an input image filename
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is the simplest interface for writing a single image
with pdf encoding to a stream.  It uses G4 encoding for 1 bpp,
JPEG encoding for 8 bpp (no cmap) and 32 bpp, and FLATE
encoding for everything else.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteStreamPdf(*args)
    
    

    try:
        leptonica.pixWriteMemPdf.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.pixWriteMemPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixWriteMemPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixWriteMemPdf(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*pnbytes')       
('PIX', '*pix')       
('l_int32', 'res')       
('const char', '*title')       

:param[out]   pdata:      pdf as byte array
:param[out]   pnbytes:    number of bytes in pdf array
:param[in]    pix:        all depths, cmap OK
:param[in]    res:        override the resolution of the input image, in ppi;
use 0 to respect the res embedded in the input
:param[in]    title:      [optional] pdf title; taken from the first image
placed on a page; e.g., an input image filename
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This is the simplest interface for writing a single image
with pdf encoding to memory.  It uses G4 encoding for 1 bpp,
and makes a guess whether to use JPEG or FLATE encoding for
everything else.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixWriteMemPdf(*args)
    
    

    try:
        leptonica.convertSegmentedFilesToPdf.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertSegmentedFilesToPdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertSegmentedFilesToPdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertSegmentedFilesToPdf(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'res')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('BOXAA', '*baa')       
('l_int32', 'quality')       
('l_float32', 'scalefactor')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    dirname:       directory name containing images
:param[in]    substr:        [optional] substring filter on filenames;
can be NULL
:param[in]    res:           input resolution of all images
:param[in]    type:          compression type for non-image regions; the
image regions are always compressed with
L_JPEG_ENCODE
:param[in]    thresh:        used for converting gray --> 1 bpp with
L_G4_ENCODE
:param[in]    baa:           [optional] boxaa of image regions
:param[in]    quality:       used for JPEG only; 0 for default (75)
:param[in]    scalefactor:   scaling factor applied to each image region
:param[in]    title:         [optional] pdf title; if null, taken from
the first image filename
:param[in]    fileout:       pdf file of all images
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If %substr is not NULL, only image filenames that contain
the substring can be used.  If %substr == NULL, all files
in the directory are used.
(2) The files in the directory, after optional filtering by
the substring, are lexically sorted in increasing order
before concatenation.
(3) The images are encoded with G4 if 1 bpp; JPEG if 8 bpp without
colormap and many colors, or 32 bpp; FLATE for anything else.
(4) The boxaa, if it exists, contains one boxa of "image regions"
for each image file.  The boxa must be aligned with the
sorted set of images.
(5) The scalefactor is applied to each image region.  It is
typically < 1.0, to save bytes in the final pdf, because
the resolution is often not critical in non-text regions.
(6) If the non-image regions have pixel depth > 1 and the encoding
type is G4, they are automatically scaled up by 2x and
thresholded.  Otherwise, no scaling is performed on them.
(7) Note that this function can be used to generate multipage
G4 compressed pdf from any input, by using %boxaa == NULL
and %type == L_G4_ENCODE.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertSegmentedFilesToPdf(*args)
    
    

    try:
        leptonica.convertNumberedMasksToBoxaa.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.convertNumberedMasksToBoxaa.restype = lambda address: BOXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function convertNumberedMasksToBoxaa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertNumberedMasksToBoxaa(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_int32', 'numpre')       
('l_int32', 'numpost')       

:param[in]    dirname:   directory name containing mask images
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    numpre:    number of characters in name before number
:param[in]    numpost:   number of characters in name after number, up
to a dot before an extension
:returns:  boxaa of mask regions, or NULL on error

<pre>
Notes:
(1) This is conveniently used to generate the input boxaa
for convertSegmentedFilesToPdf().  It guarantees that the
boxa will be aligned with the page images, even if some
of the boxa are empty.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertNumberedMasksToBoxaa(*args)
    
    

    try:
        leptonica.convertToPdfSegmented.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.convertToPdfSegmented.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertToPdfSegmented not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToPdfSegmented(*args):
        """
        ('const char', '*filein')       
('l_int32', 'res')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('BOXA', '*boxa')       
('l_int32', 'quality')       
('l_float32', 'scalefactor')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    filein:        input image file -- any format
:param[in]    res:           input image resolution; typ. 300 ppi;
use 0 for default
:param[in]    type:          compression type for non-image regions; image
regions are always compressed with L_JPEG_ENCODE
:param[in]    thresh:        for converting gray --> 1 bpp with L_G4_ENCODE
:param[in]    boxa:          [optional] of image regions; can be null
:param[in]    quality:       used for jpeg image regions; 0 for default
:param[in]    scalefactor:   used for jpeg regions; must be <= 1.0
:param[in]    title:         [optional] pdf title; typically taken from the
input file for the pix
:param[in]    fileout:       output pdf file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there are no image regions, set %boxa == NULL;
%quality and %scalefactor are ignored.
(2) Typically, %scalefactor is < 1.0, because the image regions
can be rendered at a lower resolution (for better compression)
than the text regions.  If %scalefactor == 0, we use 1.0.
If the input image is 1 bpp and scalefactor < 1.0, we
use scaleToGray() to downsample the image regions to gray
before compressing them.
(3) If the compression type for non-image regions is L_G4_ENCODE
and bpp > 1, the image is upscaled 2x and thresholded
to 1 bpp.  That is the only situation where %thresh is used.
(4) The parameter %quality is only used for image regions.
If %type == L_JPEG_ENCODE, default jpeg quality (75) is
used for the non-image regions.
(5) Processing matrix for non-image regions.

Input           G4              JPEG                FLATE
----------|---------------------------------------------------
1 bpp     |  1x, 1 bpp       1x flate, 1 bpp     1x, 1 bpp
|
cmap      |  2x, 1 bpp       1x flate, cmap      1x, cmap
|
2,4 bpp   |  2x, 1 bpp       1x flate            1x, 2,4 bpp
no cmap   |                  2,4 bpp
|
8,32 bpp  |  2x, 1 bpp       1x (jpeg)           1x, 8,32 bpp
no cmap   |                  8,32 bpp

Summary:
(a) if G4 is requested, G4 is used, with 2x upscaling
for all cases except 1 bpp.
(b) if JPEG is requested, use flate encoding for all cases
except 8 bpp without cmap and 32 bpp (rgb).
(c) if FLATE is requested, use flate with no transformation
of the raster data.
(6) Calling options/sequence for these functions:
file  -->  file      (convertToPdfSegmented)
pix  -->  file      (pixConvertToPdfSegmented)
pix  -->  data      (pixConvertToPdfDataSegmented)
file  -->  data      (convertToPdfDataSegmented)
pix  -->  data      (pixConvertToPdfDataSegmented)
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertToPdfSegmented(*args)
    
    

    try:
        leptonica.pixConvertToPdfSegmented.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.pixConvertToPdfSegmented.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToPdfSegmented not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToPdfSegmented(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'res')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('BOXA', '*boxa')       
('l_int32', 'quality')       
('l_float32', 'scalefactor')       
('const char', '*title')       
('const char', '*fileout')       

:param[in]    pixs:          any depth, cmap OK
:param[in]    res:           input image resolution; typ. 300 ppi;
use 0 for default
:param[in]    type:          compression type for non-image regions; image
regions are always compressed with L_JPEG_ENCODE
:param[in]    thresh:        for converting gray --> 1 bpp with L_G4_ENCODE
:param[in]    boxa:          [optional] of image regions; can be null
:param[in]    quality:       used for jpeg image regions; 0 for default
:param[in]    scalefactor:   used for jpeg regions; must be <= 1.0
:param[in]    title:         [optional] pdf title; typically taken from the
input file for the pix
:param[in]    fileout:       output pdf file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See convertToPdfSegmented() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToPdfSegmented(*args)
    
    

    try:
        leptonica.convertToPdfDataSegmented.argtypes = [ctypes.c_char_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.convertToPdfDataSegmented.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function convertToPdfDataSegmented not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def convertToPdfDataSegmented(*args):
        """
        ('const char', '*filein')       
('l_int32', 'res')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('BOXA', '*boxa')       
('l_int32', 'quality')       
('l_float32', 'scalefactor')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    filein:        input image file -- any format
:param[in]    res:           input image resolution; typ. 300 ppi;
use 0 for default
:param[in]    type:          compression type for non-image regions; image
regions are always compressed with L_JPEG_ENCODE
:param[in]    thresh:        for converting gray --> 1 bpp with L_G4_ENCODE
:param[in]    boxa:          [optional] image regions; can be null
:param[in]    quality:       used for jpeg image regions; 0 for default
:param[in]    scalefactor:   used for jpeg regions; must be <= 1.0
:param[in]    title:         [optional] pdf title; if null, uses filein
:param[out]   pdata:         pdf data in memory
:param[out]   pnbytes:       number of bytes in pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If there are no image regions, set %boxa == NULL;
%quality and %scalefactor are ignored.
(2) Typically, %scalefactor is < 1.0.  The image regions are
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.convertToPdfDataSegmented(*args)
    
    

    try:
        leptonica.pixConvertToPdfDataSegmented.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixConvertToPdfDataSegmented.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function pixConvertToPdfDataSegmented not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixConvertToPdfDataSegmented(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'res')       
('l_int32', 'type')       
('l_int32', 'thresh')       
('BOXA', '*boxa')       
('l_int32', 'quality')       
('l_float32', 'scalefactor')       
('const char', '*title')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    pixs:          any depth, cmap OK
:param[in]    res:           input image resolution; typ. 300 ppi;
use 0 for default
:param[in]    type:          compression type for non-image regions; image
regions are always compressed with L_JPEG_ENCODE
:param[in]    thresh:        for converting gray --> 1 bpp with L_G4_ENCODE
:param[in]    boxa:          [optional] of image regions; can be null
:param[in]    quality:       used for jpeg image regions; 0 for default
:param[in]    scalefactor:   used for jpeg regions; must be <= 1.0
:param[in]    title:         [optional] pdf title; typically taken from the
input file for the pix
:param[out]   pdata:         pdf data in memory
:param[out]   pnbytes:       number of bytes in pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) See convertToPdfSegmented() for details.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixConvertToPdfDataSegmented(*args)
    
    

    try:
        leptonica.concatenatePdf.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p]
        leptonica.concatenatePdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function concatenatePdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def concatenatePdf(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('const char', '*fileout')       

:param[in]    dirname:   directory name containing single-page pdf files
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[in]    fileout:   concatenated pdf file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only works with leptonica-formatted single-page pdf files.
(2) If %substr is not NULL, only filenames that contain
the substring can be returned.  If %substr == NULL,
none of the filenames are filtered out.
(3) The files in the directory, after optional filtering by
the substring, are lexically sorted in increasing order
before concatenation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.concatenatePdf(*args)
    
    

    try:
        leptonica.saConcatenatePdf.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.saConcatenatePdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function saConcatenatePdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def saConcatenatePdf(*args):
        """
        ('SARRAY', '*sa')       
('const char', '*fileout')       

:param[in]    sa:        string array of pathnames for single-page pdf files
:param[in]    fileout:   concatenated pdf file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only works with leptonica-formatted single-page pdf files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.saConcatenatePdf(*args)
    
    

    try:
        leptonica.ptraConcatenatePdf.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.ptraConcatenatePdf.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function ptraConcatenatePdf not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def ptraConcatenatePdf(*args):
        """
        ('L_PTRA', '*pa')       
('const char', '*fileout')       

:param[in]    pa:       array of pdf strings, each for a single-page pdf file
:param[in]    fileout:  concatenated pdf file
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only works with leptonica-formatted single-page pdf files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.ptraConcatenatePdf(*args)
    
    

    try:
        leptonica.concatenatePdfToData.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.concatenatePdfToData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function concatenatePdfToData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def concatenatePdfToData(*args):
        """
        ('const char', '*dirname')       
('const char', '*substr')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    dirname:   directory name containing single-page pdf files
:param[in]    substr:    [optional] substring filter on filenames; can be NULL
:param[out]   pdata:     concatenated pdf data in memory
:param[out]   pnbytes:   number of bytes in pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only works with leptonica-formatted single-page pdf files.
(2) If %substr is not NULL, only filenames that contain
the substring can be returned.  If %substr == NULL,
none of the filenames are filtered out.
(3) The files in the directory, after optional filtering by
the substring, are lexically sorted in increasing order
before concatenation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.concatenatePdfToData(*args)
    
    

    try:
        leptonica.saConcatenatePdfToData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.saConcatenatePdfToData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function saConcatenatePdfToData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def saConcatenatePdfToData(*args):
        """
        ('SARRAY', '*sa')       
('l_uint8', '**pdata')       
('size_t', '*pnbytes')       

:param[in]    sa:        string array of pathnames for single-page pdf files
:param[out]   pdata:     concatenated pdf data in memory
:param[out]   pnbytes:   number of bytes in pdf data
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This only works with leptonica-formatted single-page pdf files.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.saConcatenatePdfToData(*args)
    




class pdfio1stub(object):
    """<pre>

Stubs for pdfio1.c functions
</pre>




"""
    



class libversions(object):
    """<pre>

Image library version number
char      *getImagelibVersions()
</pre>




"""
    
    try:
        leptonica.getImagelibVersions.argtypes = []
        leptonica.getImagelibVersions.restype = lambda address: (ctypes.string_at(address), free(address))[0]
    except AttributeError:
        sys.stderr.write("Warning - function getImagelibVersions not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def getImagelibVersions(*args):
        """
               

<pre>
Notes:
(1) This returns a string of version numbers; e.g.,
libgif 5.0.3
libjpeg 8b (libjpeg-turbo 1.3.0)
libpng 1.4.3
libtiff 3.9.5
zlib 1.2.5
libwebp 0.3.0
libopenjp2 2.1.0
(2) The caller must free the memory.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.getImagelibVersions(*args)
    




class bytearray(object):
    """<pre>

Functions for handling byte arrays, in analogy with C++ 'strings'

Creation, copy, clone, destruction
L_BYTEA      *l_byteaCreate()
L_BYTEA      *l_byteaInitFromMem()
L_BYTEA      *l_byteaInitFromFile()
L_BYTEA      *l_byteaInitFromStream()
L_BYTEA      *l_byteaCopy()
void          l_byteaDestroy()

Accessors
size_t        l_byteaGetSize()
l_uint8      *l_byteaGetData()
l_uint8      *l_byteaCopyData()

Appending
l_int32       l_byteaAppendData()
l_int32       l_byteaAppendString()
static l_int32  l_byteaExtendArrayToSize()

Join/Split
l_int32       l_byteaJoin()
l_int32       l_byteaSplit()

Search
l_int32       l_byteaFindEachSequence()

Output to file
l_int32       l_byteaWrite()
l_int32       l_byteaWriteStream()

The internal data array is always null-terminated, for ease of use
in the event that it is an ascii string without null bytes.
</pre>




"""
    
    try:
        leptonica.l_byteaCreate.argtypes = [ctypes.c_size_t]
        leptonica.l_byteaCreate.restype = lambda address: L_BYTEA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaCreate(*args):
        """
        ('size_t', 'nbytes')       

:param[in]    nbytes:    determines initial size of data array
:returns:  l_bytea, or NULL on error

<pre>
Notes:
(1) The allocated array is n + 1 bytes.  This allows room
for null termination.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaCreate(*args)
    
    

    try:
        leptonica.l_byteaInitFromMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.l_byteaInitFromMem.restype = lambda address: L_BYTEA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaInitFromMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaInitFromMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    to be copied to the array
:param[in]    size:    amount of data
:returns:  l_bytea, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaInitFromMem(*args)
    
    

    try:
        leptonica.l_byteaInitFromFile.argtypes = [ctypes.c_char_p]
        leptonica.l_byteaInitFromFile.restype = lambda address: L_BYTEA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaInitFromFile not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaInitFromFile(*args):
        """
        ('const char', '*fname')       

:param[in]    fname:
:returns:  l_bytea, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaInitFromFile(*args)
    
    

    try:
        leptonica.l_byteaInitFromStream.argtypes = [ctypes.c_void_p]
        leptonica.l_byteaInitFromStream.restype = lambda address: L_BYTEA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaInitFromStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaInitFromStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  l_bytea, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaInitFromStream(*args)
    
    

    try:
        leptonica.l_byteaCopy.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.l_byteaCopy.restype = lambda address: L_BYTEA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaCopy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaCopy(*args):
        """
        ('L_BYTEA', '*bas')       
('l_int32', 'copyflag')       

:param[in]    bas:        source lba
:param[in]    copyflag:   L_COPY, L_CLONE
:returns:  clone or copy of bas, or NULL on error

<pre>
Notes:
(1) If cloning, up the refcount and return a ptr to %bas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaCopy(*args)
    
    

    try:
        leptonica.l_byteaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.l_byteaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaDestroy(*args):
        """
        ('L_BYTEA', '**pba')       

:param[in,out]   pba:    will be set to null before returning
:returns:  void

<pre>
Notes:
(1) Decrements the ref count and, if 0, destroys the lba.
(2) Always nulls the input ptr.
(3) If the data has been previously removed, the lba will
have been nulled, so this will do nothing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaDestroy(*args)
    
    

    try:
        leptonica.l_byteaGetSize.argtypes = [ctypes.c_void_p]
        leptonica.l_byteaGetSize.restype = ctypes.c_size_t
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaGetSize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaGetSize(*args):
        """
        ('L_BYTEA', '*ba')       

:param[in]    ba:
:returns:  size of stored byte array, or 0 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaGetSize(*args)
    
    

    try:
        leptonica.l_byteaGetData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_byteaGetData.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaGetData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaGetData(*args):
        """
        ('L_BYTEA', '*ba')       
('size_t', '*psize')       

:param[in]    ba:
:param[out]   psize:     size of data in lba
:returns:  ptr to existing data array, or NULL on error

<pre>
Notes:
(1) The returned ptr is owned by %ba.  Do not free it!
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaGetData(*args)
    
    

    try:
        leptonica.l_byteaCopyData.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_byteaCopyData.restype = ctypes.POINTER(ctypes.c_ubyte)
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaCopyData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaCopyData(*args):
        """
        ('L_BYTEA', '*ba')       
('size_t', '*psize')       

:param[in]    ba:
:param[out]   psize:     size of data in lba
:returns:  copy of data in use in the data array, or NULL on error.

<pre>
Notes:
(1) The returned data is owned by the caller.  The input %ba
still owns the original data array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaCopyData(*args)
    
    

    try:
        leptonica.l_byteaAppendData.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t]
        leptonica.l_byteaAppendData.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaAppendData not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaAppendData(*args):
        """
        ('L_BYTEA', '*ba')       
('const l_uint8', '*newdata')       
('size_t', 'newbytes')       

:param[in]    ba:
:param[in]    newdata:    byte array to be appended
:param[in]    newbytes:   size of data array
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaAppendData(*args)
    
    

    try:
        leptonica.l_byteaAppendString.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.l_byteaAppendString.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaAppendString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaAppendString(*args):
        """
        ('L_BYTEA', '*ba')       
('const char', '*str')       

:param[in]    ba:
:param[in]    str:    null-terminated string to be appended
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaAppendString(*args)
    
    

    try:
        leptonica.l_byteaJoin.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.l_byteaJoin.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaJoin not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaJoin(*args):
        """
        ('L_BYTEA', '*ba1')       
('L_BYTEA', '**pba2')       

:param[in]       ba1:
:param[in,out]   pba2:    data array is added to the one in ba1;
then ba2 is destroyed and its pointer is nulled.
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) It is a no-op, not an error, for %ba2 to be null.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaJoin(*args)
    
    

    try:
        leptonica.l_byteaSplit.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.l_byteaSplit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaSplit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaSplit(*args):
        """
        ('L_BYTEA', '*ba1')       
('size_t', 'splitloc')       
('L_BYTEA', '**pba2')       

:param[in]    ba1:       lba to split; array bytes nulled beyond the split loc
:param[in]    splitloc:  location in ba1 to split; ba2 begins there
:param[out]   pba2:      with data starting at splitloc
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaSplit(*args)
    
    

    try:
        leptonica.l_byteaFindEachSequence.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p]
        leptonica.l_byteaFindEachSequence.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaFindEachSequence not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaFindEachSequence(*args):
        """
        ('L_BYTEA', '*ba')       
('const l_uint8', '*sequence')       
('size_t', 'seqlen')       
('L_DNA', '**pda')       

:param[in]    ba:
:param[in]    sequence:   subarray of bytes to find in data
:param[in]    seqlen:     length of sequence, in bytes
:param[out]   pda:        byte positions of each occurrence of %sequence
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaFindEachSequence(*args)
    
    

    try:
        leptonica.l_byteaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]
        leptonica.l_byteaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaWrite(*args):
        """
        ('const char', '*fname')       
('L_BYTEA', '*ba')       
('size_t', 'startloc')       
('size_t', 'nbytes')       

:param[in]    fname:      output file
:param[in]    ba:
:param[in]    startloc:   first byte to output
:param[in]    nbytes:     number of bytes to write; use 0 to write to
the end of the data array
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaWrite(*args)
    
    

    try:
        leptonica.l_byteaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_size_t]
        leptonica.l_byteaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_byteaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_byteaWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_BYTEA', '*ba')       
('size_t', 'startloc')       
('size_t', 'nbytes')       

:param[in]    fp:         file stream opened for binary write
:param[in]    ba:
:param[in]    startloc:   first byte to output
:param[in]    nbytes:     number of bytes to write; use 0 to write to
the end of the data array
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_byteaWriteStream(*args)
    




class dewarp1(object):
    """<pre>

Basic operations and serialization

Create/destroy dewarp
L_DEWARP          *dewarpCreate()
L_DEWARP          *dewarpCreateRef()
void               dewarpDestroy()

Create/destroy dewarpa
L_DEWARPA         *dewarpaCreate()
L_DEWARPA         *dewarpaCreateFromPixacomp()
void               dewarpaDestroy()
l_int32            dewarpaDestroyDewarp()

Dewarpa insertion/extraction
l_int32            dewarpaInsertDewarp()
static l_int32     dewarpaExtendArraysToSize()
L_DEWARP          *dewarpaGetDewarp()

Setting parameters to control rendering from the model
l_int32            dewarpaSetCurvatures()
l_int32            dewarpaUseBothArrays()
l_int32            dewarpaSetCheckColumns()
l_int32            dewarpaSetMaxDistance()

Dewarp serialized I/O
L_DEWARP          *dewarpRead()
L_DEWARP          *dewarpReadStream()
L_DEWARP          *dewarpReadMem()
l_int32            dewarpWrite()
l_int32            dewarpWriteStream()
l_int32            dewarpWriteMem()

Dewarpa serialized I/O
L_DEWARPA         *dewarpaRead()
L_DEWARPA         *dewarpaReadStream()
L_DEWARPA         *dewarpaReadMem()
l_int32            dewarpaWrite()
l_int32            dewarpaWriteStream()
l_int32            dewarpaWriteMem()


Examples of usage
=================

See dewarpaCreateFromPixacomp() for an example of the basic
operations, starting from a set of 1 bpp images.

Basic functioning to dewarp a specific single page:
\code
// Make the Dewarpa for the pages
L_Dewarpa *dewa = dewarpaCreate(1, 30, 1, 15, 50);
dewarpaSetCurvatures(dewa, -1, 5, -1, -1, -1, -1);
dewarpaUseBothArrays(dewa, 1);  // try to use both disparity
// arrays for this example

// Do the page: start with a binarized image
Pix *pixb = "binarize"(pixs);
// Initialize a Dewarp for this page (say, page 214)
L_Dewarp *dew = dewarpCreate(pixb, 214);
// Insert in Dewarpa and obtain parameters for building the model
dewarpaInsertDewarp(dewa, dew);
// Do the work
dewarpBuildPageModel(dew, NULL);  // no debugging
// Optionally set rendering parameters
// Apply model to the input pixs
Pix *pixd;
dewarpaApplyDisparity(dewa, 214, pixs, 255, 0, 0, &pixd, NULL);
pixDestroy(&pixb);
\endcode

Basic functioning to dewarp many pages:
\code
// Make the Dewarpa for the set of pages; use fullres 1 bpp
L_Dewarpa *dewa = dewarpaCreate(10, 30, 1, 15, 50);
// Optionally set rendering parameters
dewarpaSetCurvatures(dewa, -1, 10, -1, -1, -1, -1);
dewarpaUseBothArrays(dewa, 0);  // just use the vertical disparity
// array for this example

// Do first page: start with a binarized image
Pix *pixb = "binarize"(pixs);
// Initialize a Dewarp for this page (say, page 1)
L_Dewarp *dew = dewarpCreate(pixb, 1);
// Insert in Dewarpa and obtain parameters for building the model
dewarpaInsertDewarp(dewa, dew);
// Do the work
dewarpBuildPageModel(dew, NULL);  // no debugging
dewarpMinimze(dew);  // remove most heap storage
pixDestroy(&pixb);

// Do the other pages the same way
...

// Apply models to each page; if the page model is invalid,
// try to use a valid neighboring model.  Note that the call
// to dewarpaInsertRefModels() is optional, because it is called
// by dewarpaApplyDisparity() on the first page it acts on.
dewarpaInsertRefModels(dewa, 0, 1); // use debug flag to get more
// detailed information about the page models
[For each page, where pixs is the fullres image to be dewarped] {
L_Dewarp *dew = dewarpaGetDewarp(dewa, pageno);
if (dew) {  // disparity model exists
Pix *pixd;
dewarpaApplyDisparity(dewa, pageno, pixs, 255,
0, 0, &pixd, NULL);
dewarpMinimize(dew);  // clean out the pix and fpix arrays
// Squirrel pixd away somewhere ...)
}
}
\endcode

Basic functioning to dewarp a small set of pages, potentially
using models from nearby pages:
\code
// (1) Generate a set of binarized images in the vicinity of the
// pages to be dewarped.  We will attempt to compute models
// for pages from 'firstpage' to 'lastpage'.
// Store the binarized images in a compressed array of
// size 'n', where 'n' is the number of images to be stored,
// and where the offset is the first page.
PixaComp *pixac = pixacompCreateInitialized(n, firstpage, NULL,
IFF_TIFF_G4);
for (i = firstpage; i <= lastpage; i++) {
Pix *pixb = "binarize"(pixs);
pixacompReplacePix(pixac, i, pixb, IFF_TIFF_G4);
pixDestroy(&pixb);
}

// (2) Make the Dewarpa for the pages.
L_Dewarpa *dewa =
dewarpaCreateFromPixacomp(pixac, 30, 15, 20);
dewarpaUseBothArrays(dewa, 1);  // try to use both disparity arrays
// in this example

// (3) Finally, apply the models.  For page 'firstpage' with image pixs:
L_Dewarp *dew = dewarpaGetDewarp(dewa, firstpage);
if (dew) {  // disparity model exists
Pix *pixd;
dewarpaApplyDisparity(dewa, firstpage, pixs, 255, 0, 0, &pixd, NULL);
dewarpMinimize(dew);
}
\endcode

Because in general some pages will not have enough text to build a
model, we fill in for those pages with a reference to the page
model to use.  Both the target page and the reference page must
have the same parity.  We can also choose to use either a partial model
(with only vertical disparity) or the full model of a nearby page.

Minimizing the data in a model by stripping out images,
numas, and full resolution disparity arrays:
dewarpMinimize(dew);
This can be done at any time to save memory.  Serialization does
not use the data that is stripped.

You can apply any model (in a dew), stripped or not, to another image:
\code
// For all pages with invalid models, assign the nearest valid
// page model with same parity.
dewarpaInsertRefModels(dewa, 0, 0);
// You can then apply to 'newpix' the page model that was assigned
// to 'pageno', giving the result in pixd:
Pix *pixd;
dewarpaApplyDisparity(dewa, pageno, newpix, 255, 0, 0, &pixd, NULL);
\endcode

You can apply the disparity arrays to a deliberately undercropped
image.  Suppose that you undercrop by (left, right, top, bot), so
that the disparity arrays are aligned with their origin at (left, top).
Dewarp the undercropped image with:
\code
Pix *pixd;
dewarpaApplyDisparity(dewa, pageno, undercropped_pix, 255,
left, top, &pixd, NULL);
\endcode

Description of the approach to analyzing page image distortion
==============================================================

When a book page is scanned, there are several possible causes
for the text lines to appear to be curved:
(1) A barrel (fish-eye) effect because the camera is at
a finite distance from the page.  Take the normal from
the camera to the page (the 'optic axis').  Lines on
the page "below" this point will appear to curve upward
(negative curvature); lines "above" this will curve downward.
(2) Radial distortion from the camera lens.  Probably not
a big factor.
(3) Local curvature of the page in to (or out of) the image
plane (which is perpendicular to the optic axis).
This has no effect if the page is flat.

In the following, the optic axis is in the z direction and is
perpendicular to the xy plane;, the book is assumed to be aligned
so that y is approximately along the binding.
The goal is to compute the "disparity" field, D(x,y), which
is actually a vector composed of the horizontal and vertical
disparity fields H(x,y) and V(x,y).  Each of these is a local
function that gives the amount each point in the image is
required to move in order to rectify the horizontal and vertical
lines.  It would also be nice to "flatten" the page to compensate
for effect (3), foreshortening due to bending of the page into
the z direction, but that is more difficult.

Effects (1) and (2) can be directly compensated by calibrating
the scene, using a flat page with horizontal and vertical lines.
Then H(x,y) and V(x,y) can be found as two (non-parametric) arrays
of values.  Suppose this has been done.  Then the remaining
distortion is due to (3).

We consider the simple situation where the page bending is independent
of y, and is described by alpha(x), where alpha is the angle between
the normal to the page and the optic axis.  cos(alpha(x)) is the local
compression factor of the page image in the horizontal direction, at x.
Thus, if we know alpha(x), we can compute the disparity H(x) required
to flatten the image by simply integrating 1/cos(alpha), and we could
compute the remaining disparities, H(x,y) and V(x,y), from the
page content, as described below.  Unfortunately, we don't know
alpha.  What do we know?  If there are horizontal text lines
on the page, we can compute the vertical disparity, V(x,y), which
is the local translation required to make the text lines parallel
to the rasters.  If the margins are left and right aligned, we can
also estimate the horizontal disparity, H(x,y), required to have
uniform margins.  All that can be done from the image alone,
assuming we have text lines covering a sufficient part of the page.

What about alpha(x)?  The basic question relating to (3) is this:

Is it possible, using the shape of the text lines alone,
to compute both the vertical and horizontal disparity fields?

The underlying problem is to separate the line curvature effects due
to the camera view from those due to actual bending of the page.
I believe the proper way to do this is to make some measurements
based on the camera setup, which will depend mostly on the distance
of the camera from the page, and to a smaller extent on the location
of the optic axis with respect to the page.

Here is the procedure.  Photograph a page with a fine 2D line grid
several times, each with a different slope near the binding.
This can be done by placing the grid page on books that have
different shapes z(x) near the binding.  For each one you can
measure, near the binding:
(1) ds/dy, the vertical rate of change of slope of the horizontal lines
(2) the local horizontal compression of the vertical lines due
to the page angle dz/dx.
As mentioned above, the local horizontal compression is simply
cos(dz/dx).  But the measurement you can make on an actual book
page is (1).  The difficulty is to generate (2) from (1).

Back to the procedure.  The function in (1), ds/dy, likely needs
to be measured at a few y locations, because the relation
between (1) and (2) may weakly depend on the y-location with
respect to the y-coordinate of the optic axis of the camera.
From these measurements you can determine, for the camera setup
that you have, the local horizontal compression, cos(dz/dx), as a
function of the both vertical location (y) and your measured vertical
derivative of the text line slope there, ds/dy.  Then with
appropriate smoothing of your measured values, you can set up a
horizontal disparity array to correct for the compression due
to dz/dx.

Now consider V(x,0) and V(x,h), the vertical disparity along
the top and bottom of the image.  With a little thought you
can convince yourself that the local foreshortening,
as a function of x, is proportional to the difference
between the slope of V(x,0) and V(x,h).  The horizontal
disparity can then be computed by integrating the local foreshortening
over x.  Integration of the slope of V(x,0) and V(x,h) gives
the vertical disparity itself.  We have to normalize to h, the
height of the page.  So the very simple result is that

H(x) ~ (V(x,0) - V(x,h)) / h         [1]

which is easily computed.  There is a proportionality constant
that depends on the ratio of h to the distance to the camera.
Can we actually believe this for the case where the bending
is independent of y?  I believe the answer is yes,
as long as you first remove the apparent distortion due
to the camera being at a finite distance.

If you know the intersection of the optical axis with the page
and the distance to the camera, and if the page is perpendicular
to the optic axis, you can compute the horizontal and vertical
disparities due to (1) and (2) and remove them.  The resulting
distortion should be entirely due to bending (3), for which
the relation

Hx(x) dx = C * ((Vx(x,0) - Vx(x, h))/h) dx         [2]

holds for each point in x (Hx and Vx are partial derivatives w/rt x).
Integrating over x, and using H(0) = 0, we get the result [1].

I believe this result holds differentially for each value of y, so
that in the case where the bending is not independent of y,
the expression (V(x,0) - V(x,h)) / h goes over to Vy(x,y).  Then

H(x,y) = Integral(0,x) (Vyx(x,y) dx)         [3]

where Vyx() is the partial derivative of V w/rt both x and y.

It would be nice if there were a simple mathematical relation between
the horizontal and vertical disparities for the situation
where the paper bends without stretching or kinking.
I had hoped to get a relation between H and V, such as
Hx(x,y) ~ Vy(x,y), which would imply that H and V are real
and imaginary parts of a complex potential, each of which
satisfy the laplace equation.  But then the gradients of the
two potentials would be normal, and that does not appear to be the case.
Thus, the questions of proving the relations above (for small bending),
or finding a simpler relation between H and V than those equations,
remain open.  So far, we have only used [1] for the horizontal
disparity H(x).

In the version of the code that follows, we first use text lines
to find V(x,y).  Then, we try to compute H(x,y) that will align
the text vertically on the left and right margins.  This is not
always possible -- sometimes the right margin is not right justified.
By default, we don't require the horizontal disparity to have a
valid page model for dewarping a page, but this requirement can
be forced using dewarpaUseFullModel().

As described above, one can add a y-independent component of
the horizontal disparity H(x) to counter the foreshortening
effect due to the bending of the page near the binding.
This requires widening the image on the side near the binding,
and we do not provide this option here.  However, we do provide
a function that will generate this disparity field:
fpixExtraHorizDisparity()

Here is the basic outline for building the disparity arrays.

(1) Find lines going approximately through the center of the
text in each text line.  Accept only lines that are
close in length to the longest line.
(2) Use these lines to generate a regular and highly subsampled
vertical disparity field V(x,y).
(3) Interpolate this to generate a full resolution vertical
disparity field.
(4) For lines that are sufficiently long, assume they are approximately
left and right-justified, and construct a highly subsampled
horizontal disparity field H(x,y) that will bring them into alignment.
(5) Interpolate this to generate a full resolution horizontal
disparity field.
(6) Apply the vertical dewarping, followed by the horizontal dewarping.

Step (1) is clearly described by the code in pixGetTextlineCenters().

Steps (2) and (3) follow directly from the data in step (1),
and constitute the bulk of the work done in dewarpBuildPageModel().
Virtually all the noise in the data is smoothed out by doing
least-square quadratic fits, first horizontally to the data
points representing the text line centers, and then vertically.
The trick is to sample these lines on a regular grid.
First each horizontal line is sampled at equally spaced
intervals horizontally.  We thus get a set of points,
one in each line, that are vertically aligned, and
the data we represent is the vertical distance of each point
from the min or max value on the curve, depending on the
sign of the curvature component.  Each of these vertically
aligned sets of points constitutes a sampled vertical disparity,
and we do a LS quartic fit to each of them, followed by
vertical sampling at regular intervals.  We now have a subsampled
grid of points, all equally spaced, giving at each point the local
vertical disparity.  Finally, the full resolution vertical disparity
is formed by interpolation.  All the least square fits do a
great job of smoothing everything out, as can be observed by
the contour maps that are generated for the vertical disparity field.
</pre>




"""
    
    try:
        leptonica.dewarpCreate.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpCreate.restype = lambda address: L_DEWARP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpCreate(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'pageno')       

:param[in]   pixs:     1 bpp
:param[in]   pageno:   page number
:returns:  dew or NULL on error

<pre>
Notes:
(1) The input pixs is either full resolution or 2x reduced.
(2) The page number is typically 0-based.  If scanned from a book,
the even pages are usually on the left.  Disparity arrays
built for even pages should only be applied to even pages.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpCreate(*args)
    
    

    try:
        leptonica.dewarpCreateRef.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpCreateRef.restype = lambda address: L_DEWARP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpCreateRef not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpCreateRef(*args):
        """
        ('l_int32', 'pageno')       
('l_int32', 'refpage')       

:param[in]    pageno:    this page number
:param[in]    refpage:   page number of dewarp disparity arrays to be used
:returns:  dew or NULL on error

<pre>
Notes:
(1) This specifies which dewarp struct should be used for
the given page.  It is placed in dewarpa for pages
for which no model can be built.
(2) This page and the reference page have the same parity and
the reference page is the closest page with a disparity model
to this page.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpCreateRef(*args)
    
    

    try:
        leptonica.dewarpDestroy.argtypes = [ctypes.c_void_p]
        leptonica.dewarpDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpDestroy(*args):
        """
        ('L_DEWARP', '**pdew')       

:param[in,out]   pdew:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpDestroy(*args)
    
    

    try:
        leptonica.dewarpaCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpaCreate.restype = lambda address: L_DEWARPA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaCreate(*args):
        """
        ('l_int32', 'nptrs')       
('l_int32', 'sampling')       
('l_int32', 'redfactor')       
('l_int32', 'minlines')       
('l_int32', 'maxdist')       

:param[in]   nptrs:       number of dewarp page ptrs; typ. the number of pages
:param[in]   sampling:    use 0 for default value; the minimum allowed is 8
:param[in]   redfactor:   of input images: 1 is full res; 2 is 2x reduced
:param[in]   minlines:    minimum number of lines to accept; use 0 for default
:param[in]   maxdist:     for locating reference disparity; use -1 for default
:returns:  dewa or NULL on error

<pre>
Notes:
(1) The sampling, minlines and maxdist parameters will be
applied to all images.
(2) The sampling factor is used for generating the disparity arrays
from the input image.  For 2x reduced input, use a sampling
factor that is half the sampling you want on the full resolution
images.
(3) Use %redfactor = 1 for full resolution; 2 for 2x reduction.
All input images must be at one of these two resolutions.
(4) %minlines is the minimum number of nearly full-length lines
required to generate a vertical disparity array.  The default
number is 15.  Use a smaller number to accept a questionable
array, but not smaller than 4.
(5) When a model can't be built for a page, it looks up to %maxdist
in either direction for a valid model with the same page parity.
Use -1 for the default value of %maxdist; use 0 to avoid using
a ref model.
(6) The ptr array is expanded as necessary to accommodate page images.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaCreate(*args)
    
    

    try:
        leptonica.dewarpaCreateFromPixacomp.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpaCreateFromPixacomp.restype = lambda address: L_DEWARPA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaCreateFromPixacomp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaCreateFromPixacomp(*args):
        """
        ('PIXAC', '*pixac')       
('l_int32', 'useboth')       
('l_int32', 'sampling')       
('l_int32', 'minlines')       
('l_int32', 'maxdist')       

:param[in]   pixac:      pixacomp of G4, 1 bpp images; with 1x1x1 placeholders
:param[in]   useboth:    0 for only vert disparity; 1 for both vert and horiz
:param[in]   sampling:   use -1 or 0 for default value; otherwise minimum of 5
:param[in]   minlines:   minimum number of lines to accept; e.g., 10
:param[in]   maxdist:    for locating reference disparity; use -1 for default
:returns:  dewa or NULL on error

<pre>
Notes:
(1) The returned dewa has disparity arrays calculated and
is ready for serialization or for use in dewarping.
(2) The sampling, minlines and maxdist parameters are
applied to all images.  See notes in dewarpaCreate() for details.
(3) The pixac is full.  Placeholders, if any, are w=h=d=1 images,
and the real input images are 1 bpp at full resolution.
They are assumed to be cropped to the actual page regions,
and may be arbitrarily sparse in the array.
(4) The output dewarpa is indexed by the page number.
The offset in the pixac gives the mapping between the
array index in the pixac and the page number.
(5) This adds the ref page models.
(6) This can be used to make models for any desired set of pages.
The direct models are only made for pages with images in
the pixacomp; the ref models are made for pages of the
same parity within %maxdist of the nearest direct model.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaCreateFromPixacomp(*args)
    
    

    try:
        leptonica.dewarpaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.dewarpaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaDestroy(*args):
        """
        ('L_DEWARPA', '**pdewa')       

:param[in,out]   pdewa:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaDestroy(*args)
    
    

    try:
        leptonica.dewarpaDestroyDewarp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpaDestroyDewarp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaDestroyDewarp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaDestroyDewarp(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'pageno')       

:param[in]    dewa:
:param[in]    pageno:    of dew to be destroyed
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaDestroyDewarp(*args)
    
    

    try:
        leptonica.dewarpaInsertDewarp.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpaInsertDewarp.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaInsertDewarp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaInsertDewarp(*args):
        """
        ('L_DEWARPA', '*dewa')       
('L_DEWARP', '*dew')       

:param[in]    dewa:
:param[in]    dew:     to be added
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This inserts the dewarp into the array, which now owns it.
It also keeps track of the largest page number stored.
It must be done before the disparity model is built.
(2) Note that this differs from the usual method of filling out
arrays in leptonica, where the arrays are compact and
new elements are typically added to the end.  Here,
the dewarp can be added anywhere, even beyond the initial
allocation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaInsertDewarp(*args)
    
    

    try:
        leptonica.dewarpaGetDewarp.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpaGetDewarp.restype = lambda address: L_DEWARP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaGetDewarp not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaGetDewarp(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'index')       

:param[in]    dewa:    populated with dewarp structs for pages
:param[in]    index:   into dewa: this is the pageno
:returns:  dew   handle; still owned by dewa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaGetDewarp(*args)
    
    

    try:
        leptonica.dewarpaSetCurvatures.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpaSetCurvatures.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaSetCurvatures not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaSetCurvatures(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'max_linecurv')       
('l_int32', 'min_diff_linecurv')       
('l_int32', 'max_diff_linecurv')       
('l_int32', 'max_edgecurv')       
('l_int32', 'max_diff_edgecurv')       
('l_int32', 'max_edgeslope')       

:param[in]    dewa:
:param[in]    max_linecurv:        -1 for default
:param[in]    min_diff_linecurv:   -1 for default; 0 to accept all models
:param[in]    max_diff_linecurv:   -1 for default
:param[in]    max_edgecurv:        -1 for default
:param[in]    max_diff_edgecurv:   -1 for default
:param[in]    max_edgeslope:       -1 for default
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Approximating the line by a quadratic, the coefficient
of the quadratic term is the curvature, and distance
units are in pixels (of course).  The curvature is very
small, so we multiply by 10^6 and express the constraints
on the model curvatures in micro-units.
(2) This sets five curvature thresholds and a slope threshold:
the maximum absolute value of the vertical disparity
line curvatures
the minimum absolute value of the largest difference in
vertical disparity line curvatures (Use a value of 0
to accept all models.)
the maximum absolute value of the largest difference in
vertical disparity line curvatures
the maximum absolute value of the left and right edge
curvature for the horizontal disparity
the maximum absolute value of the difference between
left and right edge curvature for the horizontal disparity
all in micro-units, for dewarping to take place.
Use -1 for default values.
(3) An image with a line curvature less than about 0.00001
has fairly straight textlines.  This is 10 micro-units.
(4) For example, if %max_linecurv == 100, this would prevent dewarping
if any of the lines has a curvature exceeding 100 micro-units.
A model having maximum line curvature larger than about 150
micro-units should probably not be used.
(5) A model having a left or right edge curvature larger than
about 50 micro-units should probably not be used.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaSetCurvatures(*args)
    
    

    try:
        leptonica.dewarpaUseBothArrays.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpaUseBothArrays.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaUseBothArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaUseBothArrays(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'useboth')       

:param[in]    dewa:
:param[in]    useboth:   0 for false, 1 for true
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This sets the useboth field.  If set, this will attempt
to apply both vertical and horizontal disparity arrays.
Note that a model with only a vertical disparity array will
always be valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaUseBothArrays(*args)
    
    

    try:
        leptonica.dewarpaSetCheckColumns.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpaSetCheckColumns.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaSetCheckColumns not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaSetCheckColumns(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'check_columns')       

:param[in]    dewa:
:param[in]    check_columns:    0 for false, 1 for true
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This sets the 'check_columns" field.  If set, and if
'useboth' is set, this will count the number of text
columns.  If the number is larger than 1, this will
prevent the application of horizontal disparity arrays
if they exist.
(2) The check_columns field is set to TRUE by default.
For horizontal disparity correction to take place on a
single column of text, you must have:
- a valid horizontal disparity array
- useboth = 1 (TRUE)
If there are multiple columns, in addition you need
- check_columns = 0 (FALSE)

</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaSetCheckColumns(*args)
    
    

    try:
        leptonica.dewarpaSetMaxDistance.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpaSetMaxDistance.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaSetMaxDistance not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaSetMaxDistance(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'maxdist')       

:param[in]    dewa:
:param[in]    maxdist:    for using ref models
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This sets the maxdist field.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaSetMaxDistance(*args)
    
    

    try:
        leptonica.dewarpRead.argtypes = [ctypes.c_char_p]
        leptonica.dewarpRead.restype = lambda address: L_DEWARP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  dew, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpRead(*args)
    
    

    try:
        leptonica.dewarpReadStream.argtypes = [ctypes.c_void_p]
        leptonica.dewarpReadStream.restype = lambda address: L_DEWARP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  dew  dewarp, or NULL on error

<pre>
Notes:
(1) The dewarp struct is stored in minimized format, with only
subsampled disparity arrays.
(2) The sampling and extra horizontal disparity parameters are
stored here.  During generation of the dewarp struct, they
are passed in from the dewarpa.  In readback, it is assumed
that they are (a) the same for each page and (b) the same
as the values used to create the dewarpa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpReadStream(*args)
    
    

    try:
        leptonica.dewarpReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.dewarpReadMem.restype = lambda address: L_DEWARP(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:     serialization of dewarp
:param[in]    size:     of data in bytes
:returns:  dew  dewarp, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpReadMem(*args)
    
    

    try:
        leptonica.dewarpWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.dewarpWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpWrite(*args):
        """
        ('const char', '*filename')       
('L_DEWARP', '*dew')       

:param[in]    filename:
:param[in]    dew:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpWrite(*args)
    
    

    try:
        leptonica.dewarpWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_DEWARP', '*dew')       

:param[in]    fp:     file stream opened for "wb"
:param[in]    dew:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This should not be written if there is no sampled
vertical disparity array, which means that no model has
been built for this page.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpWriteStream(*args)
    
    

    try:
        leptonica.dewarpWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('L_DEWARP', '*dew')       

:param[out]   pdata:    data of serialized dewarp (not ascii)
:param[out]   psize:    size of returned data
:param[in]    dew:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a dewarp in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpWriteMem(*args)
    
    

    try:
        leptonica.dewarpaRead.argtypes = [ctypes.c_char_p]
        leptonica.dewarpaRead.restype = lambda address: L_DEWARPA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  dewa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaRead(*args)
    
    

    try:
        leptonica.dewarpaReadStream.argtypes = [ctypes.c_void_p]
        leptonica.dewarpaReadStream.restype = lambda address: L_DEWARPA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:    file stream
:returns:  dewa, or NULL on error

<pre>
Notes:
(1) The serialized dewarp contains a Numa that gives the
(increasing) page number of the dewarp structs that are
contained.
(2) Reference pages are added in after readback.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaReadStream(*args)
    
    

    try:
        leptonica.dewarpaReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.dewarpaReadMem.restype = lambda address: L_DEWARPA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:  serialization of dewarpa
:param[in]    size:  of data in bytes
:returns:  dewa  dewarpa, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaReadMem(*args)
    
    

    try:
        leptonica.dewarpaWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.dewarpaWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaWrite(*args):
        """
        ('const char', '*filename')       
('L_DEWARPA', '*dewa')       

:param[in]    filename:
:param[in]    dewa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaWrite(*args)
    
    

    try:
        leptonica.dewarpaWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpaWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_DEWARPA', '*dewa')       

:param[in]    fp:     file stream opened for "wb"
:param[in]    dewa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaWriteStream(*args)
    
    

    try:
        leptonica.dewarpaWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpaWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('L_DEWARPA', '*dewa')       

:param[out]   pdata:    data of serialized dewarpa (not ascii)
:param[out]   psize:    size of returned data
:param[in]    dewa:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a dewarpa in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaWriteMem(*args)
    




class dewarp2(object):
    """<pre>

Build the page disparity model

Build basic page disparity model
l_int32            dewarpBuildPageModel()
l_int32            dewarpFindVertDisparity()
l_int32            dewarpFindHorizDisparity()
PTAA              *dewarpGetTextlineCenters()
static PTA        *dewarpGetMeanVerticals()
PTAA              *dewarpRemoveShortLines()
static l_int32     dewarpGetLineEndPoints()
static l_int32     dewarpFilterLineEndPoints()
static PTA        *dewarpRemoveBadEndPoints()
static l_int32     dewarpIsLineCoverageValid()
static l_int32     dewarpQuadraticLSF()

Build disparity model for slope near binding
l_int32            dewarpFindHorizSlopeDisparity()

Build the line disparity model
l_int32            dewarpBuildLineModel()

Query model status
l_int32            dewarpaModelStatus()

Rendering helpers
static l_int32     pixRenderMidYs()
static l_int32     pixRenderHorizEndPoints
</pre>




"""
    
    try:
        leptonica.dewarpBuildPageModel.argtypes = [ctypes.c_void_p, ctypes.c_char_p]
        leptonica.dewarpBuildPageModel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpBuildPageModel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpBuildPageModel(*args):
        """
        ('L_DEWARP', '*dew')       
('const char', '*debugfile')       

:param[in]    dew:
:param[in]    debugfile:    use NULL to skip writing this
:returns:  0 if OK, 1 if unable to build the model or on error

<pre>
Notes:
(1) This is the basic function that builds the horizontal and
vertical disparity arrays, which allow determination of the
src pixel in the input image corresponding to each
dest pixel in the dewarped image.
(2) Sets vsuccess = 1 if the vertical disparity array builds.
Always attempts to build the horizontal disparity array,
even if it will not be requested (useboth == 0).
Sets hsuccess = 1 if horizontal disparity builds.
(3) The method is as follows:
(a) Estimate the points along the centers of all the
long textlines.  If there are too few lines, no
disparity models are built.
(b) From the vertical deviation of the lines, estimate
the vertical disparity.
(c) From the ends of the lines, estimate the horizontal
disparity, assuming that the text is made of lines
that are close to left and right justified.
(d) One can also compute an additional contribution to the
horizontal disparity, inferred from slopes of the top
and bottom lines.  We do not do this.
(4) In more detail for the vertical disparity:
(a) Fit a LS quadratic to center locations along each line.
This smooths the curves.
(b) Sample each curve at a regular interval, find the y-value
of the mid-point on each curve, and subtract the sampled
curve value from this value.  This is the vertical
disparity at sampled points along each curve.
(c) Fit a LS quadratic to each set of vertically aligned
disparity samples.  This smooths the disparity values
in the vertical direction.  Then resample at the same
regular interval.  We now have a regular grid of smoothed
vertical disparity valuels.
(5) Once the sampled vertical disparity array is found, it can be
interpolated to get a full resolution vertical disparity map.
This can be applied directly to the src image pixels
to dewarp the image in the vertical direction, making
all textlines horizontal.  Likewise, the horizontal
disparity array is used to left- and right-align the
longest textlines.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpBuildPageModel(*args)
    
    

    try:
        leptonica.dewarpFindVertDisparity.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpFindVertDisparity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpFindVertDisparity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpFindVertDisparity(*args):
        """
        ('L_DEWARP', '*dew')       
('PTAA', '*ptaa')       
('l_int32', 'rotflag')       

:param[in]    dew:
:param[in]    ptaa:       unsmoothed lines, not vertically ordered
:param[in]    rotflag:    0 if using dew->pixs; 1 if rotated by 90 degrees cw
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This starts with points along the centers of textlines.
It does quadratic fitting (and smoothing), first along the
lines and then in the vertical direction, to generate
the sampled vertical disparity map.  This can then be
interpolated to full resolution and used to remove
the vertical line warping.
(2) Use %rotflag == 1 if you are dewarping vertical lines, as
is done in dewarpBuildLineModel().  The usual case is for
%rotflag == 0.
(3) Note that this builds a vertical disparity model (VDM), but
does not check it against constraints for validity.
Constraint checking is done after building the models,
and before inserting reference models.
(4) This sets the vsuccess flag to 1 on success.
(5) Pix debug output goes to /tmp/dewvert/ for collection into
a pdf.  Non-pix debug output goes to /tmp.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpFindVertDisparity(*args)
    
    

    try:
        leptonica.dewarpFindHorizDisparity.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpFindHorizDisparity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpFindHorizDisparity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpFindHorizDisparity(*args):
        """
        ('L_DEWARP', '*dew')       
('PTAA', '*ptaa')       

:param[in]    dew:
:param[in]    ptaa:     unsmoothed lines, not vertically ordered
:returns:  0 if OK, 1 if horizontal disparity array is not built, or on error

<pre>
Notes:
(1) This builds a horizontal disparity model (HDM), but
does not check it against constraints for validity.
Constraint checking is done at rendering time.
(2) Horizontal disparity is not required for a successful model;
only the vertical disparity is required.  This will not be
called if the function to build the vertical disparity fails.
(3) This sets the hsuccess flag to 1 on success.
(4) Internally in ptal1, ptar1, ptal2, ptar2: x and y are reversed,
so the 'y' value is horizontal distance across the image width.
(5) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpFindHorizDisparity(*args)
    
    

    try:
        leptonica.dewarpGetTextlineCenters.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpGetTextlineCenters.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpGetTextlineCenters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpGetTextlineCenters(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'debugflag')       

:param[in]    pixs:        1 bpp
:param[in]    debugflag:   1 for debug output
:returns:  ptaa of center values of textlines

<pre>
Notes:
(1) This in general does not have a point for each value
of x, because there will be gaps between words.
It doesn't matter because we will fit a quadratic to the
points that we do have.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpGetTextlineCenters(*args)
    
    

    try:
        leptonica.dewarpRemoveShortLines.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.dewarpRemoveShortLines.restype = lambda address: PTAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function dewarpRemoveShortLines not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpRemoveShortLines(*args):
        """
        ('PIX', '*pixs')       
('PTAA', '*ptaas')       
('l_float32', 'fract')       
('l_int32', 'debugflag')       

:param[in]    pixs:       1 bpp
:param[in]    ptaas:      input lines
:param[in]    fract:      minimum fraction of longest line to keep
:param[in]    debugflag:
:returns:  ptaad containing only lines of sufficient length,
or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpRemoveShortLines(*args)
    
    

    try:
        leptonica.dewarpFindHorizSlopeDisparity.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32]
        leptonica.dewarpFindHorizSlopeDisparity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpFindHorizSlopeDisparity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpFindHorizSlopeDisparity(*args):
        """
        ('L_DEWARP', '*dew')       
('PIX', '*pixb')       
('l_float32', 'fractthresh')       
('l_int32', 'parity')       

:param[in]    dew:
:param[in]    pixb:         1 bpp, with vert and horiz disparity removed
:param[in]    fractthresh:  threshold fractional difference in density
:param[in]    parity:       0 if even page, 1 if odd page
:returns:       0 if OK, 1 on error

<pre>
Notes:
(1) %fractthresh is a threshold on the fractional difference in stroke
density between between left and right sides.  Process this
disparity only if the absolute value of the fractional
difference equals or exceeds this threshold.
(2) %parity indicates where the binding is: on the left for
%parity == 0 and on the right for %parity == 1.
(3) This takes a 1 bpp %pixb where both vertical and horizontal
disparity have been applied, so the text lines are straight and,
more importantly, the line end points are vertically aligned.
It estimates the foreshortening of the characters on the
binding side, and if significant, computes a one-dimensional
horizontal disparity function to compensate.
(4) The first attempt was to use the average width of the
connected components (c.c.) in vertical slices.  This does not work
reliably, because the horizontal compression of the text is
often accompanied by horizontal joining of c.c.
(5) We use the density of vertical strokes, measured by first using
a vertical opening, which improves the signal.  The result
is relatively insensitive to the size of the opening; we use
a 10-pixel opening.  The relative density is measured by
finding the number of c.c. in a full height sliding window
of width 50 pixels, and compute every 25 pixels.  Similar results
are obtained counting c.c. that either intersect the window
or are fully contained within it.
(6) Debug output goes to /tmp/lept/dewmod/ for collection into a pdf.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpFindHorizSlopeDisparity(*args)
    
    

    try:
        leptonica.dewarpBuildLineModel.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.dewarpBuildLineModel.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpBuildLineModel not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpBuildLineModel(*args):
        """
        ('L_DEWARP', '*dew')       
('l_int32', 'opensize')       
('const char', '*debugfile')       

:param[in]    dew:
:param[in]    opensize:    size of opening to remove perpendicular lines
:param[in]    debugfile:   use NULL to skip writing this
:returns:  0 if OK, 1 if unable to build the model or on error

<pre>
Notes:
(1) This builds the horizontal and vertical disparity arrays
for an input of ruled lines, typically for calibration.
In book scanning, you could lay the ruled paper over a page.
Then for that page and several below it, you can use the
disparity correction of the line model to dewarp the pages.
(2) The dew has been initialized with the image of ruled lines.
These lines must be continuous, but we do a small amount
of pre-processing here to insure that.
(3) %opensize is typically about 8.  It must be larger than
the thickness of the lines to be extracted.  This is the
default value, which is applied if %opensize < 3.
(4) Sets vsuccess = 1 and hsuccess = 1 if the vertical and/or
horizontal disparity arrays build.
(5) Similar to dewarpBuildPageModel(), except here the vertical
and horizontal disparity arrays are both built from ruled lines.
See notes there.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpBuildLineModel(*args)
    
    

    try:
        leptonica.dewarpaModelStatus.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpaModelStatus.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaModelStatus not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaModelStatus(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'pageno')       
('l_int32', '*pvsuccess')       
('l_int32', '*phsuccess')       

:param[in]    dewa:
:param[in]    pageno:
:param[out]   pvsuccess:    [optional] 1 on success
:param[out]   phsuccess:    [optional] 1 on success
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This tests if a model has been built, not if it is valid.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaModelStatus(*args)
    




class dewarp3(object):
    """<pre>

Applying and stripping the page disparity model

Apply disparity array to pix
l_int32            dewarpaApplyDisparity()
static l_int32     dewarpaApplyInit()
static PIX        *pixApplyVertDisparity()
static PIX        *pixApplyHorizDisparity()

Apply disparity array to boxa
l_int32            dewarpaApplyDisparityBoxa()
static BOXA       *boxaApplyDisparity()

Stripping out data and populating full res disparity
l_int32            dewarpMinimize()
l_int32            dewarpPopulateFullRes()

Static functions not presently in use
static FPIX       *fpixSampledDisparity()
static FPIX       *fpixExtraHorizDisparity()

</pre>




"""
    
    try:
        leptonica.dewarpaApplyDisparity.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.dewarpaApplyDisparity.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaApplyDisparity not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaApplyDisparity(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'pageno')       
('PIX', '*pixs')       
('l_int32', 'grayin')       
('l_int32', 'x')       
('l_int32', 'y')       
('PIX', '**ppixd')       
('const char', '*debugfile')       

:param[in]    dewa:
:param[in]    pageno:      of page model to be used; may be a ref model
:param[in]    pixs:        image to be modified; can be 1, 8 or 32 bpp
:param[in]    grayin:      gray value, from 0 to 255, for pixels brought in;
use -1 to use pixels on the boundary of pixs
:param[in]    x,: y        origin for generation of disparity arrays
:param[out]   ppixd:       disparity corrected image
:param[in]    debugfile:   use NULL to skip writing this
:returns:  0 if OK, 1 on error no models or ref models available

<pre>
Notes:
(1) This applies the disparity arrays to the specified image.
(2) Specify gray color for pixels brought in from the outside:
0 is black, 255 is white.  Use -1 to select pixels from the
boundary of the source image.
(3) If the models and ref models have not been validated, this
will do so by calling dewarpaInsertRefModels().
(4) This works with both stripped and full resolution page models.
If the full res disparity array(s) are missing, they are remade.
(5) The caller must handle errors that are returned because there
are no valid models or ref models for the page -- typically
by using the input pixs.
(6) If there is no model for %pageno, this will use the model for
'refpage' and put the result in the dew for %pageno.
(7) This populates the full resolution disparity arrays if
necessary.  If x and/or y are positive, they are used,
in conjunction with pixs, to determine the required
slope-based extension of the full resolution disparity
arrays in each direction.  When (x,y) == (0,0), all
extension is to the right and down.  Nonzero values of (x,y)
are useful for dewarping when pixs is deliberately undercropped.
(8) Important: when applying disparity to a number of images,
after calling this function and saving the resulting pixd,
you should call dewarpMinimize(dew) on the dew for %pageno.
This will remove pixs and pixd (or their clones) stored in dew,
as well as the full resolution disparity arrays.  Together,
these hold approximately 16 bytes for each pixel in pixs.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaApplyDisparity(*args)
    
    

    try:
        leptonica.dewarpaApplyDisparityBoxa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p]
        leptonica.dewarpaApplyDisparityBoxa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaApplyDisparityBoxa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaApplyDisparityBoxa(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'pageno')       
('PIX', '*pixs')       
('BOXA', '*boxas')       
('l_int32', 'mapdir')       
('l_int32', 'x')       
('l_int32', 'y')       
('BOXA', '**pboxad')       
('const char', '*debugfile')       

:param[in]    dewa:
:param[in]    pageno:      of page model to be used; may be a ref model
:param[in]    pixs:        initial pix reference; for alignment and debugging
:param[in]    boxas:       boxa to be mapped
:param[in]    mapdir:      1 if mapping forward from original to dewarped;
0 if backward
:param[in]    x,: y        origin for generation of disparity arrays with
respect to the source region
:param[out]   pboxad:      disparity corrected boxa
:param[in]    debugfile:   use NULL to skip writing this
:returns:  0 if OK, 1 on error no models or ref models available

<pre>
Notes:
(1) This applies the disparity arrays in one of two mapping directions
to the specified boxa.  It can be used in the backward direction
to locate a box in the original coordinates that would have
been dewarped to to the specified image.
(2) If there is no model for %pageno, this will use the model for
'refpage' and put the result in the dew for %pageno.
(3) This works with both stripped and full resolution page models.
If the full res disparity array(s) are missing, they are remade.
(4) If an error occurs, a copy of the input boxa is returned.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaApplyDisparityBoxa(*args)
    
    

    try:
        leptonica.dewarpMinimize.argtypes = [ctypes.c_void_p]
        leptonica.dewarpMinimize.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpMinimize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpMinimize(*args):
        """
        ('L_DEWARP', '*dew')       

:param[in]    dew:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This removes all data that is not needed for serialization.
It keeps the subsampled disparity array(s), so the full
resolution arrays can be reconstructed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpMinimize(*args)
    
    

    try:
        leptonica.dewarpPopulateFullRes.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpPopulateFullRes.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpPopulateFullRes not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpPopulateFullRes(*args):
        """
        ('L_DEWARP', '*dew')       
('PIX', '*pix')       
('l_int32', 'x')       
('l_int32', 'y')       

:param[in]    dew:
:param[in]    pix:     [optional], to give size of actual image
:param[in]    x,: y    origin for generation of disparity arrays
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) If the full resolution vertical and horizontal disparity
arrays do not exist, they are built from the subsampled ones.
(2) If pixs is not given, the size of the arrays is determined
by the original image from which the sampled version was
generated.  Any values of (x,y) are ignored.
(3) If pixs is given, the full resolution disparity arrays must
be large enough to accommodate it.
(a) If the arrays do not exist, the value of (x,y) determines
the origin of the full resolution arrays without extension,
relative to pixs.  Thus, (x,y) gives the amount of
slope extension in (left, top).  The (right, bottom)
extension is then determined by the size of pixs and
(x,y); the values should never be < 0.
(b) If the arrays exist and pixs is too large, the existing
full res arrays are destroyed and new ones are made,
again using (x,y) to determine the extension in the
four directions.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpPopulateFullRes(*args)
    




class dewarp4(object):
    """<pre>

Single page dewarper

Reference model (book-level, dewarpa) operations and debugging output

Top-level single page dewarper
l_int32            dewarpSinglePage()
l_int32            dewarpSinglePageInit()
l_int32            dewarpSinglePageRun()

Operations on dewarpa
l_int32            dewarpaListPages()
l_int32            dewarpaSetValidModels()
l_int32            dewarpaInsertRefModels()
l_int32            dewarpaStripRefModels()
l_int32            dewarpaRestoreModels()

Dewarp debugging output
l_int32            dewarpaInfo()
l_int32            dewarpaModelStats()
static l_int32     dewarpaTestForValidModel()
l_int32            dewarpaShowArrays()
l_int32            dewarpDebug()
l_int32            dewarpShowResults()
</pre>




"""
    
    try:
        leptonica.dewarpSinglePage.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpSinglePage.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpSinglePage not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpSinglePage(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('l_int32', 'adaptive')       
('l_int32', 'useboth')       
('l_int32', 'check_columns')       
('PIX', '**ppixd')       
('L_DEWARPA', '**pdewa')       
('l_int32', 'debug')       

:param[in]    pixs:            with text, any depth
:param[in]    thresh:          for global thresh to 1 bpp; ignore otherwise
:param[in]    adaptive:        1 for adaptive thresh; 0 for global threshold
:param[in]    useboth:         1 for both horiz and vert; 0 for vertical only
:param[in]    check_columns:   1 to skip horizontal if multiple columns;
0 otherwise; default is to skip
:param[out]   ppixd:           dewarped result
:param[out]   pdewa:           [optional] dewa with single page; NULL to skip
:param[in]    debug:           1 for debugging output, 0 otherwise
:returns:  0 if OK, 1 on error list of page numbers, or NULL on error

<pre>
Notes:
(1) Dewarps pixs and returns the result in &pixd.
(2) This uses default values for all model parameters.
(3) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
(4) If it can't build a model, returns a copy of pixs in &pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpSinglePage(*args)
    
    

    try:
        leptonica.dewarpSinglePageInit.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpSinglePageInit.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpSinglePageInit not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpSinglePageInit(*args):
        """
        ('PIX', '*pixs')       
('l_int32', 'thresh')       
('l_int32', 'adaptive')       
('l_int32', 'useboth')       
('l_int32', 'check_columns')       
('PIX', '**ppixb')       
('L_DEWARPA', '**pdewa')       

:param[in]    pixs:            with text, any depth
:param[in]    thresh:          for global thresh to 1 bpp; ignore otherwise
:param[in]    adaptive:        1 for adaptive thresh; 0 for global threshold
:param[in]    useboth:         1 for both horiz and vert; 0 for vertical only
:param[in]    check_columns:   1 to skip horizontal if multiple columns;
0 otherwise; default is to skip
:param[out]   ppixb:           1 bpp debug image
:param[out]   pdewa:           initialized dewa
:returns:  0 if OK, 1 on error list of page numbers, or NULL on error

<pre>
Notes:
(1) This binarizes the input pixs if necessary, returning the
binarized image.  It also initializes the dewa to default values
for the model parameters.
(2) If pixs is 1 bpp, the parameters %adaptive and %thresh are ignored.
(3) To change the model parameters, call dewarpaSetCurvatures()
before running dewarpSinglePageRun().  For example:
dewarpSinglePageInit(pixs, 0, 1, 1, 1, &pixb, &dewa);
dewarpaSetCurvatures(dewa, 250, -1, -1, 80, 70, 150);
dewarpSinglePageRun(pixs, pixb, dewa, &pixd, 0);
dewarpaDestroy(&dewa);
pixDestroy(&pixb);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpSinglePageInit(*args)
    
    

    try:
        leptonica.dewarpSinglePageRun.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.dewarpSinglePageRun.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpSinglePageRun not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpSinglePageRun(*args):
        """
        ('PIX', '*pixs')       
('PIX', '*pixb')       
('L_DEWARPA', '*dewa')       
('PIX', '**ppixd')       
('l_int32', 'debug')       

:param[in]    pixs:    any depth
:param[in]    pixb:    1 bpp
:param[in]    dewa:    initialized
:param[out]   ppixd:   dewarped result
:param[in]    debug:   1 for debugging output, 0 otherwise
:returns:  0 if OK, 1 on error list of page numbers, or NULL on error

<pre>
Notes:
(1) Dewarps pixs and returns the result in &pixd.
(2) The 1 bpp version %pixb and %dewa are conveniently generated by
dewarpSinglePageInit().
(3) Non-default model parameters must be set before calling this.
(4) If a model cannot be built, this returns a copy of pixs in &pixd.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpSinglePageRun(*args)
    
    

    try:
        leptonica.dewarpaListPages.argtypes = [ctypes.c_void_p]
        leptonica.dewarpaListPages.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaListPages not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaListPages(*args):
        """
        ('L_DEWARPA', '*dewa')       

:param[in]    dewa:    populated with dewarp structs for pages
:returns:  0 if OK, 1 on error list of page numbers, or NULL on error

<pre>
Notes:
(1) This generates two numas, stored in the dewarpa, that give:
(a) the page number for each dew that has a page model.
(b) the page number for each dew that has either a page
model or a reference model.
It can be called at any time.
(2) It is called by the dewarpa serializer before writing.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaListPages(*args)
    
    

    try:
        leptonica.dewarpaSetValidModels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpaSetValidModels.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaSetValidModels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaSetValidModels(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'notests')       
('l_int32', 'debug')       

:param[in]    dewa:
:param[in]    notests:
:param[in]    debug:     1 to output information on invalid page models
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) A valid model must meet the rendering requirements, which
include whether or not a vertical disparity model exists
and conditions on curvatures for vertical and horizontal
disparity models.
(2) If %notests == 1, this ignores the curvature constraints
and assumes that all successfully built models are valid.
(3) This function does not need to be called by the application.
It is called by dewarpaInsertRefModels(), which
will destroy all invalid dewarps.  Consequently, to inspect
an invalid dewarp model, it must be done before calling
dewarpaInsertRefModels().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaSetValidModels(*args)
    
    

    try:
        leptonica.dewarpaInsertRefModels.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpaInsertRefModels.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaInsertRefModels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaInsertRefModels(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', 'notests')       
('l_int32', 'debug')       

:param[in]    dewa:
:param[in]    notests:    if 1, ignore curvature constraints on model
:param[in]    debug:      1 to output information on invalid page models
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This destroys all dewarp models that are invalid, and then
inserts reference models where possible.
(2) If %notests == 1, this ignores the curvature constraints
and assumes that all successfully built models are valid.
(3) If useboth == 0, it uses the closest valid model within the
distance and parity constraints.  If useboth == 1, it tries
to use the closest allowed hvalid model; if it doesn't find
an hvalid model, it uses the closest valid model.
(4) For all pages without a model, this clears out any existing
invalid and reference dewarps, finds the nearest valid model
with the same parity, and inserts an empty dewarp with the
reference page.
(5) Then if it is requested to use both vertical and horizontal
disparity arrays (useboth == 1), it tries to replace any
hvalid == 0 model or reference with an hvalid == 1 reference.
(6) The distance constraint is that any reference model must
be within maxdist.  Note that with the parity constraint,
no reference models will be used if maxdist < 2.
(7) This function must be called, even if reference models will
not be used.  It should be called after building models on all
available pages, and after setting the rendering parameters.
(8) If the dewa has been serialized, this function is called by
dewarpaRead() when it is read back.  It is also called
any time the rendering parameters are changed.
(9) Note: if this has been called with useboth == 1, and useboth
is reset to 0, you should first call dewarpaRestoreModels()
to bring real models from the cache back to the primary array.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaInsertRefModels(*args)
    
    

    try:
        leptonica.dewarpaStripRefModels.argtypes = [ctypes.c_void_p]
        leptonica.dewarpaStripRefModels.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaStripRefModels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaStripRefModels(*args):
        """
        ('L_DEWARPA', '*dewa')       

:param[in]    dewa:    populated with dewarp structs for pages
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This examines each dew in a dewarpa, and removes
all that don't have their own page model (i.e., all
that have "references" to nearby pages with valid models).
These references were generated by dewarpaInsertRefModels(dewa).
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaStripRefModels(*args)
    
    

    try:
        leptonica.dewarpaRestoreModels.argtypes = [ctypes.c_void_p]
        leptonica.dewarpaRestoreModels.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaRestoreModels not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaRestoreModels(*args):
        """
        ('L_DEWARPA', '*dewa')       

:param[in]    dewa:     populated with dewarp structs for pages
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This puts all real models (and only real models) in the
primary dewarpa array.  First remove all dewarps that are
only references to other page models.  Then move all models
that had been cached back into the primary dewarp array.
(2) After this is done, we still need to recompute and insert
the reference models before dewa->modelsready is true.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaRestoreModels(*args)
    
    

    try:
        leptonica.dewarpaInfo.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpaInfo.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaInfo not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaInfo(*args):
        """
        ('FILE', '*fp')       
('L_DEWARPA', '*dewa')       

:param[in]    fp:
:param[in]    dewa:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaInfo(*args)
    
    

    try:
        leptonica.dewarpaModelStats.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.dewarpaModelStats.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaModelStats not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaModelStats(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_int32', '*pnnone')       
('l_int32', '*pnvsuccess')       
('l_int32', '*pnvvalid')       
('l_int32', '*pnhsuccess')       
('l_int32', '*pnhvalid')       
('l_int32', '*pnref')       

:param[in]    dewa:
:param[out]   pnnone:       [optional] number without any model
:param[out]   pnvsuccess:   [optional] number with a vert model
:param[out]   pnvvalid:     [optional] number with a valid vert model
:param[out]   pnhsuccess:   [optional] number with both models
:param[out]   pnhvalid:     [optional] number with both models valid
:param[out]   pnref:        [optional] number with a reference model
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) A page without a model has no dew.  It most likely failed to
generate a vertical model, and has not been assigned a ref
model from a neighboring page with a valid vertical model.
(2) A page has vsuccess == 1 if there is at least a model of the
vertical disparity.  The model may be invalid, in which case
dewarpaInsertRefModels() will stash it in the cache and
attempt to replace it by a valid ref model.
(3) A vvvalid model is a vertical disparity model whose parameters
satisfy the constraints given in dewarpaSetValidModels().
(4) A page has hsuccess == 1 if both the vertical and horizontal
disparity arrays have been constructed.
(5) An  hvalid model has vertical and horizontal disparity
models whose parameters satisfy the constraints given
in dewarpaSetValidModels().
(6) A page has a ref model if it failed to generate a valid
model but was assigned a vvalid or hvalid model on another
page (within maxdist) by dewarpaInsertRefModel().
(7) This calls dewarpaTestForValidModel(); it ignores the vvalid
and hvalid fields.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaModelStats(*args)
    
    

    try:
        leptonica.dewarpaShowArrays.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.dewarpaShowArrays.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpaShowArrays not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpaShowArrays(*args):
        """
        ('L_DEWARPA', '*dewa')       
('l_float32', 'scalefact')       
('l_int32', 'first')       
('l_int32', 'last')       

:param[in]    dewa:
:param[in]    scalefact:    on contour images; typ. 0.5
:param[in]    first:        first page model to render
:param[in]    last:         last page model to render; use 0 to go to end
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Generates a pdf of contour plots of the disparity arrays.
(2) This only shows actual models; not ref models
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpaShowArrays(*args)
    
    

    try:
        leptonica.dewarpDebug.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.dewarpDebug.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpDebug not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpDebug(*args):
        """
        ('L_DEWARP', '*dew')       
('const char', '*subdirs')       
('l_int32', 'index')       

:param[in]    dew:
:param[in]    subdirs:   one or more subdirectories of /tmp; e.g., "dew1"
:param[in]    index:     to help label output images; e.g., the page number
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Prints dewarp fields and generates disparity array contour images.
The contour images are written to file:
/tmp/[subdirs]/pixv_[index].png
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpDebug(*args)
    
    

    try:
        leptonica.dewarpShowResults.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_char_p]
        leptonica.dewarpShowResults.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function dewarpShowResults not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def dewarpShowResults(*args):
        """
        ('L_DEWARPA', '*dewa')       
('SARRAY', '*sa')       
('BOXA', '*boxa')       
('l_int32', 'firstpage')       
('l_int32', 'lastpage')       
('const char', '*pdfout')       

:param[in]    dewa:
:param[in]    sa:          of indexed input images
:param[in]    boxa:        crop boxes for input images; can be null
:param[in]    firstpage:
:param[in]    lastpage:
:param[in]    pdfout:      filename
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This generates a pdf of image pairs (before, after) for
the designated set of input pages.
(2) If the boxa exists, its elements are aligned with numbers
in the filenames in %sa.  It is used to crop the input images.
It is assumed that the dewa was generated from the cropped
images.  No undercropping is applied before rendering.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.dewarpShowResults(*args)
    




class recogbasic(object):
    """<pre>

Recog creation, destruction and access
L_RECOG            *recogCreateFromRecog()
L_RECOG            *recogCreateFromPixa()
L_RECOG            *recogCreateFromPixaNoFinish()
L_RECOG            *recogCreate()
void                recogDestroy()

Recog accessors
l_int32             recogGetCount()
l_int32             recogSetParams()
static l_int32      recogGetCharsetSize()

Character/index lookup
l_int32             recogGetClassIndex()
l_int32             recogStringToIndex()
l_int32             recogGetClassString()
l_int32             l_convertCharstrToInt()

Serialization
L_RECOG            *recogRead()
L_RECOG            *recogReadStream()
L_RECOG            *recogReadMem()
l_int32             recogWrite()
l_int32             recogWriteStream()
l_int32             recogWriteMem()
PIXA               *recogExtractPixa()
static l_int32      recogAddCharstrLabels()
static l_int32      recogAddAllSamples()

The recognizer functionality is split into four files:
recogbasic.c: create, destroy, access, serialize
recogtrain.c: training on labeled and unlabeled data
recogident.c: running the recognizer(s) on input
recogdid.c:   running the recognizer(s) on input using a
document image decoding (DID) hidden markov model

This is a content-adapted (or book-adapted) recognizer (BAR) application.
The recognizers here are typically assembled from data that has
been labeled by a generic recognition system, such as Tesseract.
The general procedure to create a recognizer (recog) from labeled data is
to add the labeled character bitmaps, either one at a time or
all together from a pixa with labeled pix.

The suggested use for a BAR that consists of labeled templates drawn
from a single source (e.g., a book) is to identify unlabeled samples
by using unscaled character templates in the BAR, picking the
template closest to the unlabeled sample.

Outliers can be removed from a pixa of labeled pix.  This is one of
two methods that use averaged templates (the other is greedy splitting
of characters).  See recogtrain.c for a discussion and the implementation.

A special bootstrap recognizer (BSR) can be used to make a BAR from
unlabeled book data.  This is done by comparing character images
from the book with labeled templates in the BSR, where all images
are scaled to h = 40.  The templates can be either the scanned images
or images consisting of width-normalized strokes derived from
the skeleton of the character bitmaps.

Two BARs of labeled character data, that have been made by
different recognizers, can be joined by extracting a pixa of the
labeled templates from each, joining the two pixa, and then
and regenerating a BAR from the joined set of templates.
If all the labeled character data is from a single source (e.g, a book),
identification can proceed using unscaled templates (either the input
image or width-normalized lines).  But if the labeled data comes from
more than one source, (a "hybrid" recognizer), the templates should
be scaled, and we recommend scaling to a fixed height.

Suppose it is not possible to generate a BAR with a sufficient number
of templates of each class taken from a single source.  In that case,
templates from the BSR itself can be added.  This is the condition
described above, where the labeled templates come from multiple
sources, and it is necessary to do all character matches using
templates that have been scaled to a fixed height (e.g., 40).
Likewise, the samples to be identified using this hybrid recognizer
must be modified in the same way.  See prog/recogtest3.c for an
example of the steps that can be taken in the construction of a BAR
using a BSR.

For training numeric input, an example set of calls that scales
each training input to fixed h and will use the line templates of
width linew for identifying unknown characters is:
L_Recog  *rec = recogCreate(0, h, linew, 128, 1);
for (i = 0; i < n; i++) {  // read in n training digits
Pix *pix = ...
recogTrainLabeled(rec, pix, NULL, text[i], 0);
}
recogTrainingFinished(&rec, 1, -1, -1.0);  // required

It is an error if any function that computes averages, removes
outliers or requests identification of an unlabeled character,
such as:
(1) computing the sample averages: recogAverageSamples()
(2) removing outliers: recogRemoveOutliers1() or recogRemoveOutliers2()
(3) requesting identification of an unlabeled character:
recogIdentifyPix()
is called before an explicit call to finish training.  Note that
to do further training on a "finished" recognizer, you can set
recog->train_done = FALSE;
add the new training samples, and again call
recogTrainingFinished(&rec, 1, -1, -1.0);  // required

If not scaling, using the images directly for identification, and
removing outliers, do something like this:
L_Recog  *rec = recogCreate(0, 0, 0, 128, 1);
for (i = 0; i < n; i++) {  // read in n training characters
Pix *pix = ...
recogTrainLabeled(rec, pix, NULL, text[i], 0);
}
recogTrainingFinished(&rec, 1, -1, -1.0);
if (!rec) ... [return]
// remove outliers
recogRemoveOutliers1(&rec, 0.7, 2, NULL, NULL);

You can generate a recognizer from a pixa where the text field in
each pix is the character string label for the pix.  For example,
the following recognizer will store unscaled line images:
L_Recog  *rec = recogCreateFromPixa(pixa, 0, 0, linew, 128, 1);
and in use, it is fed unscaled line images to identify.

For the following, assume that you have a pixa of labeled templates.
If it is likely that some of the input templates are mislabeled,
there are several things that can be done to remove them.
The first is to put a size and quantity filter on them; e.g.
Pixa *pixa2 = recogFilterPixaBySize(pixa1, 10, 15, 2.6);
Then you can remove outliers; e.g.,
Pixa *pixa3 = pixaRemoveOutliers2(pixa2, -1.0, -1, NULL, NULL);

To this point, all templates are from a single source, so you
can make a recognizer that uses the unscaled templates and optionally
attempts to split touching characters:
L_Recog *recog1 = recogCreateFromPixa(pixa3, ...);
Alternatively, if you need more templates for some of the classes,
you can pad with templates from a "bootstrap" recognizer (BSR).
If you pad, it is necessary to scale the templates and input
samples to a fixed height, and no attempt will be made to split
the input sample connected components:
L_Recog *recog1 = recogCreateFromPixa(pixa3, 0, 40, 0, 128, 0);
recogPadDigitTrainingSet(&recog1, 40, 0);

A special case is a pure BSR, that contains images scaled to a fixed
height (we use 40 in these examples).
For this,use either the scanned bitmap:
L_Recog  *recboot = recogCreateFromPixa(pixa, 0, 40, 0, 128, 1);
or width-normalized lines (use width of 5 here):
L_Recog  *recboot = recogCreateFromPixa(pixa, 0, 40, 5, 128, 1);

This can be used to train a new book adapted recognizer (BAC), on
unlabeled data from, e.g., a book.  To do this, the following is required:
(1) the input images from the book must be scaled in the same
way as those in the BSR, and
(2) both the BSR and the input images must be set up to be either
input scanned images or width-normalized lines.

</pre>




"""
    
    try:
        leptonica.recogCreateFromRecog.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogCreateFromRecog.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogCreateFromRecog not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCreateFromRecog(*args):
        """
        ('L_RECOG', '*recs')       
('l_int32', 'scalew')       
('l_int32', 'scaleh')       
('l_int32', 'linew')       
('l_int32', 'threshold')       
('l_int32', 'maxyshift')       

:param[in]    recs:        source recog with arbitrary input parameters
:param[in]    scalew:      scale all widths to this; use 0 otherwise
:param[in]    scaleh:      scale all heights to this; use 0 otherwise
:param[in]    linew:       width of normalized strokes; use 0 to skip
:param[in]    threshold:   for binarization; typically ~128
:param[in]    maxyshift:   from nominal centroid alignment; default is 1
:returns:  recd, or NULL on error

<pre>
Notes:
(1) This is a convenience function that generates a recog using
the unscaled training data in an existing recog.
(2) It is recommended to use %maxyshift = 1 (the default value)
(3) See recogCreate() for use of %scalew, %scaleh and %linew.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogCreateFromRecog(*args)
    
    

    try:
        leptonica.recogCreateFromPixa.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogCreateFromPixa.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogCreateFromPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCreateFromPixa(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'scalew')       
('l_int32', 'scaleh')       
('l_int32', 'linew')       
('l_int32', 'threshold')       
('l_int32', 'maxyshift')       

:param[in]    pixa:         of labeled, 1 bpp images
:param[in]    scalew:       scale all widths to this; use 0 otherwise
:param[in]    scaleh:       scale all heights to this; use 0 otherwise
:param[in]    linew:        width of normalized strokes; use 0 to skip
:param[in]    threshold:    for binarization; typically ~150
:param[in]    maxyshift:    from nominal centroid alignment; default is 1
:returns:  recog, or NULL on error

<pre>
Notes:
(1) This is a convenience function for training from labeled data.
The pixa can be read from file.
(2) The pixa should contain the unscaled bitmaps used for training.
(3) See recogCreate() for use of %scalew, %scaleh and %linew.
(4) It is recommended to use %maxyshift = 1 (the default value)
(5) All examples in the same class (i.e., with the same character
label) should be similar.  They can be made similar by invoking
recogRemoveOutliers[1,2]() on %pixa before calling this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogCreateFromPixa(*args)
    
    

    try:
        leptonica.recogCreateFromPixaNoFinish.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogCreateFromPixaNoFinish.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogCreateFromPixaNoFinish not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCreateFromPixaNoFinish(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'scalew')       
('l_int32', 'scaleh')       
('l_int32', 'linew')       
('l_int32', 'threshold')       
('l_int32', 'maxyshift')       

:param[in]    pixa:         of labeled, 1 bpp images
:param[in]    scalew:       scale all widths to this; use 0 otherwise
:param[in]    scaleh:       scale all heights to this; use 0 otherwise
:param[in]    linew:        width of normalized strokes; use 0 to skip
:param[in]    threshold:    for binarization; typically ~150
:param[in]    maxyshift:    from nominal centroid alignment; default is 1
:returns:  recog, or NULL on error

<pre>
Notes:
(1) See recogCreateFromPixa() for details.
(2) This is also used to generate a pixaa with templates
in each class within a pixa.  For that, all args except for
%pixa are ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogCreateFromPixaNoFinish(*args)
    
    

    try:
        leptonica.recogCreate.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogCreate.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogCreate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCreate(*args):
        """
        ('l_int32', 'scalew')       
('l_int32', 'scaleh')       
('l_int32', 'linew')       
('l_int32', 'threshold')       
('l_int32', 'maxyshift')       

:param[in]    scalew:       scale all widths to this; use 0 otherwise
:param[in]    scaleh:       scale all heights to this; use 0 otherwise
:param[in]    linew:        width of normalized strokes; use 0 to skip
:param[in]    threshold:    for binarization; typically ~128; 0 for default
:param[in]    maxyshift:    from nominal centroid alignment; default is 1
:returns:  recog, or NULL on error

<pre>
Notes:
(1) If %scalew == 0 and %scaleh == 0, no scaling is done.
If one of these is 0 and the other is > 0, scaling is isotropic
to the requested size.  We typically do not set both > 0.
(2) Use linew > 0 to convert the templates to images with fixed
width strokes.  linew == 0 skips the conversion.
(3) The only valid values for %maxyshift are 0, 1 and 2.
It is recommended to use %maxyshift == 1 (default value).
Using %maxyshift == 0 is much faster than %maxyshift == 1, but
it is much less likely to find the template with the best
correlation.  Use of anything but 1 results in a warning.
(4) Scaling is used for finding outliers and for training a
book-adapted recognizer (BAR) from a bootstrap recognizer (BSR).
Scaling the height to a fixed value and scaling the width
accordingly (e.g., %scaleh = 40, %scalew = 0) is recommended.
(5) The storage for most of the arrays is allocated when training
is finished.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogCreate(*args)
    
    

    try:
        leptonica.recogDestroy.argtypes = [ctypes.c_void_p]
        leptonica.recogDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function recogDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogDestroy(*args):
        """
        ('L_RECOG', '**precog')       

:param[in,out]   precog:    will be set to null before returning
:returns:  void


        """
        args = _convert_params(*args)
        
        return leptonica.recogDestroy(*args)
    
    

    try:
        leptonica.recogGetCount.argtypes = [ctypes.c_void_p]
        leptonica.recogGetCount.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogGetCount not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogGetCount(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]    recog:
:returns:  count of classes in recog; 0 if no recog or on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogGetCount(*args)
    
    

    try:
        leptonica.recogSetParams.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_float]
        leptonica.recogSetParams.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogSetParams not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogSetParams(*args):
        """
        ('L_RECOG', '*recog')       
('l_int32', 'type')       
('l_int32', 'min_nopad')       
('l_float32', 'max_wh_ratio')       
('l_float32', 'max_ht_ratio')       

:param[in]    recog:          to be padded, if necessary
:param[in]    type:           type of char set; -1 for default;
see enum in recog.h
:param[in]    min_nopad:      min number in a class without padding;
use -1 for default
:param[in]    max_wh_ratio:   max width/height ratio allowed for splitting;
use -1.0 for default
:param[in]    max_ht_ratio:   max of max/min averaged template height ratio;
use -1.0 for default
:returns:       0 if OK, 1 on error

<pre>
Notes:
(1) This is called when a recog is created.
(2) Default %min_nopad value allows for some padding.
To disable padding, set %min_nopad = 0.  To pad only when
no samples are available for the class, set %min_nopad = 1.
(3) The %max_wh_ratio limits the width/height ratio for components
that we attempt to split.  Splitting long components is expensive.
(4) The %max_ht_ratio is a quality requirement on the training data.
The recognizer will not run if the averages are computed and
the templates do not satisfy it.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogSetParams(*args)
    
    

    try:
        leptonica.recogGetClassIndex.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.recogGetClassIndex.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogGetClassIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogGetClassIndex(*args):
        """
        ('L_RECOG', '*recog')       
('l_int32', 'val')       
('char', '*text')       
('l_int32', '*pindex')       

:param[in]    recog:     with LUT's pre-computed
:param[in]    val:       integer value; can be up to 3 bytes for UTF-8
:param[in]    text:      text from which %val was derived; used if not found
:param[out]   pindex:    index into dna_tochar
:returns:  0 if found; 1 if not found and added; 2 on error.

<pre>
Notes:
(1) This is used during training.  There is one entry in
recog->dna_tochar (integer value, e.g., ascii) and
one in recog->sa_text (e.g, ascii letter in a string)
for each character class.
(2) This searches the dna character array for %val.  If it is
not found, the template represents a character class not
already seen: it increments setsize (the number of character
classes) by 1, and augments both the index (dna_tochar)
and text (sa_text) arrays.
(3) Returns the index in &index, except on error.
(4) Caller must check the function return value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogGetClassIndex(*args)
    
    

    try:
        leptonica.recogStringToIndex.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.recogStringToIndex.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogStringToIndex not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogStringToIndex(*args):
        """
        ('L_RECOG', '*recog')       
('char', '*text')       
('l_int32', '*pindex')       

:param[in]    recog:
:param[in]    text:     text string for some class
:param[out]   pindex:   index for that class; -1 if not found
:returns:  0 if OK, 1 on error not finding the string is an error


        """
        args = _convert_params(*args)
        
        return leptonica.recogStringToIndex(*args)
    
    

    try:
        leptonica.recogGetClassString.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_char_p]
        leptonica.recogGetClassString.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogGetClassString not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogGetClassString(*args):
        """
        ('L_RECOG', '*recog')       
('l_int32', 'index')       
('char', '**pcharstr')       

:param[in]    recog:
:param[in]    index:       into array of char types
:param[out]   pcharstr:    string representation;
returns an empty string on error
:returns:  0 if found, 1 on error

<pre>
Notes:
(1) Extracts a copy of the string from sa_text, which
the caller must free.
(2) Caller must check the function return value.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogGetClassString(*args)
    
    

    try:
        leptonica.l_convertCharstrToInt.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.l_convertCharstrToInt.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function l_convertCharstrToInt not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def l_convertCharstrToInt(*args):
        """
        ('const char', '*str')       
('l_int32', '*pval')       

:param[in]    str:     input string representing one UTF-8 character;
not more than 4 bytes
:param[out]   pval:    integer value for the input.  Think of it
as a 1-to-1 hash code.
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.l_convertCharstrToInt(*args)
    
    

    try:
        leptonica.recogRead.argtypes = [ctypes.c_char_p]
        leptonica.recogRead.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogRead not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogRead(*args):
        """
        ('const char', '*filename')       

:param[in]    filename:
:returns:  recog, or NULL on error

<pre>
Notes:
(1) When a recog is serialized, a pixaa of the templates that are
actually used for correlation is saved in the pixaa_u array
of the recog.  These can be different from the templates that
were used to generate the recog, because those original templates
can be scaled and turned into normalized lines.  When recog1
is deserialized to recog2, these templates are put in both the
unscaled array (pixaa_u) and the modified array (pixaa) in recog2.
Why not put it in only the unscaled array and let
recogTrainingFinalized() regenerate the modified templates?
The reason is that with normalized lines, the operation of
thinning to a skeleton and dilating back to a fixed width
is not idempotent.  Thinning to a skeleton saves pixels at
the end of a line segment, and thickening the skeleton puts
additional pixels at the end of the lines.  This tends to
close gaps.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogRead(*args)
    
    

    try:
        leptonica.recogReadStream.argtypes = [ctypes.c_void_p]
        leptonica.recogReadStream.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogReadStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogReadStream(*args):
        """
        ('FILE', '*fp')       

:param[in]    fp:     file stream
:returns:  recog, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogReadStream(*args)
    
    

    try:
        leptonica.recogReadMem.argtypes = [ctypes.c_void_p, ctypes.c_size_t]
        leptonica.recogReadMem.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogReadMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogReadMem(*args):
        """
        ('const l_uint8', '*data')       
('size_t', 'size')       

:param[in]    data:    serialization of recog (not ascii)
:param[in]    size:    of data in bytes
:returns:  recog, or NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogReadMem(*args)
    
    

    try:
        leptonica.recogWrite.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
        leptonica.recogWrite.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogWrite not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogWrite(*args):
        """
        ('const char', '*filename')       
('L_RECOG', '*recog')       

:param[in]    filename:
:param[in]    recog:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pixaa of templates that is written is the modified one
in the pixaa field. It is the pixaa that is actually used
for correlation. This is not the unscaled array of labeled
bitmaps, in pixaa_u, that was used to generate the recog in the
first place.  See the notes in recogRead() for the rationale.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogWrite(*args)
    
    

    try:
        leptonica.recogWriteStream.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogWriteStream.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogWriteStream not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogWriteStream(*args):
        """
        ('FILE', '*fp')       
('L_RECOG', '*recog')       

:param[in]    fp:      file stream opened for "wb"
:param[in]    recog:
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogWriteStream(*args)
    
    

    try:
        leptonica.recogWriteMem.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogWriteMem.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogWriteMem not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogWriteMem(*args):
        """
        ('l_uint8', '**pdata')       
('size_t', '*psize')       
('L_RECOG', '*recog')       

:param[out]   pdata:    data of serialized recog (not ascii)
:param[out]   psize:    size of returned data
:param[in]    recog:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Serializes a recog in memory and puts the result in a buffer.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogWriteMem(*args)
    
    

    try:
        leptonica.recogExtractPixa.argtypes = [ctypes.c_void_p]
        leptonica.recogExtractPixa.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogExtractPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogExtractPixa(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]   recog:
:returns:  pixa if OK, NULL on error

<pre>
Notes:
(1) This generates a pixa of all the unscaled images in the
recognizer, where each one has its character class label in
the pix text field, by flattening pixaa_u to a pixa.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogExtractPixa(*args)
    




class recogdid(object):
    """<pre>

Top-level identification
BOXA             *recogDecode()

Generate decoding arrays
static l_int32    recogPrepareForDecoding()
static l_int32    recogMakeDecodingArray()

Dynamic programming for best path
static l_int32    recogRunViterbi()
static l_int32    recogRescoreDidResult()
static PIX       *recogShowPath()

Create/destroy temporary DID data
l_int32           recogCreateDid()
l_int32           recogDestroyDid()

Various helpers
l_int32           recogDidExists()
L_RDID           *recogGetDid()
static l_int32    recogGetWindowedArea()
l_int32           recogSetChannelParams()
static l_int32    recogTransferRchToDid()

See recogbasic.c for examples of training a recognizer, which is
required before it can be used for document image decoding.

Gary Kopec pioneered this hidden markov approach to "Document Image
Decoding" (DID) in the early 1990s.  It is based on estimation
using a generative model of the image generation process, and
provides the most likely decoding of an image if the model is correct.
Given the model, it finds the maximum a posteriori (MAP) "message"
given the observed image.  The model describes how to generate
an image from a message, and the MAP message is derived from the
observed image using Bayes' theorem.  This approach can also be used
to build the model, using the iterative expectation/maximization
method from labeled but errorful data.

In a little more detail: The model comprises three things: the ideal
printed character templates, the independent bit-flip noise model, and
the character setwidths.  When a character is printed, the setwidth
is the distance in pixels that you move forward before being able
to print the next character.  It is typically slightly less than the
width of the character template: if too small, an extra character can be
hallucinated; if too large, it will not be able to match the next
character template on the line.  The model assumes that the probabilities
of bit flip depend only on the assignment of the pixel to background
or template foreground.  The multilevel templates have different
bit flip probabilities for each level.  Because a character image
is composed of many pixels, each of which can be independently flipped,
the actual probability of seeing any rendering is exceedingly small,
being composed of the product of the probabilities for each pixel.
The log likelihood is used both to avoid numeric underflow and,
more importantly, because it results in a summation of independent
pixel probabilities.  That summation can be shown, in Kopec's
original paper, to consist of a sum of two terms: (a) the number of
fg pixels in the bit-and of the observed image with the ideal
template and (b) the number of fg pixels in the template.  Each
has a coefficient that depends only on the bit-flip probabilities
for the fg and bg.  A beautiful result, and computationally simple!
One nice feature of this approach is that the result of the decoding
is not very sensitive to the values  used for the bit flip probabilities.

The procedure for finding the best decoding (MAP) for a given image goes
under several names: Viterbi, dynamic programming, hidden markov model.
It is called a "hidden markov model" because the templates are assumed
to be printed serially and we don't know what they are -- the identity
of the templates must be inferred from the observed image.
The possible decodings form a dense trellis over the pixel positions,
where at each pixel position you have the possibility of having any
of the characters printed there (with some reference point) or having
a single pixel wide space inserted there.  Thus, before the trellis
can be traversed, we must do the work of finding the log probability,
at each pixel location, that each of the templates was printed there.
Armed with those arrays of data, the dynamic programming procedure
moves from left to right, one pixel at a time, recursively finding
the path with the highest log probability that gets to that pixel
position (and noting which template was printed to arrive there).
After reaching the right side of the image, we can simply backtrack
along the path, jumping over each template that lies on the highest
scoring path.  This best path thus only goes through a few of the
pixel positions.

There are two refinements to the original Kopec paper.  In the first,
one uses multiple, non-overlapping fg templates, each with its own
bit flip probability.  This makes sense, because the probability
that a fg boundary pixel flips to bg is greater than that of a fg
pixel not on the boundary.  And the flip probability of a fg boundary
pixel is smaller than that of a bg boundary pixel, which in turn
is greater than that of a bg pixel not on a boundary (the latter
is taken to be the true background).  Then the simplest realistic
multiple template model has three templates that are not background.

In the second refinement, a heuristic (strict upper bound) is used
iteratively in the Viterbi process to compute the log probabilities.
Using the heuristic, you find the best path, and then score all nodes
on that path with the actual probability, which is guaranteed to
be a smaller number.  You run this iteratively, rescoring just the best
found path each time.  After each rescoring, the path may change because
the local scores have been reduced.  However, the process converges
rapidly, and when it doesn't change, it must be the best path because
it is properly scored (even if neighboring paths are heuristically
scored).  The heuristic score is found column-wise by assuming
that all the fg pixels in the template are on fg pixels in the image --
we just take the minimum of the number of pixels in the template
and image column.  This can easily give a 10-fold reduction in
computation because the heuristic score can be computed much faster
than the exact score.

For reference, the classic paper on the approach by Kopec is:
"Document Image Decoding Using Markov Source Models", IEEE Trans.
PAMI, Vol 16, No. 6, June 1994, pp 602-617.
A refinement of the method for multilevel templates by Kopec is:
"Multilevel Character Templates for Document Image Decoding",
Proc. SPIE 3027, Document Recognition IV, p. 168ff, 1997.
Further refinements for more efficient decoding are given in these
two papers, which are both stored on leptonica.org:
"Document Image Decoding using Iterated Complete Path Search", Minka,
Bloomberg and Popat, Proc. SPIE Vol 4307, p. 250-258, Document
Recognition and Retrieval VIII, San Jose, CA 2001.
"Document Image Decoding using Iterated Complete Path Search with
Subsampled Heuristic Scoring", Bloomberg, Minka and Popat, ICDAR 2001,
p. 344-349, Sept. 2001, Seattle.
</pre>




"""
    
    try:
        leptonica.recogDecode.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_void_p]
        leptonica.recogDecode.restype = lambda address: BOXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogDecode not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogDecode(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('l_int32', 'nlevels')       
('PIX', '**ppixdb')       

:param[in]    recog:      with LUT's pre-computed
:param[in]    pixs:       typically of multiple touching characters, 1 bpp
:param[in]    nlevels:    of templates; 2 for now
:param[out]   ppixdb:     [optional] debug result; can be null
:returns:  boxa  segmentation of pixs into characters, or NULL on error

<pre>
Notes:
(1) The input pixs has been filtered so that it is likely to be
composed of more than one touching character.  Specifically,
its height can only slightly exceed that of the tallest
unscaled template, the width is somewhat larger than the
width of the widest unscaled template, and the w/h aspect ratio
is bounded by max_wh_ratio.
(2) This uses the DID mechanism with labeled templates to
segment the input %pixs.  The resulting segmentation is
returned.  (It is given by did->boxa).
(3) In debug mode, the Viterbi path is rescored based on all
the templates.  In non-debug mode, the same procedure is
carried out by recogIdentifyPix() on the result of the
segmentation.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogDecode(*args)
    
    

    try:
        leptonica.recogCreateDid.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogCreateDid.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogCreateDid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCreateDid(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       

:param[in]    recog:
:param[in]    pixs:     of 1 bpp image to match
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogCreateDid(*args)
    
    

    try:
        leptonica.recogDestroyDid.argtypes = [ctypes.c_void_p]
        leptonica.recogDestroyDid.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogDestroyDid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogDestroyDid(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]    recog:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) As the signature indicates, this is owned by the recog, and can
only be destroyed using this function.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogDestroyDid(*args)
    
    

    try:
        leptonica.recogDidExists.argtypes = [ctypes.c_void_p]
        leptonica.recogDidExists.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogDidExists not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogDidExists(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]    recog:
:returns:  1 if recog->did exists; 0 if not or on error.


        """
        args = _convert_params(*args)
        
        return leptonica.recogDidExists(*args)
    
    

    try:
        leptonica.recogGetDid.argtypes = [ctypes.c_void_p]
        leptonica.recogGetDid.restype = lambda address: L_RDID(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogGetDid not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogGetDid(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]    recog:
:returns:  did still owned by the recog, or NULL on error

<pre>
Notes:
(1) This also makes sure the arrays are defined.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogGetDid(*args)
    
    

    try:
        leptonica.recogSetChannelParams.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogSetChannelParams.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogSetChannelParams not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogSetChannelParams(*args):
        """
        ('L_RECOG', '*recog')       
('l_int32', 'nlevels')       

:param[in]    recog:
:param[in]    nlevels:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This converts the independent bit-flip probabilities in the
"channel" into log-likelihood coefficients on image sums.
These coefficients are only defined for the non-background
template levels.  Thus for nlevels = 2 (one fg, one bg),
only beta[1] and gamma[1] are used.  For nlevels = 4 (three
fg templates), we use beta[1-3] and gamma[1-3].
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogSetChannelParams(*args)
    




class recogident(object):
    """<pre>

Top-level identification
l_int32             recogIdentifyMultiple()

Segmentation and noise removal
l_int32             recogSplitIntoCharacters()

Greedy character splitting
l_int32             recogCorrelationBestRow()
l_int32             recogCorrelationBestChar()
static l_int32      pixCorrelationBestShift()

Low-level identification of single characters
l_int32             recogIdentifyPixa()
l_int32             recogIdentifyPix()
l_int32             recogSkipIdentify()

Operations for handling identification results
static L_RCHA      *rchaCreate()
void                rchaDestroy()
static L_RCH       *rchCreate()
void                rchDestroy()
l_int32             rchaExtract()
l_int32             rchExtract()
static l_int32      transferRchToRcha()

Preprocessing and filtering
l_int32             recogProcessToIdentify()
static PIX         *recogPreSplittingFilter()
static PIX         *recogSplittingFilter()

Postprocessing
SARRAY             *recogExtractNumbers()
PIX                *showExtractNumbers()

Static debug helper
static void         l_showIndicatorSplitValues()

See recogbasic.c for examples of training a recognizer, which is
required before it can be used for identification.

The character splitter repeatedly does a greedy correlation with each
averaged unscaled template, at all pixel locations along the text to
be identified.  The vertical alignment is between the template
centroid and the (moving) windowed centroid, including a delta of
1 pixel above and below.  The best match then removes part of the
input image, leaving 1 or 2 pieces, which, after filtering,
are put in a queue.  The process ends when the queue is empty.
The filtering is based on the size and aspect ratio of the
remaining pieces; the intent is to remove anything that is
unlikely to be text, such as small pieces and line graphics.

After splitting, the selected segments are identified using
the input parameters that were initially specified for the
recognizer.  Unlike the splitter, which uses the averaged
templates from the unscaled input, the recognizer can use
either all training examples or averaged templates, and these
can be either scaled or unscaled.  These choices are specified
when the recognizer is constructed.
</pre>




"""
    
    try:
        leptonica.recogIdentifyMultiple.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogIdentifyMultiple.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogIdentifyMultiple not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogIdentifyMultiple(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('l_int32', 'minh')       
('l_int32', 'skipsplit')       
('BOXA', '**pboxa')       
('PIXA', '**ppixa')       
('PIX', '**ppixdb')       
('l_int32', 'debugsplit')       

:param[in]    recog:       with training finished
:param[in]    pixs:        containing typically a small number of characters
:param[in]    minh:        remove shorter components; use 0 for default
:param[in]    skipsplit:   1 to skip the splitting step
:param[out]   pboxa:       [optional] locations of identified components
:param[out]   ppixa:       [optional] images of identified components
:param[out]   ppixdb:      [optional] debug pix: inputs and best fits
:param[in]    debugsplit:  1 returns pix split debugging images
:returns:  0 if OK; 1 if nothing is found; 2 for other errors.

<pre>
Notes:
(1) This filters the input pixa and calls recogIdentifyPixa()
(2) Splitting is relatively slow, because it tries to match all
character templates to all locations.  This step can be skipped.
(3) An attempt is made to order the (optionally) returned images
and boxes in 2-dimensional sorted order.  These can then
be used to aggregate identified characters into numbers or words.
One typically wants the pixa, which contains a boxa of the
extracted subimages.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogIdentifyMultiple(*args)
    
    

    try:
        leptonica.recogSplitIntoCharacters.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogSplitIntoCharacters.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogSplitIntoCharacters not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogSplitIntoCharacters(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('l_int32', 'minh')       
('l_int32', 'skipsplit')       
('BOXA', '**pboxa')       
('PIXA', '**ppixa')       
('l_int32', 'debug')       

:param[in]    recog:
:param[in]    pixs:        1 bpp, contains only mostly deskewed text
:param[in]    minh:        remove shorter components; use 0 for default
:param[in]    skipsplit:   1 to skip the splitting step
:param[out]   pboxa:       character bounding boxes
:param[out]   ppixa:       character images
:param[in]    debug:       1 for results written to pixadb_split
:returns:  0 if OK, 1 on error or if no components are returned

<pre>
Notes:
(1) This can be given an image that has an arbitrary number
of text characters.  It optionally splits connected
components based on document image decoding in recogDecode().
The returned pixa includes the boxes from which the
(possibly split) components are extracted.
(2) After noise filtering, the resulting components are put in
row-major (2D) order, and the smaller of overlapping
components are removed if they satisfy conditions of
relative size and fractional overlap.
(3) Note that the splitting function uses unscaled templates
and does not bother returning the class results and scores.
These are more accurately found later using the scaled templates.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogSplitIntoCharacters(*args)
    
    

    try:
        leptonica.recogCorrelationBestRow.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogCorrelationBestRow.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogCorrelationBestRow not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCorrelationBestRow(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('BOXA', '**pboxa')       
('NUMA', '**pnascore')       
('NUMA', '**pnaindex')       
('SARRAY', '**psachar')       
('l_int32', 'debug')       

:param[in]    recog:       with LUT's pre-computed
:param[in]    pixs:        typically of multiple touching characters, 1 bpp
:param[out]   pboxa:       bounding boxs of best fit character
:param[out]   pnascore:    [optional] correlation scores
:param[out]   pnaindex:    [optional] indices of classes
:param[out]   psachar:     [optional] array of character strings
:param[in]    debug:       1 for results written to pixadb_split
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Supervises character matching for (in general) a c.c with
multiple touching characters.  Finds the best match greedily.
Rejects small parts that are left over after splitting.
(2) Matching is to the average, and without character scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogCorrelationBestRow(*args)
    
    

    try:
        leptonica.recogCorrelationBestChar.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.recogCorrelationBestChar.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogCorrelationBestChar not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogCorrelationBestChar(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('BOX', '**pbox')       
('l_float32', '*pscore')       
('l_int32', '*pindex')       
('char', '**pcharstr')       
('PIX', '**ppixdb')       

:param[in]    recog:       with LUT's pre-computed
:param[in]    pixs:        can be of multiple touching characters, 1 bpp
:param[out]   pbox:        bounding box of best fit character
:param[out]   pscore:      correlation score
:param[out]   pindex:      [optional] index of class
:param[out]   pcharstr:    [optional] character string of class
:param[out]   ppixdb:      [optional] debug pix showing input and best fit
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Basic matching character splitter.  Finds the best match among
all templates to some region of the image.  This can result
in splitting the image into two parts.  This is "image decoding"
without dynamic programming, because we don't use a setwidth
and compute the best matching score for the entire image.
(2) Matching is to the average templates, without character scaling.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogCorrelationBestChar(*args)
    
    

    try:
        leptonica.recogIdentifyPixa.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogIdentifyPixa.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogIdentifyPixa not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogIdentifyPixa(*args):
        """
        ('L_RECOG', '*recog')       
('PIXA', '*pixa')       
('PIX', '**ppixdb')       

:param[in]    recog:
:param[in]    pixa:     of 1 bpp images to match
:param[out]   ppixdb:   [optional] pix showing inputs and best fits
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This should be called by recogIdentifyMuliple(), which
binarizes and splits characters before sending %pixa here.
(2) This calls recogIdentifyPix(), which does the same operation
on each pix in %pixa, and optionally returns the arrays
of results (scores, class index and character string)
for the best correlation match.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogIdentifyPixa(*args)
    
    

    try:
        leptonica.recogIdentifyPix.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogIdentifyPix.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogIdentifyPix not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogIdentifyPix(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('PIX', '**ppixdb')       

:param[in]    recog:     with LUT's pre-computed
:param[in]    pixs:      of a single character, 1 bpp
:param[out]   ppixdb:    [optional] debug pix showing input and best fit
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Basic recognition function for a single character.
(2) If templ_use == L_USE_ALL_TEMPLATES, which is the default
situation, matching is attempted to every bitmap in the recog,
and the identify of the best match is returned.
(3) For finding outliers, templ_use == L_USE_AVERAGE_TEMPLATES, and
matching is only attemplted to the averaged bitmaps.  For this
case, the index of the bestsample is meaningless (0 is returned
if requested).
(4) The score is related to the confidence (probability of correct
identification), in that a higher score is correlated with
a higher probability.  However, the actual relation between
the correlation (score) and the probability is not known;
we call this a "score" because "confidence" can be misinterpreted
as an actual probability.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogIdentifyPix(*args)
    
    

    try:
        leptonica.recogSkipIdentify.argtypes = [ctypes.c_void_p]
        leptonica.recogSkipIdentify.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogSkipIdentify not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogSkipIdentify(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]    recog:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This just writes a "dummy" result with 0 score and empty
string id into the rch.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogSkipIdentify(*args)
    
    

    try:
        leptonica.rchaDestroy.argtypes = [ctypes.c_void_p]
        leptonica.rchaDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function rchaDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def rchaDestroy(*args):
        """
        ('L_RCHA', '**prcha')       

:param[in,out]   prcha:     to be nulled


        """
        args = _convert_params(*args)
        
        return leptonica.rchaDestroy(*args)
    
    

    try:
        leptonica.rchDestroy.argtypes = [ctypes.c_void_p]
        leptonica.rchDestroy.restype = None
    except AttributeError:
        sys.stderr.write("Warning - function rchDestroy not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def rchDestroy(*args):
        """
        ('L_RCH', '**prch')       

:param[in,out] prch: to be nulled


        """
        args = _convert_params(*args)
        
        return leptonica.rchDestroy(*args)
    
    

    try:
        leptonica.rchaExtract.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.rchaExtract.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function rchaExtract not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def rchaExtract(*args):
        """
        ('L_RCHA', '*rcha')       
('NUMA', '**pnaindex')       
('NUMA', '**pnascore')       
('SARRAY', '**psatext')       
('NUMA', '**pnasample')       
('NUMA', '**pnaxloc')       
('NUMA', '**pnayloc')       
('NUMA', '**pnawidth')       

:param[in]    rcha:
:param[out]   pnaindex:    [optional] indices of best templates
:param[out]   pnascore:    [optional] correl scores of best templates
:param[out]   psatext:     [optional] character strings of best templates
:param[out]   pnasample:   [optional] indices of best samples
:param[out]   pnaxloc:     [optional] x-locations of templates
:param[out]   pnayloc:     [optional] y-locations of templates
:param[out]   pnawidth:    [optional] widths of best templates
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This returns clones of the number and string arrays.  They must
be destroyed by the caller.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.rchaExtract(*args)
    
    

    try:
        leptonica.rchExtract.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.rchExtract.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function rchExtract not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def rchExtract(*args):
        """
        ('L_RCH', '*rch')       
('l_int32', '*pindex')       
('l_float32', '*pscore')       
('char', '**ptext')       
('l_int32', '*psample')       
('l_int32', '*pxloc')       
('l_int32', '*pyloc')       
('l_int32', '*pwidth')       

:param[in]    rch:
:param[out]   pindex:    [optional] index of best template
:param[out]   pscore:    [optional] correlation score of best template
:param[out]   ptext:     [optional] character string of best template
:param[out]   psample:   [optional] index of best sample
:param[out]   pxloc:     [optional] x-location of template
:param[out]   pyloc:     [optional] y-location of template
:param[out]   pwidth:    [optional] width of best template
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.rchExtract(*args)
    
    

    try:
        leptonica.recogProcessToIdentify.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogProcessToIdentify.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogProcessToIdentify not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogProcessToIdentify(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('l_int32', 'pad')       

:param[in]    recog:     with LUT's pre-computed
:param[in]    pixs:      typ. single character, possibly d > 1 and uncropped
:param[in]    pad:       extra pixels added to left and right sides
:returns:  pixd 1 bpp, clipped to foreground, or NULL if there
are no fg pixels or on error.

<pre>
Notes:
(1) This is a lightweight operation to insure that the input
image is 1 bpp, properly cropped, and padded on each side.
If bpp > 1, the image is thresholded.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogProcessToIdentify(*args)
    
    

    try:
        leptonica.recogExtractNumbers.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogExtractNumbers.restype = lambda address: SARRAY(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogExtractNumbers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogExtractNumbers(*args):
        """
        ('L_RECOG', '*recog')       
('BOXA', '*boxas')       
('l_float32', 'scorethresh')       
('l_int32', 'spacethresh')       
('BOXAA', '**pbaa')       
('NUMAA', '**pnaa')       

:param[in]    recog:
:param[in]    boxas:         location of components
:param[in]    scorethresh:   min score for which we accept a component
:param[in]    spacethresh:   max horizontal distance allowed between digits;
use -1 for default
:param[out]   pbaa:          [optional] bounding boxes of identified numbers
:param[out]   pnaa:          [optional] scores of identified digits
:returns:  sa of identified numbers, or NULL on error

<pre>
Notes:
(1) This extracts digit data after recogaIdentifyMultiple() or
lower-level identification has taken place.
(2) Each string in the returned sa contains a sequence of ascii
digits in a number.
(3) The horizontal distance between boxes (limited by %spacethresh)
is the negative of the horizontal overlap.
(4) Components with a score less than %scorethresh, which may
be hyphens or other small characters, will signal the
end of the current sequence of digits in the number.  A typical
value for %scorethresh is 0.60.
(5) We allow two digits to be combined if these conditions apply:
(a) the first is to the left of the second
(b) the second has a horizontal separation less than %spacethresh
(c) the vertical overlap >= 0 (vertical separation < 0)
(d) both have a score that exceeds %scorethresh
(6) Each numa in the optionally returned naa contains the digit
scores of a number.  Each boxa in the optionally returned baa
contains the bounding boxes of the digits in the number.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogExtractNumbers(*args)
    
    

    try:
        leptonica.showExtractNumbers.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.showExtractNumbers.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function showExtractNumbers not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def showExtractNumbers(*args):
        """
        ('PIX', '*pixs')       
('SARRAY', '*sa')       
('BOXAA', '*baa')       
('NUMAA', '*naa')       
('PIX', '**ppixdb')       

:param[in]    pixs:     input 1 bpp image
:param[in]    sa:       recognized text strings
:param[in]    baa:      boxa array for location of characters in each string
:param[in]    naa:      numa array for scores of characters in each string
:param[out]   ppixdb:   [optional] input pixs with identified chars outlined
:returns:  pixa   of identified strings with text and scores, or NULL on error

<pre>
Notes:
(1) This is a debugging routine on digit identification; e.g.:
recogIdentifyMultiple(recog, pixs, 0, 1, &boxa, NULL, NULL, 0);
sa = recogExtractNumbers(recog, boxa, 0.8, -1, &baa, &naa);
pixa = showExtractNumbers(pixs, sa, baa, naa, NULL);
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.showExtractNumbers(*args)
    




class recogtrain(object):
    """<pre>

Training on labeled data
l_int32             recogTrainLabeled()
PIX                *recogProcessLabeled()
l_int32             recogAddSample()
PIX                *recogModifyTemplate()
l_int32             recogAverageSamples()
l_int32             pixaAccumulateSamples()
l_int32             recogTrainingFinished()
static l_int32      recogTemplatesAreOK()
PIXA               *recogFilterPixaBySize()
PIXAA              *recogSortPixaByClass()
l_int32             recogRemoveOutliers1()
PIXA               *pixaRemoveOutliers1()
l_int32             recogRemoveOutliers2()
PIXA               *pixaRemoveOutliers2()

Training on unlabeled data
L_RECOG             recogTrainFromBoot()

Padding the digit training set
l_int32             recogPadDigitTrainingSet()
l_int32             recogIsPaddingNeeded()
static SARRAY      *recogAddMissingClassStrings()
PIXA               *recogAddDigitPadTemplates()
static l_int32      recogCharsetAvailable()

Making a boot digit recognizer
L_RECOG            *recogMakeBootDigitRecog()
PIXA               *recogMakeBootDigitTemplates()

Debugging
l_int32             recogShowContent()
l_int32             recogDebugAverages()
l_int32             recogShowAverageTemplates()
static PIX         *pixDisplayOutliers()
PIX                *recogDisplayOutlier()
PIX                *recogShowMatchesInRange()
PIX                *recogShowMatch()

These abbreviations are for the type of template to be used:
SI (for the scanned images)
WNL (for width-normalized lines, formed by first skeletonizing
the scanned images, and then dilating to a fixed width)
These abbreviations are for the type of recognizer:
BAR (book-adapted recognizer; the best type; can do identification
with unscaled images and separation of touching characters.
BSR (bootstrap recognizer; used if more labeled templates are
required for a BAR, either for finding more templates from
the book, or making a hybrid BAR/BSR.

The recog struct typically holds two versions of the input templates
(e.g. from a pixa) that were used to generate it.  One version is
the unscaled input templates.  The other version is the one that
will be used by the recog to identify unlabeled data.  That version
depends on the input parameters when the recog is created.  The choices
for the latter version, and their suggested use, are:
(1) unscaled SI -- typical for BAR, generated from book images
(2) unscaled WNL -- ditto
(3) scaled SI -- typical for recognizers containing template
images from sources other than the book to be recognized
(4) scaled WNL -- ditto
For cases (3) and (4), we recommend scaling to fixed height; e.g.,
scalew = 0, scaleh = 40.
When using WNL, we recommend using a width of 5 in the template
and 4 in the unlabeled data.
It appears that better results for a BAR are usually obtained using
SI than WNL, but more experimentation is needed.

This utility is designed to build recognizers that are specifically
adapted from a large amount of material, such as a book.  These
use labeled templates taken from the material, and not scaled.
In addition, two special recognizers are useful:
(1) Bootstrap recognizer (BSR).  This uses height-scaled templates,
that have been extended with several repetitions in one of two ways:
(a) aniotropic width scaling (for either SI or WNL)
(b) iterative erosions/dilations (for SI).
(2) Outlier removal.  This uses height scaled templates.  It can be
implemented without using templates that are aligned averages of all
templates in a class.

Recognizers are inexpensive to generate, for example, from a pixa
of labeled templates.  The general process of building a BAR is
to start with labeled templates, e.g., in a pixa, make a BAR, and
analyze new samples from the book to augment the BAR until it has
enough samples for each character class.  Along the way, samples
from a BSR may be added for help in training.  If not enough samples
are available for the BAR, it can finally be augmented with BSR
samples, in which case the resulting hybrid BAR/BSR recognizer
must work on scaled images.

Here are the steps in doing recog training:
A. Generate a BAR from any existing labeled templates
(1) Create a recog and add the templates, using recogAddSample().
This stores the unscaled templates.
[Note: this can be done in one step if the labeled templates are put
into a pixa:
L_Recog *rec = recogCreateFromPixa(pixa, ...);  ]
(2) Call recogTrainingFinished() to generate the (sometimes modified)
templates to be used for correlation.
(3) Optionally, remove outliers.
If there are sufficient samples in the classes, we're done. Otherwise,
B. Try to get more samples from the book to pad the BAR.
(1) Save the unscaled, labeled templates from the BAR.
(2) Supplement the BAR with bootstrap templates to make a hybrid BAR/BSR.
(3) Do recognition on more unlabeled images, scaled to a fixed height
(4) Add the unscaled, labeled images to the saved set.
(5) Optionally, remove outliers.
If there are sufficient samples in the classes, we're done. Otherwise,
C. For classes without a sufficient number of templates, we can
supplement the BAR with templates from a BSR (a hybrid RAR/BSR),
and do recognition scaled to a fixed height.

Here are several methods that can be used for identifying outliers:
(1) Compute average templates for each class and remove a candidate
that is poorly correlated with the average.  This is the most
simple method.  recogRemoveOutliers1() uses this, supplemented with
a second threshold and a target number of templates to be saved.
(2) Compute average templates for each class and remove a candidate
that is more highly correlated with the average of some other class.
This does not require setting a threshold for the correlation.
recogRemoveOutliers2() uses this method, supplemented with a minimum
correlation score.
(3) For each candidate, find the average correlation with other
members of its class, and remove those that have a relatively
low average correlation.  This is similar to (1), gives comparable
results and because it does not use average templates, it requires
a bit more computation.
</pre>




"""
    
    try:
        leptonica.recogTrainLabeled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_int32]
        leptonica.recogTrainLabeled.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogTrainLabeled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogTrainLabeled(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('BOX', '*box')       
('char', '*text')       
('l_int32', 'debug')       

:param[in]    recog:     in training mode
:param[in]    pixs:      if depth > 1, will be thresholded to 1 bpp
:param[in]    box:       [optional] cropping box
:param[in]    text:      [optional] if null, use text field in pix
:param[in]    debug:     1 to display images of samples not captured
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Training is restricted to the addition of a single
character in an arbitrary (e.g., UTF8) charset
(2) If box != null, it should represent the location in %pixs
of the character image.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogTrainLabeled(*args)
    
    

    try:
        leptonica.recogProcessLabeled.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_void_p]
        leptonica.recogProcessLabeled.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogProcessLabeled not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogProcessLabeled(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       
('BOX', '*box')       
('char', '*text')       
('PIX', '**ppix')       

:param[in]    recog:   in training mode
:param[in]    pixs:    if depth > 1, will be thresholded to 1 bpp
:param[in]    box:     [optional] cropping box
:param[in]    text:    [optional] if null, use text field in pix
:param[out]   ppix:    addr of pix, 1 bpp, labeled
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This crops and binarizes the input image, generating a pix
of one character where the charval is inserted into the pix.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogProcessLabeled(*args)
    
    

    try:
        leptonica.recogAddSample.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogAddSample.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogAddSample not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogAddSample(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pix')       
('l_int32', 'debug')       

:param[in]    recog:
:param[in]    pix:         a single character, 1 bpp
:param[in]    debug:
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) The pix is 1 bpp, with the character string label embedded.
(2) The pixaa_u array of the recog is initialized to accept
up to 256 different classes.  When training is finished,
the arrays are truncated to the actual number of classes.
To pad an existing recog from the boot recognizers, training
is started again; if samples from a new class are added,
the pixaa_u array is extended by adding a pixa to hold them.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogAddSample(*args)
    
    

    try:
        leptonica.recogModifyTemplate.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogModifyTemplate.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogModifyTemplate not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogModifyTemplate(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pixs')       

:param[in]    recog:
:param[in]    pixs:   1 bpp, to be optionally scaled and turned into
strokes of fixed width
:returns:  pixd   modified pix if OK, NULL on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogModifyTemplate(*args)
    
    

    try:
        leptonica.recogAverageSamples.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogAverageSamples.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogAverageSamples not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogAverageSamples(*args):
        """
        ('L_RECOG', '**precog')       
('l_int32', 'debug')       

:param[in]   precog:    addr of existing recog; may be destroyed
:param[in]   debug:
:returns:  0 on success, 1 on failure

<pre>
Notes:
(1) This is only called in two situations:
(a) When splitting characters using either the DID method
recogDecode() or the the greedy splitter
recogCorrelationBestRow()
(b) By a special recognizer that is used to remove outliers.
Both unscaled and scaled inputs are averaged.
(2) If the data in any class is nonexistent (no samples), or
very bad (no fg pixels in the average), or if the ratio
of max/min average unscaled class template heights is
greater than max_ht_ratio, this destroys the recog.
The caller must check the return value of the recog.
(3) Set debug = 1 to view the resulting templates and their centroids.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogAverageSamples(*args)
    
    

    try:
        leptonica.pixaAccumulateSamples.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaAccumulateSamples.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function pixaAccumulateSamples not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaAccumulateSamples(*args):
        """
        ('PIXA', '*pixa')       
('PTA', '*pta')       
('PIX', '**ppixd')       
('l_float32', '*px')       
('l_float32', '*py')       

:param[in]    pixa:     of samples from the same class, 1 bpp
:param[in]    pta:      [optional] of centroids of the samples
:param[out]   ppixd:    accumulated samples, 8 bpp
:param[out]   px:       [optional] average x coordinate of centroids
:param[out]   py:       [optional] average y coordinate of centroids
:returns:  0 on success, 1 on failure

<pre>
Notes:
(1) This generates an aligned (by centroid) sum of the input pix.
(2) We use only the first 256 samples; that's plenty.
(3) If pta is not input, we generate two tables, and discard
after use.  If this is called many times, it is better
to precompute the pta.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaAccumulateSamples(*args)
    
    

    try:
        leptonica.recogTrainingFinished.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float]
        leptonica.recogTrainingFinished.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogTrainingFinished not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogTrainingFinished(*args):
        """
        ('L_RECOG', '**precog')       
('l_int32', 'modifyflag')       
('l_int32', 'minsize')       
('l_float32', 'minfract')       

:param[in]    precog:       addr of recog
:param[in]    modifyflag:   1 to use recogModifyTemplate(); 0 otherwise
:param[in]    minsize:      set to -1 for default
:param[in]    minfract:     set to -1.0 for default
:returns:  0 if OK, 1 on error (input recog will be destroyed)

<pre>
Notes:
(1) This must be called after all training samples have been added.
(2) If the templates are not good enough, the recog input is destroyed.
(3) Usually, %modifyflag == 1, because we want to apply
recogModifyTemplate() to generate the actual templates
that will be used.  The one exception is when reading a
serialized recog: there we want to put the same set of
templates in both the unscaled and modified pixaa.
See recogReadStream() to see why we do this.
(4) See recogTemplatesAreOK() for %minsize and %minfract usage.
(5) The following things are done here:
(a) Allocate (or reallocate) storage for (possibly) modified
bitmaps, centroids, and fg areas.
(b) Generate the (possibly) modified bitmaps.
(c) Compute centroid and fg area data for both unscaled and
modified bitmaps.
(d) Truncate the pixaa, ptaa and numaa arrays down from
256 to the actual size.
(6) Putting these operations here makes it simple to recompute
the recog with different modifications on the bitmaps.
(7) Call recogShowContent() to display the templates, both
unscaled and modified.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogTrainingFinished(*args)
    
    

    try:
        leptonica.recogFilterPixaBySize.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32, ctypes.c_float, ctypes.c_void_p]
        leptonica.recogFilterPixaBySize.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogFilterPixaBySize not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogFilterPixaBySize(*args):
        """
        ('PIXA', '*pixas')       
('l_int32', 'setsize')       
('l_int32', 'maxkeep')       
('l_float32', 'max_ht_ratio')       
('NUMA', '**pna')       

:param[in]   pixas:         labeled templates
:param[in]   setsize:       size of character set (number of classes)
:param[in]   maxkeep:       max number of templates to keep in a class
:param[in]   max_ht_ratio:  max allowed height ratio (see below)
:param[out]  pna:           [optional] debug output, giving the number
in each class after filtering; use NULL to skip
:returns:  pixa   filtered templates, or NULL on error

<pre>
Notes:
(1) The basic assumption is that the most common and larger
templates in each class are more likely to represent the
characters we are interested in.  For example, larger digits
are more likely to represent page numbers, and smaller digits
could be data in tables.  Therefore, we bias the first
stage of filtering toward the larger characters by removing
very small ones, and select based on proximity of the
remaining characters to median height.
(2) For each of the %setsize classes, order the templates
increasingly by height.  Take the rank 0.9 height.  Eliminate
all templates that are shorter by more than %max_ht_ratio.
Of the remaining ones, select up to %maxkeep that are closest
in rank order height to the median template.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogFilterPixaBySize(*args)
    
    

    try:
        leptonica.recogSortPixaByClass.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogSortPixaByClass.restype = lambda address: PIXAA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogSortPixaByClass not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogSortPixaByClass(*args):
        """
        ('PIXA', '*pixa')       
('l_int32', 'setsize')       

:param[in]   pixa:       labeled templates
:param[in]   setsize:    size of character set (number of classes)
:returns:  paa   pixaa where each pixa has templates for one class,
or null on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogSortPixaByClass(*args)
    
    

    try:
        leptonica.recogRemoveOutliers1.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogRemoveOutliers1.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogRemoveOutliers1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogRemoveOutliers1(*args):
        """
        ('L_RECOG', '**precog')       
('l_float32', 'minscore')       
('l_int32', 'mintarget')       
('l_int32', 'minsize')       
('PIX', '**ppixsave')       
('PIX', '**ppixrem')       

:param[in]   precog:       addr of recog with unscaled labeled templates
:param[in]   minscore:     keep everything with at least this score
:param[in]   mintarget:    minimum desired number to retain if possible
:param[in]   minsize:      minimum number of samples required for a class
:param[out]  ppixsave:     [optional debug] saved templates, with scores
:param[out]  ppixrem:      [optional debug] removed templates, with scores
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This is a convenience wrapper when using default parameters
for the recog.  See pixaRemoveOutliers1() for details.
(2) If this succeeds, the new recog replaces the input recog;
if it fails, the input recog is destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogRemoveOutliers1(*args)
    
    

    try:
        leptonica.pixaRemoveOutliers1.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaRemoveOutliers1.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaRemoveOutliers1 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemoveOutliers1(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'minscore')       
('l_int32', 'mintarget')       
('l_int32', 'minsize')       
('PIX', '**ppixsave')       
('PIX', '**ppixrem')       

:param[in]   pixas:        unscaled labeled templates
:param[in]   minscore:     keep everything with at least this score;
use -1.0 for default.
:param[in]   mintarget:    minimum desired number to retain if possible;
use -1 for default.
:param[in]   minsize:      minimum number of samples required for a class;
use -1 for default.
:param[out]  ppixsave:     [optional debug] saved templates, with scores
:param[out]  ppixrem:      [optional debug] removed templates, with scores
:returns:  pixa   of unscaled templates to be kept, or NULL on error

<pre>
Notes:
(1) Removing outliers is particularly important when recognition
goes against all the samples in the training set, as opposed
to the averages for each class.  The reason is that we get
an identification error if a mislabeled template is a best
match for an input sample.
(2) Because the score values depend strongly on the quality
of the character images, to avoid losing too many samples
we supplement a minimum score for retention with a score
necessary to acquire the minimum target number of templates.
To do this we are willing to use a lower threshold,
LowerScoreThreshold, on the score.  Consequently, with
poor quality templates, we may keep samples with a score
less than %minscore, but never less than LowerScoreThreshold.
And if the number of samples is less than %minsize, we do
not use any.
(3) This is meant to be used on a BAR, where the templates all
come from the same book; use minscore ~0.75.
(4) Method: make a scaled recog from the input %pixas.  Then,
for each class: generate the averages, match each
scaled template against the average, and save unscaled
templates that had a sufficiently good match.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemoveOutliers1(*args)
    
    

    try:
        leptonica.recogRemoveOutliers2.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogRemoveOutliers2.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogRemoveOutliers2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogRemoveOutliers2(*args):
        """
        ('L_RECOG', '**precog')       
('l_float32', 'minscore')       
('l_int32', 'minsize')       
('PIX', '**ppixsave')       
('PIX', '**ppixrem')       

:param[in]   precog:      addr of recog with unscaled labeled templates
:param[in]   minscore:    keep everything with at least this score
:param[in]   minsize:     minimum number of samples required for a class
:param[out]  ppixsave:    [optional debug] saved templates, with scores
:param[out]  ppixrem:     [optional debug] removed templates, with scores
:returns:  0 if OK, 1 on error.

<pre>
Notes:
(1) This is a convenience wrapper when using default parameters
for the recog.  See pixaRemoveOutliers2() for details.
(2) If this succeeds, the new recog replaces the input recog;
if it fails, the input recog is destroyed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogRemoveOutliers2(*args)
    
    

    try:
        leptonica.pixaRemoveOutliers2.argtypes = [ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_void_p, ctypes.c_void_p]
        leptonica.pixaRemoveOutliers2.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function pixaRemoveOutliers2 not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def pixaRemoveOutliers2(*args):
        """
        ('PIXA', '*pixas')       
('l_float32', 'minscore')       
('l_int32', 'minsize')       
('PIX', '**ppixsave')       
('PIX', '**ppixrem')       

:param[in]   pixas:       unscaled labeled templates
:param[in]   minscore:    keep everything with at least this score;
use -1.0 for default.
:param[in]   minsize:     minimum number of samples required for a class;
use -1 for default.
:param[out]  ppixsave:    [optional debug] saved templates, with scores
:param[out]  ppixrem:     [optional debug] removed templates, with scores
:returns:  pixa   of unscaled templates to be kept, or NULL on error

<pre>
Notes:
(1) Removing outliers is particularly important when recognition
goes against all the samples in the training set, as opposed
to the averages for each class.  The reason is that we get
an identification error if a mislabeled template is a best
match for an input sample.
(2) This method compares each template against the average templates
of each class, and discards any template that has a higher
correlation to a class different from its own.  It also
sets a lower bound on correlation scores with its class average.
(3) This is meant to be used on a BAR, where the templates all
come from the same book; use minscore ~0.75.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.pixaRemoveOutliers2(*args)
    
    

    try:
        leptonica.recogTrainFromBoot.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogTrainFromBoot.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogTrainFromBoot not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogTrainFromBoot(*args):
        """
        ('L_RECOG', '*recogboot')       
('PIXA', '*pixas')       
('l_float32', 'minscore')       
('l_int32', 'threshold')       
('l_int32', 'debug')       

:param[in]    recogboot:   labeled boot recognizer
:param[in]    pixas:       set of unlabeled input characters
:param[in]    minscore:    min score for accepting the example; e.g., 0.75
:param[in]    threshold:   for binarization, if needed
:param[in]    debug:       1 for debug output saved to recogboot; 0 otherwise
:returns:  pixad   labeled version of input pixas, trained on a BSR,
or NULL on error

<pre>
Notes:
(1) This takes %pixas of unscaled single characters and %recboot,
a bootstrep recognizer (BSR) that has been set up with parameters
scaleh: scale all templates to this height
linew: width of normalized strokes, or 0 if using
the input image
It modifies the pix in %pixas accordingly and correlates
with the templates in the BSR.  It returns those input
images in %pixas whose best correlation with the BSR is at
or above %minscore.  The returned pix have added text labels
for the text string of the class to which the best
correlated template belongs.
(2) Identification occurs in scaled mode (typically with h = 40),
optionally using a width-normalized line images derived
from those in %pixas.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogTrainFromBoot(*args)
    
    

    try:
        leptonica.recogPadDigitTrainingSet.argtypes = [ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogPadDigitTrainingSet.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogPadDigitTrainingSet not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogPadDigitTrainingSet(*args):
        """
        ('L_RECOG', '**precog')       
('l_int32', 'scaleh')       
('l_int32', 'linew')       

:param[in,out]   precog:    trained; if padding is needed, it is replaced
by a a new padded recog
:param[in]       scaleh:    must be > 0; suggest ~40.
:param[in]       linew:     use 0 for original scanned images
:returns:       0 if OK, 1 on error

<pre>
Notes:
(1) This is a no-op if padding is not needed.  However,
if it is, this replaces the input recog with a new recog,
padded appropriately with templates from a boot recognizer,
and set up with correlation templates derived from
%scaleh and %linew.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogPadDigitTrainingSet(*args)
    
    

    try:
        leptonica.recogIsPaddingNeeded.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogIsPaddingNeeded.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogIsPaddingNeeded not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogIsPaddingNeeded(*args):
        """
        ('L_RECOG', '*recog')       
('SARRAY', '**psa')       

:param[in]    recog:   trained
:param[out]   psa:     addr of returned string containing text value
:returns:       1 on error; 0 if OK, whether or not additional padding
templates are required.

<pre>
Notes:
(1) This returns a string array in &sa containing character values
for which extra templates are needed; this sarray is
used by recogGetPadTemplates().  It returns NULL
if no padding templates are needed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogIsPaddingNeeded(*args)
    
    

    try:
        leptonica.recogAddDigitPadTemplates.argtypes = [ctypes.c_void_p, ctypes.c_void_p]
        leptonica.recogAddDigitPadTemplates.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogAddDigitPadTemplates not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogAddDigitPadTemplates(*args):
        """
        ('L_RECOG', '*recog')       
('SARRAY', '*sa')       

:param[in]    recog:   trained
:param[in]    sa:      set of text strings that need to be padded
:returns:  pixa   of all templates from %recog and the additional pad
templates from a boot recognizer; or NULL on error

<pre>
Notes:
(1) Call recogIsPaddingNeeded() first, which returns %sa of
template text strings for classes where more templates
are needed.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogAddDigitPadTemplates(*args)
    
    

    try:
        leptonica.recogMakeBootDigitRecog.argtypes = [ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogMakeBootDigitRecog.restype = lambda address: L_RECOG(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogMakeBootDigitRecog not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogMakeBootDigitRecog(*args):
        """
        ('l_int32', 'nsamp')       
('l_int32', 'scaleh')       
('l_int32', 'linew')       
('l_int32', 'maxyshift')       
('l_int32', 'debug')       

:param[in]    nsamp:       number of samples of each digit; or 0
:param[in]    scaleh:      scale all heights to this; typ. use 40
:param[in]    linew:       normalized line width; typ. use 5; 0 to skip
:param[in]    maxyshift:   from nominal centroid alignment; typically 0 or 1
:param[in]    debug:       1 for showing templates; 0 otherwise
:returns:  recog, or NULL on error

<pre>
Notes:
(1) This takes a set of pre-computed, labeled pixa of single
digits, and generates a recognizer from them.
The templates used in the recognizer can be modified by:
- scaling (isotropically to fixed height)
- generating a skeleton and thickening so that all strokes
have the same width.
(2) The resulting templates are scaled versions of either the
input bitmaps or images with fixed line widths.  To use the
input bitmaps, set %linew = 0; otherwise, set %linew to the
desired line width.
(3) If %nsamp == 0, this uses and extends the output from
three boot generators:
l_bootnum_gen1, l_bootnum_gen2, l_bootnum_gen3.
Otherwise, it uses exactly %nsamp templates of each digit,
extracted by l_bootnum_gen4.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogMakeBootDigitRecog(*args)
    
    

    try:
        leptonica.recogMakeBootDigitTemplates.argtypes = [ctypes.c_int32, ctypes.c_int32]
        leptonica.recogMakeBootDigitTemplates.restype = lambda address: PIXA(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogMakeBootDigitTemplates not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogMakeBootDigitTemplates(*args):
        """
        ('l_int32', 'nsamp')       
('l_int32', 'debug')       

:param[in]    nsamp:     number of samples of each digit; or 0
:param[in]    debug:     1 for display of templates
:returns:  pixa   of templates; or NULL on error

<pre>
Notes:
(1) See recogMakeBootDigitRecog().
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogMakeBootDigitTemplates(*args)
    
    

    try:
        leptonica.recogShowContent.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_int32]
        leptonica.recogShowContent.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogShowContent not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogShowContent(*args):
        """
        ('FILE', '*fp')       
('L_RECOG', '*recog')       
('l_int32', 'index')       
('l_int32', 'display')       

:param[in]    fp:       file stream
:param[in]    recog:
:param[in]    index:    for naming of output files of template images
:param[in]    display:  1 for showing template images; 0 otherwise
:returns:  0 if OK, 1 on error


        """
        args = _convert_params(*args)
        
        return leptonica.recogShowContent(*args)
    
    

    try:
        leptonica.recogDebugAverages.argtypes = [ctypes.c_void_p, ctypes.c_int32]
        leptonica.recogDebugAverages.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogDebugAverages not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogDebugAverages(*args):
        """
        ('L_RECOG', '**precog')       
('l_int32', 'debug')       

:param[in]    precog:    addr of recog
:param[in]    debug:     0 no output; 1 for images; 2 for text; 3 for both
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) Generates an image that pairs each of the input images used
in training with the average template that it is best
correlated to.  This is written into the recog.
(2) It also generates pixa_tr of all the input training images,
which can be used, e.g., in recogShowMatchesInRange().
(3) Destroys the recog if the averaging function finds any bad classes.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogDebugAverages(*args)
    
    

    try:
        leptonica.recogShowAverageTemplates.argtypes = [ctypes.c_void_p]
        leptonica.recogShowAverageTemplates.restype = ctypes.c_int32
    except AttributeError:
        sys.stderr.write("Warning - function recogShowAverageTemplates not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogShowAverageTemplates(*args):
        """
        ('L_RECOG', '*recog')       

:param[in]    recog:
:returns:  0 on success, 1 on failure

<pre>
Notes:
(1) This debug routine generates a display of the averaged templates,
both scaled and unscaled, with the centroid visible in red.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogShowAverageTemplates(*args)
    
    

    try:
        leptonica.recogShowMatchesInRange.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_float, ctypes.c_float, ctypes.c_int32]
        leptonica.recogShowMatchesInRange.restype = ctypes.c_int
    except AttributeError:
        sys.stderr.write("Warning - function recogShowMatchesInRange not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogShowMatchesInRange(*args):
        """
        ('L_RECOG', '*recog')       
('PIXA', '*pixa')       
('l_float32', 'minscore')       
('l_float32', 'maxscore')       
('l_int32', 'display')       

:param[in]    recog:
:param[in]    pixa:        of 1 bpp images to match
:param[in]    minscore:    min score to include output
:param[in]    maxscore:    max score to include output
:param[in]    display:     1 to display the result
:returns:  0 if OK, 1 on error

<pre>
Notes:
(1) This gives a visual output of the best matches for a given
range of scores.  Each pair of images can optionally be
labeled with the index of the best match and the correlation.
(2) To use this, save a set of 1 bpp images (labeled or
unlabeled) that can be given to a recognizer in a pixa.
Then call this function with the pixa and parameters
to filter a range of scores.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogShowMatchesInRange(*args)
    
    

    try:
        leptonica.recogShowMatch.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_int32, ctypes.c_float]
        leptonica.recogShowMatch.restype = lambda address: PIX(from_address=address) if address else None
    except AttributeError:
        sys.stderr.write("Warning - function recogShowMatch not exported " +
            "by libleptonica\n\tCalls to it won't work\n")
    
    @staticmethod
    def recogShowMatch(*args):
        """
        ('L_RECOG', '*recog')       
('PIX', '*pix1')       
('PIX', '*pix2')       
('BOX', '*box')       
('l_int32', 'index')       
('l_float32', 'score')       

:param[in]    recog:
:param[in]    pix1:    input pix; several possibilities
:param[in]    pix2:    [optional] matching template
:param[in]    box:     [optional] region in pix1 for which pix2 matches
:param[in]    index:   index of matching template; use -1 to disable printing
:param[in]    score:   score of match
:returns:  pixd pair of images, showing input pix and best template,
optionally with matching information, or NULL on error.

<pre>
Notes:
(1) pix1 can be one of these:
(a) The input pix alone, which can be either a single character
(box == NULL) or several characters that need to be
segmented.  If more than character is present, the box
region is displayed with an outline.
(b) Both the input pix and the matching template.  In this case,
pix2 and box will both be null.
(2) If the bmf has been made (by a call to recogMakeBmf())
and the index >= 0, the text field, match score and index
will be rendered; otherwise their values will be ignored.
</pre>


        """
        args = _convert_params(*args)
        
        return leptonica.recogShowMatch(*args)
    




# In C, you don't have to know in which "module" a function lives
# you should not need in Python - All Leptonica functions are agregated here:
functions = type("all_functions", (object,), dict (
        (function_name, function)
        for cls in globals().values() if isinstance(cls, type)
        for function_name, function in cls.__dict__.items()
            if isinstance(function, staticmethod)
    ))

__all__ = ['adaptmap', 'colorcontent', 'numafunc1', 'psio1stub', 'sel1', 'affine', 'colormap', 'fpix1', 'numafunc2', 'psio2', 'sel2', 'affinecompose', 'colormorph', 'fpix2', 'pageseg', 'psio2stub', 'selgen', 'colorquant1', 'paintcmap', 'ptabasic', 'shear', 'arrayaccess', 'colorquant2', 'gifio', 'parseprotos', 'ptafunc1', 'skew', 'colorseg', 'coloring', 'colorspace', 'colorinfo', 'gifiostub', 'partition', 'ptra', 'spixio', 'bardecode', 'compare', 'gplot', 'pix1', 'queue', 'stack', 'baseline', 'conncomp', 'graphics', 'pix2', 'rank', 'sudoku', 'bbuffer', 'convertfiles', 'graymorph', 'pix3', 'readbarcode', 'textops', 'bilinear', 'convolve', 'pix4', 'readfile', 'tiffio', 'binarize', 'grayquant', 'pix5', 'regutils', 'tiffiostub', 'binexpand', 'correlscore', 'pixabasic', 'rop', 'utils1', 'utils2', 'heap', 'pixacc', 'binreduce', 'jbclass', 'pixafunc1', 'warper', 'jpegio', 'pixafunc2', 'rotateam', 'watershed', 'blend', 'edge', 'jpegiostub', 'pixalloc', 'webpio', 'webpanimio', 'webpanimiostub', 'bmf', 'kernel', 'pixarith', 'rotate', 'webpiostub', 'bmpio', 'enhance', 'leptwin', 'pixcomp', 'rotateorth', 'writefile', 'bmpiostub', 'fhmtauto', 'list', 'pixconv', 'boxbasic', 'makefile', 'pixtiling', 'rotateshear', 'zlibmem', 'boxfunc1', 'maze', 'pngio', 'runlength', 'zlibmemstub', 'boxfunc2', 'finditalic', 'morphapp', 'pngiostub', 'sarray1', 'sarray2', 'boxfunc3', 'boxfunc4', 'boxfunc5', 'flipdetect', 'morph', 'pnmio', 'scale1', 'scale2', 'ccbord', 'fliphmtgen', 'morphdwa', 'pnmiostub', 'ccthin', 'fmorphauto', 'morphseq', 'projective', 'seedfill', 'classapp', 'numabasic', 'psio1', 'strokes', 'dnafunc1', 'dnahash', 'dnabasic', 'ptafunc2', 'checkerboard', 'partify', 'rbtree', 'quadtree', 'map', 'encoding', 'stringcode', 'bilateral', 'pixlabel', 'bootnumgen1', 'bootnumgen2', 'bootnumgen3', 'bootnumgen4', 'jp2kheader', 'jp2kheaderstub', 'jp2kio', 'jp2kiostub', 'pdfio2', 'pdfio2stub', 'pdfio1', 'pdfio1stub', 'libversions', 'bytearray', 'dewarp1', 'dewarp2', 'dewarp3', 'dewarp4', 'recogbasic', 'recogdid', 'recogident', 'recogtrain'] + ["leptonica", "functions"]
